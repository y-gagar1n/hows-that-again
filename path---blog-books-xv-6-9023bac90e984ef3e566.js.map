{"version":3,"sources":["webpack:///path---blog-books-xv-6-9023bac90e984ef3e566.js","webpack:///./.cache/json/blog-books-xv-6.json"],"names":["webpackJsonp","415","module","exports","data","markdownRemark","html","frontmatter","path","title","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA;AAA4pmGC,aAAgCC,KAAA,kBAAAC,MAAA,SAAyCC","file":"path---blog-books-xv-6-9023bac90e984ef3e566.js","sourcesContent":["webpackJsonp([160831456888542],{\n\n/***/ 415:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p><a href=\\\"https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf\\\">Комментарии к исходному коду</a>\\n<a href=\\\"https://github.com/YehudaShapira/xv6-explained/blob/master/Explanations.md\\\">Еще комментарии</a></p>\\n<p><a href=\\\"https://pdos.csail.mit.edu/6.828/2018/xv6/xv6-rev11.pdf\\\">Исходный код</a></p>\\n<h1>xv6</h1>\\n<p>Важное замечание для начала: во всех ассемблерах UNIX, включая используемый здесь, команда mov имеет следующий синтаксис: <code>MOV src dest</code>.</p>\\n<p>То есть <code>mov $a $b</code> означает, что значение регистра a будет присвоено регистру b.</p>\\n<h2>Основные понятия</h2>\\n<h3>Процесс</h3>\\n<p>Память любого процесса состоит из 3 частей: инструкции, данные, стек.</p>\\n<h3>fork</h3>\\n<p>Создает новый процесс (child process), содержимое памяти которого идентично содержимому памяти вызывающего процесса (parent process). Но это не одна и та же память, это копия. Так как память у процессов одинаковая, значит одинаковые и инструкции, значит в обоих процессах выполнение продолжается со следующей инструкции. Только в child process функция fork возвращает 0, а в родительском - pid созданного процесса.</p>\\n<pre><code class=\\\"language-c\\\">int pid = fork();\\nif(pid > 0){\\n    printf(\\\"parent: child=%d\\\\n\\\", pid);\\n    pid = wait();\\n    printf(\\\"child %d is done\\\\n\\\", pid);\\n} else if(pid == 0){\\n    printf(\\\"child: exiting\\\\n\\\");\\n    exit();\\n} else {\\n    printf(\\\"fork error\\\\n\\\");\\n}\\n</code></pre>\\n<p><code>exit</code> - запускает процедуру выхода из процесса и освобождает ресурсы (память, открытые файлы)</p>\\n<p><code>wait</code> - ожидает завершения дочернего процесса и возвращает его pid.</p>\\n<p>В приведенном примере на экран будет выдано:</p>\\n<pre><code>parent: child=1234\\nchild: exiting\\nchild 1234 is done\\n</code></pre>\\n<h3>exec</h3>\\n<p>Принимает в качестве аргумента путь к исполняемому файлу и заменяет память вызывающего процесса на память, загруженную из этого файла. Файл должен быть в специальном формате (ELF), в котором указано начало секции инструкций, начало секции данных, с какой инструкции начать выполнение и т.д. Если вызов exec совершен удачно, то выполнение продолжится с той инструкции, которая указана первой к исполнению в загруженном файле.</p>\\n<p>Пример:</p>\\n<pre><code class=\\\"language-c\\\">char *argv[3];\\nargv[0] = \\\"echo\\\";\\nargv[1] = \\\"hello\\\";\\nargv[2] = 0;\\nexec(\\\"/bin/echo\\\", argv);\\nprintf(\\\"exec error\\\\n\\\");\\n</code></pre>\\n<p>Здесь исполняемая программа заменяется программой <code>/bin/echo</code>, которая получает в качестве списка аргументов <code>echo hello</code>.</p>\\n<h3>sh</h3>\\n<p>Шелл использует <code>fork</code> и <code>exec</code> для исполнения программ. В общем структура выполнения выглядит так:</p>\\n<pre><code class=\\\"language-c\\\">int\\nmain(void)\\n{\\n  static char buf[100];\\n\\n  while(getcmd(buf, sizeof(buf)) >= 0){\\n    if(fork1() == 0)\\n      runcmd(parsecmd(buf));\\n    wait();\\n  }\\n  exit();\\n}\\n\\nvoid\\nruncmd(struct cmd *cmd)\\n{\\n  struct execcmd *ecmd;\\n\\n  switch(cmd->type){  \\n    ...\\n  case EXEC:\\n    ecmd = (struct execcmd*)cmd;\\n    exec(ecmd->argv[0], ecmd->argv);\\n    printf(2, \\\"exec %s failed\\\\n\\\", ecmd->argv[0]);\\n    break;\\n    ...\\n  }\\n  exit();\\n}\\n</code></pre>\\n<ul>\\n<li><code>main</code> - делает дочерний процесс, в нем парсит команду, подает на выполнение</li>\\n<li><code>runcmd</code> - делает <code>exec</code>, заменяя текущий процесс (тот, который был создан форком в <code>main</code>) на исполняемый файл, указанный в команде</li>\\n</ul>\\n<p>После завершения дочернего процесса исполнение продолжается на инструкции, следующей за <code>wait()</code>.</p>\\n<h3>Дескрипторы файлов</h3>\\n<p>У каждого процесса свой набор дескрипторов файлов, начинающийся с 0. По соглашению, 0 - дескриптор стандартного ввода/stdin, 1 - стандартного вывода/stdout, 2 - дескриптор канала ошибок/stderr.</p>\\n<p>При открытии файла он всегда получает наименьший из неиспользуемых в текущем процессе дексрипторов.</p>\\n<p>Вот так, например, выглядит <code>cat</code>:</p>\\n<pre><code class=\\\"language-c\\\">char buf[512];\\n\\nvoid\\ncat(int fd)\\n{\\n  int n;\\n\\n  while((n = read(fd, buf, sizeof(buf))) > 0) { // читаем из указанного дескриптора\\n    if (write(1, buf, n) != n) {  // пишем в 1, то есть stdout\\n      printf(1, \\\"cat: write error\\\\n\\\");\\n      exit();\\n    }\\n  }\\n\\n  // error handling\\n  if(n &#x3C; 0){\\n    printf(1, \\\"cat: read error\\\\n\\\");\\n    exit();\\n  }\\n}\\n\\nint\\nmain(int argc, char *argv[])\\n{\\n  int fd, i;\\n\\n  if(argc &#x3C;= 1){ // если аргументов не указано, то читаем из 0, то есть stdin\\n    cat(0);\\n    exit();\\n  }\\n\\n  for(i = 1; i &#x3C; argc; i++){ // если аргументы есть, то открываем файлы по этим путям и читаем из дескрипторов этих файлов\\n    if((fd = open(argv[i], 0)) &#x3C; 0){\\n      printf(1, \\\"cat: cannot open %s\\\\n\\\", argv[i]);\\n      exit();\\n    }\\n    cat(fd);\\n    close(fd);\\n  }\\n  exit();\\n}\\n</code></pre>\\n<h4>Перенаправление I/O</h4>\\n<p><code>exec</code> заменяет содержимое памяти вызывающего процесса, но при этом <strong>оставляет неизменной его таблицу дескрипторов</strong>. Это позволяет реализовать перенаправление I/O. Вот, что происходит при вызове <code>cat &#x3C; input.txt</code>:</p>\\n<pre><code class=\\\"language-c\\\">char *argv[2];\\nargv[0] = \\\"cat\\\";\\nargv[1] = 0;\\nif(fork() == 0) {\\n    close(0);\\n    open(\\\"input.txt\\\", O_RDONLY);\\n    exec(\\\"cat\\\", argv);\\n}\\n</code></pre>\\n<p>Здесь используется правило \\\"При открытии файла он всегда получает наименьший из неиспользуемых в текущем процессе дексрипторов\\\". Когда вызывается <code>close(0)</code>, дескриптор 0 (stdin) освобождается, а значит следующая инструкция <code>open</code> назначит открытому файлу <code>input.txt</code> дексриптор 0. Затем вызывается программа <code>cat</code>, которая при вызове без аргументов читает содержимое из дескриптора 0.</p>\\n<p>В коде шелла этот кусок выглядит так:</p>\\n<pre><code class=\\\"language-c\\\">void\\nruncmd(struct cmd *cmd)\\n{\\n  struct redircmd *rcmd;\\n\\n    switch(cmd->type){\\n  ...\\n\\n  case REDIR:\\n    rcmd = (struct redircmd*)cmd;\\n    close(rcmd->fd);\\n    if(open(rcmd->file, rcmd->mode) &#x3C; 0){\\n      printf(2, \\\"open %s failed\\\\n\\\", rcmd->file);\\n      exit();\\n    }\\n    runcmd(rcmd->cmd);\\n    break;\\n    ...\\n  }\\n  exit();\\n}\\n\\n...\\n\\nstruct cmd*\\nparseredirs(struct cmd *cmd, char **ps, char *es)\\n{\\n  int tok;\\n  char *q, *eq;\\n\\n  while(peek(ps, es, \\\"&#x3C;>\\\")){\\n    tok = gettoken(ps, es, 0, 0);\\n    switch(tok){\\n    case '&#x3C;':\\n      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);\\n      break;\\n    case '>':\\n      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);\\n      break;\\n    case '+':  // >>\\n      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);\\n      break;\\n    }\\n  }\\n  return cmd;\\n}\\n</code></pre>\\n<p><code>rcmd</code> при парсинге получит <code>fd</code>, равный 0, при использовании <code>&#x3C;</code> и равный 1 при использовании <code>></code>. В ветке <code>REDIR</code> мы закрыли дексриптор, на который будем перенаправлять ввод или вывод, открыли нужный файл и вызвали <code>runcmd</code>, внутри которого будет использован <code>exec</code>.</p>\\n<h4>Использование дескрипторов в fork</h4>\\n<p>При форке таблица дескрипторов копируется, а сдвиги - шарятся между процессами. То есть следующий пример:</p>\\n<pre><code class=\\\"language-c\\\">if(fork() == 0) {\\n    write(1, \\\"hello \\\", 6);\\n    exit();\\n} else {\\n    wait();\\n    write(1, \\\"world\\\\n\\\", 6);\\n}\\n</code></pre>\\n<p>Выведет на экран <code>hello world</code>. </p>\\n<p>Благодаря этому мы можем писать: <code>(echo hello; echo world)>output.txt</code>. (хотя пока непонятно, почему тут должен вызываться fork, а не exec).</p>\\n<h4>dup</h4>\\n<p>Копирует дескриптор, после чего оба дескриптора шарят сдвиг.</p>\\n<p>То есть:</p>\\n<pre><code class=\\\"language-c\\\">fd = dup(1);\\nwrite(1, \\\"hello \\\", 6);\\nwrite(fd, \\\"world\\\\n\\\", 6);\\n</code></pre>\\n<p>тоже выведет <code>hello world</code>.</p>\\n<p>Таким образом, два дексриптора файла шарят между собой сдвиг только в том случае, если они были получены из одного и того же дескриптора вызовами <code>fork</code> и <code>dup</code>. Во всех остальных случаях сдвиги не шарятся.</p>\\n<p><code>dup</code> позволяет писать такие команды:</p>\\n<pre><code class=\\\"language-shell\\\">ls existing-file non-existing-file > tmp1 2>&#x26;1\\n</code></pre>\\n<p>Здесь <code>2>&#x26;1</code> как раз копирует дексриптор 1 в дескриптор 2, чтобы все ошибки выводились в stdout.</p>\\n<h3>pipes</h3>\\n<p>Вызов <code>pipe</code> принимает массив из двух элементов и записывает в него 2 дексриптора: первый - для чтения и второй - для записи. Все, что будет записано в дексриптор для записи, можно будет прочитать из дескриптора для чтения.</p>\\n<p>Пример использования <code>pipe</code>:</p>\\n<pre><code class=\\\"language-c\\\">int p[2];\\nchar *argv[2];\\nargv[0] = \\\"wc\\\";\\nargv[1] = 0;\\n\\npipe(p);\\nif(fork() == 0) {\\n    close(0);\\n    dup(p[0]);\\n    close(p[0]);\\n    close(p[1]);\\n    exec(\\\"/bin/wc\\\", argv);\\n} else {\\n    close(p[0]);\\n    write(p[1], \\\"hello world\\\\n\\\", 12);\\n    close(p[1]);\\n}\\n</code></pre>\\n<p>Здесь дочерний процесс закрывает <code>stdin</code>, дублирует дескриптор чтения из пайпа в дескриптор 0, закрывает дескриптор чтения и записи и запускает <code>wc</code>, который будет принимать ввод от дескриптора 0, то есть будет читать из пайпа.</p>\\n<p>Родительский процесс пишет в дескриптор записи и закрывает оба дескриптора пайпа.</p>\\n<p>Приблизительно так же выглядит и ветка <code>PIPE</code> в <code>runcmd</code>, только она создает 2 дочерних процесса:</p>\\n<pre><code class=\\\"language-c\\\">void\\nruncmd(struct cmd *cmd)\\n{\\n   struct pipecmd *pcmd;\\n \\n  switch(cmd->type){\\n    ...\\n  case PIPE:\\n    pcmd = (struct pipecmd*)cmd;\\n    if(pipe(p) &#x3C; 0)\\n      panic(\\\"pipe\\\");\\n    if(fork1() == 0){\\n      close(1);\\n      dup(p[1]);\\n      close(p[0]);\\n      close(p[1]);\\n      runcmd(pcmd->left);\\n    }\\n    if(fork1() == 0){\\n      close(0);\\n      dup(p[0]);\\n      close(p[0]);\\n      close(p[1]);\\n      runcmd(pcmd->right);\\n    }\\n    close(p[0]);\\n    close(p[1]);\\n    wait();\\n    wait();\\n    break;\\n    ...\\n  }\\n  exit();\\n}\\n</code></pre>\\n<p>В шелле пайпы используются при выполнении команд вида <code>grep fork sh.c | wc -l</code>.</p>\\n<p>Преимущества пайпов перед временными файлами:</p>\\n<ul>\\n<li>автоматическое очищение</li>\\n<li>можно передавать очень длинные потоки данных, не беспокоясь, что на диске кончится место</li>\\n<li>возможно параллельное выполнение левой и правой команды</li>\\n<li>для межпроцессного общения блокирующая модель записи и чтения пайпов удобнее, чем неблокирующая модель файлов</li>\\n</ul>\\n<h3>Файловая система</h3>\\n<p><code>fstat</code> - возвращает информацию о файле, на который указывает дескрриптор</p>\\n<p>У файла может быть несколько имен, или \\\"линков\\\". Сам файл называется <code>inode</code>. Линки создаются командой <code>link</code>, например:</p>\\n<pre><code class=\\\"language-c\\\">open(\\\"a\\\", O_CREATE|O_WRONLY);\\nlink(\\\"a\\\", \\\"b\\\");\\n</code></pre>\\n<p>После этого <code>a</code> и <code>b</code> ссылаются на один и тот же <code>inode</code> и запись/чтение в <code>a</code> равносильно записи/чтению в <code>b</code>.</p>\\n<p>Каждый айнод идентифицируется своим <code>inode number</code>. Его можно получить вызовом <code>fstat</code>.</p>\\n<p>Линки удаляются командой <code>unlink</code>. Айнод и место на диске очищаются только когда количество линков уменьшится до 0 и не останется дескрипторов, ссылающихся на него.</p>\\n<h2>Организация операционной системы</h2>\\n<h3>Загрузчик</h3>\\n<p>Загрузчик состоит из 2 частей: <code>bootasm.s</code>, написанный на ассемблере и <code>bootmain.c</code>, написанный на С.</p>\\n<p>Когда компьютер стартует, он выполняет программу BIOS, которая записана в энергонезависимой памяти материнской платы. BIOS подготавливает аппаратное обеспечение к работе и передает управление коду, записанному в загрузочный сектор, т.е. первый 512-байтовый сектор загрузочного диска. В этом секторе содержится загрузчик: инструкции по загрузке ядра в память. BIOS загружает содержимое загрузочного сектора в адрес <code>0x7c00</code> и переходит на этот адрес. Начинается исполнение файла <code>bootasm.s</code>.</p>\\n<p>Первая инструкция загрузчика - <code>cli</code>, которая отключает прерывания. BIOS возможно установил какие-то свои обработчики прерываний, чтобы инициализировать устройства, но мы уже покинули BIOS, поэтому они нам больше не нужны. Когда операционная система загрузится, она включит прерывания обратно.</p>\\n<p>Затем загрузчик должен перевести процессор из реального режима работы в защищенный.</p>\\n<p>После этого загрузчик переходит в <code>bootmain.c</code>.</p>\\n<p>Задача <code>bootmain.c</code> - загрузить и запустить ядро. Ядро должно быть в формате ELF. <code>bootmain</code> загружает первые 4096 байт из бинарника ELF и кладет их копию по адресу <code>0x10000</code>. Затем он проверяет, что это действительно ELF путем проверки магического числа в заголовке файла. Затем он проходит по всем сегментам файла, загружает их в память и переходит в точку входа в ядро, а именно <code>0x10000c</code>.</p>\\n<h3>Старт ядра</h3>\\n<p>Когда загрузчик передает управления в ядро, первая выполняемая инструкция - это <code>entry:</code> в файле <code>entry.s</code>. Первое, что делает ядро - это настраивает аппаратный пэйджинг. Добавляется маппинг виртуальных адресов, начинающихся с <code>0x80000000</code> на физические, начинающиеся с <code>0x0</code>:</p>\\n<pre><code class=\\\"language-asm\\\">  movl    $(V2P_WO(entrypgdir)), %eax\\n  movl    %eax, %cr3\\n</code></pre>\\n<p><code>V2P_WO</code>(virtual to physical) - это макрос, который отнимает от \\\"высокого\\\" адреса <code>entrypgdir</code> константу <code>0x80000000</code>. Это нужно, потому что у нас еще не работает маппинг виртуальных адресов, но ядро слинковано с их использованием.</p>\\n<p>Таблица страниц entrypgdir описана в main.c:</p>\\n<pre><code class=\\\"language-c\\\">__attribute__((__aligned__(PGSIZE)))\\npde_t entrypgdir[NPDENTRIES] = {\\n  // Map VA's [0, 4MB) to PA's [0, 4MB)\\n  [0] = (0) | PTE_P | PTE_W | PTE_PS,\\n  // Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)\\n  [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,\\n};\\n</code></pre>\\n<p>Затем ядро включает аппаратный пейджинг:</p>\\n<pre><code>  orl     $(CR0_PG|CR0_WP), %eax\\n  movl    %eax, %cr0\\n</code></pre>\\n<p>Ну и наконец мы переходим в <code>main.c</code>:</p>\\n<pre><code class=\\\"language-asm\\\">  # Set up the stack pointer.\\n  movl $(stack + KSTACKSIZE), %esp\\n\\n  # Jump to main(), and switch to executing at\\n  # high addresses. The indirect call is needed because\\n  # the assembler produces a PC-relative instruction\\n  # for a direct jump.\\n  mov $main, %eax\\n  jmp *%eax\\n</code></pre>\\n<h3>Создание первого процесса</h3>\\n<p>Процесс описывается следующей структурой:</p>\\n<pre><code class=\\\"language-c\\\">// Per-process state\\nstruct proc {\\n  uint sz;                     // Size of process memory (bytes)\\n  pde_t* pgdir;                // Page table\\n  char *kstack;                // Bottom of kernel stack for this process\\n  enum procstate state;        // Process state\\n  int pid;                     // Process ID\\n  struct proc *parent;         // Parent process\\n  struct trapframe *tf;        // Trap frame for current syscall\\n  struct context *context;     // swtch() here to run process\\n  void *chan;                  // If non-zero, sleeping on chan\\n  int killed;                  // If non-zero, have been killed\\n  struct file *ofile[NOFILE];  // Open files\\n  struct inode *cwd;           // Current directory\\n  char name[16];               // Process name (debugging)\\n};\\n\\nstruct context {\\n  uint edi;\\n  uint esi;\\n  uint ebx;\\n  uint ebp;\\n  uint eip;\\n};\\n</code></pre>\\n<p><code>main</code> инициализирует кучу устройств и подсистем:</p>\\n<pre><code class=\\\"language-c\\\">// Bootstrap processor starts running C code here.\\n// Allocate a real stack and switch to it, first\\n// doing some setup required for memory allocator to work.\\nint\\nmain(void)\\n{\\n  kinit1(end, P2V(4*1024*1024)); // phys page allocator\\n  kvmalloc();      // kernel page table\\n  mpinit();        // detect other processors\\n  lapicinit();     // interrupt controller\\n  seginit();       // segment descriptors\\n  picinit();       // disable pic\\n  ioapicinit();    // another interrupt controller\\n  consoleinit();   // console hardware\\n  uartinit();      // serial port\\n  pinit();         // process table\\n  tvinit();        // trap vectors\\n  binit();         // buffer cache\\n  fileinit();      // file table\\n  ideinit();       // disk \\n  startothers();   // start other processors\\n  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()\\n  userinit();      // first user process\\n  mpmain();        // finish this processor's setup\\n}\\n</code></pre>\\n<p>Первый процесс создается вызовом <code>userinit()</code>, который вызывает <code>allocproc()</code>. Задача <code>allocproc()</code> - аллоцировать структуру типа <code>proc</code> в системной таблице процессов и инициализировать части состояния процесса, чтобы он мог запуститься. <code>allocproc()</code> запускается для каждого нового процесса, а <code>userinit()</code> - только для первого.</p>\\n<pre><code class=\\\"language-c\\\">// Look in the process table for an UNUSED proc.\\n// If found, change state to EMBRYO and initialize\\n// state required to run in the kernel.\\n// Otherwise return 0.\\nstatic struct proc*\\nallocproc(void)\\n{\\n  struct proc *p;\\n  char *sp;\\n\\n  acquire(&#x26;ptable.lock);\\n\\n  for(p = ptable.proc; p &#x3C; &#x26;ptable.proc[NPROC]; p++)\\n    if(p->state == UNUSED)\\n      goto found;\\n\\n  release(&#x26;ptable.lock);\\n  return 0;\\n\\nfound:\\n  p->state = EMBRYO;\\n  p->pid = nextpid++;\\n\\n  release(&#x26;ptable.lock);\\n\\n  // Allocate kernel stack.\\n  if((p->kstack = kalloc()) == 0){\\n    p->state = UNUSED;\\n    return 0;\\n  }\\n  sp = p->kstack + KSTACKSIZE;\\n\\n  // Leave room for trap frame.\\n  sp -= sizeof *p->tf;\\n  p->tf = (struct trapframe*)sp;\\n\\n  // Set up new context to start executing at forkret,\\n  // which returns to trapret.\\n  sp -= 4;\\n  *(uint*)sp = (uint)trapret;\\n\\n  sp -= sizeof *p->context;\\n  p->context = (struct context*)sp;\\n  memset(p->context, 0, sizeof *p->context);\\n  p->context->eip = (uint)forkret;\\n\\n  return p;\\n}\\n</code></pre>\\n<ul>\\n<li>регистр EIP в x86 означает Extended Instruction Pointer</li>\\n</ul>\\n<p>Allocproc:</p>\\n<ol>\\n<li>ищет в таблице процессов слот с состоянием UNUSED</li>\\n<li>когда находит, устанавливает ему состояние EMBRYO и дает процессу уникальный pid.</li>\\n<li>затем пытается выделить в памяти 4096 байт для ядерного стека процесса. Если не получается, то выставляет состояние обратно в UNUSED и возвращает 0.</li>\\n<li>если получилось, то поля структуры proc инициализируются адресами в стеке для trap frame, trapret, context. В результате полученный ядерный стек выглядит так:</li>\\n</ol>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/d05989cf0b10a4cc4b2d7a61cf6fb487/f7060/new-kernel-stack.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 325px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 105.23076923076921%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsSAAALEgHS3X78AAACPElEQVQ4y5VVia7iMAzk/38NCR4rbomr9L6gB6XlmvX4vfLYcm6kyGlCJvZ4bFr4GZfLRe3pdITnuYjCEI7rwfN9eK4Lx3FQlhWyLENVVTgcDnqHlt/H41Hvtx4BmuYaYeDDth0FWq8NWKaJNM3Q+/pCFEWIZY7HY8SbjeynCIJAQa+At6CvRlEUCriJY/T7fSQCVhQ7+BJJWZb3HtI+mufzWc834pFlWQoaBCFiAebatm0NvfXKmxrs9sEkSbDdbtXDTqeDPN9hv98jFM4/AmwCE4yXmRyu8zzXyZAV8FmIt/N28HIggEmyhWGskAow9zzPe+9hPdI0wXKx1EwOBgPNvCVKaLfbcD1feb1yuFqtsFjM5TVDyV7MuTZhyutr04L5s0dL/obDoUgqwHQ6xZ9eTx8oir3uKaAromX8tNSU73vqCYUdRbHyxfVWwBgaAfm7MAzQ7XZVNrvd7pdD/OeoLzMhhrFWUTNBVw4/TcZtUsgh9UfeyB/BuffQw98SPEnIofI6XyywXK7Um9lsho0AxHLWEw7TjDoslKaXgKyMLEs1EcqjVAO9G41G+s0SZPjce8vhq5rmJdZsc5DHf2r5k5r+1mSq3jUHI3kI+K4Ms4wh5nAdG9PJBOPJFJX0xKcePvOy7ja8WAhnBGVPDEWrPKfnCtgMqWkfyYbd5b4803sPm2Bl+V1SFC0rqKwOor9Is1orofacWlRA6o0AtM1WxabgCFdzqeWlaDEII+3S7DYUdj31L0Eswf8C0/9bMV1u3ygAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"New kernel stack\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/d05989cf0b10a4cc4b2d7a61cf6fb487/f7060/new-kernel-stack.png\\\"\\n        srcset=\\\"/hows-that-again/static/d05989cf0b10a4cc4b2d7a61cf6fb487/c5e8e/new-kernel-stack.png 163w,\\n/hows-that-again/static/d05989cf0b10a4cc4b2d7a61cf6fb487/f7060/new-kernel-stack.png 325w\\\"\\n        sizes=\\\"(max-width: 325px) 100vw, 325px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>После заполнения стэка в <code>p->context->eip</code> будет адрес функции <code>forkret</code>, а над контекстом, там, где обычно пишется адрес возврата - будет адрес функции <code>trapret</code>. Созданный поток начинает выполнение со значениями регистров, скопированными из <code>p->context</code>, поэтому при старте потока в регистре EIP будет адрес <code>forkret</code> и начнет выполняться она. После выполнения будет возврат из функции, а значит переход к инструкции, которая располагается сразу над <code>p->context</code>, то есть <code>trapret</code>. <code>trapret</code> восстанавливает значение регистров из значений, сохраненных наверху стэка и прыгает внутрь процесса.</p>\\n<p>Такая сложная конструкция нужна, потому что этот же код используется и для форков. А <code>trapret</code> нужен потому что переход из юзерспейса в ядро происходит через исключения, или, как они называются в x86, трэпы. При трэпе выстреливается прерывание, побирается соответствующий обработчик прерывания, а этот обработчик сохраняет в стэк все значения регистров и вызывает функцию<code>trap()</code>.</p>\\n<p>После создания процесса, ему указывается программа для выполнения, и в случае userinit это программа <code>initcode.s</code>. Но чтобы ее запустить, нужно выделить память, чтобы хранить в ней эту программу, скопировать туда программу, и создать таблицу страниц для этого процесса:</p>\\n<pre><code class=\\\"language-c\\\">void\\nuserinit(void)\\n{\\n  struct proc *p;\\n  extern char _binary_initcode_start[], _binary_initcode_size[];\\n\\n  p = allocproc();\\n  \\n  initproc = p;\\n  if((p->pgdir = setupkvm()) == 0)\\n    panic(\\\"userinit: out of memory?\\\");\\n  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);\\n  p->sz = PGSIZE;\\n  memset(p->tf, 0, sizeof(*p->tf));\\n  p->tf->cs = (SEG_UCODE &#x3C;&#x3C; 3) | DPL_USER;\\n  p->tf->ds = (SEG_UDATA &#x3C;&#x3C; 3) | DPL_USER;\\n  p->tf->es = p->tf->ds;\\n  p->tf->ss = p->tf->ds;\\n  p->tf->eflags = FL_IF;\\n  p->tf->esp = PGSIZE;\\n  p->tf->eip = 0;  // beginning of initcode.S\\n\\n  safestrcpy(p->name, \\\"initcode\\\", sizeof(p->name));\\n  p->cwd = namei(\\\"/\\\");\\n\\n  // this assignment to p->state lets other cores\\n  // run this process. the acquire forces the above\\n  // writes to be visible, and the lock is also needed\\n  // because the assignment might not be atomic.\\n  acquire(&#x26;ptable.lock);\\n\\n  p->state = RUNNABLE;\\n\\n  release(&#x26;ptable.lock);\\n}\\n</code></pre>\\n<p>Процедура <code>setupkvm</code> создает таблицу страниц для нашего процесса. </p>\\n<p><code>inituvm</code> загружает по 0-му адресу выделенной процессу памяти содержимое скомпилированной процедуры <code>initcode</code>, константы <code>_binary_initcode_start</code> и <code>_binary_initcode_size</code> прописываются в процессе билда ядра и обозначают начало и размер эмбеженной в ядро функции <code>initcode</code>.</p>\\n<p>Затем <code>userinit</code> заполняет трэпфрейм, записывая в регистры сегментов селектор сегмента <code>SEG_UCODE</code> и <code>SEG_UDATA</code> с уровнем привилегий <code>DPL_USER</code>, не позволяющим работать в режиме ядра. Указатель стека %esp выставляется в самый большой виртуальный адрес, доступный процессу, а указатель инструкций выставляется в самый маленький, то есть 0. <code>p->name</code> выставляется в основном для отладки, <code>p->cwd</code> выставляет рабочую папку. </p>\\n<p>Когда заполнили все поля процесса, он ставится в очередь на выполнение путем установки поля <code>state</code> в <code>RUNNABLE</code>.</p>\\n<h3>Запуск первого процесса</h3>\\n<p>Итак, первый процесс готов к запуску, а мы выходим из <code>userinit</code> обратно в <code>main</code> и следующая строчка вызывает <code>mpmain()</code>, который вызывает <code>scheduler()</code>.</p>\\n<p><code>scheduler()</code> находится в <code>proc.c</code>, вот его код:</p>\\n<pre><code class=\\\"language-c\\\">void\\nscheduler(void)\\n{\\n  struct proc *p;\\n  struct cpu *c = mycpu();\\n  c->proc = 0;\\n  \\n  for(;;){\\n    // Enable interrupts on this processor.\\n    sti();\\n\\n    // Loop over process table looking for process to run.\\n    acquire(&#x26;ptable.lock);\\n    for(p = ptable.proc; p &#x3C; &#x26;ptable.proc[NPROC]; p++){\\n      if(p->state != RUNNABLE)\\n        continue;\\n\\n      // Switch to chosen process.  It is the process's job\\n      // to release ptable.lock and then reacquire it\\n      // before jumping back to us.\\n      c->proc = p;\\n      switchuvm(p);\\n      p->state = RUNNING;\\n\\n      swtch(&#x26;(c->scheduler), p->context);\\n      switchkvm();\\n\\n      // Process is done running for now.\\n      // It should have changed its p->state before coming back.\\n      c->proc = 0;\\n    }\\n    release(&#x26;ptable.lock);\\n\\n  }\\n}\\n</code></pre>\\n<p>Шедулер проходит по всем процессам в <code>ptable</code> и ищет первый, у которого state равен <code>RUNNABLE</code>. Когда такой процесс найден, он записывается в переменную <code>proc</code> для процессора текущего треда, после чего вызывается <code>switchuvm(p)</code>, которая дает железу команду начать использовать таблицу страниц этого процесса (kvm означает kernel virtual memory, uvm означает user virtual memory).</p>\\n<p>Затем шедулер устанавливает state в RUNNING и вызывает <code>swtch</code>, чтобы переключиться на выбранный поток.</p>\\n<p>После переключения, поток начинает выполнять <code>forkret</code>, потому что <code>allocproc</code> записал ее адрес в <code>p->context->eip</code>. <code>forkret</code> что-то там инициализирует и возвращается. Затем, по заветам <code>allocproc</code>, выполняется <code>trapret</code>. Он восстанавливает регистры <code>gs</code>, <code>fs</code>, <code>es</code> и <code>ds</code> из стека (<code>swtch</code> делает то же самое, но для общих регистров). В данном случае они туда попали в процедуре <code>allocproc</code>, который пытался новому потоку создать такой стек, как будто он был создан ранее и мы на него переключились в процессе нормального context switch. В обычных ситуациях происходит настоящий context switch и эти регистры в стек попадают в процедуре <code>alltraps</code> (см. ниже).</p>\\n<pre><code class=\\\"language-asm\\\">  # Return falls through to trapret...\\n.globl trapret\\ntrapret:\\n  popal\\n  popl %gs\\n  popl %fs\\n  popl %es\\n  popl %ds\\n  addl $0x8, %esp  # trapno and errcode\\n  iret\\n</code></pre>\\n<p>Инструкция <code>iret</code> извлекает регистры <code>cs</code>, <code>eip</code>, <code>flags</code>, <code>esp</code> и <code>ss</code>. Следующей выполняется инструкция, адрес которой записан в <code>$eip</code>. В случае <code>initproc</code> это адрес 0, а <code>$esp</code> получает адрес 4096 (верх страницы, чтобы стек мог расти вниз). Это уже виртуальные адреса.</p>\\n<h3>Первый системный вызов: exec</h3>\\n<p>Первое, что делает <code>initcode.S</code> - это вызывает <code>exec</code>:</p>\\n<pre><code class=\\\"language-asm\\\"># exec(init, argv)\\n.globl start\\nstart:\\n  pushl $argv\\n  pushl $init\\n  pushl $0  // where caller pc would be\\n  movl $SYS_exec, %eax\\n  int $T_SYSCALL\\n\\n# char init[] = \\\"/init\\\\0\\\";\\ninit:\\n  .string \\\"/init\\\\0\\\"\\n\\n# char *argv[] = { init, 0 };\\n.p2align 2\\nargv:\\n  .long init\\n  .long 0\\n</code></pre>\\n<p>Ну точнее она сначала кладет в стек аргументы командной строки (<code>$argv</code> = [init, 0]), адрес вызываемой программы (<code>$init</code> = \\\"/init\\\"), адрес возврата (0), а потом кладет в <code>$eax</code> номер системного вызова <code>exec</code> и выполняет инструкцию <code>int $T_SYSCALL</code> - это просьба выстрелить прерывание с номером, соответствующим системному вызову. Если все пройдет хорошо, то в результате в этом же процессе будет вызвана программа <code>/init</code>, заменив память процесса памятью этой программы.</p>\\n<p><code>/init</code> создаст дескриптор консоли, откроет дескрипторы 0, 1, 2, запустит шелл и будет в цикле принимать команды.</p>\\n<h2>Context switch</h2>\\n<p>Переключение контекста состоит из 3 шагов:</p>\\n<ol>\\n<li>Активация прерывания по таймеру</li>\\n<li>Вызов шедулера</li>\\n<li>Переключение контекста</li>\\n</ol>\\n<p>Рассмотрим шаги по отдельности:</p>\\n<h3>Активация прерывания по таймеру</h3>\\n<p>При билде скрипт <code>vectors.pl</code> генерирует обработчики для 256 прерываний, каждый из обработчиков выглядит приблизительно так:</p>\\n<pre><code class=\\\"language-asm\\\">vector 32:\\n  pushl $0 //error code\\n  pushl $32 //vector number of timer interrupt\\n  jmp alltraps\\n</code></pre>\\n<p>Здесь мы видим обработчик прерывания с номером 32. Он пишет в стек 0 и 32 в качестве аргументов вызова и вызывает процедуру <code>alltraps</code>.</p>\\n<p>Эта процедура описана в файле <code>trapasm.S</code>, вот ее код:</p>\\n<pre><code class=\\\"language-asm\\\">.globl alltraps\\nalltraps:\\n  # Build trap frame.\\n  pushl %ds #data segment register\\n  pushl %es #extra segment register\\n  pushl %fs #general segment register\\n  pushl %gs #general segment register\\n  pushal    #all local registers (push EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI)\\n  \\n  # Set up data segments.\\n  movw $(SEG_KDATA&#x3C;&#x3C;3), %ax\\n  movw %ax, %ds\\n  movw %ax, %es\\n\\n  # Call trap(tf), where tf=%esp\\n  pushl %esp\\n  call trap\\n  addl $4, %esp\\n\\n  # Return falls through to trapret...\\n.globl trapret\\ntrapret:\\n  popal\\n  popl %gs\\n  popl %fs\\n  popl %es\\n  popl %ds\\n  addl $0x8, %esp  # trapno and errcode\\n  iret\\n</code></pre>\\n<p>Итак, процедура <code>alltraps</code> сохранила на стеке значение регистров. Регистр esp мы не трогали, но каждый пуш уменьшает его значение, поэтому сейчас он указывает на низ фрейма. а над ним - сохраненные нами регистры и сегменты. Передавая значение регистра esp внутрь процедуры <code>trap</code>, мы, таким образом, передаем внутрь ее структуру <code>tf</code> типа <code>trapframe</code>. Вот код структуры:</p>\\n<pre><code class=\\\"language-c\\\">struct trapframe {\\n  // registers as pushed by pusha\\n  uint edi;\\n  uint esi;\\n  uint ebp;\\n  uint oesp;      // useless &#x26; ignored\\n  uint ebx;\\n  uint edx;\\n  uint ecx;\\n  uint eax;\\n\\n  // rest of trap frame\\n  ushort gs;\\n  ushort padding1;\\n  ushort fs;\\n  ushort padding2;\\n  ushort es;\\n  ushort padding3;\\n  ushort ds;\\n  ushort padding4;\\n  uint trapno;\\n\\n  // below here defined by x86 hardware\\n  uint err;\\n  uint eip;\\n  ushort cs;\\n  ushort padding5;\\n  uint eflags;\\n\\n  // below here only when crossing rings, such as from user to kernel\\n  uint esp;\\n  ushort ss;\\n  ushort padding6;\\n};\\n</code></pre>\\n<p>В процедуре <code>alltraps</code> у этой структуры мы заполняем только верхние поля от <code>edi</code> до <code>padding4</code>. Поля <code>trapno</code> и <code>err</code> были ранее заполнены обработчиком прерывания <code>vector 32</code>. Оставшиеся поля составляют kernel stack и записываются аппаратным обеспечением.</p>\\n<p>Итак, перед вызовом <code>trap</code> стэк имеет следующий вид:</p>\\n<pre><code>err\\ntrapno\\npadding4\\nds\\npadding3\\nes\\npadding2\\nfs\\npadding1\\ngs\\neax\\necx\\nedx\\nebx\\noesp\\nebp\\nesi\\nedi &#x3C;--- $esp\\n</code></pre>\\n<p>Переход в <code>alltraps</code> осуществлялся командой <code>JMP</code>, поэтому адрес возврата нигде не записан (для вызова процедуры с возможностью возврата используется <code>CALL</code>, который автоматически пишет адрес следующей инструкции в стэк. Вызовы функций изнутри C всегда осуществляются через <code>CALL</code>, поэтому стэк трапфрейма составляется на ассемблере).</p>\\n<p>Далее, в <code>trap.c (109)</code> видим, что произошло прерывание по таймеру и вызываем процедуру <code>yield()</code> для запуска шедурера:</p>\\n<pre><code class=\\\"language-c\\\">if(myproc() &#x26;&#x26; myproc()->state == RUNNING &#x26;&#x26;\\n   tf->trapno == T_IRQ0+IRQ_TIMER)\\nyield();\\n</code></pre>\\n<h3>Вызов шедулера</h3>\\n<p>Посмотрим, что делает <code>yield()</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Give up the CPU for one scheduling round.\\nvoid\\nyield(void)\\n{\\n  acquire(&#x26;ptable.lock);\\n  proc->state = RUNNABLE;\\n  sched();\\n  release(&#x26;ptable.lock);\\n}\\n</code></pre>\\n<p>Здесь ничего особенного, смотрим что там в <code>sched()</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Enter scheduler.  Must hold only ptable.lock\\n// and have changed proc->state.\\nvoid\\nsched(void)\\n{\\n  int intena;\\n\\n  // If we aren't holding the ptable lock, panic\\n  if(!holding(&#x26;ptable.lock))\\n    panic(\\\"sched ptable.lock\\\");\\n\\n  // If we aren't 1 pushcli level deep, panic\\n  if(cpu->ncli != 1)\\n    panic(\\\"sched locks\\\");\\n\\n  // If the current process is in the running state, panic\\n  if(proc->state == RUNNING)\\n    panic(\\\"sched running\\\");\\n\\n  // If the processor can be interrupted, panic\\n  if(readeflags()&#x26;FL_IF)\\n    panic(\\\"sched interruptible\\\");\\n\\n  intena = cpu->intena;\\n  swtch(&#x26;proc->context, cpu->scheduler);\\n  cpu->intena = intena;\\n}\\n</code></pre>\\n<p>Здесь у нас в основном проверки, что мы действительно можем сделать переключение контекста и сохранение поля <code>intena</code> (interruptions enabled), неизвестно зачем.</p>\\n<p>В конце вызывается непосредственно процедура переключения контекста, в которую передается контекст текущего процесса и контекст щедулера, то есть контекст, на который мы будем переключаться (предполагаю, что где-то в другом месте шедулер выбирает процесс, на который переключаемся и подставляет его контекст).</p>\\n<h3>Переключение контекста</h3>\\n<p>Вот код <code>swtch.S</code>:</p>\\n<pre><code class=\\\"language-asm\\\"># Context switch\\n#\\n#   void swtch(struct context **old, struct context *new);\\n#\\n# Save current register context in old\\n# and then load register context from new.\\n\\n.globl swtch\\nswtch:\\n  movl 4(%esp), %eax\\n  movl 8(%esp), %edx # сохраняем *new в %edx, **old в %eax\\n\\n  # Save old callee-save registers\\n  pushl %ebp\\n  pushl %ebx\\n  pushl %esi\\n  pushl %edi\\n\\n  # Switch stacks\\n  movl %esp, (%eax)\\n  movl %edx, %esp   # пишем значение %edx, то есть *new в %esp\\n\\n  # Load new callee-save registers\\n  popl %edi\\n  popl %esi\\n  popl %ebx\\n  popl %ebp\\n  ret\\n</code></pre>\\n<p>Здесь общий смысл такой:</p>\\n<ol>\\n<li>мы сохраняем значение регистров на стеке</li>\\n<li>перемещаем указатель стека <code>esp</code> на тот, который указан в новом контексте</li>\\n<li>теперь мы работаем со стеком нового контекста, в котором запушены его значения регистров. Нам осталось только сделать <code>pop</code> для всех регистров и продолжить выполнение.</li>\\n</ol>\\n<h2>Организация страничной памяти</h2>\\n<p>Каждому процессу доступны 4 ГБ виртуальной памяти, из которых верхние 2 ГБ всегда занимает адресное пространство ядра, а нижние 2 выделены под нужды процесса. Начало области виртуального адресного пространства ядра обозначается константой <code>KERNBASE</code>.</p>\\n<h3>Создание адресного пространства ядра</h3>\\n<p>Процедура <code>main</code> вызывает <code>kvmalloc</code>, который создает и переключается на страницу памяти, описывающую маппинги страниц выше <code>KERNBASE</code>, необходимых для работы ядра:</p>\\n<pre><code class=\\\"language-c\\\">// Allocate one page table for the machine for the kernel address\\n// space for scheduler processes.\\nvoid\\nkvmalloc(void)\\n{\\n  kpgdir = setupkvm();\\n  switchkvm();\\n}\\n</code></pre>\\n<p>Основная работа происходит в <code>setupkvm</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Set up kernel part of a page table.\\npde_t*\\nsetupkvm(void)\\n{\\n  pde_t *pgdir;\\n  struct kmap *k;\\n\\n  if((pgdir = (pde_t*)kalloc()) == 0)\\n    return 0;\\n  memset(pgdir, 0, PGSIZE);\\n  if (P2V(PHYSTOP) > (void*)DEVSPACE)\\n    panic(\\\"PHYSTOP too high\\\");\\n  for(k = kmap; k &#x3C; &#x26;kmap[NELEM(kmap)]; k++)\\n    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,\\n                (uint)k->phys_start, k->perm) &#x3C; 0) {\\n      freevm(pgdir);\\n      return 0;\\n    }\\n  return pgdir;\\n}\\n</code></pre>\\n<p>Сначала <code>kalloc</code> находит и выделяет 1 физическую страницу памяти для ядра:</p>\\n<pre><code class=\\\"language-c\\\">// Allocate one 4096-byte page of physical memory.\\n// Returns a pointer that the kernel can use.\\n// Returns 0 if the memory cannot be allocated.\\nchar*\\nkalloc(void)\\n{\\n  struct run *r;\\n\\n  if(kmem.use_lock)\\n    acquire(&#x26;kmem.lock);\\n  r = kmem.freelist;\\n  if(r)\\n    kmem.freelist = r->next;\\n  if(kmem.use_lock)\\n    release(&#x26;kmem.lock);\\n  return (char*)r;\\n}\\n</code></pre>\\n<p>Как видим, <code>kalloc</code> выделяет страницы по очереди, начиная с первой.</p>\\n<p>Затем <code>setupkvm</code> зануляет полученную страницу: <code>memset(pgdir, 0, PGSIZE);</code>.</p>\\n<p>Затем проходит по перенаправлениям, описанным в массиве <code>kmap</code>:</p>\\n<pre><code class=\\\"language-c\\\">static struct kmap {\\n  void *virt;\\n  uint phys_start;\\n  uint phys_end;\\n  int perm;\\n} kmap[] = {\\n { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space\\n { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata\\n { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory\\n { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices\\n};\\n</code></pre>\\n<p>И для каждого перенаправления создает запись в странице таблиц памяти:</p>\\n<pre><code class=\\\"language-c\\\">for(k = kmap; k &#x3C; &#x26;kmap[NELEM(kmap)]; k++)\\n    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,\\n                (uint)k->phys_start, k->perm) &#x3C; 0) {\\n      freevm(pgdir);\\n      return 0;\\n    }\\n</code></pre>\\n<p>Вот как выглядит <code>mappages</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Create PTEs for virtual addresses starting at va that refer to\\n// physical addresses starting at pa. va and size might not\\n// be page-aligned.\\nstatic int\\nmappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)\\n{\\n  char *a, *last;\\n  pte_t *pte;\\n\\n  a = (char*)PGROUNDDOWN((uint)va);\\n  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);\\n  for(;;){\\n    if((pte = walkpgdir(pgdir, a, 1)) == 0)\\n      return -1;\\n    if(*pte &#x26; PTE_P)\\n      panic(\\\"remap\\\");\\n    *pte = pa | perm | PTE_P;\\n    if(a == last)\\n      break;\\n    a += PGSIZE;\\n    pa += PGSIZE;\\n  }\\n  return 0;\\n}\\n</code></pre>\\n<p>Он проходит по каждой странице (<code>a</code> - текущий виртуальный адрес, <code>pa</code> - текущий физический, в каждой итерации к ним прибавляется <code>PGSIZE</code>, то есть размер страницы).</p>\\n<p>Процедура <code>walkpgdir</code> здесь ищет нужную запись в таблице страниц:</p>\\n<pre><code class=\\\"language-c\\\">// Return the address of the PTE in page table pgdir\\n// that corresponds to virtual address va.  If alloc!=0,\\n// create any required page table pages.\\nstatic pte_t *\\nwalkpgdir(pde_t *pgdir, const void *va, int alloc)\\n{\\n  pde_t *pde;\\n  pte_t *pgtab;\\n\\n  pde = &#x26;pgdir[PDX(va)];\\n  if(*pde &#x26; PTE_P){\\n    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));\\n  } else {\\n    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)\\n      return 0;\\n    // Make sure all those PTE_P bits are zero.\\n    memset(pgtab, 0, PGSIZE);\\n    // The permissions here are overly generous, but they can\\n    // be further restricted by the permissions in the page table\\n    // entries, if necessary.\\n    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;\\n  }\\n  return &#x26;pgtab[PTX(va)];\\n}\\n</code></pre>\\n<p>Для адресации используется 2-уровневое дерево, первый уровень называется PD (page directory), в нем ищется запись по индексу, соотв-му первым 10 битам виртуального адреса. полученная запись называется PDE (page directory entry) и она обозначает адрес используемой в этом процессе таблицы страниц. Следующие 10 бит виртуального адреса обозначают индекс в таблице страниц процесса, по которому лежит PTE (page table entry). В каждом PTE записан PPN (physical page number) и несколько флагов, регулирующие доступ к этой физической странице. Для получения необходимой строки внутри страницы используются последние 12 бит виртуального адреса.</p>\\n<p>Сначала <code>walkpgdir</code> использует верхние 10 бит (макрос PDX) виртуального адреса <code>va</code>, чтобы получить PDE. Если PDE не найден, значит таблица страниц для этого процесса еще не инициализирована, и если параметр <code>alloc</code> выставлен, то мы выделяем для нее память через <code>kalloc</code>, зануляем память и сохраняем ее адрес в <code>pgdir</code>. Затем получаем в таблице страниц строчку по индексу, состоящему из вторых 10 бит адреса (макрос PTX) и возвращаем ссылку на нее.</p>\\n<p>Вернувшись в <code>mappages</code>, пишем текущий физический адрес в полученную <code>PTE</code>:</p>\\n<pre><code class=\\\"language-c\\\">*pte = pa | perm | PTE_P;\\n</code></pre>\\n<h3>Аллокация физической памяти для ядра</h3>\\n<p>Аллокатор физической памяти использует <strong>free list</strong> (список освобождения), чтобы отслеживать страницы физической памяти, доступные для аллокации. Это связанный список страниц, в котором каждая аллокация памяти удаляет страницу, а каждое освобождение памяти - добавляет. Каждый элемент списка имеет тип <code>run</code>:</p>\\n<pre><code class=\\\"language-c\\\">struct run {\\n  struct run *next;\\n};\\n</code></pre>\\n<p>Каждая структура <code>run</code> хранится в начале свободной страницы памяти, потому что в ней все равно больше нечего хранить, она же свободная.</p>\\n<p>Доступ к free list защищается спинлоком:</p>\\n<pre><code class=\\\"language-c\\\">struct {\\n  struct spinlock lock;\\n  int use_lock;\\n  struct run *freelist;\\n} kmem;\\n</code></pre>\\n<p>Для инициализации аллокатора процедура <code>main</code> вызывает процедуры <code>kinit1</code> в начале и <code>kinit2</code> в конце. Это нужно потому что нам нужно аллоцировать немножко памяти, чтобы мы могли поднять все остальное (в том числе таблицу страниц), а уже после этого мы можем использовать нормальный стандартный большой аллокатор. Поэтому <code>kinit1</code> инициализирует аллокатор на 4 МБ, не использующий локов, а <code>kinit2</code> инициализирует полномощный аллокатор:</p>\\n<pre><code class=\\\"language-c\\\">int\\nmain(void)\\n{\\n  kinit1(end, P2V(4*1024*1024)); // phys page allocator\\n  ...\\n  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()\\n  ...  \\n}\\n\\n// Initialization happens in two phases.\\n// 1. main() calls kinit1() while still using entrypgdir to place just\\n// the pages mapped by entrypgdir on free list.\\n// 2. main() calls kinit2() with the rest of the physical pages\\n// after installing a full page table that maps them on all cores.\\nvoid\\nkinit1(void *vstart, void *vend)\\n{\\n  initlock(&#x26;kmem.lock, \\\"kmem\\\");\\n  kmem.use_lock = 0;\\n  freerange(vstart, vend);\\n}\\n\\nvoid\\nkinit2(void *vstart, void *vend)\\n{\\n  freerange(vstart, vend);\\n  kmem.use_lock = 1;\\n}\\n</code></pre>\\n<p><code>freerange</code> заносит страницы из указанного ренджа по одной во free list и выставляет каждый байт в них в 1, это нужно чтобы код, который попытается прочесть эту память после ее освобождения, не наткнулся на старые данные и выдал ошибку как можно быстрее.</p>\\n<h2>Пользовательское пространство</h2>\\n<p>На схеме изображено содержимое памяти для процесса:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/165bd8d61bd499051f28e2b358bf2ad9/bdbe7/memory-layout-main.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 57.80089153046062%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAABoElEQVQoz4VTa4+CMBDk//+uM/G+mJgIiAEMLwV5ig9EwbnOnjXRu8s1aVq2u9OZ2WI4joNtmiLPc5xOJ5zPZxyPR/R9j//G/X7/ETP0Zr/f43q9StLlchFwjnEccbvd0KlY13UYhkFy/pqGvoXMxnGQPQEIyrUsS2w3GyyXS5lplkmM57+NF8BOzd1uJ0zJhkV1XSOJY5iWBdpDawj4raiXGlpERWT/lEwAytMMmcSELN3CdV34vo/VaoUgDJEkCTzPw3w+h6NYF0WBXBGh74YwU2DaQ+55cDgcBDyKQiwWCwG1bQumaarVxkbZkCn5740x6E+sJK3Xa1lZQAZkqAE/p1NY1gPMsoVtqJgyn8zKshIrGkXqKZmMmMRkAvKbFhRFDk/FJpMPzGYzUdI0tch3XU98dZX8IAhE+rMpNJVyq6oSyWRIC3Q8jiK5jOeMUXKhWJEZG9kqAi/PhoyYyEkwektggjGHxU3TSC4v0g3889mwmF2lJCbrd6i7zQv00+CZ/pNeH/bjT2nbFr5qChmwSMvSbAjAVe8Jpom8d/kLO2GZD/ds8UwAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Memory layout\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/165bd8d61bd499051f28e2b358bf2ad9/10273/memory-layout-main.png\\\"\\n        srcset=\\\"/hows-that-again/static/165bd8d61bd499051f28e2b358bf2ad9/9b14a/memory-layout-main.png 163w,\\n/hows-that-again/static/165bd8d61bd499051f28e2b358bf2ad9/94962/memory-layout-main.png 325w,\\n/hows-that-again/static/165bd8d61bd499051f28e2b358bf2ad9/10273/memory-layout-main.png 650w,\\n/hows-that-again/static/165bd8d61bd499051f28e2b358bf2ad9/bdbe7/memory-layout-main.png 673w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Каждый пользовательский процесс стартует с адреса 0. Внизу пространства располагаются текст программы, ее данные и стек. Здесь <strong>важное различие</strong> относительно схемы памяти в илнуксе.</p>\\n<p>В xv6 стек располагается под кучей. <strong>В линуксе - стек наверху и растет вниз, куча внизу и растет вверх</strong>.</p>\\n<p>Стек занимает одну страницу и на схеме показан с содержимым после вызова <code>exec</code>. Сначала идут аргументы командной строки <code>argv</code>, представляющие ссылки на строки, затем аргумент <code>args</code> и адрес возврата. Чтобы стек не смог вырасти больше одной страницы, под ним располагается <strong>guard page</strong>. Эта страница не замаплена, поэтому когда стек попытается ее аллоцировать, будет сгенерировано исключение. Реальные ОС позволяют выделить больше пространства для стека, и он располагается на нескольких страницах.</p>\\n<p><code>sbrk</code> - это системный вызов для увеличения или уменьшения памяти процесса. Реализуется функцией <code>growproc</code>. Если аргумент положительный, то аллоцируется 1 или несколько страниц и мапятся наверх пользовательского пространства. Если отрицательный - размапливаются 1 или несколько страниц пользовательского пространства и освобождаются соответствующие им физические страницы.</p>\\n<pre><code class=\\\"language-c\\\">// Grow current process's memory by n bytes.\\n// Return 0 on success, -1 on failure.\\nint\\ngrowproc(int n)\\n{\\n  uint sz;\\n  struct proc *curproc = myproc();\\n\\n  sz = curproc->sz;\\n  if(n > 0){\\n    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)\\n      return -1;\\n  } else if(n &#x3C; 0){\\n    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)\\n      return -1;\\n  }\\n  curproc->sz = sz;\\n  switchuvm(curproc);\\n  return 0;\\n}\\n</code></pre>\\n<p>Для выделения области памяти в пользовательском пространстве используется <code>allocuvm</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Allocate page tables and physical memory to grow process from oldsz to\\n// newsz, which need not be page aligned.  Returns new size or 0 on error.\\nint\\nallocuvm(pde_t *pgdir, uint oldsz, uint newsz)\\n{\\n  char *mem;\\n  uint a;\\n\\n  if(newsz >= KERNBASE)\\n    return 0;\\n  if(newsz &#x3C; oldsz)\\n    return oldsz;\\n\\n  a = PGROUNDUP(oldsz);\\n  for(; a &#x3C; newsz; a += PGSIZE){\\n    mem = kalloc();\\n    if(mem == 0){\\n      cprintf(\\\"allocuvm out of memory\\\\n\\\");\\n      deallocuvm(pgdir, newsz, oldsz);\\n      return 0;\\n    }\\n    memset(mem, 0, PGSIZE);\\n    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) &#x3C; 0){\\n      cprintf(\\\"allocuvm out of memory (2)\\\\n\\\");\\n      deallocuvm(pgdir, newsz, oldsz);\\n      kfree(mem);\\n      return 0;\\n    }\\n  }\\n  return newsz;\\n}\\n</code></pre>\\n<p>Как видим, она проходит по одной странице от нижней до верхней границы ренджа, выделяет им виртуальную память, зануляет ее и пишет маппинг в таблицу страниц.</p>\\n<p>Похожим образом работает и деаалоцирование пользовательской памяти:</p>\\n<pre><code class=\\\"language-c\\\">// Deallocate user pages to bring the process size from oldsz to\\n// newsz.  oldsz and newsz need not be page-aligned, nor does newsz\\n// need to be less than oldsz.  oldsz can be larger than the actual\\n// process size.  Returns the new process size.\\nint\\ndeallocuvm(pde_t *pgdir, uint oldsz, uint newsz)\\n{\\n  pte_t *pte;\\n  uint a, pa;\\n\\n  if(newsz >= oldsz)\\n    return oldsz;\\n\\n  a = PGROUNDUP(newsz);\\n  for(; a  &#x3C; oldsz; a += PGSIZE){\\n    pte = walkpgdir(pgdir, (char*)a, 0);\\n    if(!pte)\\n      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;\\n    else if((*pte &#x26; PTE_P) != 0){\\n      pa = PTE_ADDR(*pte);\\n      if(pa == 0)\\n        panic(\\\"kfree\\\");\\n      char *v = P2V(pa);\\n      kfree(v);\\n      *pte = 0;\\n    }\\n  }\\n  return newsz;\\n}\\n</code></pre>\\n<h3>exec</h3>\\n<pre><code class=\\\"language-c\\\">int\\nexec(char *path, char **argv)\\n{\\n  # ------------------------------------------\\n  # сначала загружаем образ программы в память\\n  # ------------------------------------------\\n\\n  ...\\n  if((ip = namei(path)) == 0){   # ищет и возвращает inode по адресу path\\n    end_op();\\n    cprintf(\\\"exec: fail\\\\n\\\");\\n    return -1;\\n  }\\n  ilock(ip);        # лочит полученный inode\\n\\n  // Check ELF header\\n  if(readi(ip, (char*)&#x26;elf, 0, sizeof(elf)) != sizeof(elf))     # читает заголовок ELF-файла из inode в структуру &#x26;elf (которая имеет тип elfhdr)\\n    goto bad;\\n  if(elf.magic != ELF_MAGIC)                                    # проверяет, что это действительно ELF-файл\\n    goto bad;\\n\\n  if((pgdir = setupkvm()) == 0)                                 # аллоцирует новую таблицу страниц для этого процесса\\n    goto bad;\\n\\n  // Load program into memory.\\n  for(i=0, off=elf.phoff; i&#x3C;elf.phnum; i++, off+=sizeof(ph)){   # проходим по всем program headers ELF-файла, в каждом из которых описано расположение какого-либо сегмента памяти\\n    if(readi(ip, (char*)&#x26;ph, off, sizeof(ph)) != sizeof(ph))    # читает с диска program header\\n      goto bad;\\n    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)    # выделяем в виртуальной памяти кусок под сегмент\\n      goto bad;\\n    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) &#x3C; 0)  # загружаем постранично сегмент в память\\n      goto bad;\\n  }\\n  iunlockput(ip);       # разлочивает inode\\n\\n  # --------------------------------------------\\n  # теперь будем создавать пользовательский стек\\n  # --------------------------------------------\\n\\n  // Allocate two pages at the next page boundary.\\n  // Make the first inaccessible.  Use the second as the user stack.\\n  sz = PGROUNDUP(sz);\\n  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0) # аллоцируем 2 страницы над сегментами\\n    goto bad;\\n  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));          # первую страницу удаляем из таблицы страниц, это будет наша guard page\\n  sp = sz;\\n\\n  // Push argument strings, prepare rest of stack in ustack.\\n  for(argc = 0; argv[argc]; argc++) {\\n    sp = (sp - (strlen(argv[argc]) + 1)) &#x26; ~3;\\n    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) &#x3C; 0)\\n      goto bad;\\n    ustack[3+argc] = sp;\\n  }\\n  ustack[3+argc] = 0;\\n\\n  ustack[0] = 0xffffffff;  // fake return PC\\n  ustack[1] = argc;\\n  ustack[2] = sp - (argc+1)*4;  // argv pointer\\n\\n  sp -= (3+argc+1) * 4;\\n  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) &#x3C; 0)      # записываем стек в память\\n    goto bad;\\n\\n  # -----------------------------------\\n  # теперь переключаемся на новый имедж\\n  # -----------------------------------\\n\\n  // Commit to the user image.\\n  oldpgdir = curproc->pgdir;\\n  curproc->pgdir = pgdir;   # устанавливаем процессу созданную нами таблицу страниц\\n  curproc->sz = sz;\\n  curproc->tf->eip = elf.entry;  # следующей выполняемой инструкцией будет точка входа в загруженный образ\\n  curproc->tf->esp = sp;        # устанавливаем указатель стека на созданный нами стек\\n  switchuvm(curproc);       # переключаемся на использование образа нового процесса\\n  freevm(oldpgdir);         # удаляем старую таблицу страниц\\n  return 0;\\n}\\n</code></pre>\\n<p>В результате всех этих манипуляций <code>exec</code> загружает сегменты программы по тем адресам, которые указаны в ELF-файле. Эти адреса вполне могут указывать на область памяти ядра, поэтому <code>exec</code> опасен. Внутри кода <code>exec</code> есть некоторые дополнительные проверки для этого, которые здесь были опущены.</p>\\n<p>В настоящих операционных системах есть еще пейджинг неиспользуемых страниц на диск, copy-on-write, разделяемая память, лениво-аллоцируемые страницы и автоматически расширяемые стеки. В xv6 этого всего нет.</p>\\n<h2>Трэпы/исключения, прерывания и драйвера</h2>\\n<p>Управление от пользовательской программы в ядро передается в 3 случаях:</p>\\n<ol>\\n<li>Системный вызов</li>\\n<li>Исключение (официальная терминология xv6 использует термин trap)</li>\\n<li>Прерывание (разделение времени среди процессов осуществляется по прерыванию таймера)</li>\\n</ol>\\n<p>Все прерывания обрабатываются ядром, потому что обычно только у него есть необходимые привилегии.</p>\\n<p>Все 3 случая на самом деле реализуются через прерывания: для системного вызова генерируется прерывание инструкцией int, для исключений тоже.</p>\\n<p>При каждом переходе в ядро ОС сохраняет значения регистров, готовится к выполнению кода в ядре, выбирает точку входа в ядро, получает информация о произошедшем событии. Общий алгоритм работы при прерывании такой:</p>\\n<ul>\\n<li>прерывание приостанавливает нормальную работу процессора</li>\\n<li>процессор сохраняет значения регистров, чтобы можно было потом к ним вернуться</li>\\n<li>процессор запускает новую последовательность инструкций, называемую <em>обработчик прерываний</em></li>\\n</ul>\\n<h3>Защита X86</h3>\\n<p>У процессоров x86 есть 4 уровня защиты, именуемые от 0 (самый привилегированный) до 3 (наименее привилегированный). На практике, большинство ОС используют только 0 и 3, которые называются <em>режим ядра</em> и  <em>пользовательский режим</em>, соответственно. Текущий уровень привилегий хранится в регистре <code>%cs</code>.</p>\\n<p>Обработчики прерываний определены в IDT (interrupt descriptor table). IDT содержит 256 строк, в каждой из которых есть <code>%cs</code> и <code>%eip</code> для обработки прерывания.</p>\\n<p>Для выполнения системного вызова на x86, программа выполняет инструкцию <code>int n</code>, где <code>n</code> - индекс обработчика в IDT. Инструкция <code>int n</code> делает следующее:</p>\\n<ol>\\n<li>Получает n-ю запись из IDT</li>\\n<li>Берет CPL (current privilege level) из регистра %cs, проверяет, что CPL &#x3C;= DPL, где DPL = descriptor privilege level, хранящийся в полученной из IDT строке. Благодаря этому пользовательские программы (CPL=3) не могут дергать обработчики уровня ядра (DPL=0).</li>\\n<li>Сохраняет значения <code>%esp</code> и <code>%ss</code> (stack segment) во внутренних регистрах CPU, но только если уровень привилегий нужного сегмента &#x3C; CPL</li>\\n<li>Загружает <code>%ss</code> и <code>%esp</code> из дескриптора сегмента таска (?)</li>\\n<li>Пушит <code>%ss</code>, <code>%esp</code>, <code>%eflags</code>, <code>%cs</code>, <code>%eip</code>.</li>\\n<li>Очищает бит IF в <code>%eflags</code>, но только в случае прерывания</li>\\n<li>Выставляет <code>%cs</code> и <code>%eip</code> в значения, полученные из дескриптора.</li>\\n</ol>\\n<h3>Реализация системного вызова</h3>\\n<p>Выше я уже описывал, как заполняется файл <code>vectors.S</code>, но не было описано, как он используется. Так вот, при старте процедура <code>main()</code> вызывает <code>tvinit()</code>. Вот ее код:</p>\\n<pre><code class=\\\"language-c\\\">void\\ntvinit(void)\\n{\\n  int i;\\n\\n  for(i = 0; i &#x3C; 256; i++)\\n    SETGATE(idt[i], 0, SEG_KCODE&#x3C;&#x3C;3, vectors[i], 0);\\n  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE&#x3C;&#x3C;3, vectors[T_SYSCALL], DPL_USER);\\n\\n  initlock(&#x26;tickslock, \\\"time\\\");\\n}\\n\\n// Set up a normal interrupt/trap gate descriptor.\\n// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.\\n//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone\\n// - sel: Code segment selector for interrupt/trap handler\\n// - off: Offset in code segment for interrupt/trap handler\\n// - dpl: Descriptor Privilege Level -\\n//        the privilege level required for software to invoke\\n//        this interrupt/trap gate explicitly using an int instruction.\\n#define SETGATE(gate, istrap, sel, off, d)                \\\\\\n{                                                         \\\\\\n  (gate).off_15_0 = (uint)(off) &#x26; 0xffff;                \\\\\\n  (gate).cs = (sel);                                      \\\\\\n  (gate).args = 0;                                        \\\\\\n  (gate).rsv1 = 0;                                        \\\\\\n  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \\\\\\n  (gate).s = 0;                                           \\\\\\n  (gate).dpl = (d);                                       \\\\\\n  (gate).p = 1;                                           \\\\\\n  (gate).off_31_16 = (uint)(off) >> 16;                  \\\\\\n}\\n</code></pre>\\n<p>Видим, что цикл проходит по всем элементам <code>vectors</code> и для каждого создает запись в массиве <code>idt</code>, потом отдельно добавляет запись, предназначенную для обработки системных вызовов под номером 64.</p>\\n<p>У обычных обработчиков вторым параметром передается 0, что делает их обработчиками прерываний, а у системного вызова - 1, что делает его исключением или трэпом. Так же ему выставляется <code>DPL = DPL_USER</code>, а обработчикам прерываний - <code>DPL = 0</code>. xv6 зарещает пользовательскому коду вызывать любые другие прерывания, кроме 64, если они попытаются, то получат <code>general protection exception</code>.</p>\\n<p>Первая часть обработки системного вызова описана в разделе <strong>Context switch</strong>. Для системного вызова там актуально все, что до вызова <code>trap(tf)</code>. Там в этой процедуре пошли по ветви, соответствующей прерыванию таймера. Здесь пойдем по ветке, соответствующей <code>T_SYSCALL</code>:</p>\\n<pre><code class=\\\"language-c\\\">void\\ntrap(struct trapframe *tf)\\n{\\n  if(tf->trapno == T_SYSCALL){\\n    ...\\n    myproc()->tf = tf;\\n    syscall();\\n    ...\\n    return;\\n  }\\n  ...\\n}\\n</code></pre>\\n<p>Шлавное, что здесь происходит - вызывается <code>syscall()</code>. Посмотрим на него:</p>\\n<pre><code class=\\\"language-c\\\">void\\nsyscall(void)\\n{\\n  int num;\\n  struct proc *curproc = myproc();\\n\\n  num = curproc->tf->eax;\\n  if(num > 0 &#x26;&#x26; num &#x3C; NELEM(syscalls) &#x26;&#x26; syscalls[num]) {\\n    curproc->tf->eax = syscalls[num]();\\n  } else {\\n    cprintf(\\\"%d %s: unknown sys call %d\\\\n\\\",\\n            curproc->pid, curproc->name, num);\\n    curproc->tf->eax = -1;\\n  }\\n}\\n</code></pre>\\n<p>Он сохраняет номер вызова из регистра <code>eax</code> в переменную <code>num</code>, получает по этому индексу функцию из массива <code>syscalls</code>, выполняет ее и кладет результат в регистр <code>eax</code>.</p>\\n<p>Массив <code>syscalls</code> выглядит так:</p>\\n<pre><code class=\\\"language-c\\\">static int (*syscalls[])(void) = {\\n[SYS_fork]    sys_fork,\\n[SYS_exit]    sys_exit,\\n[SYS_wait]    sys_wait,\\n[SYS_pipe]    sys_pipe,\\n[SYS_read]    sys_read,\\n[SYS_kill]    sys_kill,\\n[SYS_exec]    sys_exec,\\n[SYS_fstat]   sys_fstat,\\n[SYS_chdir]   sys_chdir,\\n[SYS_dup]     sys_dup,\\n[SYS_getpid]  sys_getpid,\\n[SYS_sbrk]    sys_sbrk,\\n[SYS_sleep]   sys_sleep,\\n[SYS_uptime]  sys_uptime,\\n[SYS_open]    sys_open,\\n[SYS_write]   sys_write,\\n[SYS_mknod]   sys_mknod,\\n[SYS_unlink]  sys_unlink,\\n[SYS_link]    sys_link,\\n[SYS_mkdir]   sys_mkdir,\\n[SYS_close]   sys_close,\\n};\\n</code></pre>\\n<p>Для получения своих аргументов системные функции используют функции <code>argint</code>, <code>argptr</code>, <code>argstr</code> и <code>argfd</code>. Они принимают первым аргументов <code>n</code> и возвращают n-й аргумент как число, указатель, строку или файловый дескриптор. n-й аргумент лежит по адресу <code>%esp+4+4*n</code> (адрес возврата лежит  %esp, а первый аргумент лежит в %esp+4).</p>\\n<p>Системные функции лежат в syspoc.c и sysfile.c и в основном являются оболочками - читают аргументы со стека, используя функции <code>arg*</code> и вызывают с этими аргументами реальные реализации.</p>\\n<h3>Реализация прерываний</h3>\\n<p>Раньше у материнских плат был programmable interrupt controller (PIC), который занимался обслуживанием прерываний. Но потом появились системы с несколькими процессорами и пришлось каждому делать свой, интегрированный APIC (advanced PIC). Теперь для работы с прерываниями на уровне ОС используется 2 API: работающий с прерываниями системы I/O (ioapic.c) и работающий с локальными APIC, интегрированными в каждый процессор (lapic.c).</p>\\n<p><code>ioapic.c</code> предоставляет функцию <code>ioapicenable</code>, которая позволяет различным устройствам ввода-вывода включать отдельные прерывания и указывать, на каком процессоре они должны быть обработаны:</p>\\n<pre><code class=\\\"language-c\\\">void\\nioapicenable(int irq, int cpunum)\\n{\\n  // Mark interrupt edge-triggered, active high,\\n  // enabled, and routed to the given cpunum,\\n  // which happens to be that cpu's APIC ID.\\n  ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);\\n  ioapicwrite(REG_TABLE+2*irq+1, cpunum &#x3C;&#x3C; 24);\\n}\\n</code></pre>\\n<p>Например, при старте консоль направляет прерывания клавиатуры на процессор 0:</p>\\n<pre><code class=\\\"language-c\\\">void\\nconsoleinit(void)\\n{\\n  ...\\n  ioapicenable(IRQ_KBD, 0);\\n}\\n</code></pre>\\n<p>А прерывания от дисков отправляются на последний процессор:</p>\\n<pre><code class=\\\"language-c\\\">void\\nideinit(void)\\n{\\n  ...\\n  ioapicenable(IRQ_IDE, ncpu - 1);\\n  ...\\n}\\n</code></pre>\\n<p><code>lapic.c</code> инициализирует все свои прерывания сам, в <code>lapicinit</code>. Там же инициализируется и прерывание для таймера, которое потом обрабатывается в <code>trap.c</code>.</p>\\n<h3>Драйвера</h3>\\n<p>Драйвера указывают устройствам, какие операции выполнять и какие прерывания генерировать, когда закончат, а так же реагируют на эти прерывания.</p>\\n<p>Рассмотрим реализацию драйвера диска.</p>\\n<p>Диск хранит данные как последовательность 512-байтных <em>блоков</em>, или <em>секторов</em>. Операционная система использует свои блоки, размер которых обычно кратен размеру сектора. В xv6 блок тоже 512 байт. В памяти блок представлен структурой <code>buf</code>:</p>\\n<pre><code class=\\\"language-c\\\">struct buf {\\n  int flags;            # B_VALID если данные прочитали, B_DIRTY если они изменились и нужно их записать\\n  uint dev;             # номер устройства\\n  uint blockno;         # номер сектора\\n  struct sleeplock lock;\\n  uint refcnt;\\n  struct buf *prev; // LRU cache list\\n  struct buf *next;\\n  struct buf *qnext; // disk queue\\n  uchar data[BSIZE];    # копия данных сектора в памяти\\n};\\n</code></pre>\\n<p>При загрузке ОС инициализирует драйвер диска вызовом <code>ideinit</code> из <code>main</code>:</p>\\n<pre><code class=\\\"language-c\\\">void\\nideinit(void)\\n{\\n  int i;\\n\\n  initlock(&#x26;idelock, \\\"ide\\\");\\n  ioapicenable(IRQ_IDE, ncpu - 1);  # включает прерывание диска\\n  idewait(0);                       # ждет, пока диск будет готов к принятию команд\\n\\n  // Check if disk 1 is present\\n  outb(0x1f6, 0xe0 | (1&#x3C;&#x3C;4));       # проверяет доступен ли еще один диск - диск 1. Для этого пишет в порт 0x1f6, чтобы выбрать этот диск\\n  for(i=0; i&#x3C;1000; i++){            # затем в течение 1000 попыток пытается прочесть статус с порта 0x1f7. Если получается - считаем, что диск есть.\\n    if(inb(0x1f7) != 0){\\n      havedisk1 = 1;\\n      break;\\n    }\\n  }\\n\\n  // Switch back to disk 0.\\n  outb(0x1f6, 0xe0 | (0&#x3C;&#x3C;4));       # выбираем обратно диск 0\\n}\\n</code></pre>\\n<p><code>idewait</code> работает так: материнка выставляет статус диска в I/O порту <code>0x1f7</code>, а <code>idewait</code> в цикле читает этот статус и ждет, пока бит IDE<em>BSY не будет снят, а IDE</em>DRDY не выставлен:</p>\\n<p>(I/O порт - это такая отдельная память в процессоре, через которую он работает с устройствами ввода-вывода)</p>\\n<pre><code class=\\\"language-c\\\">// Wait for IDE disk to become ready.\\nstatic int\\nidewait(int checkerr)\\n{\\n  int r;\\n\\n  while(((r = inb(0x1f7)) &#x26; (IDE_BSY|IDE_DRDY)) != IDE_DRDY)\\n    ;\\n  if(checkerr &#x26;&#x26; (r &#x26; (IDE_DF|IDE_ERR)) != 0)\\n    return -1;\\n  return 0;\\n}\\n</code></pre>\\n<p>После <code>ideinit</code> диск никто не трогает, пока кэш буфера не решит, что пора выполнить <code>iderw</code>, который вызывает <code>idestart</code>, который в зависимости от флагов синхронизирует содержимое буфера с содержимым сектора:</p>\\n<pre><code class=\\\"language-c\\\">// Sync buf with disk.\\n// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.\\n// Else if B_VALID is not set, read buf from disk, set B_VALID.\\nvoid\\niderw(struct buf *b)\\n{\\n  struct buf **pp;\\n\\n  if(!holdingsleep(&#x26;b->lock))\\n    panic(\\\"iderw: buf not locked\\\");\\n  if((b->flags &#x26; (B_VALID|B_DIRTY)) == B_VALID)\\n    panic(\\\"iderw: nothing to do\\\");\\n  if(b->dev != 0 &#x26;&#x26; !havedisk1)\\n    panic(\\\"iderw: ide disk 1 not present\\\");\\n\\n  acquire(&#x26;idelock);  //DOC:acquire-lock\\n\\n  // Append b to idequeue.\\n  b->qnext = 0;\\n  for(pp=&#x26;idequeue; *pp; pp=&#x26;(*pp)->qnext)  // записываем наш буфер в очередь запросов к диску. idequeue указывает на буфер, который сейчас читается или пишется на диск.\\n    ;\\n  *pp = b;\\n\\n  // Start disk if necessary.\\n  if(idequeue == b)                     // если подошла очередь нашего блока, то сразу его обрабатываем. Иначе - ему придется подождать, пока не сработают прерывания завершения операции для всех блоков перед ним.\\n    idestart(b);\\n\\n  // Wait for request to finish.\\n  while((b->flags &#x26; (B_VALID|B_DIRTY)) != B_VALID){\\n    sleep(b, &#x26;idelock);\\n  }\\n\\n\\n  release(&#x26;idelock);\\n}\\n\\n// Start the request for b.  Caller must hold idelock.\\nstatic void\\nidestart(struct buf *b)\\n{\\n  if(b == 0)\\n    panic(\\\"idestart\\\");\\n  if(b->blockno >= FSSIZE)\\n    panic(\\\"incorrect blockno\\\");\\n  int sector_per_block =  BSIZE/SECTOR_SIZE;\\n  int sector = b->blockno * sector_per_block;\\n  int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;\\n  int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;\\n\\n  if (sector_per_block > 7) panic(\\\"idestart\\\");\\n\\n  idewait(0);\\n  outb(0x3f6, 0);  // generate interrupt\\n  outb(0x1f2, sector_per_block);  // number of sectors\\n  outb(0x1f3, sector &#x26; 0xff);\\n  outb(0x1f4, (sector >> 8) &#x26; 0xff);\\n  outb(0x1f5, (sector >> 16) &#x26; 0xff);\\n  outb(0x1f6, 0xe0 | ((b->dev&#x26;1)&#x3C;&#x3C;4) | ((sector>>24)&#x26;0x0f));\\n  if(b->flags &#x26; B_DIRTY){\\n    outb(0x1f7, write_cmd);\\n    outsl(0x1f0, b->data, BSIZE/4);\\n  } else {\\n    outb(0x1f7, read_cmd);\\n  }\\n}\\n</code></pre>\\n<p>Делает он это тоже через порты ввода-вывода. Чтение/запись происходят асинхронно, то есть например при чтении мы даем команду и отправляется делать другие вещи, а обработчик прерываний ловит прерывание конца чтения и записывает в буфер данные. При записи мы сразу пишем данные в порт, а в обработчике прерывания только лишь продвигаем очередь к следующему блоку. Вот как это выглядит:</p>\\n<pre><code class=\\\"language-c\\\">void\\ntrap(struct trapframe *tf)\\n{\\n  ...\\n  case T_IRQ0 + IRQ_IDE:\\n    ideintr();                  # регистрируем вызов нашего обработчика\\n    lapiceoi();\\n    break;\\n  ...  \\n}\\n\\n// Interrupt handler.\\nvoid\\nideintr(void)\\n{\\n  struct buf *b;\\n\\n  // First queued buffer is the active request.\\n  acquire(&#x26;idelock);\\n\\n  if((b = idequeue) == 0){  # читаем текущий буфер в b\\n    release(&#x26;idelock);\\n    return;\\n  }\\n  idequeue = b->qnext;      # продвигаем очередь к следующему буферу\\n\\n  // Read data if needed.\\n  if(!(b->flags &#x26; B_DIRTY) &#x26;&#x26; idewait(1) >= 0)  # если флаг b не выставлен, значит у нас не запись, значит - чтение\\n    insl(0x1f0, b->data, BSIZE/4);              # подаем на ассемблер команду прочесть данные с порта ввода-вывода 0x1f0 в буфер b->data\\n\\n  // Wake process waiting for this buf.\\n  b->flags |= B_VALID;\\n  b->flags &#x26;= ~B_DIRTY;\\n  wakeup(b);\\n\\n  if(idequeue != 0)         # запускаем обработку следующео буфера в очереди\\n    idestart(idequeue);\\n\\n  release(&#x26;idelock);\\n}\\n</code></pre>\\n<p>Некоторые устройства динамически переключаются между получением данных по прерываниям и поллингом, например, если устройство знает, что ей нужно совершить много однотипных операций подряд, то оно может на  переключиться на поллинг. Когда пакет принят - переключается обратно на прерывания.</p>\\n<p>Некоторые драйверы настраивают APIC так, чтобы балансировать нагрузку между процессорами.</p>\\n<p>Когда программа читает файл, данные из него копируются дважды - сначала с диска в ядро через порты ввода-вывода, потом из ядра в программу командой <code>read</code>. Если после этого мы шлем данные по сети, то они копируются еще два раза - в ядро командой <code>write</code> и в сетевое устройство через порты ввода-вывода. Поэтому часто, чтобы избежать этих лишних операций, операционные системы используют специальные функции для избежания копий данных, чтобы данные шли сразу в адресное пространство процесса.</p>\\n<h2>Потоковая синхронизация</h2>\\n<h3>Локи</h3>\\n<p>В xv6 есть 2 типа локов: спин-локи и слип-локи. Начнем со спинлоков.</p>\\n<h4>Спинлоки</h4>\\n<p>Спинлок представлен структурой <code>spinlock</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Mutual exclusion lock.\\nstruct spinlock {\\n  uint locked;       // Is the lock held?\\n\\n  // For debugging:\\n  char *name;        // Name of lock.\\n  struct cpu *cpu;   // The cpu holding the lock.\\n  uint pcs[10];      // The call stack (an array of program counters)\\n                     // that locked the lock.\\n};\\n</code></pre>\\n<p>Чтобы выставить лок, есть специальная инструкция x86: <code>xchg</code>, вот как она используется в нашем коде (x86.h):</p>\\n<pre><code class=\\\"language-c\\\">static inline uint\\nxchg(volatile uint *addr, uint newval)\\n{\\n  uint result;\\n\\n  // The + in \\\"+m\\\" denotes a read-modify-write operand.\\n  asm volatile(\\\"lock; xchgl %0, %1\\\" :\\n               \\\"+m\\\" (*addr), \\\"=a\\\" (result) :\\n               \\\"1\\\" (newval) :\\n               \\\"cc\\\");\\n  return result;\\n}\\n</code></pre>\\n<p>(Кстати, в этом же файле описаны и все остальные используемые инструкции x86)</p>\\n<p><code>xchg</code> позволяет атомарно поменять местами содержимое адреса памяти и значение регистра. То есть если в памяти хранилось 1, а в регистре 2, то после операции в памяти будет 2, а в регистре 1.</p>\\n<p>Функция <code>acquire</code> использует эту инструкцию:</p>\\n<pre><code class=\\\"language-c\\\">// Acquire the lock.\\n// Loops (spins) until the lock is acquired.\\n// Holding a lock for a long time may cause\\n// other CPUs to waste time spinning to acquire it.\\nvoid\\nacquire(struct spinlock *lk)\\n{\\n  pushcli(); // disable interrupts to avoid deadlock.\\n\\n  while(xchg(&#x26;lk->locked, 1) != 0);   # пишем в память 1 и проверяем, что там был 0. если мы записали 1, а там и так был 1, значит лок захвачен другим потоком.\\n\\n  // Tell the C compiler and the processor to not move loads or stores\\n  // past this point, to ensure that the critical section's memory\\n  // references happen after the lock is acquired.\\n  __sync_synchronize();\\n\\n  lk->cpu = mycpu();\\n  getcallerpcs(&#x26;lk, lk->pcs);\\n}\\n</code></pre>\\n<p>После захвата лока <code>acquire</code> еще пишет в лок номер процессора и стек трейс для отладки в случае проблем.</p>\\n<p>Функция <code>release</code> работает ровно наоборот - сначала очищает отладочную информацию, потом пишет в поле <code>locked</code> значение 0:</p>\\n<pre><code class=\\\"language-c\\\">// Release the lock.\\nvoid\\nrelease(struct spinlock *lk)\\n{\\n  ...\\n  lk->pcs[0] = 0;\\n  lk->cpu = 0;\\n\\n  // Tell the C compiler and the processor to not move loads or stores\\n  // past this point, to ensure that all the stores in the critical\\n  // section are visible to other cores before the lock is released.\\n  // Both the C compiler and the hardware may re-order loads and\\n  // stores; __sync_synchronize() tells them both not to.\\n  __sync_synchronize();\\n\\n  // Release the lock, equivalent to lk->locked = 0.\\n  // This code can't use a C assignment, since it might\\n  // not be atomic. A real OS would use C atomics here.\\n  asm volatile(\\\"movl $0, %0\\\" : \\\"+m\\\" (lk->locked) : );\\n  \\n  popcli();\\n}\\n</code></pre>\\n<h4>Слиплоки</h4>\\n<p>Проблема спин-локов в том, что они отключают прерывания, а значит между <code>acquire</code> и <code>release</code> не может произойти <code>context switch</code>. То есть если у нас какой-то долгий лок, то остальные потоки будут его ждать. Слип-локи допускают переключение контекста в критической секции.</p>\\n<p><strong>ПРИМЕЧАНИЕ</strong>: Те спинлоки, которые в дотнете - реализованы в юзерспейсе, поэтому там вполне может быть переключение потока между захватом и освобождением лока. А вот в ядре линукса - не может.</p>\\n<p>Слиплок описан следующей структурой:</p>\\n<pre><code class=\\\"language-c\\\">// Long-term locks for processes\\nstruct sleeplock {\\n  uint locked;       // Is the lock held?\\n  struct spinlock lk; // spinlock protecting this sleep lock\\n  \\n  // For debugging:\\n  char *name;        // Name of lock.\\n  int pid;           // Process holding lock\\n};\\n</code></pre>\\n<p>Реализация слиплока описана в <code>sleeplock.c</code>. Вот методы захвата и освобождения:</p>\\n<pre><code class=\\\"language-c\\\">void\\nacquiresleep(struct sleeplock *lk)\\n{\\n  acquire(&#x26;lk->lk);\\n  while (lk->locked) {\\n    sleep(lk, &#x26;lk->lk);\\n  }\\n  lk->locked = 1;\\n  lk->pid = myproc()->pid;\\n  release(&#x26;lk->lk);\\n}\\n\\nvoid\\nreleasesleep(struct sleeplock *lk)\\n{\\n  acquire(&#x26;lk->lk);\\n  lk->locked = 0;\\n  lk->pid = 0;\\n  wakeup(lk);\\n  release(&#x26;lk->lk);\\n}\\n</code></pre>\\n<p><code>acquiresleep</code> ожидает, пока освободится <code>lk->locked</code> и выставляет его в 1. <code>releasesleep</code> сразу выставляет <code>lk->locked</code> в 0. </p>\\n<p>Непонятно, как работает ситуация, когда <code>acquiresleep</code> взял спинлок, крутится в <code>while</code>, а освободить <code>lk->locked</code> некому, так как <code>releasesleep</code> не может захватить этот же спинлок. Дело в том, что при <code>sleep</code> функция <code>acquiresleep</code> отпускает спинлок и дает возможность поработать другим функциям.</p>\\n<p>Вот как реализован <code>sleep</code>:</p>\\n<pre><code class=\\\"language-c\\\">sleep(void *chan, struct spinlock *lk)\\n{\\n  struct proc *p = myproc();\\n  \\n  if(p == 0)\\n    panic(\\\"sleep\\\");\\n\\n  if(lk == 0)\\n    panic(\\\"sleep without lk\\\");\\n\\n  // Must acquire ptable.lock in order to\\n  // change p->state and then call sched.\\n  // Once we hold ptable.lock, we can be\\n  // guaranteed that we won't miss any wakeup\\n  // (wakeup runs with ptable.lock locked),\\n  // so it's okay to release lk.\\n  if(lk != &#x26;ptable.lock){  //DOC: sleeplock0\\n    acquire(&#x26;ptable.lock);  //DOC: sleeplock1\\n    release(lk);\\n  }\\n  // Go to sleep.\\n  p->chan = chan;\\n  p->state = SLEEPING;\\n\\n  sched();\\n\\n  // Tidy up.\\n  p->chan = 0;\\n\\n  // Reacquire original lock.\\n  if(lk != &#x26;ptable.lock){  //DOC: sleeplock2\\n    release(&#x26;ptable.lock);\\n    acquire(lk);\\n  }\\n}\\n</code></pre>\\n<p>Она сначала делает <code>release(lk)</code>, потом <code>sched()</code>, отдавая управление другим потокам, а когда получит управление обратно, делает <code>acquire(lk)</code>, захватывая спинлок обратно. Таким образом, если другой поток захватит этот лок, то наш поток какое-то время не сможет вернуться из слипа.</p>\\n<h2>Файловая система</h2>\\n<p>Состоит из 7 слоев, каждый из которых исплоьзует результаты работы нижележащего:</p>\\n<ul>\\n<li>слой дескрипторов файлов - абстрагирует многие ресурсы Unix, используя интерфейс файловой системы</li>\\n<li>слой путей - предоставляет иерархические пути к файлам и возможность получения файла по пути путем рекурсивного поиска</li>\\n<li>слой директорий - предоставляет директории, каждая из которых является специальным видом ай-ноды, в которой хранится последовательность детей директории, для каждого из которых записано имя файла и i-номер</li>\\n<li>слой айнодов - предоставляет индивидуальные файлы, каждый из которых представлен как <em>inode</em> с уникальным i-номером и несколькими секторами, в которых содержится содержимое файла</li>\\n<li>слой логирования - заворачивает операции доступа от высших слоев в транзакции и обеспечивает атомарность изменений секторов</li>\\n<li>слой буферного кэша - кэширует сектора в памяти и синхронизирует доступ к ним</li>\\n<li>слой диска - читает и пишет сектора на диск через драйвер IDE</li>\\n</ul>\\n<h3>Слой буферного кэша</h3>\\n<p>Описан в файле <code>bio.c</code>. Основные функции:</p>\\n<ul>\\n<li><code>bread</code> - получает <code>buf</code>, содержащий копию данных сектора</li>\\n<li><code>brwite</code> - записывает модифицированный буффер в соответствующий ему сектор на диске.</li>\\n</ul>\\n<p>Сам кэш описывается следующей структурой:</p>\\n<pre><code class=\\\"language-c\\\">struct {\\n  struct spinlock lock;\\n  struct buf buf[NBUF];  // связанный список секторов в кэше, каждый ссылается на соседние через prev/next\\n  \\n  struct buf head;\\n} bcache;\\n</code></pre>\\n<p>Он содержит фиксированное количество объектов структуры <code>buf</code>, каждая из которых содержит данные 1 сектора.</p>\\n<p>Рассмотрим функции <code>bread</code> и <code>bwrite</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Write b's contents to disk.  Must be locked.\\nvoid\\nbwrite(struct buf *b)\\n{\\n  if(!holdingsleep(&#x26;b->lock))\\n    panic(\\\"bwrite\\\");\\n  b->flags |= B_DIRTY;\\n  iderw(b);\\n}\\n\\n// Return a locked buf with the contents of the indicated block.\\nstruct buf*\\nbread(uint dev, uint blockno)\\n{\\n  struct buf *b;\\n\\n  b = bget(dev, blockno);\\n  if((b->flags &#x26; B_VALID) == 0) { // данные неактуальны\\n    iderw(b);                     // нужно перечитать с диска\\n  }\\n  return b;\\n}\\n\\n// Look through buffer cache for block on device dev.\\n// If not found, allocate a buffer.\\n// In either case, return locked buffer.\\nstatic struct buf*\\nbget(uint dev, uint blockno)\\n{\\n  struct buf *b;\\n\\n  acquire(&#x26;bcache.lock);\\n\\n  for(b = bcache.head.next; b != &#x26;bcache.head; b = b->next){  // проходим по закэшированным буфам\\n    if(b->dev == dev &#x26;&#x26; b->blockno == blockno){   // проверяем, искомый ли это буф\\n      b->refcnt++;            // если да, то инкрементируем счетчик ссылок и возвращаем сектор\\n      release(&#x26;bcache.lock);\\n      acquiresleep(&#x26;b->lock);\\n      return b;\\n    }\\n  }\\n\\n  // Если мы оказались здесь, значит в памяти искомого сектора нет\\n  // Нужно убрать из кэша один сектора и положить на его место прочитанный с диска\\n  // Убирать из кэша можно только сектор, который никем не используется и не содержт незаписанных на диск изменений. \\n  // То есть у него должно быть refcnt == 0 и не стоять флаг B_DIRTY.\\n  for(b = bcache.head.prev; b != &#x26;bcache.head; b = b->prev){ // кэш закольцован, поэтому через head.prev мы можем обратиться к последнему элементу, это будет least recently used элемент\\n    if(b->refcnt == 0 &#x26;&#x26; (b->flags &#x26; B_DIRTY) == 0) {\\n      b->dev = dev;           // когда нашли неиспользуемый сектор в кэше, то просто перезаписываем его поля\\n      b->blockno = blockno;\\n      b->flags = 0;           // это сбросить флаг B_VALID, чтобы bread узнал, что в секторе неактуальные данные и прочитал их туда с диска\\n      b->refcnt = 1;\\n      release(&#x26;bcache.lock);\\n      acquiresleep(&#x26;b->lock);\\n      return b;\\n    }\\n  }\\n  panic(\\\"bget: no buffers\\\");\\n}\\n</code></pre>\\n<p>После окончания работы с сектором, его нужно отпустить функцией <code>brelse</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Release a locked buffer.\\n// Move to the head of the MRU list.\\nvoid\\nbrelse(struct buf *b)\\n{\\n  if(!holdingsleep(&#x26;b->lock))\\n    panic(\\\"brelse\\\");\\n\\n  releasesleep(&#x26;b->lock);\\n\\n  acquire(&#x26;bcache.lock);\\n  b->refcnt--;\\n  if (b->refcnt == 0) {\\n    // no one is waiting for it.\\n    b->next->prev = b->prev;\\n    b->prev->next = b->next;\\n    b->next = bcache.head.next;\\n    b->prev = &#x26;bcache.head;\\n    bcache.head.next->prev = b;\\n    bcache.head.next = b;\\n  }\\n  \\n  release(&#x26;bcache.lock);\\n}\\n</code></pre>\\n<h3>Слой логирования</h3>\\n<p>Перед каждой операцией записи ее описание пишется в <em>лог</em> на диске. После этого на диск пишется <em>commit record</em>, означающая, что лог завершен. После осуществления записи на диск, лог и его <em>commit record</em> уничтожается.</p>\\n<p>После перезагрузки на старте системы, если на диске есть <em>commit record</em>, то пишем данные из соответствующего лога на диск. Если лог есть, а коммит рекорда нет - значит, операция записи еще не началась, можем проигнорировать лог. В любом случае лог в конце восстановления удаляется.</p>\\n<p>Лог состоит из блока заголовка и последовательности копий обновленных секторов (т.н. залогированные сектора). Блок заголовка содержит массив номеров секторов и количество залогированных секторов. Если это количество равно 0, то транзакций в логе нет, а если больше 0, то значит лог содержит закоммиченную транзакцию с указанным количеством блоков. Блог заголовка записывается при коммите и зануляется после записи на диск.</p>\\n<p>Использование лога в системном вызове выглядит так:</p>\\n<pre><code class=\\\"language-c\\\">begin_op();\\n...\\nbp = bread(...);\\nbp->data[...] = ...;\\nlog_write(bp);\\n...\\nend_op();\\n</code></pre>\\n<p><code>begin_op</code> ожидает, пока система логирования освободится и пока в логе появится достаточное количество места, после чего инкрементирует <code>log.outstanding</code>, которое означает количество одновременных системных вызовов к файловой системе, которые зарезервировали место в нашем логе. Общее зарезервированное пространство в логе = <code>log.outstanding * MAXOPBLOCKS</code>.</p>\\n<p><code>log_write</code> - это прокси над <code>bwrite</code>, которое пишет номер сектора в память, резервирует слот в логе на диске, и помечает буфер флагом <code>B_DIRTY</code>, чтобы слой кэша его не удалил.</p>\\n<p><code>end_op</code> уменьшает <code>log.outstanding</code>, если оно стало 0, значит больше никто в наш лог не пишет, можем вызывать <code>commit()</code>.</p>\\n<p>Коммит состоит из 4 этапов:</p>\\n<ol>\\n<li><code>write_log()</code> - копирует каждый сектор, модифицированный в кэше в соответствующий ему слот лога на диске</li>\\n<li><code>write_head()</code> - пишет блог заголовка лога на диск</li>\\n<li><code>install_trans()</code> - читает каждый блок из лога и пишет его на диск</li>\\n<li><code>end_op</code> пишет заголовок сектора еще раз, но уже выставив ему количество блоков в 0.</li>\\n</ol>\\n<p>Логирование описано в файле <code>log.c</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Contents of the header block, used for both the on-disk header block\\n// and to keep track in memory of logged block# before commit.\\nstruct logheader {\\n  int n;\\n  int block[LOGSIZE];\\n};\\n\\nstruct log {\\n  struct spinlock lock;\\n  int start;\\n  int size;\\n  int outstanding; // how many FS sys calls are executing.\\n  int committing;  // in commit(), please wait.\\n  int dev;\\n  struct logheader lh;\\n};\\nstruct log log;\\n\\n// called at the start of each FS system call.\\nvoid\\nbegin_op(void)\\n{\\n  acquire(&#x26;log.lock);\\n  while(1){\\n    if(log.committing){\\n      sleep(&#x26;log, &#x26;log.lock);\\n    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){\\n      // this op might exhaust log space; wait for commit.\\n      sleep(&#x26;log, &#x26;log.lock);\\n    } else {\\n      log.outstanding += 1;\\n      release(&#x26;log.lock);\\n      break;\\n    }\\n  }\\n}\\n\\n// Caller has modified b->data and is done with the buffer.\\n// Record the block number and pin in the cache with B_DIRTY.\\n// commit()/write_log() will do the disk write.\\n//\\n// log_write() replaces bwrite(); a typical use is:\\n//   bp = bread(...)\\n//   modify bp->data[]\\n//   log_write(bp)\\n//   brelse(bp)\\nvoid\\nlog_write(struct buf *b)\\n{\\n  int i;\\n\\n  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)\\n    panic(\\\"too big a transaction\\\");\\n  if (log.outstanding &#x3C; 1)\\n    panic(\\\"log_write outside of trans\\\");\\n\\n  acquire(&#x26;log.lock);\\n  for (i = 0; i &#x3C; log.lh.n; i++) {\\n    if (log.lh.block[i] == b->blockno)   // log absorbtion\\n      break;\\n  }\\n  log.lh.block[i] = b->blockno;\\n  if (i == log.lh.n)\\n    log.lh.n++;\\n  b->flags |= B_DIRTY; // prevent eviction\\n  release(&#x26;log.lock);\\n}\\n\\nstatic void\\ncommit()\\n{\\n  if (log.lh.n > 0) {\\n    write_log();     // Write modified blocks from cache to log\\n    write_head();    // Write header to disk -- the real commit\\n    install_trans(); // Now install writes to home locations\\n    log.lh.n = 0;\\n    write_head();    // Erase the transaction from the log\\n  }\\n}\\n\\n\\n// called at the end of each FS system call.\\n// commits if this was the last outstanding operation.\\nvoid\\nend_op(void)\\n{\\n  int do_commit = 0;\\n\\n  acquire(&#x26;log.lock);\\n  log.outstanding -= 1;\\n  if(log.committing)\\n    panic(\\\"log.committing\\\");\\n  if(log.outstanding == 0){\\n    do_commit = 1;\\n    log.committing = 1;\\n  } else {\\n    // begin_op() may be waiting for log space,\\n    // and decrementing log.outstanding has decreased\\n    // the amount of reserved space.\\n    wakeup(&#x26;log);\\n  }\\n  release(&#x26;log.lock);\\n\\n  if(do_commit){\\n    // call commit w/o holding locks, since not allowed\\n    // to sleep with locks.\\n    commit();\\n    acquire(&#x26;log.lock);\\n    log.committing = 0;\\n    wakeup(&#x26;log);\\n    release(&#x26;log.lock);\\n  }\\n}\\n</code></pre>\\n<p>Восстановление из лога осуществляется в <code>recover_from_log</code>, который вызывается в <code>initlog</code>:</p>\\n<pre><code class=\\\"language-c\\\">static void\\nrecover_from_log(void)\\n{\\n  read_head();\\n  install_trans(); // if committed, copy from log to disk\\n  log.lh.n = 0;\\n  write_head(); // clear the log\\n}\\n</code></pre>\\n<p>Процедура читает заголовок и повторяет действия коммита.</p>\\n<p>Реальный пример использования из процедуры <code>filewrite</code>:</p>\\n<pre><code class=\\\"language-c\\\">begin_op();\\nilock(f->ip);\\nif ((r = writei(f->ip, addr + i, f->off, n1)) > 0)\\n  f->off += r;\\niunlock(f->ip);\\nend_op();\\n</code></pre>\\n<p><code>log_write</code> вызывается внутри <code>writei</code>. Чтобы не превысить размер лога транзакции, кусок кода из примера вызывается в цикле, каждый раз сохраняя в транзакции по несколько блоков.</p>\\n<h4>Аллокатор блоков</h4>\\n<p>Файлы и папки хранятся в дисковых блоках, которые тоже должны аллоцироваться и свобождаться. Для этого есть <em>аллокатор блоков</em>, вызываемый функциями <code>balloc</code> и <code>bfree</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Allocate a zeroed disk block.\\nstatic uint\\nballoc(uint dev)\\n{\\n  int b, bi, m;\\n  struct buf *bp;\\n\\n  bp = 0;\\n  for(b = 0; b &#x3C; sb.size; b += BPB){\\n    bp = bread(dev, BBLOCK(b, sb));\\n    for(bi = 0; bi &#x3C; BPB &#x26;&#x26; b + bi &#x3C; sb.size; bi++){\\n      m = 1 &#x3C;&#x3C; (bi % 8);\\n      if((bp->data[bi/8] &#x26; m) == 0){  // Is block free?\\n        bp->data[bi/8] |= m;  // Mark block in use.\\n        log_write(bp);\\n        brelse(bp);\\n        bzero(dev, b + bi);\\n        return b + bi;\\n      }\\n    }\\n    brelse(bp);\\n  }\\n  panic(\\\"balloc: out of blocks\\\");\\n}\\n\\n// Free a disk block.\\nstatic void\\nbfree(int dev, uint b)\\n{\\n  struct buf *bp;\\n  int bi, m;\\n\\n  readsb(dev, &#x26;sb);\\n  bp = bread(dev, BBLOCK(b, sb));\\n  bi = b % BPB;\\n  m = 1 &#x3C;&#x3C; (bi % 8);\\n  if((bp->data[bi/8] &#x26; m) == 0)\\n    panic(\\\"freeing free block\\\");\\n  bp->data[bi/8] &#x26;= ~m;\\n  log_write(bp);\\n  brelse(bp);\\n}\\n</code></pre>\\n<h3>Слой айнодов</h3>\\n<p><code>inode</code> бывают двух типов:</p>\\n<ul>\\n<li>хранящиеся на диске - содержат размер файла и список номеров его секторов данных</li>\\n<li>хранящиеся в памяти - содержат копию дискового айнода и дополнительную информацию, необходимую ядру</li>\\n</ul>\\n<p>Дисковые айноды лежат последовательно в области диска, называемой \\\"блоки айнодов\\\". Каждый айнод имеет фиксированный размер, поэтому их легко находить по номеру, такие номера называются ай-номеры.</p>\\n<p>Дисковые айноды описываются структурой <code>dinode</code>:</p>\\n<pre><code class=\\\"language-c\\\">// On-disk inode structure\\nstruct dinode {\\n  short type;           // Тип айнода: файл, директория, \\\"специальный\\\" файл (девайс). 0 означает, что айнод свободен.\\n  short major;          // Major device number (T_DEV only)\\n  short minor;          // Minor device number (T_DEV only)\\n  short nlink;          // Количество ссылок на этот айнод из директорий. Когда достигает нуля, айнод можно удалять.\\n  uint size;            // Размер, т.е. количество байт в содержимом файла\\n  uint addrs[NDIRECT+1];   // Номера секторов данных на диске, в которых записано содержимое файла\\n};\\n</code></pre>\\n<p>Копии активных дисковых айнодов содержатся в памяти ядра в структурах <code>inode</code>:</p>\\n<pre><code class=\\\"language-c\\\">// in-memory copy of an inode\\nstruct inode {\\n  uint dev;           // Device number\\n  uint inum;          // Inode number\\n  int ref;            // Количество C-указателей на этот айнод, когда достигает нуля - удаляем из памяти.\\n  struct sleeplock lock; // protects everything below here\\n  int valid;          // inode has been read from disk?\\n\\n  short type;         // copy of disk inode\\n  short major;\\n  short minor;\\n  short nlink;\\n  uint size;\\n  uint addrs[NDIRECT+1];\\n};\\n</code></pre>\\n<p>Копия айнода в памяти содержится только если есть указатели, ссылающиеся на этот айнод.</p>\\n<p>Чтобы аллоцировать новый айнод (например, при создании файла), вызывается <code>ialloc</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Allocate an inode on device dev.\\n// Mark it as allocated by  giving it type type.\\n// Returns an unlocked but allocated and referenced inode.\\nstruct inode*\\nialloc(uint dev, short type)\\n{\\n  int inum;\\n  struct buf *bp;\\n  struct dinode *dip;\\n\\n  for(inum = 1; inum &#x3C; sb.ninodes; inum++){\\n    bp = bread(dev, IBLOCK(inum, sb));\\n    dip = (struct dinode*)bp->data + inum%IPB;\\n    if(dip->type == 0){  // a free inode\\n      memset(dip, 0, sizeof(*dip));\\n      dip->type = type;\\n      log_write(bp);   // mark it allocated on the disk\\n      brelse(bp);\\n      return iget(dev, inum);\\n    }\\n    brelse(bp);\\n  }\\n  panic(\\\"ialloc: no inodes\\\");\\n}\\n</code></pre>\\n<p><code>ialloc</code> проходит по всем айнодам на диске, ища пустой. Когда находит, помечает его как аллоцированный и возвращает его копию из памяти через <code>iget</code>.</p>\\n<pre><code class=\\\"language-c\\\">// Find the inode with number inum on device dev\\n// and return the in-memory copy. Does not lock\\n// the inode and does not read it from disk.\\nstatic struct inode*\\niget(uint dev, uint inum)\\n{\\n  struct inode *ip, *empty;\\n\\n  acquire(&#x26;icache.lock);\\n\\n  // Is the inode already cached?\\n  empty = 0;\\n  for(ip = &#x26;icache.inode[0]; ip &#x3C; &#x26;icache.inode[NINODE]; ip++){\\n    if(ip->ref > 0 &#x26;&#x26; ip->dev == dev &#x26;&#x26; ip->inum == inum){\\n      ip->ref++;\\n      release(&#x26;icache.lock);\\n      return ip;\\n    }\\n    if(empty == 0 &#x26;&#x26; ip->ref == 0)    // Remember empty slot.\\n      empty = ip;\\n  }\\n\\n  // Recycle an inode cache entry.\\n  if(empty == 0)\\n    panic(\\\"iget: no inodes\\\");\\n\\n  ip = empty;\\n  ip->dev = dev;\\n  ip->inum = inum;\\n  ip->ref = 1;\\n  ip->valid = 0;\\n  release(&#x26;icache.lock);\\n\\n  return ip;\\n}\\n</code></pre>\\n<p>Прежде чем читать или писать в айнод, код должен его сначала залочить:</p>\\n<pre><code class=\\\"language-c\\\">// Lock the given inode.\\n// Reads the inode from disk if necessary.\\nvoid\\nilock(struct inode *ip)\\n{\\n  struct buf *bp;\\n  struct dinode *dip;\\n\\n  if(ip == 0 || ip->ref &#x3C; 1)\\n    panic(\\\"ilock\\\");\\n\\n  acquiresleep(&#x26;ip->lock);\\n\\n  if(ip->valid == 0){\\n    bp = bread(ip->dev, IBLOCK(ip->inum, sb));\\n    dip = (struct dinode*)bp->data + ip->inum%IPB;\\n    ip->type = dip->type;\\n    ip->major = dip->major;\\n    ip->minor = dip->minor;\\n    ip->nlink = dip->nlink;\\n    ip->size = dip->size;\\n    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));\\n    brelse(bp);\\n    ip->valid = 1;\\n    if(ip->type == 0)\\n      panic(\\\"ilock: no type\\\");\\n  }\\n}\\n\\n// Unlock the given inode.\\nvoid\\niunlock(struct inode *ip)\\n{\\n  if(ip == 0 || !holdingsleep(&#x26;ip->lock) || ip->ref &#x3C; 1)\\n    panic(\\\"iunlock\\\");\\n\\n  releasesleep(&#x26;ip->lock);\\n}\\n</code></pre>\\n<h4>Содержимое айнодов</h4>\\n<pre><code class=\\\"language-c\\\">// Copy stat information from inode.\\n// Caller must hold ip->lock.\\nvoid\\nstati(struct inode *ip, struct stat *st)\\n{\\n  st->dev = ip->dev;\\n  st->ino = ip->inum;\\n  st->type = ip->type;\\n  st->nlink = ip->nlink;\\n  st->size = ip->size;\\n}\\n\\n//PAGEBREAK!\\n// Read data from inode.\\n// Caller must hold ip->lock.\\nint\\nreadi(struct inode *ip, char *dst, uint off, uint n)\\n{\\n  uint tot, m;\\n  struct buf *bp;\\n\\n  if(ip->type == T_DEV){\\n    if(ip->major &#x3C; 0 || ip->major >= NDEV || !devsw[ip->major].read)\\n      return -1;\\n    return devsw[ip->major].read(ip, dst, n);\\n  }\\n\\n  if(off > ip->size || off + n &#x3C; off)\\n    return -1;\\n  if(off + n > ip->size)\\n    n = ip->size - off;\\n\\n  for(tot=0; tot&#x3C;n; tot+=m, off+=m, dst+=m){\\n    bp = bread(ip->dev, bmap(ip, off/BSIZE));\\n    m = min(n - tot, BSIZE - off%BSIZE);\\n    memmove(dst, bp->data + off%BSIZE, m);\\n    brelse(bp);\\n  }\\n  return n;\\n}\\n\\n// PAGEBREAK!\\n// Write data to inode.\\n// Caller must hold ip->lock.\\nint\\nwritei(struct inode *ip, char *src, uint off, uint n)\\n{\\n  uint tot, m;\\n  struct buf *bp;\\n\\n  if(ip->type == T_DEV){\\n    if(ip->major &#x3C; 0 || ip->major >= NDEV || !devsw[ip->major].write)\\n      return -1;\\n    return devsw[ip->major].write(ip, src, n);\\n  }\\n\\n  if(off > ip->size || off + n &#x3C; off)\\n    return -1;\\n  if(off + n > MAXFILE*BSIZE)\\n    return -1;\\n\\n  for(tot=0; tot&#x3C;n; tot+=m, off+=m, src+=m){\\n    bp = bread(ip->dev, bmap(ip, off/BSIZE));\\n    m = min(n - tot, BSIZE - off%BSIZE);\\n    memmove(bp->data + off%BSIZE, src, m);\\n    log_write(bp);\\n    brelse(bp);\\n  }\\n\\n  if(n > 0 &#x26;&#x26; off > ip->size){\\n    ip->size = off;\\n    iupdate(ip);\\n  }\\n  return n;\\n}\\n</code></pre>\\n<h3>Слой директорий</h3>\\n<pre><code class=\\\"language-c\\\">// Look for a directory entry in a directory.\\n// If found, set *poff to byte offset of entry.\\nstruct inode*\\ndirlookup(struct inode *dp, char *name, uint *poff)\\n{\\n  uint off, inum;\\n  struct dirent de;\\n\\n  if(dp->type != T_DIR)\\n    panic(\\\"dirlookup not DIR\\\");\\n\\n  for(off = 0; off &#x3C; dp->size; off += sizeof(de)){\\n    if(readi(dp, (char*)&#x26;de, off, sizeof(de)) != sizeof(de))\\n      panic(\\\"dirlookup read\\\");\\n    if(de.inum == 0)\\n      continue;\\n    if(namecmp(name, de.name) == 0){\\n      // entry matches path element\\n      if(poff)\\n        *poff = off;\\n      inum = de.inum;\\n      return iget(dp->dev, inum);\\n    }\\n  }\\n\\n  return 0;\\n}\\n\\n// Write a new directory entry (name, inum) into the directory dp.\\nint\\ndirlink(struct inode *dp, char *name, uint inum)\\n{\\n  int off;\\n  struct dirent de;\\n  struct inode *ip;\\n\\n  // Check that name is not present.\\n  if((ip = dirlookup(dp, name, 0)) != 0){\\n    iput(ip);\\n    return -1;\\n  }\\n\\n  // Look for an empty dirent.\\n  for(off = 0; off &#x3C; dp->size; off += sizeof(de)){\\n    if(readi(dp, (char*)&#x26;de, off, sizeof(de)) != sizeof(de))\\n      panic(\\\"dirlink read\\\");\\n    if(de.inum == 0)\\n      break;\\n  }\\n\\n  strncpy(de.name, name, DIRSIZ);\\n  de.inum = inum;\\n  if(writei(dp, (char*)&#x26;de, off, sizeof(de)) != sizeof(de))\\n    panic(\\\"dirlink\\\");\\n\\n  return 0;\\n}\\n</code></pre>\\n<h3>Слой путей</h3>\\n<pre><code class=\\\"language-c\\\">// Copy the next path element from path into name.\\n// Return a pointer to the element following the copied one.\\n// The returned path has no leading slashes,\\n// so the caller can check *path=='\\\\0' to see if the name is the last one.\\n// If no name to remove, return 0.\\n//\\n// Examples:\\n//   skipelem(\\\"a/bb/c\\\", name) = \\\"bb/c\\\", setting name = \\\"a\\\"\\n//   skipelem(\\\"///a//bb\\\", name) = \\\"bb\\\", setting name = \\\"a\\\"\\n//   skipelem(\\\"a\\\", name) = \\\"\\\", setting name = \\\"a\\\"\\n//   skipelem(\\\"\\\", name) = skipelem(\\\"////\\\", name) = 0\\n//\\nstatic char*\\nskipelem(char *path, char *name)\\n{\\n  char *s;\\n  int len;\\n\\n  while(*path == '/')\\n    path++;\\n  if(*path == 0)\\n    return 0;\\n  s = path;\\n  while(*path != '/' &#x26;&#x26; *path != 0)\\n    path++;\\n  len = path - s;\\n  if(len >= DIRSIZ)\\n    memmove(name, s, DIRSIZ);\\n  else {\\n    memmove(name, s, len);\\n    name[len] = 0;\\n  }\\n  while(*path == '/')\\n    path++;\\n  return path;\\n}\\n\\n// Look up and return the inode for a path name.\\n// If parent != 0, return the inode for the parent and copy the final\\n// path element into name, which must have room for DIRSIZ bytes.\\n// Must be called inside a transaction since it calls iput().\\nstatic struct inode*\\nnamex(char *path, int nameiparent, char *name)\\n{\\n  struct inode *ip, *next;\\n\\n  if(*path == '/')\\n    ip = iget(ROOTDEV, ROOTINO);\\n  else\\n    ip = idup(myproc()->cwd);\\n\\n  while((path = skipelem(path, name)) != 0){\\n    ilock(ip);\\n    if(ip->type != T_DIR){\\n      iunlockput(ip);\\n      return 0;\\n    }\\n    if(nameiparent &#x26;&#x26; *path == '\\\\0'){\\n      // Stop one level early.\\n      iunlock(ip);\\n      return ip;\\n    }\\n    if((next = dirlookup(ip, name, 0)) == 0){\\n      iunlockput(ip);\\n      return 0;\\n    }\\n    iunlockput(ip);\\n    ip = next;\\n  }\\n  if(nameiparent){\\n    iput(ip);\\n    return 0;\\n  }\\n  return ip;\\n}\\n\\nstruct inode*\\nnamei(char *path)\\n{\\n  char name[DIRSIZ];\\n  return namex(path, 0, name);\\n}\\n\\nstruct inode*\\nnameiparent(char *path, char *name)\\n{\\n  return namex(path, 1, name);\\n}\\n</code></pre>\\n<h3>Слой дескрипторов файлов</h3>\\n<pre><code class=\\\"language-c\\\">// Allocate a file structure.\\nstruct file*\\nfilealloc(void)\\n{\\n  struct file *f;\\n\\n  acquire(&#x26;ftable.lock);\\n  for(f = ftable.file; f &#x3C; ftable.file + NFILE; f++){\\n    if(f->ref == 0){\\n      f->ref = 1;\\n      release(&#x26;ftable.lock);\\n      return f;\\n    }\\n  }\\n  release(&#x26;ftable.lock);\\n  return 0;\\n}\\n\\n// Close file f.  (Decrement ref count, close when reaches 0.)\\nvoid\\nfileclose(struct file *f)\\n{\\n  struct file ff;\\n\\n  acquire(&#x26;ftable.lock);\\n  if(f->ref &#x3C; 1)\\n    panic(\\\"fileclose\\\");\\n  if(--f->ref > 0){\\n    release(&#x26;ftable.lock);\\n    return;\\n  }\\n  ff = *f;\\n  f->ref = 0;\\n  f->type = FD_NONE;\\n  release(&#x26;ftable.lock);\\n\\n  if(ff.type == FD_PIPE)\\n    pipeclose(ff.pipe, ff.writable);\\n  else if(ff.type == FD_INODE){\\n    begin_op();\\n    iput(ff.ip);\\n    end_op();\\n  }\\n}\\n\\n// Read from file f.\\nint\\nfileread(struct file *f, char *addr, int n)\\n{\\n  int r;\\n\\n  if(f->readable == 0)\\n    return -1;\\n  if(f->type == FD_PIPE)\\n    return piperead(f->pipe, addr, n);\\n  if(f->type == FD_INODE){\\n    ilock(f->ip);\\n    if((r = readi(f->ip, addr, f->off, n)) > 0)\\n      f->off += r;\\n    iunlock(f->ip);\\n    return r;\\n  }\\n  panic(\\\"fileread\\\");\\n}\\n\\n//PAGEBREAK!\\n// Write to file f.\\nint\\nfilewrite(struct file *f, char *addr, int n)\\n{\\n  int r;\\n\\n  if(f->writable == 0)\\n    return -1;\\n  if(f->type == FD_PIPE)\\n    return pipewrite(f->pipe, addr, n);\\n  if(f->type == FD_INODE){\\n    // write a few blocks at a time to avoid exceeding\\n    // the maximum log transaction size, including\\n    // i-node, indirect block, allocation blocks,\\n    // and 2 blocks of slop for non-aligned writes.\\n    // this really belongs lower down, since writei()\\n    // might be writing a device like the console.\\n    int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;\\n    int i = 0;\\n    while(i &#x3C; n){\\n      int n1 = n - i;\\n      if(n1 > max)\\n        n1 = max;\\n\\n      begin_op();\\n      ilock(f->ip);\\n      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)\\n        f->off += r;\\n      iunlock(f->ip);\\n      end_op();\\n\\n      if(r &#x3C; 0)\\n        break;\\n      if(r != n1)\\n        panic(\\\"short filewrite\\\");\\n      i += r;\\n    }\\n    return i == n ? n : -1;\\n  }\\n  panic(\\\"filewrite\\\");\\n}\\n</code></pre>\",\"frontmatter\":{\"path\":\"/blog/books/xv6\",\"title\":\"xv6\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---blog-books-xv-6-9023bac90e984ef3e566.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p><a href=\\\"https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf\\\">Комментарии к исходному коду</a>\\n<a href=\\\"https://github.com/YehudaShapira/xv6-explained/blob/master/Explanations.md\\\">Еще комментарии</a></p>\\n<p><a href=\\\"https://pdos.csail.mit.edu/6.828/2018/xv6/xv6-rev11.pdf\\\">Исходный код</a></p>\\n<h1>xv6</h1>\\n<p>Важное замечание для начала: во всех ассемблерах UNIX, включая используемый здесь, команда mov имеет следующий синтаксис: <code>MOV src dest</code>.</p>\\n<p>То есть <code>mov $a $b</code> означает, что значение регистра a будет присвоено регистру b.</p>\\n<h2>Основные понятия</h2>\\n<h3>Процесс</h3>\\n<p>Память любого процесса состоит из 3 частей: инструкции, данные, стек.</p>\\n<h3>fork</h3>\\n<p>Создает новый процесс (child process), содержимое памяти которого идентично содержимому памяти вызывающего процесса (parent process). Но это не одна и та же память, это копия. Так как память у процессов одинаковая, значит одинаковые и инструкции, значит в обоих процессах выполнение продолжается со следующей инструкции. Только в child process функция fork возвращает 0, а в родительском - pid созданного процесса.</p>\\n<pre><code class=\\\"language-c\\\">int pid = fork();\\nif(pid > 0){\\n    printf(\\\"parent: child=%d\\\\n\\\", pid);\\n    pid = wait();\\n    printf(\\\"child %d is done\\\\n\\\", pid);\\n} else if(pid == 0){\\n    printf(\\\"child: exiting\\\\n\\\");\\n    exit();\\n} else {\\n    printf(\\\"fork error\\\\n\\\");\\n}\\n</code></pre>\\n<p><code>exit</code> - запускает процедуру выхода из процесса и освобождает ресурсы (память, открытые файлы)</p>\\n<p><code>wait</code> - ожидает завершения дочернего процесса и возвращает его pid.</p>\\n<p>В приведенном примере на экран будет выдано:</p>\\n<pre><code>parent: child=1234\\nchild: exiting\\nchild 1234 is done\\n</code></pre>\\n<h3>exec</h3>\\n<p>Принимает в качестве аргумента путь к исполняемому файлу и заменяет память вызывающего процесса на память, загруженную из этого файла. Файл должен быть в специальном формате (ELF), в котором указано начало секции инструкций, начало секции данных, с какой инструкции начать выполнение и т.д. Если вызов exec совершен удачно, то выполнение продолжится с той инструкции, которая указана первой к исполнению в загруженном файле.</p>\\n<p>Пример:</p>\\n<pre><code class=\\\"language-c\\\">char *argv[3];\\nargv[0] = \\\"echo\\\";\\nargv[1] = \\\"hello\\\";\\nargv[2] = 0;\\nexec(\\\"/bin/echo\\\", argv);\\nprintf(\\\"exec error\\\\n\\\");\\n</code></pre>\\n<p>Здесь исполняемая программа заменяется программой <code>/bin/echo</code>, которая получает в качестве списка аргументов <code>echo hello</code>.</p>\\n<h3>sh</h3>\\n<p>Шелл использует <code>fork</code> и <code>exec</code> для исполнения программ. В общем структура выполнения выглядит так:</p>\\n<pre><code class=\\\"language-c\\\">int\\nmain(void)\\n{\\n  static char buf[100];\\n\\n  while(getcmd(buf, sizeof(buf)) >= 0){\\n    if(fork1() == 0)\\n      runcmd(parsecmd(buf));\\n    wait();\\n  }\\n  exit();\\n}\\n\\nvoid\\nruncmd(struct cmd *cmd)\\n{\\n  struct execcmd *ecmd;\\n\\n  switch(cmd->type){  \\n    ...\\n  case EXEC:\\n    ecmd = (struct execcmd*)cmd;\\n    exec(ecmd->argv[0], ecmd->argv);\\n    printf(2, \\\"exec %s failed\\\\n\\\", ecmd->argv[0]);\\n    break;\\n    ...\\n  }\\n  exit();\\n}\\n</code></pre>\\n<ul>\\n<li><code>main</code> - делает дочерний процесс, в нем парсит команду, подает на выполнение</li>\\n<li><code>runcmd</code> - делает <code>exec</code>, заменяя текущий процесс (тот, который был создан форком в <code>main</code>) на исполняемый файл, указанный в команде</li>\\n</ul>\\n<p>После завершения дочернего процесса исполнение продолжается на инструкции, следующей за <code>wait()</code>.</p>\\n<h3>Дескрипторы файлов</h3>\\n<p>У каждого процесса свой набор дескрипторов файлов, начинающийся с 0. По соглашению, 0 - дескриптор стандартного ввода/stdin, 1 - стандартного вывода/stdout, 2 - дескриптор канала ошибок/stderr.</p>\\n<p>При открытии файла он всегда получает наименьший из неиспользуемых в текущем процессе дексрипторов.</p>\\n<p>Вот так, например, выглядит <code>cat</code>:</p>\\n<pre><code class=\\\"language-c\\\">char buf[512];\\n\\nvoid\\ncat(int fd)\\n{\\n  int n;\\n\\n  while((n = read(fd, buf, sizeof(buf))) > 0) { // читаем из указанного дескриптора\\n    if (write(1, buf, n) != n) {  // пишем в 1, то есть stdout\\n      printf(1, \\\"cat: write error\\\\n\\\");\\n      exit();\\n    }\\n  }\\n\\n  // error handling\\n  if(n &#x3C; 0){\\n    printf(1, \\\"cat: read error\\\\n\\\");\\n    exit();\\n  }\\n}\\n\\nint\\nmain(int argc, char *argv[])\\n{\\n  int fd, i;\\n\\n  if(argc &#x3C;= 1){ // если аргументов не указано, то читаем из 0, то есть stdin\\n    cat(0);\\n    exit();\\n  }\\n\\n  for(i = 1; i &#x3C; argc; i++){ // если аргументы есть, то открываем файлы по этим путям и читаем из дескрипторов этих файлов\\n    if((fd = open(argv[i], 0)) &#x3C; 0){\\n      printf(1, \\\"cat: cannot open %s\\\\n\\\", argv[i]);\\n      exit();\\n    }\\n    cat(fd);\\n    close(fd);\\n  }\\n  exit();\\n}\\n</code></pre>\\n<h4>Перенаправление I/O</h4>\\n<p><code>exec</code> заменяет содержимое памяти вызывающего процесса, но при этом <strong>оставляет неизменной его таблицу дескрипторов</strong>. Это позволяет реализовать перенаправление I/O. Вот, что происходит при вызове <code>cat &#x3C; input.txt</code>:</p>\\n<pre><code class=\\\"language-c\\\">char *argv[2];\\nargv[0] = \\\"cat\\\";\\nargv[1] = 0;\\nif(fork() == 0) {\\n    close(0);\\n    open(\\\"input.txt\\\", O_RDONLY);\\n    exec(\\\"cat\\\", argv);\\n}\\n</code></pre>\\n<p>Здесь используется правило \\\"При открытии файла он всегда получает наименьший из неиспользуемых в текущем процессе дексрипторов\\\". Когда вызывается <code>close(0)</code>, дескриптор 0 (stdin) освобождается, а значит следующая инструкция <code>open</code> назначит открытому файлу <code>input.txt</code> дексриптор 0. Затем вызывается программа <code>cat</code>, которая при вызове без аргументов читает содержимое из дескриптора 0.</p>\\n<p>В коде шелла этот кусок выглядит так:</p>\\n<pre><code class=\\\"language-c\\\">void\\nruncmd(struct cmd *cmd)\\n{\\n  struct redircmd *rcmd;\\n\\n    switch(cmd->type){\\n  ...\\n\\n  case REDIR:\\n    rcmd = (struct redircmd*)cmd;\\n    close(rcmd->fd);\\n    if(open(rcmd->file, rcmd->mode) &#x3C; 0){\\n      printf(2, \\\"open %s failed\\\\n\\\", rcmd->file);\\n      exit();\\n    }\\n    runcmd(rcmd->cmd);\\n    break;\\n    ...\\n  }\\n  exit();\\n}\\n\\n...\\n\\nstruct cmd*\\nparseredirs(struct cmd *cmd, char **ps, char *es)\\n{\\n  int tok;\\n  char *q, *eq;\\n\\n  while(peek(ps, es, \\\"&#x3C;>\\\")){\\n    tok = gettoken(ps, es, 0, 0);\\n    switch(tok){\\n    case '&#x3C;':\\n      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);\\n      break;\\n    case '>':\\n      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);\\n      break;\\n    case '+':  // >>\\n      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);\\n      break;\\n    }\\n  }\\n  return cmd;\\n}\\n</code></pre>\\n<p><code>rcmd</code> при парсинге получит <code>fd</code>, равный 0, при использовании <code>&#x3C;</code> и равный 1 при использовании <code>></code>. В ветке <code>REDIR</code> мы закрыли дексриптор, на который будем перенаправлять ввод или вывод, открыли нужный файл и вызвали <code>runcmd</code>, внутри которого будет использован <code>exec</code>.</p>\\n<h4>Использование дескрипторов в fork</h4>\\n<p>При форке таблица дескрипторов копируется, а сдвиги - шарятся между процессами. То есть следующий пример:</p>\\n<pre><code class=\\\"language-c\\\">if(fork() == 0) {\\n    write(1, \\\"hello \\\", 6);\\n    exit();\\n} else {\\n    wait();\\n    write(1, \\\"world\\\\n\\\", 6);\\n}\\n</code></pre>\\n<p>Выведет на экран <code>hello world</code>. </p>\\n<p>Благодаря этому мы можем писать: <code>(echo hello; echo world)>output.txt</code>. (хотя пока непонятно, почему тут должен вызываться fork, а не exec).</p>\\n<h4>dup</h4>\\n<p>Копирует дескриптор, после чего оба дескриптора шарят сдвиг.</p>\\n<p>То есть:</p>\\n<pre><code class=\\\"language-c\\\">fd = dup(1);\\nwrite(1, \\\"hello \\\", 6);\\nwrite(fd, \\\"world\\\\n\\\", 6);\\n</code></pre>\\n<p>тоже выведет <code>hello world</code>.</p>\\n<p>Таким образом, два дексриптора файла шарят между собой сдвиг только в том случае, если они были получены из одного и того же дескриптора вызовами <code>fork</code> и <code>dup</code>. Во всех остальных случаях сдвиги не шарятся.</p>\\n<p><code>dup</code> позволяет писать такие команды:</p>\\n<pre><code class=\\\"language-shell\\\">ls existing-file non-existing-file > tmp1 2>&#x26;1\\n</code></pre>\\n<p>Здесь <code>2>&#x26;1</code> как раз копирует дексриптор 1 в дескриптор 2, чтобы все ошибки выводились в stdout.</p>\\n<h3>pipes</h3>\\n<p>Вызов <code>pipe</code> принимает массив из двух элементов и записывает в него 2 дексриптора: первый - для чтения и второй - для записи. Все, что будет записано в дексриптор для записи, можно будет прочитать из дескриптора для чтения.</p>\\n<p>Пример использования <code>pipe</code>:</p>\\n<pre><code class=\\\"language-c\\\">int p[2];\\nchar *argv[2];\\nargv[0] = \\\"wc\\\";\\nargv[1] = 0;\\n\\npipe(p);\\nif(fork() == 0) {\\n    close(0);\\n    dup(p[0]);\\n    close(p[0]);\\n    close(p[1]);\\n    exec(\\\"/bin/wc\\\", argv);\\n} else {\\n    close(p[0]);\\n    write(p[1], \\\"hello world\\\\n\\\", 12);\\n    close(p[1]);\\n}\\n</code></pre>\\n<p>Здесь дочерний процесс закрывает <code>stdin</code>, дублирует дескриптор чтения из пайпа в дескриптор 0, закрывает дескриптор чтения и записи и запускает <code>wc</code>, который будет принимать ввод от дескриптора 0, то есть будет читать из пайпа.</p>\\n<p>Родительский процесс пишет в дескриптор записи и закрывает оба дескриптора пайпа.</p>\\n<p>Приблизительно так же выглядит и ветка <code>PIPE</code> в <code>runcmd</code>, только она создает 2 дочерних процесса:</p>\\n<pre><code class=\\\"language-c\\\">void\\nruncmd(struct cmd *cmd)\\n{\\n   struct pipecmd *pcmd;\\n \\n  switch(cmd->type){\\n    ...\\n  case PIPE:\\n    pcmd = (struct pipecmd*)cmd;\\n    if(pipe(p) &#x3C; 0)\\n      panic(\\\"pipe\\\");\\n    if(fork1() == 0){\\n      close(1);\\n      dup(p[1]);\\n      close(p[0]);\\n      close(p[1]);\\n      runcmd(pcmd->left);\\n    }\\n    if(fork1() == 0){\\n      close(0);\\n      dup(p[0]);\\n      close(p[0]);\\n      close(p[1]);\\n      runcmd(pcmd->right);\\n    }\\n    close(p[0]);\\n    close(p[1]);\\n    wait();\\n    wait();\\n    break;\\n    ...\\n  }\\n  exit();\\n}\\n</code></pre>\\n<p>В шелле пайпы используются при выполнении команд вида <code>grep fork sh.c | wc -l</code>.</p>\\n<p>Преимущества пайпов перед временными файлами:</p>\\n<ul>\\n<li>автоматическое очищение</li>\\n<li>можно передавать очень длинные потоки данных, не беспокоясь, что на диске кончится место</li>\\n<li>возможно параллельное выполнение левой и правой команды</li>\\n<li>для межпроцессного общения блокирующая модель записи и чтения пайпов удобнее, чем неблокирующая модель файлов</li>\\n</ul>\\n<h3>Файловая система</h3>\\n<p><code>fstat</code> - возвращает информацию о файле, на который указывает дескрриптор</p>\\n<p>У файла может быть несколько имен, или \\\"линков\\\". Сам файл называется <code>inode</code>. Линки создаются командой <code>link</code>, например:</p>\\n<pre><code class=\\\"language-c\\\">open(\\\"a\\\", O_CREATE|O_WRONLY);\\nlink(\\\"a\\\", \\\"b\\\");\\n</code></pre>\\n<p>После этого <code>a</code> и <code>b</code> ссылаются на один и тот же <code>inode</code> и запись/чтение в <code>a</code> равносильно записи/чтению в <code>b</code>.</p>\\n<p>Каждый айнод идентифицируется своим <code>inode number</code>. Его можно получить вызовом <code>fstat</code>.</p>\\n<p>Линки удаляются командой <code>unlink</code>. Айнод и место на диске очищаются только когда количество линков уменьшится до 0 и не останется дескрипторов, ссылающихся на него.</p>\\n<h2>Организация операционной системы</h2>\\n<h3>Загрузчик</h3>\\n<p>Загрузчик состоит из 2 частей: <code>bootasm.s</code>, написанный на ассемблере и <code>bootmain.c</code>, написанный на С.</p>\\n<p>Когда компьютер стартует, он выполняет программу BIOS, которая записана в энергонезависимой памяти материнской платы. BIOS подготавливает аппаратное обеспечение к работе и передает управление коду, записанному в загрузочный сектор, т.е. первый 512-байтовый сектор загрузочного диска. В этом секторе содержится загрузчик: инструкции по загрузке ядра в память. BIOS загружает содержимое загрузочного сектора в адрес <code>0x7c00</code> и переходит на этот адрес. Начинается исполнение файла <code>bootasm.s</code>.</p>\\n<p>Первая инструкция загрузчика - <code>cli</code>, которая отключает прерывания. BIOS возможно установил какие-то свои обработчики прерываний, чтобы инициализировать устройства, но мы уже покинули BIOS, поэтому они нам больше не нужны. Когда операционная система загрузится, она включит прерывания обратно.</p>\\n<p>Затем загрузчик должен перевести процессор из реального режима работы в защищенный.</p>\\n<p>После этого загрузчик переходит в <code>bootmain.c</code>.</p>\\n<p>Задача <code>bootmain.c</code> - загрузить и запустить ядро. Ядро должно быть в формате ELF. <code>bootmain</code> загружает первые 4096 байт из бинарника ELF и кладет их копию по адресу <code>0x10000</code>. Затем он проверяет, что это действительно ELF путем проверки магического числа в заголовке файла. Затем он проходит по всем сегментам файла, загружает их в память и переходит в точку входа в ядро, а именно <code>0x10000c</code>.</p>\\n<h3>Старт ядра</h3>\\n<p>Когда загрузчик передает управления в ядро, первая выполняемая инструкция - это <code>entry:</code> в файле <code>entry.s</code>. Первое, что делает ядро - это настраивает аппаратный пэйджинг. Добавляется маппинг виртуальных адресов, начинающихся с <code>0x80000000</code> на физические, начинающиеся с <code>0x0</code>:</p>\\n<pre><code class=\\\"language-asm\\\">  movl    $(V2P_WO(entrypgdir)), %eax\\n  movl    %eax, %cr3\\n</code></pre>\\n<p><code>V2P_WO</code>(virtual to physical) - это макрос, который отнимает от \\\"высокого\\\" адреса <code>entrypgdir</code> константу <code>0x80000000</code>. Это нужно, потому что у нас еще не работает маппинг виртуальных адресов, но ядро слинковано с их использованием.</p>\\n<p>Таблица страниц entrypgdir описана в main.c:</p>\\n<pre><code class=\\\"language-c\\\">__attribute__((__aligned__(PGSIZE)))\\npde_t entrypgdir[NPDENTRIES] = {\\n  // Map VA's [0, 4MB) to PA's [0, 4MB)\\n  [0] = (0) | PTE_P | PTE_W | PTE_PS,\\n  // Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)\\n  [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,\\n};\\n</code></pre>\\n<p>Затем ядро включает аппаратный пейджинг:</p>\\n<pre><code>  orl     $(CR0_PG|CR0_WP), %eax\\n  movl    %eax, %cr0\\n</code></pre>\\n<p>Ну и наконец мы переходим в <code>main.c</code>:</p>\\n<pre><code class=\\\"language-asm\\\">  # Set up the stack pointer.\\n  movl $(stack + KSTACKSIZE), %esp\\n\\n  # Jump to main(), and switch to executing at\\n  # high addresses. The indirect call is needed because\\n  # the assembler produces a PC-relative instruction\\n  # for a direct jump.\\n  mov $main, %eax\\n  jmp *%eax\\n</code></pre>\\n<h3>Создание первого процесса</h3>\\n<p>Процесс описывается следующей структурой:</p>\\n<pre><code class=\\\"language-c\\\">// Per-process state\\nstruct proc {\\n  uint sz;                     // Size of process memory (bytes)\\n  pde_t* pgdir;                // Page table\\n  char *kstack;                // Bottom of kernel stack for this process\\n  enum procstate state;        // Process state\\n  int pid;                     // Process ID\\n  struct proc *parent;         // Parent process\\n  struct trapframe *tf;        // Trap frame for current syscall\\n  struct context *context;     // swtch() here to run process\\n  void *chan;                  // If non-zero, sleeping on chan\\n  int killed;                  // If non-zero, have been killed\\n  struct file *ofile[NOFILE];  // Open files\\n  struct inode *cwd;           // Current directory\\n  char name[16];               // Process name (debugging)\\n};\\n\\nstruct context {\\n  uint edi;\\n  uint esi;\\n  uint ebx;\\n  uint ebp;\\n  uint eip;\\n};\\n</code></pre>\\n<p><code>main</code> инициализирует кучу устройств и подсистем:</p>\\n<pre><code class=\\\"language-c\\\">// Bootstrap processor starts running C code here.\\n// Allocate a real stack and switch to it, first\\n// doing some setup required for memory allocator to work.\\nint\\nmain(void)\\n{\\n  kinit1(end, P2V(4*1024*1024)); // phys page allocator\\n  kvmalloc();      // kernel page table\\n  mpinit();        // detect other processors\\n  lapicinit();     // interrupt controller\\n  seginit();       // segment descriptors\\n  picinit();       // disable pic\\n  ioapicinit();    // another interrupt controller\\n  consoleinit();   // console hardware\\n  uartinit();      // serial port\\n  pinit();         // process table\\n  tvinit();        // trap vectors\\n  binit();         // buffer cache\\n  fileinit();      // file table\\n  ideinit();       // disk \\n  startothers();   // start other processors\\n  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()\\n  userinit();      // first user process\\n  mpmain();        // finish this processor's setup\\n}\\n</code></pre>\\n<p>Первый процесс создается вызовом <code>userinit()</code>, который вызывает <code>allocproc()</code>. Задача <code>allocproc()</code> - аллоцировать структуру типа <code>proc</code> в системной таблице процессов и инициализировать части состояния процесса, чтобы он мог запуститься. <code>allocproc()</code> запускается для каждого нового процесса, а <code>userinit()</code> - только для первого.</p>\\n<pre><code class=\\\"language-c\\\">// Look in the process table for an UNUSED proc.\\n// If found, change state to EMBRYO and initialize\\n// state required to run in the kernel.\\n// Otherwise return 0.\\nstatic struct proc*\\nallocproc(void)\\n{\\n  struct proc *p;\\n  char *sp;\\n\\n  acquire(&#x26;ptable.lock);\\n\\n  for(p = ptable.proc; p &#x3C; &#x26;ptable.proc[NPROC]; p++)\\n    if(p->state == UNUSED)\\n      goto found;\\n\\n  release(&#x26;ptable.lock);\\n  return 0;\\n\\nfound:\\n  p->state = EMBRYO;\\n  p->pid = nextpid++;\\n\\n  release(&#x26;ptable.lock);\\n\\n  // Allocate kernel stack.\\n  if((p->kstack = kalloc()) == 0){\\n    p->state = UNUSED;\\n    return 0;\\n  }\\n  sp = p->kstack + KSTACKSIZE;\\n\\n  // Leave room for trap frame.\\n  sp -= sizeof *p->tf;\\n  p->tf = (struct trapframe*)sp;\\n\\n  // Set up new context to start executing at forkret,\\n  // which returns to trapret.\\n  sp -= 4;\\n  *(uint*)sp = (uint)trapret;\\n\\n  sp -= sizeof *p->context;\\n  p->context = (struct context*)sp;\\n  memset(p->context, 0, sizeof *p->context);\\n  p->context->eip = (uint)forkret;\\n\\n  return p;\\n}\\n</code></pre>\\n<ul>\\n<li>регистр EIP в x86 означает Extended Instruction Pointer</li>\\n</ul>\\n<p>Allocproc:</p>\\n<ol>\\n<li>ищет в таблице процессов слот с состоянием UNUSED</li>\\n<li>когда находит, устанавливает ему состояние EMBRYO и дает процессу уникальный pid.</li>\\n<li>затем пытается выделить в памяти 4096 байт для ядерного стека процесса. Если не получается, то выставляет состояние обратно в UNUSED и возвращает 0.</li>\\n<li>если получилось, то поля структуры proc инициализируются адресами в стеке для trap frame, trapret, context. В результате полученный ядерный стек выглядит так:</li>\\n</ol>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/d05989cf0b10a4cc4b2d7a61cf6fb487/f7060/new-kernel-stack.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 325px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 105.23076923076921%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsSAAALEgHS3X78AAACPElEQVQ4y5VVia7iMAzk/38NCR4rbomr9L6gB6XlmvX4vfLYcm6kyGlCJvZ4bFr4GZfLRe3pdITnuYjCEI7rwfN9eK4Lx3FQlhWyLENVVTgcDnqHlt/H41Hvtx4BmuYaYeDDth0FWq8NWKaJNM3Q+/pCFEWIZY7HY8SbjeynCIJAQa+At6CvRlEUCriJY/T7fSQCVhQ7+BJJWZb3HtI+mufzWc834pFlWQoaBCFiAebatm0NvfXKmxrs9sEkSbDdbtXDTqeDPN9hv98jFM4/AmwCE4yXmRyu8zzXyZAV8FmIt/N28HIggEmyhWGskAow9zzPe+9hPdI0wXKx1EwOBgPNvCVKaLfbcD1feb1yuFqtsFjM5TVDyV7MuTZhyutr04L5s0dL/obDoUgqwHQ6xZ9eTx8oir3uKaAromX8tNSU73vqCYUdRbHyxfVWwBgaAfm7MAzQ7XZVNrvd7pdD/OeoLzMhhrFWUTNBVw4/TcZtUsgh9UfeyB/BuffQw98SPEnIofI6XyywXK7Um9lsho0AxHLWEw7TjDoslKaXgKyMLEs1EcqjVAO9G41G+s0SZPjce8vhq5rmJdZsc5DHf2r5k5r+1mSq3jUHI3kI+K4Ms4wh5nAdG9PJBOPJFJX0xKcePvOy7ja8WAhnBGVPDEWrPKfnCtgMqWkfyYbd5b4803sPm2Bl+V1SFC0rqKwOor9Is1orofacWlRA6o0AtM1WxabgCFdzqeWlaDEII+3S7DYUdj31L0Eswf8C0/9bMV1u3ygAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"New kernel stack\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/d05989cf0b10a4cc4b2d7a61cf6fb487/f7060/new-kernel-stack.png\\\"\\n        srcset=\\\"/hows-that-again/static/d05989cf0b10a4cc4b2d7a61cf6fb487/c5e8e/new-kernel-stack.png 163w,\\n/hows-that-again/static/d05989cf0b10a4cc4b2d7a61cf6fb487/f7060/new-kernel-stack.png 325w\\\"\\n        sizes=\\\"(max-width: 325px) 100vw, 325px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>После заполнения стэка в <code>p->context->eip</code> будет адрес функции <code>forkret</code>, а над контекстом, там, где обычно пишется адрес возврата - будет адрес функции <code>trapret</code>. Созданный поток начинает выполнение со значениями регистров, скопированными из <code>p->context</code>, поэтому при старте потока в регистре EIP будет адрес <code>forkret</code> и начнет выполняться она. После выполнения будет возврат из функции, а значит переход к инструкции, которая располагается сразу над <code>p->context</code>, то есть <code>trapret</code>. <code>trapret</code> восстанавливает значение регистров из значений, сохраненных наверху стэка и прыгает внутрь процесса.</p>\\n<p>Такая сложная конструкция нужна, потому что этот же код используется и для форков. А <code>trapret</code> нужен потому что переход из юзерспейса в ядро происходит через исключения, или, как они называются в x86, трэпы. При трэпе выстреливается прерывание, побирается соответствующий обработчик прерывания, а этот обработчик сохраняет в стэк все значения регистров и вызывает функцию<code>trap()</code>.</p>\\n<p>После создания процесса, ему указывается программа для выполнения, и в случае userinit это программа <code>initcode.s</code>. Но чтобы ее запустить, нужно выделить память, чтобы хранить в ней эту программу, скопировать туда программу, и создать таблицу страниц для этого процесса:</p>\\n<pre><code class=\\\"language-c\\\">void\\nuserinit(void)\\n{\\n  struct proc *p;\\n  extern char _binary_initcode_start[], _binary_initcode_size[];\\n\\n  p = allocproc();\\n  \\n  initproc = p;\\n  if((p->pgdir = setupkvm()) == 0)\\n    panic(\\\"userinit: out of memory?\\\");\\n  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);\\n  p->sz = PGSIZE;\\n  memset(p->tf, 0, sizeof(*p->tf));\\n  p->tf->cs = (SEG_UCODE &#x3C;&#x3C; 3) | DPL_USER;\\n  p->tf->ds = (SEG_UDATA &#x3C;&#x3C; 3) | DPL_USER;\\n  p->tf->es = p->tf->ds;\\n  p->tf->ss = p->tf->ds;\\n  p->tf->eflags = FL_IF;\\n  p->tf->esp = PGSIZE;\\n  p->tf->eip = 0;  // beginning of initcode.S\\n\\n  safestrcpy(p->name, \\\"initcode\\\", sizeof(p->name));\\n  p->cwd = namei(\\\"/\\\");\\n\\n  // this assignment to p->state lets other cores\\n  // run this process. the acquire forces the above\\n  // writes to be visible, and the lock is also needed\\n  // because the assignment might not be atomic.\\n  acquire(&#x26;ptable.lock);\\n\\n  p->state = RUNNABLE;\\n\\n  release(&#x26;ptable.lock);\\n}\\n</code></pre>\\n<p>Процедура <code>setupkvm</code> создает таблицу страниц для нашего процесса. </p>\\n<p><code>inituvm</code> загружает по 0-му адресу выделенной процессу памяти содержимое скомпилированной процедуры <code>initcode</code>, константы <code>_binary_initcode_start</code> и <code>_binary_initcode_size</code> прописываются в процессе билда ядра и обозначают начало и размер эмбеженной в ядро функции <code>initcode</code>.</p>\\n<p>Затем <code>userinit</code> заполняет трэпфрейм, записывая в регистры сегментов селектор сегмента <code>SEG_UCODE</code> и <code>SEG_UDATA</code> с уровнем привилегий <code>DPL_USER</code>, не позволяющим работать в режиме ядра. Указатель стека %esp выставляется в самый большой виртуальный адрес, доступный процессу, а указатель инструкций выставляется в самый маленький, то есть 0. <code>p->name</code> выставляется в основном для отладки, <code>p->cwd</code> выставляет рабочую папку. </p>\\n<p>Когда заполнили все поля процесса, он ставится в очередь на выполнение путем установки поля <code>state</code> в <code>RUNNABLE</code>.</p>\\n<h3>Запуск первого процесса</h3>\\n<p>Итак, первый процесс готов к запуску, а мы выходим из <code>userinit</code> обратно в <code>main</code> и следующая строчка вызывает <code>mpmain()</code>, который вызывает <code>scheduler()</code>.</p>\\n<p><code>scheduler()</code> находится в <code>proc.c</code>, вот его код:</p>\\n<pre><code class=\\\"language-c\\\">void\\nscheduler(void)\\n{\\n  struct proc *p;\\n  struct cpu *c = mycpu();\\n  c->proc = 0;\\n  \\n  for(;;){\\n    // Enable interrupts on this processor.\\n    sti();\\n\\n    // Loop over process table looking for process to run.\\n    acquire(&#x26;ptable.lock);\\n    for(p = ptable.proc; p &#x3C; &#x26;ptable.proc[NPROC]; p++){\\n      if(p->state != RUNNABLE)\\n        continue;\\n\\n      // Switch to chosen process.  It is the process's job\\n      // to release ptable.lock and then reacquire it\\n      // before jumping back to us.\\n      c->proc = p;\\n      switchuvm(p);\\n      p->state = RUNNING;\\n\\n      swtch(&#x26;(c->scheduler), p->context);\\n      switchkvm();\\n\\n      // Process is done running for now.\\n      // It should have changed its p->state before coming back.\\n      c->proc = 0;\\n    }\\n    release(&#x26;ptable.lock);\\n\\n  }\\n}\\n</code></pre>\\n<p>Шедулер проходит по всем процессам в <code>ptable</code> и ищет первый, у которого state равен <code>RUNNABLE</code>. Когда такой процесс найден, он записывается в переменную <code>proc</code> для процессора текущего треда, после чего вызывается <code>switchuvm(p)</code>, которая дает железу команду начать использовать таблицу страниц этого процесса (kvm означает kernel virtual memory, uvm означает user virtual memory).</p>\\n<p>Затем шедулер устанавливает state в RUNNING и вызывает <code>swtch</code>, чтобы переключиться на выбранный поток.</p>\\n<p>После переключения, поток начинает выполнять <code>forkret</code>, потому что <code>allocproc</code> записал ее адрес в <code>p->context->eip</code>. <code>forkret</code> что-то там инициализирует и возвращается. Затем, по заветам <code>allocproc</code>, выполняется <code>trapret</code>. Он восстанавливает регистры <code>gs</code>, <code>fs</code>, <code>es</code> и <code>ds</code> из стека (<code>swtch</code> делает то же самое, но для общих регистров). В данном случае они туда попали в процедуре <code>allocproc</code>, который пытался новому потоку создать такой стек, как будто он был создан ранее и мы на него переключились в процессе нормального context switch. В обычных ситуациях происходит настоящий context switch и эти регистры в стек попадают в процедуре <code>alltraps</code> (см. ниже).</p>\\n<pre><code class=\\\"language-asm\\\">  # Return falls through to trapret...\\n.globl trapret\\ntrapret:\\n  popal\\n  popl %gs\\n  popl %fs\\n  popl %es\\n  popl %ds\\n  addl $0x8, %esp  # trapno and errcode\\n  iret\\n</code></pre>\\n<p>Инструкция <code>iret</code> извлекает регистры <code>cs</code>, <code>eip</code>, <code>flags</code>, <code>esp</code> и <code>ss</code>. Следующей выполняется инструкция, адрес которой записан в <code>$eip</code>. В случае <code>initproc</code> это адрес 0, а <code>$esp</code> получает адрес 4096 (верх страницы, чтобы стек мог расти вниз). Это уже виртуальные адреса.</p>\\n<h3>Первый системный вызов: exec</h3>\\n<p>Первое, что делает <code>initcode.S</code> - это вызывает <code>exec</code>:</p>\\n<pre><code class=\\\"language-asm\\\"># exec(init, argv)\\n.globl start\\nstart:\\n  pushl $argv\\n  pushl $init\\n  pushl $0  // where caller pc would be\\n  movl $SYS_exec, %eax\\n  int $T_SYSCALL\\n\\n# char init[] = \\\"/init\\\\0\\\";\\ninit:\\n  .string \\\"/init\\\\0\\\"\\n\\n# char *argv[] = { init, 0 };\\n.p2align 2\\nargv:\\n  .long init\\n  .long 0\\n</code></pre>\\n<p>Ну точнее она сначала кладет в стек аргументы командной строки (<code>$argv</code> = [init, 0]), адрес вызываемой программы (<code>$init</code> = \\\"/init\\\"), адрес возврата (0), а потом кладет в <code>$eax</code> номер системного вызова <code>exec</code> и выполняет инструкцию <code>int $T_SYSCALL</code> - это просьба выстрелить прерывание с номером, соответствующим системному вызову. Если все пройдет хорошо, то в результате в этом же процессе будет вызвана программа <code>/init</code>, заменив память процесса памятью этой программы.</p>\\n<p><code>/init</code> создаст дескриптор консоли, откроет дескрипторы 0, 1, 2, запустит шелл и будет в цикле принимать команды.</p>\\n<h2>Context switch</h2>\\n<p>Переключение контекста состоит из 3 шагов:</p>\\n<ol>\\n<li>Активация прерывания по таймеру</li>\\n<li>Вызов шедулера</li>\\n<li>Переключение контекста</li>\\n</ol>\\n<p>Рассмотрим шаги по отдельности:</p>\\n<h3>Активация прерывания по таймеру</h3>\\n<p>При билде скрипт <code>vectors.pl</code> генерирует обработчики для 256 прерываний, каждый из обработчиков выглядит приблизительно так:</p>\\n<pre><code class=\\\"language-asm\\\">vector 32:\\n  pushl $0 //error code\\n  pushl $32 //vector number of timer interrupt\\n  jmp alltraps\\n</code></pre>\\n<p>Здесь мы видим обработчик прерывания с номером 32. Он пишет в стек 0 и 32 в качестве аргументов вызова и вызывает процедуру <code>alltraps</code>.</p>\\n<p>Эта процедура описана в файле <code>trapasm.S</code>, вот ее код:</p>\\n<pre><code class=\\\"language-asm\\\">.globl alltraps\\nalltraps:\\n  # Build trap frame.\\n  pushl %ds #data segment register\\n  pushl %es #extra segment register\\n  pushl %fs #general segment register\\n  pushl %gs #general segment register\\n  pushal    #all local registers (push EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI)\\n  \\n  # Set up data segments.\\n  movw $(SEG_KDATA&#x3C;&#x3C;3), %ax\\n  movw %ax, %ds\\n  movw %ax, %es\\n\\n  # Call trap(tf), where tf=%esp\\n  pushl %esp\\n  call trap\\n  addl $4, %esp\\n\\n  # Return falls through to trapret...\\n.globl trapret\\ntrapret:\\n  popal\\n  popl %gs\\n  popl %fs\\n  popl %es\\n  popl %ds\\n  addl $0x8, %esp  # trapno and errcode\\n  iret\\n</code></pre>\\n<p>Итак, процедура <code>alltraps</code> сохранила на стеке значение регистров. Регистр esp мы не трогали, но каждый пуш уменьшает его значение, поэтому сейчас он указывает на низ фрейма. а над ним - сохраненные нами регистры и сегменты. Передавая значение регистра esp внутрь процедуры <code>trap</code>, мы, таким образом, передаем внутрь ее структуру <code>tf</code> типа <code>trapframe</code>. Вот код структуры:</p>\\n<pre><code class=\\\"language-c\\\">struct trapframe {\\n  // registers as pushed by pusha\\n  uint edi;\\n  uint esi;\\n  uint ebp;\\n  uint oesp;      // useless &#x26; ignored\\n  uint ebx;\\n  uint edx;\\n  uint ecx;\\n  uint eax;\\n\\n  // rest of trap frame\\n  ushort gs;\\n  ushort padding1;\\n  ushort fs;\\n  ushort padding2;\\n  ushort es;\\n  ushort padding3;\\n  ushort ds;\\n  ushort padding4;\\n  uint trapno;\\n\\n  // below here defined by x86 hardware\\n  uint err;\\n  uint eip;\\n  ushort cs;\\n  ushort padding5;\\n  uint eflags;\\n\\n  // below here only when crossing rings, such as from user to kernel\\n  uint esp;\\n  ushort ss;\\n  ushort padding6;\\n};\\n</code></pre>\\n<p>В процедуре <code>alltraps</code> у этой структуры мы заполняем только верхние поля от <code>edi</code> до <code>padding4</code>. Поля <code>trapno</code> и <code>err</code> были ранее заполнены обработчиком прерывания <code>vector 32</code>. Оставшиеся поля составляют kernel stack и записываются аппаратным обеспечением.</p>\\n<p>Итак, перед вызовом <code>trap</code> стэк имеет следующий вид:</p>\\n<pre><code>err\\ntrapno\\npadding4\\nds\\npadding3\\nes\\npadding2\\nfs\\npadding1\\ngs\\neax\\necx\\nedx\\nebx\\noesp\\nebp\\nesi\\nedi &#x3C;--- $esp\\n</code></pre>\\n<p>Переход в <code>alltraps</code> осуществлялся командой <code>JMP</code>, поэтому адрес возврата нигде не записан (для вызова процедуры с возможностью возврата используется <code>CALL</code>, который автоматически пишет адрес следующей инструкции в стэк. Вызовы функций изнутри C всегда осуществляются через <code>CALL</code>, поэтому стэк трапфрейма составляется на ассемблере).</p>\\n<p>Далее, в <code>trap.c (109)</code> видим, что произошло прерывание по таймеру и вызываем процедуру <code>yield()</code> для запуска шедурера:</p>\\n<pre><code class=\\\"language-c\\\">if(myproc() &#x26;&#x26; myproc()->state == RUNNING &#x26;&#x26;\\n   tf->trapno == T_IRQ0+IRQ_TIMER)\\nyield();\\n</code></pre>\\n<h3>Вызов шедулера</h3>\\n<p>Посмотрим, что делает <code>yield()</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Give up the CPU for one scheduling round.\\nvoid\\nyield(void)\\n{\\n  acquire(&#x26;ptable.lock);\\n  proc->state = RUNNABLE;\\n  sched();\\n  release(&#x26;ptable.lock);\\n}\\n</code></pre>\\n<p>Здесь ничего особенного, смотрим что там в <code>sched()</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Enter scheduler.  Must hold only ptable.lock\\n// and have changed proc->state.\\nvoid\\nsched(void)\\n{\\n  int intena;\\n\\n  // If we aren't holding the ptable lock, panic\\n  if(!holding(&#x26;ptable.lock))\\n    panic(\\\"sched ptable.lock\\\");\\n\\n  // If we aren't 1 pushcli level deep, panic\\n  if(cpu->ncli != 1)\\n    panic(\\\"sched locks\\\");\\n\\n  // If the current process is in the running state, panic\\n  if(proc->state == RUNNING)\\n    panic(\\\"sched running\\\");\\n\\n  // If the processor can be interrupted, panic\\n  if(readeflags()&#x26;FL_IF)\\n    panic(\\\"sched interruptible\\\");\\n\\n  intena = cpu->intena;\\n  swtch(&#x26;proc->context, cpu->scheduler);\\n  cpu->intena = intena;\\n}\\n</code></pre>\\n<p>Здесь у нас в основном проверки, что мы действительно можем сделать переключение контекста и сохранение поля <code>intena</code> (interruptions enabled), неизвестно зачем.</p>\\n<p>В конце вызывается непосредственно процедура переключения контекста, в которую передается контекст текущего процесса и контекст щедулера, то есть контекст, на который мы будем переключаться (предполагаю, что где-то в другом месте шедулер выбирает процесс, на который переключаемся и подставляет его контекст).</p>\\n<h3>Переключение контекста</h3>\\n<p>Вот код <code>swtch.S</code>:</p>\\n<pre><code class=\\\"language-asm\\\"># Context switch\\n#\\n#   void swtch(struct context **old, struct context *new);\\n#\\n# Save current register context in old\\n# and then load register context from new.\\n\\n.globl swtch\\nswtch:\\n  movl 4(%esp), %eax\\n  movl 8(%esp), %edx # сохраняем *new в %edx, **old в %eax\\n\\n  # Save old callee-save registers\\n  pushl %ebp\\n  pushl %ebx\\n  pushl %esi\\n  pushl %edi\\n\\n  # Switch stacks\\n  movl %esp, (%eax)\\n  movl %edx, %esp   # пишем значение %edx, то есть *new в %esp\\n\\n  # Load new callee-save registers\\n  popl %edi\\n  popl %esi\\n  popl %ebx\\n  popl %ebp\\n  ret\\n</code></pre>\\n<p>Здесь общий смысл такой:</p>\\n<ol>\\n<li>мы сохраняем значение регистров на стеке</li>\\n<li>перемещаем указатель стека <code>esp</code> на тот, который указан в новом контексте</li>\\n<li>теперь мы работаем со стеком нового контекста, в котором запушены его значения регистров. Нам осталось только сделать <code>pop</code> для всех регистров и продолжить выполнение.</li>\\n</ol>\\n<h2>Организация страничной памяти</h2>\\n<p>Каждому процессу доступны 4 ГБ виртуальной памяти, из которых верхние 2 ГБ всегда занимает адресное пространство ядра, а нижние 2 выделены под нужды процесса. Начало области виртуального адресного пространства ядра обозначается константой <code>KERNBASE</code>.</p>\\n<h3>Создание адресного пространства ядра</h3>\\n<p>Процедура <code>main</code> вызывает <code>kvmalloc</code>, который создает и переключается на страницу памяти, описывающую маппинги страниц выше <code>KERNBASE</code>, необходимых для работы ядра:</p>\\n<pre><code class=\\\"language-c\\\">// Allocate one page table for the machine for the kernel address\\n// space for scheduler processes.\\nvoid\\nkvmalloc(void)\\n{\\n  kpgdir = setupkvm();\\n  switchkvm();\\n}\\n</code></pre>\\n<p>Основная работа происходит в <code>setupkvm</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Set up kernel part of a page table.\\npde_t*\\nsetupkvm(void)\\n{\\n  pde_t *pgdir;\\n  struct kmap *k;\\n\\n  if((pgdir = (pde_t*)kalloc()) == 0)\\n    return 0;\\n  memset(pgdir, 0, PGSIZE);\\n  if (P2V(PHYSTOP) > (void*)DEVSPACE)\\n    panic(\\\"PHYSTOP too high\\\");\\n  for(k = kmap; k &#x3C; &#x26;kmap[NELEM(kmap)]; k++)\\n    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,\\n                (uint)k->phys_start, k->perm) &#x3C; 0) {\\n      freevm(pgdir);\\n      return 0;\\n    }\\n  return pgdir;\\n}\\n</code></pre>\\n<p>Сначала <code>kalloc</code> находит и выделяет 1 физическую страницу памяти для ядра:</p>\\n<pre><code class=\\\"language-c\\\">// Allocate one 4096-byte page of physical memory.\\n// Returns a pointer that the kernel can use.\\n// Returns 0 if the memory cannot be allocated.\\nchar*\\nkalloc(void)\\n{\\n  struct run *r;\\n\\n  if(kmem.use_lock)\\n    acquire(&#x26;kmem.lock);\\n  r = kmem.freelist;\\n  if(r)\\n    kmem.freelist = r->next;\\n  if(kmem.use_lock)\\n    release(&#x26;kmem.lock);\\n  return (char*)r;\\n}\\n</code></pre>\\n<p>Как видим, <code>kalloc</code> выделяет страницы по очереди, начиная с первой.</p>\\n<p>Затем <code>setupkvm</code> зануляет полученную страницу: <code>memset(pgdir, 0, PGSIZE);</code>.</p>\\n<p>Затем проходит по перенаправлениям, описанным в массиве <code>kmap</code>:</p>\\n<pre><code class=\\\"language-c\\\">static struct kmap {\\n  void *virt;\\n  uint phys_start;\\n  uint phys_end;\\n  int perm;\\n} kmap[] = {\\n { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space\\n { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata\\n { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory\\n { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices\\n};\\n</code></pre>\\n<p>И для каждого перенаправления создает запись в странице таблиц памяти:</p>\\n<pre><code class=\\\"language-c\\\">for(k = kmap; k &#x3C; &#x26;kmap[NELEM(kmap)]; k++)\\n    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,\\n                (uint)k->phys_start, k->perm) &#x3C; 0) {\\n      freevm(pgdir);\\n      return 0;\\n    }\\n</code></pre>\\n<p>Вот как выглядит <code>mappages</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Create PTEs for virtual addresses starting at va that refer to\\n// physical addresses starting at pa. va and size might not\\n// be page-aligned.\\nstatic int\\nmappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)\\n{\\n  char *a, *last;\\n  pte_t *pte;\\n\\n  a = (char*)PGROUNDDOWN((uint)va);\\n  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);\\n  for(;;){\\n    if((pte = walkpgdir(pgdir, a, 1)) == 0)\\n      return -1;\\n    if(*pte &#x26; PTE_P)\\n      panic(\\\"remap\\\");\\n    *pte = pa | perm | PTE_P;\\n    if(a == last)\\n      break;\\n    a += PGSIZE;\\n    pa += PGSIZE;\\n  }\\n  return 0;\\n}\\n</code></pre>\\n<p>Он проходит по каждой странице (<code>a</code> - текущий виртуальный адрес, <code>pa</code> - текущий физический, в каждой итерации к ним прибавляется <code>PGSIZE</code>, то есть размер страницы).</p>\\n<p>Процедура <code>walkpgdir</code> здесь ищет нужную запись в таблице страниц:</p>\\n<pre><code class=\\\"language-c\\\">// Return the address of the PTE in page table pgdir\\n// that corresponds to virtual address va.  If alloc!=0,\\n// create any required page table pages.\\nstatic pte_t *\\nwalkpgdir(pde_t *pgdir, const void *va, int alloc)\\n{\\n  pde_t *pde;\\n  pte_t *pgtab;\\n\\n  pde = &#x26;pgdir[PDX(va)];\\n  if(*pde &#x26; PTE_P){\\n    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));\\n  } else {\\n    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)\\n      return 0;\\n    // Make sure all those PTE_P bits are zero.\\n    memset(pgtab, 0, PGSIZE);\\n    // The permissions here are overly generous, but they can\\n    // be further restricted by the permissions in the page table\\n    // entries, if necessary.\\n    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;\\n  }\\n  return &#x26;pgtab[PTX(va)];\\n}\\n</code></pre>\\n<p>Для адресации используется 2-уровневое дерево, первый уровень называется PD (page directory), в нем ищется запись по индексу, соотв-му первым 10 битам виртуального адреса. полученная запись называется PDE (page directory entry) и она обозначает адрес используемой в этом процессе таблицы страниц. Следующие 10 бит виртуального адреса обозначают индекс в таблице страниц процесса, по которому лежит PTE (page table entry). В каждом PTE записан PPN (physical page number) и несколько флагов, регулирующие доступ к этой физической странице. Для получения необходимой строки внутри страницы используются последние 12 бит виртуального адреса.</p>\\n<p>Сначала <code>walkpgdir</code> использует верхние 10 бит (макрос PDX) виртуального адреса <code>va</code>, чтобы получить PDE. Если PDE не найден, значит таблица страниц для этого процесса еще не инициализирована, и если параметр <code>alloc</code> выставлен, то мы выделяем для нее память через <code>kalloc</code>, зануляем память и сохраняем ее адрес в <code>pgdir</code>. Затем получаем в таблице страниц строчку по индексу, состоящему из вторых 10 бит адреса (макрос PTX) и возвращаем ссылку на нее.</p>\\n<p>Вернувшись в <code>mappages</code>, пишем текущий физический адрес в полученную <code>PTE</code>:</p>\\n<pre><code class=\\\"language-c\\\">*pte = pa | perm | PTE_P;\\n</code></pre>\\n<h3>Аллокация физической памяти для ядра</h3>\\n<p>Аллокатор физической памяти использует <strong>free list</strong> (список освобождения), чтобы отслеживать страницы физической памяти, доступные для аллокации. Это связанный список страниц, в котором каждая аллокация памяти удаляет страницу, а каждое освобождение памяти - добавляет. Каждый элемент списка имеет тип <code>run</code>:</p>\\n<pre><code class=\\\"language-c\\\">struct run {\\n  struct run *next;\\n};\\n</code></pre>\\n<p>Каждая структура <code>run</code> хранится в начале свободной страницы памяти, потому что в ней все равно больше нечего хранить, она же свободная.</p>\\n<p>Доступ к free list защищается спинлоком:</p>\\n<pre><code class=\\\"language-c\\\">struct {\\n  struct spinlock lock;\\n  int use_lock;\\n  struct run *freelist;\\n} kmem;\\n</code></pre>\\n<p>Для инициализации аллокатора процедура <code>main</code> вызывает процедуры <code>kinit1</code> в начале и <code>kinit2</code> в конце. Это нужно потому что нам нужно аллоцировать немножко памяти, чтобы мы могли поднять все остальное (в том числе таблицу страниц), а уже после этого мы можем использовать нормальный стандартный большой аллокатор. Поэтому <code>kinit1</code> инициализирует аллокатор на 4 МБ, не использующий локов, а <code>kinit2</code> инициализирует полномощный аллокатор:</p>\\n<pre><code class=\\\"language-c\\\">int\\nmain(void)\\n{\\n  kinit1(end, P2V(4*1024*1024)); // phys page allocator\\n  ...\\n  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()\\n  ...  \\n}\\n\\n// Initialization happens in two phases.\\n// 1. main() calls kinit1() while still using entrypgdir to place just\\n// the pages mapped by entrypgdir on free list.\\n// 2. main() calls kinit2() with the rest of the physical pages\\n// after installing a full page table that maps them on all cores.\\nvoid\\nkinit1(void *vstart, void *vend)\\n{\\n  initlock(&#x26;kmem.lock, \\\"kmem\\\");\\n  kmem.use_lock = 0;\\n  freerange(vstart, vend);\\n}\\n\\nvoid\\nkinit2(void *vstart, void *vend)\\n{\\n  freerange(vstart, vend);\\n  kmem.use_lock = 1;\\n}\\n</code></pre>\\n<p><code>freerange</code> заносит страницы из указанного ренджа по одной во free list и выставляет каждый байт в них в 1, это нужно чтобы код, который попытается прочесть эту память после ее освобождения, не наткнулся на старые данные и выдал ошибку как можно быстрее.</p>\\n<h2>Пользовательское пространство</h2>\\n<p>На схеме изображено содержимое памяти для процесса:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/165bd8d61bd499051f28e2b358bf2ad9/bdbe7/memory-layout-main.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 57.80089153046062%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAABoElEQVQoz4VTa4+CMBDk//+uM/G+mJgIiAEMLwV5ig9EwbnOnjXRu8s1aVq2u9OZ2WI4joNtmiLPc5xOJ5zPZxyPR/R9j//G/X7/ETP0Zr/f43q9StLlchFwjnEccbvd0KlY13UYhkFy/pqGvoXMxnGQPQEIyrUsS2w3GyyXS5lplkmM57+NF8BOzd1uJ0zJhkV1XSOJY5iWBdpDawj4raiXGlpERWT/lEwAytMMmcSELN3CdV34vo/VaoUgDJEkCTzPw3w+h6NYF0WBXBGh74YwU2DaQ+55cDgcBDyKQiwWCwG1bQumaarVxkbZkCn5740x6E+sJK3Xa1lZQAZkqAE/p1NY1gPMsoVtqJgyn8zKshIrGkXqKZmMmMRkAvKbFhRFDk/FJpMPzGYzUdI0tch3XU98dZX8IAhE+rMpNJVyq6oSyWRIC3Q8jiK5jOeMUXKhWJEZG9kqAi/PhoyYyEkwektggjGHxU3TSC4v0g3889mwmF2lJCbrd6i7zQv00+CZ/pNeH/bjT2nbFr5qChmwSMvSbAjAVe8Jpom8d/kLO2GZD/ds8UwAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Memory layout\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/165bd8d61bd499051f28e2b358bf2ad9/10273/memory-layout-main.png\\\"\\n        srcset=\\\"/hows-that-again/static/165bd8d61bd499051f28e2b358bf2ad9/9b14a/memory-layout-main.png 163w,\\n/hows-that-again/static/165bd8d61bd499051f28e2b358bf2ad9/94962/memory-layout-main.png 325w,\\n/hows-that-again/static/165bd8d61bd499051f28e2b358bf2ad9/10273/memory-layout-main.png 650w,\\n/hows-that-again/static/165bd8d61bd499051f28e2b358bf2ad9/bdbe7/memory-layout-main.png 673w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Каждый пользовательский процесс стартует с адреса 0. Внизу пространства располагаются текст программы, ее данные и стек. Здесь <strong>важное различие</strong> относительно схемы памяти в илнуксе.</p>\\n<p>В xv6 стек располагается под кучей. <strong>В линуксе - стек наверху и растет вниз, куча внизу и растет вверх</strong>.</p>\\n<p>Стек занимает одну страницу и на схеме показан с содержимым после вызова <code>exec</code>. Сначала идут аргументы командной строки <code>argv</code>, представляющие ссылки на строки, затем аргумент <code>args</code> и адрес возврата. Чтобы стек не смог вырасти больше одной страницы, под ним располагается <strong>guard page</strong>. Эта страница не замаплена, поэтому когда стек попытается ее аллоцировать, будет сгенерировано исключение. Реальные ОС позволяют выделить больше пространства для стека, и он располагается на нескольких страницах.</p>\\n<p><code>sbrk</code> - это системный вызов для увеличения или уменьшения памяти процесса. Реализуется функцией <code>growproc</code>. Если аргумент положительный, то аллоцируется 1 или несколько страниц и мапятся наверх пользовательского пространства. Если отрицательный - размапливаются 1 или несколько страниц пользовательского пространства и освобождаются соответствующие им физические страницы.</p>\\n<pre><code class=\\\"language-c\\\">// Grow current process's memory by n bytes.\\n// Return 0 on success, -1 on failure.\\nint\\ngrowproc(int n)\\n{\\n  uint sz;\\n  struct proc *curproc = myproc();\\n\\n  sz = curproc->sz;\\n  if(n > 0){\\n    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)\\n      return -1;\\n  } else if(n &#x3C; 0){\\n    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)\\n      return -1;\\n  }\\n  curproc->sz = sz;\\n  switchuvm(curproc);\\n  return 0;\\n}\\n</code></pre>\\n<p>Для выделения области памяти в пользовательском пространстве используется <code>allocuvm</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Allocate page tables and physical memory to grow process from oldsz to\\n// newsz, which need not be page aligned.  Returns new size or 0 on error.\\nint\\nallocuvm(pde_t *pgdir, uint oldsz, uint newsz)\\n{\\n  char *mem;\\n  uint a;\\n\\n  if(newsz >= KERNBASE)\\n    return 0;\\n  if(newsz &#x3C; oldsz)\\n    return oldsz;\\n\\n  a = PGROUNDUP(oldsz);\\n  for(; a &#x3C; newsz; a += PGSIZE){\\n    mem = kalloc();\\n    if(mem == 0){\\n      cprintf(\\\"allocuvm out of memory\\\\n\\\");\\n      deallocuvm(pgdir, newsz, oldsz);\\n      return 0;\\n    }\\n    memset(mem, 0, PGSIZE);\\n    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) &#x3C; 0){\\n      cprintf(\\\"allocuvm out of memory (2)\\\\n\\\");\\n      deallocuvm(pgdir, newsz, oldsz);\\n      kfree(mem);\\n      return 0;\\n    }\\n  }\\n  return newsz;\\n}\\n</code></pre>\\n<p>Как видим, она проходит по одной странице от нижней до верхней границы ренджа, выделяет им виртуальную память, зануляет ее и пишет маппинг в таблицу страниц.</p>\\n<p>Похожим образом работает и деаалоцирование пользовательской памяти:</p>\\n<pre><code class=\\\"language-c\\\">// Deallocate user pages to bring the process size from oldsz to\\n// newsz.  oldsz and newsz need not be page-aligned, nor does newsz\\n// need to be less than oldsz.  oldsz can be larger than the actual\\n// process size.  Returns the new process size.\\nint\\ndeallocuvm(pde_t *pgdir, uint oldsz, uint newsz)\\n{\\n  pte_t *pte;\\n  uint a, pa;\\n\\n  if(newsz >= oldsz)\\n    return oldsz;\\n\\n  a = PGROUNDUP(newsz);\\n  for(; a  &#x3C; oldsz; a += PGSIZE){\\n    pte = walkpgdir(pgdir, (char*)a, 0);\\n    if(!pte)\\n      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;\\n    else if((*pte &#x26; PTE_P) != 0){\\n      pa = PTE_ADDR(*pte);\\n      if(pa == 0)\\n        panic(\\\"kfree\\\");\\n      char *v = P2V(pa);\\n      kfree(v);\\n      *pte = 0;\\n    }\\n  }\\n  return newsz;\\n}\\n</code></pre>\\n<h3>exec</h3>\\n<pre><code class=\\\"language-c\\\">int\\nexec(char *path, char **argv)\\n{\\n  # ------------------------------------------\\n  # сначала загружаем образ программы в память\\n  # ------------------------------------------\\n\\n  ...\\n  if((ip = namei(path)) == 0){   # ищет и возвращает inode по адресу path\\n    end_op();\\n    cprintf(\\\"exec: fail\\\\n\\\");\\n    return -1;\\n  }\\n  ilock(ip);        # лочит полученный inode\\n\\n  // Check ELF header\\n  if(readi(ip, (char*)&#x26;elf, 0, sizeof(elf)) != sizeof(elf))     # читает заголовок ELF-файла из inode в структуру &#x26;elf (которая имеет тип elfhdr)\\n    goto bad;\\n  if(elf.magic != ELF_MAGIC)                                    # проверяет, что это действительно ELF-файл\\n    goto bad;\\n\\n  if((pgdir = setupkvm()) == 0)                                 # аллоцирует новую таблицу страниц для этого процесса\\n    goto bad;\\n\\n  // Load program into memory.\\n  for(i=0, off=elf.phoff; i&#x3C;elf.phnum; i++, off+=sizeof(ph)){   # проходим по всем program headers ELF-файла, в каждом из которых описано расположение какого-либо сегмента памяти\\n    if(readi(ip, (char*)&#x26;ph, off, sizeof(ph)) != sizeof(ph))    # читает с диска program header\\n      goto bad;\\n    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)    # выделяем в виртуальной памяти кусок под сегмент\\n      goto bad;\\n    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) &#x3C; 0)  # загружаем постранично сегмент в память\\n      goto bad;\\n  }\\n  iunlockput(ip);       # разлочивает inode\\n\\n  # --------------------------------------------\\n  # теперь будем создавать пользовательский стек\\n  # --------------------------------------------\\n\\n  // Allocate two pages at the next page boundary.\\n  // Make the first inaccessible.  Use the second as the user stack.\\n  sz = PGROUNDUP(sz);\\n  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0) # аллоцируем 2 страницы над сегментами\\n    goto bad;\\n  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));          # первую страницу удаляем из таблицы страниц, это будет наша guard page\\n  sp = sz;\\n\\n  // Push argument strings, prepare rest of stack in ustack.\\n  for(argc = 0; argv[argc]; argc++) {\\n    sp = (sp - (strlen(argv[argc]) + 1)) &#x26; ~3;\\n    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) &#x3C; 0)\\n      goto bad;\\n    ustack[3+argc] = sp;\\n  }\\n  ustack[3+argc] = 0;\\n\\n  ustack[0] = 0xffffffff;  // fake return PC\\n  ustack[1] = argc;\\n  ustack[2] = sp - (argc+1)*4;  // argv pointer\\n\\n  sp -= (3+argc+1) * 4;\\n  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) &#x3C; 0)      # записываем стек в память\\n    goto bad;\\n\\n  # -----------------------------------\\n  # теперь переключаемся на новый имедж\\n  # -----------------------------------\\n\\n  // Commit to the user image.\\n  oldpgdir = curproc->pgdir;\\n  curproc->pgdir = pgdir;   # устанавливаем процессу созданную нами таблицу страниц\\n  curproc->sz = sz;\\n  curproc->tf->eip = elf.entry;  # следующей выполняемой инструкцией будет точка входа в загруженный образ\\n  curproc->tf->esp = sp;        # устанавливаем указатель стека на созданный нами стек\\n  switchuvm(curproc);       # переключаемся на использование образа нового процесса\\n  freevm(oldpgdir);         # удаляем старую таблицу страниц\\n  return 0;\\n}\\n</code></pre>\\n<p>В результате всех этих манипуляций <code>exec</code> загружает сегменты программы по тем адресам, которые указаны в ELF-файле. Эти адреса вполне могут указывать на область памяти ядра, поэтому <code>exec</code> опасен. Внутри кода <code>exec</code> есть некоторые дополнительные проверки для этого, которые здесь были опущены.</p>\\n<p>В настоящих операционных системах есть еще пейджинг неиспользуемых страниц на диск, copy-on-write, разделяемая память, лениво-аллоцируемые страницы и автоматически расширяемые стеки. В xv6 этого всего нет.</p>\\n<h2>Трэпы/исключения, прерывания и драйвера</h2>\\n<p>Управление от пользовательской программы в ядро передается в 3 случаях:</p>\\n<ol>\\n<li>Системный вызов</li>\\n<li>Исключение (официальная терминология xv6 использует термин trap)</li>\\n<li>Прерывание (разделение времени среди процессов осуществляется по прерыванию таймера)</li>\\n</ol>\\n<p>Все прерывания обрабатываются ядром, потому что обычно только у него есть необходимые привилегии.</p>\\n<p>Все 3 случая на самом деле реализуются через прерывания: для системного вызова генерируется прерывание инструкцией int, для исключений тоже.</p>\\n<p>При каждом переходе в ядро ОС сохраняет значения регистров, готовится к выполнению кода в ядре, выбирает точку входа в ядро, получает информация о произошедшем событии. Общий алгоритм работы при прерывании такой:</p>\\n<ul>\\n<li>прерывание приостанавливает нормальную работу процессора</li>\\n<li>процессор сохраняет значения регистров, чтобы можно было потом к ним вернуться</li>\\n<li>процессор запускает новую последовательность инструкций, называемую <em>обработчик прерываний</em></li>\\n</ul>\\n<h3>Защита X86</h3>\\n<p>У процессоров x86 есть 4 уровня защиты, именуемые от 0 (самый привилегированный) до 3 (наименее привилегированный). На практике, большинство ОС используют только 0 и 3, которые называются <em>режим ядра</em> и  <em>пользовательский режим</em>, соответственно. Текущий уровень привилегий хранится в регистре <code>%cs</code>.</p>\\n<p>Обработчики прерываний определены в IDT (interrupt descriptor table). IDT содержит 256 строк, в каждой из которых есть <code>%cs</code> и <code>%eip</code> для обработки прерывания.</p>\\n<p>Для выполнения системного вызова на x86, программа выполняет инструкцию <code>int n</code>, где <code>n</code> - индекс обработчика в IDT. Инструкция <code>int n</code> делает следующее:</p>\\n<ol>\\n<li>Получает n-ю запись из IDT</li>\\n<li>Берет CPL (current privilege level) из регистра %cs, проверяет, что CPL &#x3C;= DPL, где DPL = descriptor privilege level, хранящийся в полученной из IDT строке. Благодаря этому пользовательские программы (CPL=3) не могут дергать обработчики уровня ядра (DPL=0).</li>\\n<li>Сохраняет значения <code>%esp</code> и <code>%ss</code> (stack segment) во внутренних регистрах CPU, но только если уровень привилегий нужного сегмента &#x3C; CPL</li>\\n<li>Загружает <code>%ss</code> и <code>%esp</code> из дескриптора сегмента таска (?)</li>\\n<li>Пушит <code>%ss</code>, <code>%esp</code>, <code>%eflags</code>, <code>%cs</code>, <code>%eip</code>.</li>\\n<li>Очищает бит IF в <code>%eflags</code>, но только в случае прерывания</li>\\n<li>Выставляет <code>%cs</code> и <code>%eip</code> в значения, полученные из дескриптора.</li>\\n</ol>\\n<h3>Реализация системного вызова</h3>\\n<p>Выше я уже описывал, как заполняется файл <code>vectors.S</code>, но не было описано, как он используется. Так вот, при старте процедура <code>main()</code> вызывает <code>tvinit()</code>. Вот ее код:</p>\\n<pre><code class=\\\"language-c\\\">void\\ntvinit(void)\\n{\\n  int i;\\n\\n  for(i = 0; i &#x3C; 256; i++)\\n    SETGATE(idt[i], 0, SEG_KCODE&#x3C;&#x3C;3, vectors[i], 0);\\n  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE&#x3C;&#x3C;3, vectors[T_SYSCALL], DPL_USER);\\n\\n  initlock(&#x26;tickslock, \\\"time\\\");\\n}\\n\\n// Set up a normal interrupt/trap gate descriptor.\\n// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.\\n//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone\\n// - sel: Code segment selector for interrupt/trap handler\\n// - off: Offset in code segment for interrupt/trap handler\\n// - dpl: Descriptor Privilege Level -\\n//        the privilege level required for software to invoke\\n//        this interrupt/trap gate explicitly using an int instruction.\\n#define SETGATE(gate, istrap, sel, off, d)                \\\\\\n{                                                         \\\\\\n  (gate).off_15_0 = (uint)(off) &#x26; 0xffff;                \\\\\\n  (gate).cs = (sel);                                      \\\\\\n  (gate).args = 0;                                        \\\\\\n  (gate).rsv1 = 0;                                        \\\\\\n  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \\\\\\n  (gate).s = 0;                                           \\\\\\n  (gate).dpl = (d);                                       \\\\\\n  (gate).p = 1;                                           \\\\\\n  (gate).off_31_16 = (uint)(off) >> 16;                  \\\\\\n}\\n</code></pre>\\n<p>Видим, что цикл проходит по всем элементам <code>vectors</code> и для каждого создает запись в массиве <code>idt</code>, потом отдельно добавляет запись, предназначенную для обработки системных вызовов под номером 64.</p>\\n<p>У обычных обработчиков вторым параметром передается 0, что делает их обработчиками прерываний, а у системного вызова - 1, что делает его исключением или трэпом. Так же ему выставляется <code>DPL = DPL_USER</code>, а обработчикам прерываний - <code>DPL = 0</code>. xv6 зарещает пользовательскому коду вызывать любые другие прерывания, кроме 64, если они попытаются, то получат <code>general protection exception</code>.</p>\\n<p>Первая часть обработки системного вызова описана в разделе <strong>Context switch</strong>. Для системного вызова там актуально все, что до вызова <code>trap(tf)</code>. Там в этой процедуре пошли по ветви, соответствующей прерыванию таймера. Здесь пойдем по ветке, соответствующей <code>T_SYSCALL</code>:</p>\\n<pre><code class=\\\"language-c\\\">void\\ntrap(struct trapframe *tf)\\n{\\n  if(tf->trapno == T_SYSCALL){\\n    ...\\n    myproc()->tf = tf;\\n    syscall();\\n    ...\\n    return;\\n  }\\n  ...\\n}\\n</code></pre>\\n<p>Шлавное, что здесь происходит - вызывается <code>syscall()</code>. Посмотрим на него:</p>\\n<pre><code class=\\\"language-c\\\">void\\nsyscall(void)\\n{\\n  int num;\\n  struct proc *curproc = myproc();\\n\\n  num = curproc->tf->eax;\\n  if(num > 0 &#x26;&#x26; num &#x3C; NELEM(syscalls) &#x26;&#x26; syscalls[num]) {\\n    curproc->tf->eax = syscalls[num]();\\n  } else {\\n    cprintf(\\\"%d %s: unknown sys call %d\\\\n\\\",\\n            curproc->pid, curproc->name, num);\\n    curproc->tf->eax = -1;\\n  }\\n}\\n</code></pre>\\n<p>Он сохраняет номер вызова из регистра <code>eax</code> в переменную <code>num</code>, получает по этому индексу функцию из массива <code>syscalls</code>, выполняет ее и кладет результат в регистр <code>eax</code>.</p>\\n<p>Массив <code>syscalls</code> выглядит так:</p>\\n<pre><code class=\\\"language-c\\\">static int (*syscalls[])(void) = {\\n[SYS_fork]    sys_fork,\\n[SYS_exit]    sys_exit,\\n[SYS_wait]    sys_wait,\\n[SYS_pipe]    sys_pipe,\\n[SYS_read]    sys_read,\\n[SYS_kill]    sys_kill,\\n[SYS_exec]    sys_exec,\\n[SYS_fstat]   sys_fstat,\\n[SYS_chdir]   sys_chdir,\\n[SYS_dup]     sys_dup,\\n[SYS_getpid]  sys_getpid,\\n[SYS_sbrk]    sys_sbrk,\\n[SYS_sleep]   sys_sleep,\\n[SYS_uptime]  sys_uptime,\\n[SYS_open]    sys_open,\\n[SYS_write]   sys_write,\\n[SYS_mknod]   sys_mknod,\\n[SYS_unlink]  sys_unlink,\\n[SYS_link]    sys_link,\\n[SYS_mkdir]   sys_mkdir,\\n[SYS_close]   sys_close,\\n};\\n</code></pre>\\n<p>Для получения своих аргументов системные функции используют функции <code>argint</code>, <code>argptr</code>, <code>argstr</code> и <code>argfd</code>. Они принимают первым аргументов <code>n</code> и возвращают n-й аргумент как число, указатель, строку или файловый дескриптор. n-й аргумент лежит по адресу <code>%esp+4+4*n</code> (адрес возврата лежит  %esp, а первый аргумент лежит в %esp+4).</p>\\n<p>Системные функции лежат в syspoc.c и sysfile.c и в основном являются оболочками - читают аргументы со стека, используя функции <code>arg*</code> и вызывают с этими аргументами реальные реализации.</p>\\n<h3>Реализация прерываний</h3>\\n<p>Раньше у материнских плат был programmable interrupt controller (PIC), который занимался обслуживанием прерываний. Но потом появились системы с несколькими процессорами и пришлось каждому делать свой, интегрированный APIC (advanced PIC). Теперь для работы с прерываниями на уровне ОС используется 2 API: работающий с прерываниями системы I/O (ioapic.c) и работающий с локальными APIC, интегрированными в каждый процессор (lapic.c).</p>\\n<p><code>ioapic.c</code> предоставляет функцию <code>ioapicenable</code>, которая позволяет различным устройствам ввода-вывода включать отдельные прерывания и указывать, на каком процессоре они должны быть обработаны:</p>\\n<pre><code class=\\\"language-c\\\">void\\nioapicenable(int irq, int cpunum)\\n{\\n  // Mark interrupt edge-triggered, active high,\\n  // enabled, and routed to the given cpunum,\\n  // which happens to be that cpu's APIC ID.\\n  ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);\\n  ioapicwrite(REG_TABLE+2*irq+1, cpunum &#x3C;&#x3C; 24);\\n}\\n</code></pre>\\n<p>Например, при старте консоль направляет прерывания клавиатуры на процессор 0:</p>\\n<pre><code class=\\\"language-c\\\">void\\nconsoleinit(void)\\n{\\n  ...\\n  ioapicenable(IRQ_KBD, 0);\\n}\\n</code></pre>\\n<p>А прерывания от дисков отправляются на последний процессор:</p>\\n<pre><code class=\\\"language-c\\\">void\\nideinit(void)\\n{\\n  ...\\n  ioapicenable(IRQ_IDE, ncpu - 1);\\n  ...\\n}\\n</code></pre>\\n<p><code>lapic.c</code> инициализирует все свои прерывания сам, в <code>lapicinit</code>. Там же инициализируется и прерывание для таймера, которое потом обрабатывается в <code>trap.c</code>.</p>\\n<h3>Драйвера</h3>\\n<p>Драйвера указывают устройствам, какие операции выполнять и какие прерывания генерировать, когда закончат, а так же реагируют на эти прерывания.</p>\\n<p>Рассмотрим реализацию драйвера диска.</p>\\n<p>Диск хранит данные как последовательность 512-байтных <em>блоков</em>, или <em>секторов</em>. Операционная система использует свои блоки, размер которых обычно кратен размеру сектора. В xv6 блок тоже 512 байт. В памяти блок представлен структурой <code>buf</code>:</p>\\n<pre><code class=\\\"language-c\\\">struct buf {\\n  int flags;            # B_VALID если данные прочитали, B_DIRTY если они изменились и нужно их записать\\n  uint dev;             # номер устройства\\n  uint blockno;         # номер сектора\\n  struct sleeplock lock;\\n  uint refcnt;\\n  struct buf *prev; // LRU cache list\\n  struct buf *next;\\n  struct buf *qnext; // disk queue\\n  uchar data[BSIZE];    # копия данных сектора в памяти\\n};\\n</code></pre>\\n<p>При загрузке ОС инициализирует драйвер диска вызовом <code>ideinit</code> из <code>main</code>:</p>\\n<pre><code class=\\\"language-c\\\">void\\nideinit(void)\\n{\\n  int i;\\n\\n  initlock(&#x26;idelock, \\\"ide\\\");\\n  ioapicenable(IRQ_IDE, ncpu - 1);  # включает прерывание диска\\n  idewait(0);                       # ждет, пока диск будет готов к принятию команд\\n\\n  // Check if disk 1 is present\\n  outb(0x1f6, 0xe0 | (1&#x3C;&#x3C;4));       # проверяет доступен ли еще один диск - диск 1. Для этого пишет в порт 0x1f6, чтобы выбрать этот диск\\n  for(i=0; i&#x3C;1000; i++){            # затем в течение 1000 попыток пытается прочесть статус с порта 0x1f7. Если получается - считаем, что диск есть.\\n    if(inb(0x1f7) != 0){\\n      havedisk1 = 1;\\n      break;\\n    }\\n  }\\n\\n  // Switch back to disk 0.\\n  outb(0x1f6, 0xe0 | (0&#x3C;&#x3C;4));       # выбираем обратно диск 0\\n}\\n</code></pre>\\n<p><code>idewait</code> работает так: материнка выставляет статус диска в I/O порту <code>0x1f7</code>, а <code>idewait</code> в цикле читает этот статус и ждет, пока бит IDE<em>BSY не будет снят, а IDE</em>DRDY не выставлен:</p>\\n<p>(I/O порт - это такая отдельная память в процессоре, через которую он работает с устройствами ввода-вывода)</p>\\n<pre><code class=\\\"language-c\\\">// Wait for IDE disk to become ready.\\nstatic int\\nidewait(int checkerr)\\n{\\n  int r;\\n\\n  while(((r = inb(0x1f7)) &#x26; (IDE_BSY|IDE_DRDY)) != IDE_DRDY)\\n    ;\\n  if(checkerr &#x26;&#x26; (r &#x26; (IDE_DF|IDE_ERR)) != 0)\\n    return -1;\\n  return 0;\\n}\\n</code></pre>\\n<p>После <code>ideinit</code> диск никто не трогает, пока кэш буфера не решит, что пора выполнить <code>iderw</code>, который вызывает <code>idestart</code>, который в зависимости от флагов синхронизирует содержимое буфера с содержимым сектора:</p>\\n<pre><code class=\\\"language-c\\\">// Sync buf with disk.\\n// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.\\n// Else if B_VALID is not set, read buf from disk, set B_VALID.\\nvoid\\niderw(struct buf *b)\\n{\\n  struct buf **pp;\\n\\n  if(!holdingsleep(&#x26;b->lock))\\n    panic(\\\"iderw: buf not locked\\\");\\n  if((b->flags &#x26; (B_VALID|B_DIRTY)) == B_VALID)\\n    panic(\\\"iderw: nothing to do\\\");\\n  if(b->dev != 0 &#x26;&#x26; !havedisk1)\\n    panic(\\\"iderw: ide disk 1 not present\\\");\\n\\n  acquire(&#x26;idelock);  //DOC:acquire-lock\\n\\n  // Append b to idequeue.\\n  b->qnext = 0;\\n  for(pp=&#x26;idequeue; *pp; pp=&#x26;(*pp)->qnext)  // записываем наш буфер в очередь запросов к диску. idequeue указывает на буфер, который сейчас читается или пишется на диск.\\n    ;\\n  *pp = b;\\n\\n  // Start disk if necessary.\\n  if(idequeue == b)                     // если подошла очередь нашего блока, то сразу его обрабатываем. Иначе - ему придется подождать, пока не сработают прерывания завершения операции для всех блоков перед ним.\\n    idestart(b);\\n\\n  // Wait for request to finish.\\n  while((b->flags &#x26; (B_VALID|B_DIRTY)) != B_VALID){\\n    sleep(b, &#x26;idelock);\\n  }\\n\\n\\n  release(&#x26;idelock);\\n}\\n\\n// Start the request for b.  Caller must hold idelock.\\nstatic void\\nidestart(struct buf *b)\\n{\\n  if(b == 0)\\n    panic(\\\"idestart\\\");\\n  if(b->blockno >= FSSIZE)\\n    panic(\\\"incorrect blockno\\\");\\n  int sector_per_block =  BSIZE/SECTOR_SIZE;\\n  int sector = b->blockno * sector_per_block;\\n  int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;\\n  int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;\\n\\n  if (sector_per_block > 7) panic(\\\"idestart\\\");\\n\\n  idewait(0);\\n  outb(0x3f6, 0);  // generate interrupt\\n  outb(0x1f2, sector_per_block);  // number of sectors\\n  outb(0x1f3, sector &#x26; 0xff);\\n  outb(0x1f4, (sector >> 8) &#x26; 0xff);\\n  outb(0x1f5, (sector >> 16) &#x26; 0xff);\\n  outb(0x1f6, 0xe0 | ((b->dev&#x26;1)&#x3C;&#x3C;4) | ((sector>>24)&#x26;0x0f));\\n  if(b->flags &#x26; B_DIRTY){\\n    outb(0x1f7, write_cmd);\\n    outsl(0x1f0, b->data, BSIZE/4);\\n  } else {\\n    outb(0x1f7, read_cmd);\\n  }\\n}\\n</code></pre>\\n<p>Делает он это тоже через порты ввода-вывода. Чтение/запись происходят асинхронно, то есть например при чтении мы даем команду и отправляется делать другие вещи, а обработчик прерываний ловит прерывание конца чтения и записывает в буфер данные. При записи мы сразу пишем данные в порт, а в обработчике прерывания только лишь продвигаем очередь к следующему блоку. Вот как это выглядит:</p>\\n<pre><code class=\\\"language-c\\\">void\\ntrap(struct trapframe *tf)\\n{\\n  ...\\n  case T_IRQ0 + IRQ_IDE:\\n    ideintr();                  # регистрируем вызов нашего обработчика\\n    lapiceoi();\\n    break;\\n  ...  \\n}\\n\\n// Interrupt handler.\\nvoid\\nideintr(void)\\n{\\n  struct buf *b;\\n\\n  // First queued buffer is the active request.\\n  acquire(&#x26;idelock);\\n\\n  if((b = idequeue) == 0){  # читаем текущий буфер в b\\n    release(&#x26;idelock);\\n    return;\\n  }\\n  idequeue = b->qnext;      # продвигаем очередь к следующему буферу\\n\\n  // Read data if needed.\\n  if(!(b->flags &#x26; B_DIRTY) &#x26;&#x26; idewait(1) >= 0)  # если флаг b не выставлен, значит у нас не запись, значит - чтение\\n    insl(0x1f0, b->data, BSIZE/4);              # подаем на ассемблер команду прочесть данные с порта ввода-вывода 0x1f0 в буфер b->data\\n\\n  // Wake process waiting for this buf.\\n  b->flags |= B_VALID;\\n  b->flags &#x26;= ~B_DIRTY;\\n  wakeup(b);\\n\\n  if(idequeue != 0)         # запускаем обработку следующео буфера в очереди\\n    idestart(idequeue);\\n\\n  release(&#x26;idelock);\\n}\\n</code></pre>\\n<p>Некоторые устройства динамически переключаются между получением данных по прерываниям и поллингом, например, если устройство знает, что ей нужно совершить много однотипных операций подряд, то оно может на  переключиться на поллинг. Когда пакет принят - переключается обратно на прерывания.</p>\\n<p>Некоторые драйверы настраивают APIC так, чтобы балансировать нагрузку между процессорами.</p>\\n<p>Когда программа читает файл, данные из него копируются дважды - сначала с диска в ядро через порты ввода-вывода, потом из ядра в программу командой <code>read</code>. Если после этого мы шлем данные по сети, то они копируются еще два раза - в ядро командой <code>write</code> и в сетевое устройство через порты ввода-вывода. Поэтому часто, чтобы избежать этих лишних операций, операционные системы используют специальные функции для избежания копий данных, чтобы данные шли сразу в адресное пространство процесса.</p>\\n<h2>Потоковая синхронизация</h2>\\n<h3>Локи</h3>\\n<p>В xv6 есть 2 типа локов: спин-локи и слип-локи. Начнем со спинлоков.</p>\\n<h4>Спинлоки</h4>\\n<p>Спинлок представлен структурой <code>spinlock</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Mutual exclusion lock.\\nstruct spinlock {\\n  uint locked;       // Is the lock held?\\n\\n  // For debugging:\\n  char *name;        // Name of lock.\\n  struct cpu *cpu;   // The cpu holding the lock.\\n  uint pcs[10];      // The call stack (an array of program counters)\\n                     // that locked the lock.\\n};\\n</code></pre>\\n<p>Чтобы выставить лок, есть специальная инструкция x86: <code>xchg</code>, вот как она используется в нашем коде (x86.h):</p>\\n<pre><code class=\\\"language-c\\\">static inline uint\\nxchg(volatile uint *addr, uint newval)\\n{\\n  uint result;\\n\\n  // The + in \\\"+m\\\" denotes a read-modify-write operand.\\n  asm volatile(\\\"lock; xchgl %0, %1\\\" :\\n               \\\"+m\\\" (*addr), \\\"=a\\\" (result) :\\n               \\\"1\\\" (newval) :\\n               \\\"cc\\\");\\n  return result;\\n}\\n</code></pre>\\n<p>(Кстати, в этом же файле описаны и все остальные используемые инструкции x86)</p>\\n<p><code>xchg</code> позволяет атомарно поменять местами содержимое адреса памяти и значение регистра. То есть если в памяти хранилось 1, а в регистре 2, то после операции в памяти будет 2, а в регистре 1.</p>\\n<p>Функция <code>acquire</code> использует эту инструкцию:</p>\\n<pre><code class=\\\"language-c\\\">// Acquire the lock.\\n// Loops (spins) until the lock is acquired.\\n// Holding a lock for a long time may cause\\n// other CPUs to waste time spinning to acquire it.\\nvoid\\nacquire(struct spinlock *lk)\\n{\\n  pushcli(); // disable interrupts to avoid deadlock.\\n\\n  while(xchg(&#x26;lk->locked, 1) != 0);   # пишем в память 1 и проверяем, что там был 0. если мы записали 1, а там и так был 1, значит лок захвачен другим потоком.\\n\\n  // Tell the C compiler and the processor to not move loads or stores\\n  // past this point, to ensure that the critical section's memory\\n  // references happen after the lock is acquired.\\n  __sync_synchronize();\\n\\n  lk->cpu = mycpu();\\n  getcallerpcs(&#x26;lk, lk->pcs);\\n}\\n</code></pre>\\n<p>После захвата лока <code>acquire</code> еще пишет в лок номер процессора и стек трейс для отладки в случае проблем.</p>\\n<p>Функция <code>release</code> работает ровно наоборот - сначала очищает отладочную информацию, потом пишет в поле <code>locked</code> значение 0:</p>\\n<pre><code class=\\\"language-c\\\">// Release the lock.\\nvoid\\nrelease(struct spinlock *lk)\\n{\\n  ...\\n  lk->pcs[0] = 0;\\n  lk->cpu = 0;\\n\\n  // Tell the C compiler and the processor to not move loads or stores\\n  // past this point, to ensure that all the stores in the critical\\n  // section are visible to other cores before the lock is released.\\n  // Both the C compiler and the hardware may re-order loads and\\n  // stores; __sync_synchronize() tells them both not to.\\n  __sync_synchronize();\\n\\n  // Release the lock, equivalent to lk->locked = 0.\\n  // This code can't use a C assignment, since it might\\n  // not be atomic. A real OS would use C atomics here.\\n  asm volatile(\\\"movl $0, %0\\\" : \\\"+m\\\" (lk->locked) : );\\n  \\n  popcli();\\n}\\n</code></pre>\\n<h4>Слиплоки</h4>\\n<p>Проблема спин-локов в том, что они отключают прерывания, а значит между <code>acquire</code> и <code>release</code> не может произойти <code>context switch</code>. То есть если у нас какой-то долгий лок, то остальные потоки будут его ждать. Слип-локи допускают переключение контекста в критической секции.</p>\\n<p><strong>ПРИМЕЧАНИЕ</strong>: Те спинлоки, которые в дотнете - реализованы в юзерспейсе, поэтому там вполне может быть переключение потока между захватом и освобождением лока. А вот в ядре линукса - не может.</p>\\n<p>Слиплок описан следующей структурой:</p>\\n<pre><code class=\\\"language-c\\\">// Long-term locks for processes\\nstruct sleeplock {\\n  uint locked;       // Is the lock held?\\n  struct spinlock lk; // spinlock protecting this sleep lock\\n  \\n  // For debugging:\\n  char *name;        // Name of lock.\\n  int pid;           // Process holding lock\\n};\\n</code></pre>\\n<p>Реализация слиплока описана в <code>sleeplock.c</code>. Вот методы захвата и освобождения:</p>\\n<pre><code class=\\\"language-c\\\">void\\nacquiresleep(struct sleeplock *lk)\\n{\\n  acquire(&#x26;lk->lk);\\n  while (lk->locked) {\\n    sleep(lk, &#x26;lk->lk);\\n  }\\n  lk->locked = 1;\\n  lk->pid = myproc()->pid;\\n  release(&#x26;lk->lk);\\n}\\n\\nvoid\\nreleasesleep(struct sleeplock *lk)\\n{\\n  acquire(&#x26;lk->lk);\\n  lk->locked = 0;\\n  lk->pid = 0;\\n  wakeup(lk);\\n  release(&#x26;lk->lk);\\n}\\n</code></pre>\\n<p><code>acquiresleep</code> ожидает, пока освободится <code>lk->locked</code> и выставляет его в 1. <code>releasesleep</code> сразу выставляет <code>lk->locked</code> в 0. </p>\\n<p>Непонятно, как работает ситуация, когда <code>acquiresleep</code> взял спинлок, крутится в <code>while</code>, а освободить <code>lk->locked</code> некому, так как <code>releasesleep</code> не может захватить этот же спинлок. Дело в том, что при <code>sleep</code> функция <code>acquiresleep</code> отпускает спинлок и дает возможность поработать другим функциям.</p>\\n<p>Вот как реализован <code>sleep</code>:</p>\\n<pre><code class=\\\"language-c\\\">sleep(void *chan, struct spinlock *lk)\\n{\\n  struct proc *p = myproc();\\n  \\n  if(p == 0)\\n    panic(\\\"sleep\\\");\\n\\n  if(lk == 0)\\n    panic(\\\"sleep without lk\\\");\\n\\n  // Must acquire ptable.lock in order to\\n  // change p->state and then call sched.\\n  // Once we hold ptable.lock, we can be\\n  // guaranteed that we won't miss any wakeup\\n  // (wakeup runs with ptable.lock locked),\\n  // so it's okay to release lk.\\n  if(lk != &#x26;ptable.lock){  //DOC: sleeplock0\\n    acquire(&#x26;ptable.lock);  //DOC: sleeplock1\\n    release(lk);\\n  }\\n  // Go to sleep.\\n  p->chan = chan;\\n  p->state = SLEEPING;\\n\\n  sched();\\n\\n  // Tidy up.\\n  p->chan = 0;\\n\\n  // Reacquire original lock.\\n  if(lk != &#x26;ptable.lock){  //DOC: sleeplock2\\n    release(&#x26;ptable.lock);\\n    acquire(lk);\\n  }\\n}\\n</code></pre>\\n<p>Она сначала делает <code>release(lk)</code>, потом <code>sched()</code>, отдавая управление другим потокам, а когда получит управление обратно, делает <code>acquire(lk)</code>, захватывая спинлок обратно. Таким образом, если другой поток захватит этот лок, то наш поток какое-то время не сможет вернуться из слипа.</p>\\n<h2>Файловая система</h2>\\n<p>Состоит из 7 слоев, каждый из которых исплоьзует результаты работы нижележащего:</p>\\n<ul>\\n<li>слой дескрипторов файлов - абстрагирует многие ресурсы Unix, используя интерфейс файловой системы</li>\\n<li>слой путей - предоставляет иерархические пути к файлам и возможность получения файла по пути путем рекурсивного поиска</li>\\n<li>слой директорий - предоставляет директории, каждая из которых является специальным видом ай-ноды, в которой хранится последовательность детей директории, для каждого из которых записано имя файла и i-номер</li>\\n<li>слой айнодов - предоставляет индивидуальные файлы, каждый из которых представлен как <em>inode</em> с уникальным i-номером и несколькими секторами, в которых содержится содержимое файла</li>\\n<li>слой логирования - заворачивает операции доступа от высших слоев в транзакции и обеспечивает атомарность изменений секторов</li>\\n<li>слой буферного кэша - кэширует сектора в памяти и синхронизирует доступ к ним</li>\\n<li>слой диска - читает и пишет сектора на диск через драйвер IDE</li>\\n</ul>\\n<h3>Слой буферного кэша</h3>\\n<p>Описан в файле <code>bio.c</code>. Основные функции:</p>\\n<ul>\\n<li><code>bread</code> - получает <code>buf</code>, содержащий копию данных сектора</li>\\n<li><code>brwite</code> - записывает модифицированный буффер в соответствующий ему сектор на диске.</li>\\n</ul>\\n<p>Сам кэш описывается следующей структурой:</p>\\n<pre><code class=\\\"language-c\\\">struct {\\n  struct spinlock lock;\\n  struct buf buf[NBUF];  // связанный список секторов в кэше, каждый ссылается на соседние через prev/next\\n  \\n  struct buf head;\\n} bcache;\\n</code></pre>\\n<p>Он содержит фиксированное количество объектов структуры <code>buf</code>, каждая из которых содержит данные 1 сектора.</p>\\n<p>Рассмотрим функции <code>bread</code> и <code>bwrite</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Write b's contents to disk.  Must be locked.\\nvoid\\nbwrite(struct buf *b)\\n{\\n  if(!holdingsleep(&#x26;b->lock))\\n    panic(\\\"bwrite\\\");\\n  b->flags |= B_DIRTY;\\n  iderw(b);\\n}\\n\\n// Return a locked buf with the contents of the indicated block.\\nstruct buf*\\nbread(uint dev, uint blockno)\\n{\\n  struct buf *b;\\n\\n  b = bget(dev, blockno);\\n  if((b->flags &#x26; B_VALID) == 0) { // данные неактуальны\\n    iderw(b);                     // нужно перечитать с диска\\n  }\\n  return b;\\n}\\n\\n// Look through buffer cache for block on device dev.\\n// If not found, allocate a buffer.\\n// In either case, return locked buffer.\\nstatic struct buf*\\nbget(uint dev, uint blockno)\\n{\\n  struct buf *b;\\n\\n  acquire(&#x26;bcache.lock);\\n\\n  for(b = bcache.head.next; b != &#x26;bcache.head; b = b->next){  // проходим по закэшированным буфам\\n    if(b->dev == dev &#x26;&#x26; b->blockno == blockno){   // проверяем, искомый ли это буф\\n      b->refcnt++;            // если да, то инкрементируем счетчик ссылок и возвращаем сектор\\n      release(&#x26;bcache.lock);\\n      acquiresleep(&#x26;b->lock);\\n      return b;\\n    }\\n  }\\n\\n  // Если мы оказались здесь, значит в памяти искомого сектора нет\\n  // Нужно убрать из кэша один сектора и положить на его место прочитанный с диска\\n  // Убирать из кэша можно только сектор, который никем не используется и не содержт незаписанных на диск изменений. \\n  // То есть у него должно быть refcnt == 0 и не стоять флаг B_DIRTY.\\n  for(b = bcache.head.prev; b != &#x26;bcache.head; b = b->prev){ // кэш закольцован, поэтому через head.prev мы можем обратиться к последнему элементу, это будет least recently used элемент\\n    if(b->refcnt == 0 &#x26;&#x26; (b->flags &#x26; B_DIRTY) == 0) {\\n      b->dev = dev;           // когда нашли неиспользуемый сектор в кэше, то просто перезаписываем его поля\\n      b->blockno = blockno;\\n      b->flags = 0;           // это сбросить флаг B_VALID, чтобы bread узнал, что в секторе неактуальные данные и прочитал их туда с диска\\n      b->refcnt = 1;\\n      release(&#x26;bcache.lock);\\n      acquiresleep(&#x26;b->lock);\\n      return b;\\n    }\\n  }\\n  panic(\\\"bget: no buffers\\\");\\n}\\n</code></pre>\\n<p>После окончания работы с сектором, его нужно отпустить функцией <code>brelse</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Release a locked buffer.\\n// Move to the head of the MRU list.\\nvoid\\nbrelse(struct buf *b)\\n{\\n  if(!holdingsleep(&#x26;b->lock))\\n    panic(\\\"brelse\\\");\\n\\n  releasesleep(&#x26;b->lock);\\n\\n  acquire(&#x26;bcache.lock);\\n  b->refcnt--;\\n  if (b->refcnt == 0) {\\n    // no one is waiting for it.\\n    b->next->prev = b->prev;\\n    b->prev->next = b->next;\\n    b->next = bcache.head.next;\\n    b->prev = &#x26;bcache.head;\\n    bcache.head.next->prev = b;\\n    bcache.head.next = b;\\n  }\\n  \\n  release(&#x26;bcache.lock);\\n}\\n</code></pre>\\n<h3>Слой логирования</h3>\\n<p>Перед каждой операцией записи ее описание пишется в <em>лог</em> на диске. После этого на диск пишется <em>commit record</em>, означающая, что лог завершен. После осуществления записи на диск, лог и его <em>commit record</em> уничтожается.</p>\\n<p>После перезагрузки на старте системы, если на диске есть <em>commit record</em>, то пишем данные из соответствующего лога на диск. Если лог есть, а коммит рекорда нет - значит, операция записи еще не началась, можем проигнорировать лог. В любом случае лог в конце восстановления удаляется.</p>\\n<p>Лог состоит из блока заголовка и последовательности копий обновленных секторов (т.н. залогированные сектора). Блок заголовка содержит массив номеров секторов и количество залогированных секторов. Если это количество равно 0, то транзакций в логе нет, а если больше 0, то значит лог содержит закоммиченную транзакцию с указанным количеством блоков. Блог заголовка записывается при коммите и зануляется после записи на диск.</p>\\n<p>Использование лога в системном вызове выглядит так:</p>\\n<pre><code class=\\\"language-c\\\">begin_op();\\n...\\nbp = bread(...);\\nbp->data[...] = ...;\\nlog_write(bp);\\n...\\nend_op();\\n</code></pre>\\n<p><code>begin_op</code> ожидает, пока система логирования освободится и пока в логе появится достаточное количество места, после чего инкрементирует <code>log.outstanding</code>, которое означает количество одновременных системных вызовов к файловой системе, которые зарезервировали место в нашем логе. Общее зарезервированное пространство в логе = <code>log.outstanding * MAXOPBLOCKS</code>.</p>\\n<p><code>log_write</code> - это прокси над <code>bwrite</code>, которое пишет номер сектора в память, резервирует слот в логе на диске, и помечает буфер флагом <code>B_DIRTY</code>, чтобы слой кэша его не удалил.</p>\\n<p><code>end_op</code> уменьшает <code>log.outstanding</code>, если оно стало 0, значит больше никто в наш лог не пишет, можем вызывать <code>commit()</code>.</p>\\n<p>Коммит состоит из 4 этапов:</p>\\n<ol>\\n<li><code>write_log()</code> - копирует каждый сектор, модифицированный в кэше в соответствующий ему слот лога на диске</li>\\n<li><code>write_head()</code> - пишет блог заголовка лога на диск</li>\\n<li><code>install_trans()</code> - читает каждый блок из лога и пишет его на диск</li>\\n<li><code>end_op</code> пишет заголовок сектора еще раз, но уже выставив ему количество блоков в 0.</li>\\n</ol>\\n<p>Логирование описано в файле <code>log.c</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Contents of the header block, used for both the on-disk header block\\n// and to keep track in memory of logged block# before commit.\\nstruct logheader {\\n  int n;\\n  int block[LOGSIZE];\\n};\\n\\nstruct log {\\n  struct spinlock lock;\\n  int start;\\n  int size;\\n  int outstanding; // how many FS sys calls are executing.\\n  int committing;  // in commit(), please wait.\\n  int dev;\\n  struct logheader lh;\\n};\\nstruct log log;\\n\\n// called at the start of each FS system call.\\nvoid\\nbegin_op(void)\\n{\\n  acquire(&#x26;log.lock);\\n  while(1){\\n    if(log.committing){\\n      sleep(&#x26;log, &#x26;log.lock);\\n    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){\\n      // this op might exhaust log space; wait for commit.\\n      sleep(&#x26;log, &#x26;log.lock);\\n    } else {\\n      log.outstanding += 1;\\n      release(&#x26;log.lock);\\n      break;\\n    }\\n  }\\n}\\n\\n// Caller has modified b->data and is done with the buffer.\\n// Record the block number and pin in the cache with B_DIRTY.\\n// commit()/write_log() will do the disk write.\\n//\\n// log_write() replaces bwrite(); a typical use is:\\n//   bp = bread(...)\\n//   modify bp->data[]\\n//   log_write(bp)\\n//   brelse(bp)\\nvoid\\nlog_write(struct buf *b)\\n{\\n  int i;\\n\\n  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)\\n    panic(\\\"too big a transaction\\\");\\n  if (log.outstanding &#x3C; 1)\\n    panic(\\\"log_write outside of trans\\\");\\n\\n  acquire(&#x26;log.lock);\\n  for (i = 0; i &#x3C; log.lh.n; i++) {\\n    if (log.lh.block[i] == b->blockno)   // log absorbtion\\n      break;\\n  }\\n  log.lh.block[i] = b->blockno;\\n  if (i == log.lh.n)\\n    log.lh.n++;\\n  b->flags |= B_DIRTY; // prevent eviction\\n  release(&#x26;log.lock);\\n}\\n\\nstatic void\\ncommit()\\n{\\n  if (log.lh.n > 0) {\\n    write_log();     // Write modified blocks from cache to log\\n    write_head();    // Write header to disk -- the real commit\\n    install_trans(); // Now install writes to home locations\\n    log.lh.n = 0;\\n    write_head();    // Erase the transaction from the log\\n  }\\n}\\n\\n\\n// called at the end of each FS system call.\\n// commits if this was the last outstanding operation.\\nvoid\\nend_op(void)\\n{\\n  int do_commit = 0;\\n\\n  acquire(&#x26;log.lock);\\n  log.outstanding -= 1;\\n  if(log.committing)\\n    panic(\\\"log.committing\\\");\\n  if(log.outstanding == 0){\\n    do_commit = 1;\\n    log.committing = 1;\\n  } else {\\n    // begin_op() may be waiting for log space,\\n    // and decrementing log.outstanding has decreased\\n    // the amount of reserved space.\\n    wakeup(&#x26;log);\\n  }\\n  release(&#x26;log.lock);\\n\\n  if(do_commit){\\n    // call commit w/o holding locks, since not allowed\\n    // to sleep with locks.\\n    commit();\\n    acquire(&#x26;log.lock);\\n    log.committing = 0;\\n    wakeup(&#x26;log);\\n    release(&#x26;log.lock);\\n  }\\n}\\n</code></pre>\\n<p>Восстановление из лога осуществляется в <code>recover_from_log</code>, который вызывается в <code>initlog</code>:</p>\\n<pre><code class=\\\"language-c\\\">static void\\nrecover_from_log(void)\\n{\\n  read_head();\\n  install_trans(); // if committed, copy from log to disk\\n  log.lh.n = 0;\\n  write_head(); // clear the log\\n}\\n</code></pre>\\n<p>Процедура читает заголовок и повторяет действия коммита.</p>\\n<p>Реальный пример использования из процедуры <code>filewrite</code>:</p>\\n<pre><code class=\\\"language-c\\\">begin_op();\\nilock(f->ip);\\nif ((r = writei(f->ip, addr + i, f->off, n1)) > 0)\\n  f->off += r;\\niunlock(f->ip);\\nend_op();\\n</code></pre>\\n<p><code>log_write</code> вызывается внутри <code>writei</code>. Чтобы не превысить размер лога транзакции, кусок кода из примера вызывается в цикле, каждый раз сохраняя в транзакции по несколько блоков.</p>\\n<h4>Аллокатор блоков</h4>\\n<p>Файлы и папки хранятся в дисковых блоках, которые тоже должны аллоцироваться и свобождаться. Для этого есть <em>аллокатор блоков</em>, вызываемый функциями <code>balloc</code> и <code>bfree</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Allocate a zeroed disk block.\\nstatic uint\\nballoc(uint dev)\\n{\\n  int b, bi, m;\\n  struct buf *bp;\\n\\n  bp = 0;\\n  for(b = 0; b &#x3C; sb.size; b += BPB){\\n    bp = bread(dev, BBLOCK(b, sb));\\n    for(bi = 0; bi &#x3C; BPB &#x26;&#x26; b + bi &#x3C; sb.size; bi++){\\n      m = 1 &#x3C;&#x3C; (bi % 8);\\n      if((bp->data[bi/8] &#x26; m) == 0){  // Is block free?\\n        bp->data[bi/8] |= m;  // Mark block in use.\\n        log_write(bp);\\n        brelse(bp);\\n        bzero(dev, b + bi);\\n        return b + bi;\\n      }\\n    }\\n    brelse(bp);\\n  }\\n  panic(\\\"balloc: out of blocks\\\");\\n}\\n\\n// Free a disk block.\\nstatic void\\nbfree(int dev, uint b)\\n{\\n  struct buf *bp;\\n  int bi, m;\\n\\n  readsb(dev, &#x26;sb);\\n  bp = bread(dev, BBLOCK(b, sb));\\n  bi = b % BPB;\\n  m = 1 &#x3C;&#x3C; (bi % 8);\\n  if((bp->data[bi/8] &#x26; m) == 0)\\n    panic(\\\"freeing free block\\\");\\n  bp->data[bi/8] &#x26;= ~m;\\n  log_write(bp);\\n  brelse(bp);\\n}\\n</code></pre>\\n<h3>Слой айнодов</h3>\\n<p><code>inode</code> бывают двух типов:</p>\\n<ul>\\n<li>хранящиеся на диске - содержат размер файла и список номеров его секторов данных</li>\\n<li>хранящиеся в памяти - содержат копию дискового айнода и дополнительную информацию, необходимую ядру</li>\\n</ul>\\n<p>Дисковые айноды лежат последовательно в области диска, называемой \\\"блоки айнодов\\\". Каждый айнод имеет фиксированный размер, поэтому их легко находить по номеру, такие номера называются ай-номеры.</p>\\n<p>Дисковые айноды описываются структурой <code>dinode</code>:</p>\\n<pre><code class=\\\"language-c\\\">// On-disk inode structure\\nstruct dinode {\\n  short type;           // Тип айнода: файл, директория, \\\"специальный\\\" файл (девайс). 0 означает, что айнод свободен.\\n  short major;          // Major device number (T_DEV only)\\n  short minor;          // Minor device number (T_DEV only)\\n  short nlink;          // Количество ссылок на этот айнод из директорий. Когда достигает нуля, айнод можно удалять.\\n  uint size;            // Размер, т.е. количество байт в содержимом файла\\n  uint addrs[NDIRECT+1];   // Номера секторов данных на диске, в которых записано содержимое файла\\n};\\n</code></pre>\\n<p>Копии активных дисковых айнодов содержатся в памяти ядра в структурах <code>inode</code>:</p>\\n<pre><code class=\\\"language-c\\\">// in-memory copy of an inode\\nstruct inode {\\n  uint dev;           // Device number\\n  uint inum;          // Inode number\\n  int ref;            // Количество C-указателей на этот айнод, когда достигает нуля - удаляем из памяти.\\n  struct sleeplock lock; // protects everything below here\\n  int valid;          // inode has been read from disk?\\n\\n  short type;         // copy of disk inode\\n  short major;\\n  short minor;\\n  short nlink;\\n  uint size;\\n  uint addrs[NDIRECT+1];\\n};\\n</code></pre>\\n<p>Копия айнода в памяти содержится только если есть указатели, ссылающиеся на этот айнод.</p>\\n<p>Чтобы аллоцировать новый айнод (например, при создании файла), вызывается <code>ialloc</code>:</p>\\n<pre><code class=\\\"language-c\\\">// Allocate an inode on device dev.\\n// Mark it as allocated by  giving it type type.\\n// Returns an unlocked but allocated and referenced inode.\\nstruct inode*\\nialloc(uint dev, short type)\\n{\\n  int inum;\\n  struct buf *bp;\\n  struct dinode *dip;\\n\\n  for(inum = 1; inum &#x3C; sb.ninodes; inum++){\\n    bp = bread(dev, IBLOCK(inum, sb));\\n    dip = (struct dinode*)bp->data + inum%IPB;\\n    if(dip->type == 0){  // a free inode\\n      memset(dip, 0, sizeof(*dip));\\n      dip->type = type;\\n      log_write(bp);   // mark it allocated on the disk\\n      brelse(bp);\\n      return iget(dev, inum);\\n    }\\n    brelse(bp);\\n  }\\n  panic(\\\"ialloc: no inodes\\\");\\n}\\n</code></pre>\\n<p><code>ialloc</code> проходит по всем айнодам на диске, ища пустой. Когда находит, помечает его как аллоцированный и возвращает его копию из памяти через <code>iget</code>.</p>\\n<pre><code class=\\\"language-c\\\">// Find the inode with number inum on device dev\\n// and return the in-memory copy. Does not lock\\n// the inode and does not read it from disk.\\nstatic struct inode*\\niget(uint dev, uint inum)\\n{\\n  struct inode *ip, *empty;\\n\\n  acquire(&#x26;icache.lock);\\n\\n  // Is the inode already cached?\\n  empty = 0;\\n  for(ip = &#x26;icache.inode[0]; ip &#x3C; &#x26;icache.inode[NINODE]; ip++){\\n    if(ip->ref > 0 &#x26;&#x26; ip->dev == dev &#x26;&#x26; ip->inum == inum){\\n      ip->ref++;\\n      release(&#x26;icache.lock);\\n      return ip;\\n    }\\n    if(empty == 0 &#x26;&#x26; ip->ref == 0)    // Remember empty slot.\\n      empty = ip;\\n  }\\n\\n  // Recycle an inode cache entry.\\n  if(empty == 0)\\n    panic(\\\"iget: no inodes\\\");\\n\\n  ip = empty;\\n  ip->dev = dev;\\n  ip->inum = inum;\\n  ip->ref = 1;\\n  ip->valid = 0;\\n  release(&#x26;icache.lock);\\n\\n  return ip;\\n}\\n</code></pre>\\n<p>Прежде чем читать или писать в айнод, код должен его сначала залочить:</p>\\n<pre><code class=\\\"language-c\\\">// Lock the given inode.\\n// Reads the inode from disk if necessary.\\nvoid\\nilock(struct inode *ip)\\n{\\n  struct buf *bp;\\n  struct dinode *dip;\\n\\n  if(ip == 0 || ip->ref &#x3C; 1)\\n    panic(\\\"ilock\\\");\\n\\n  acquiresleep(&#x26;ip->lock);\\n\\n  if(ip->valid == 0){\\n    bp = bread(ip->dev, IBLOCK(ip->inum, sb));\\n    dip = (struct dinode*)bp->data + ip->inum%IPB;\\n    ip->type = dip->type;\\n    ip->major = dip->major;\\n    ip->minor = dip->minor;\\n    ip->nlink = dip->nlink;\\n    ip->size = dip->size;\\n    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));\\n    brelse(bp);\\n    ip->valid = 1;\\n    if(ip->type == 0)\\n      panic(\\\"ilock: no type\\\");\\n  }\\n}\\n\\n// Unlock the given inode.\\nvoid\\niunlock(struct inode *ip)\\n{\\n  if(ip == 0 || !holdingsleep(&#x26;ip->lock) || ip->ref &#x3C; 1)\\n    panic(\\\"iunlock\\\");\\n\\n  releasesleep(&#x26;ip->lock);\\n}\\n</code></pre>\\n<h4>Содержимое айнодов</h4>\\n<pre><code class=\\\"language-c\\\">// Copy stat information from inode.\\n// Caller must hold ip->lock.\\nvoid\\nstati(struct inode *ip, struct stat *st)\\n{\\n  st->dev = ip->dev;\\n  st->ino = ip->inum;\\n  st->type = ip->type;\\n  st->nlink = ip->nlink;\\n  st->size = ip->size;\\n}\\n\\n//PAGEBREAK!\\n// Read data from inode.\\n// Caller must hold ip->lock.\\nint\\nreadi(struct inode *ip, char *dst, uint off, uint n)\\n{\\n  uint tot, m;\\n  struct buf *bp;\\n\\n  if(ip->type == T_DEV){\\n    if(ip->major &#x3C; 0 || ip->major >= NDEV || !devsw[ip->major].read)\\n      return -1;\\n    return devsw[ip->major].read(ip, dst, n);\\n  }\\n\\n  if(off > ip->size || off + n &#x3C; off)\\n    return -1;\\n  if(off + n > ip->size)\\n    n = ip->size - off;\\n\\n  for(tot=0; tot&#x3C;n; tot+=m, off+=m, dst+=m){\\n    bp = bread(ip->dev, bmap(ip, off/BSIZE));\\n    m = min(n - tot, BSIZE - off%BSIZE);\\n    memmove(dst, bp->data + off%BSIZE, m);\\n    brelse(bp);\\n  }\\n  return n;\\n}\\n\\n// PAGEBREAK!\\n// Write data to inode.\\n// Caller must hold ip->lock.\\nint\\nwritei(struct inode *ip, char *src, uint off, uint n)\\n{\\n  uint tot, m;\\n  struct buf *bp;\\n\\n  if(ip->type == T_DEV){\\n    if(ip->major &#x3C; 0 || ip->major >= NDEV || !devsw[ip->major].write)\\n      return -1;\\n    return devsw[ip->major].write(ip, src, n);\\n  }\\n\\n  if(off > ip->size || off + n &#x3C; off)\\n    return -1;\\n  if(off + n > MAXFILE*BSIZE)\\n    return -1;\\n\\n  for(tot=0; tot&#x3C;n; tot+=m, off+=m, src+=m){\\n    bp = bread(ip->dev, bmap(ip, off/BSIZE));\\n    m = min(n - tot, BSIZE - off%BSIZE);\\n    memmove(bp->data + off%BSIZE, src, m);\\n    log_write(bp);\\n    brelse(bp);\\n  }\\n\\n  if(n > 0 &#x26;&#x26; off > ip->size){\\n    ip->size = off;\\n    iupdate(ip);\\n  }\\n  return n;\\n}\\n</code></pre>\\n<h3>Слой директорий</h3>\\n<pre><code class=\\\"language-c\\\">// Look for a directory entry in a directory.\\n// If found, set *poff to byte offset of entry.\\nstruct inode*\\ndirlookup(struct inode *dp, char *name, uint *poff)\\n{\\n  uint off, inum;\\n  struct dirent de;\\n\\n  if(dp->type != T_DIR)\\n    panic(\\\"dirlookup not DIR\\\");\\n\\n  for(off = 0; off &#x3C; dp->size; off += sizeof(de)){\\n    if(readi(dp, (char*)&#x26;de, off, sizeof(de)) != sizeof(de))\\n      panic(\\\"dirlookup read\\\");\\n    if(de.inum == 0)\\n      continue;\\n    if(namecmp(name, de.name) == 0){\\n      // entry matches path element\\n      if(poff)\\n        *poff = off;\\n      inum = de.inum;\\n      return iget(dp->dev, inum);\\n    }\\n  }\\n\\n  return 0;\\n}\\n\\n// Write a new directory entry (name, inum) into the directory dp.\\nint\\ndirlink(struct inode *dp, char *name, uint inum)\\n{\\n  int off;\\n  struct dirent de;\\n  struct inode *ip;\\n\\n  // Check that name is not present.\\n  if((ip = dirlookup(dp, name, 0)) != 0){\\n    iput(ip);\\n    return -1;\\n  }\\n\\n  // Look for an empty dirent.\\n  for(off = 0; off &#x3C; dp->size; off += sizeof(de)){\\n    if(readi(dp, (char*)&#x26;de, off, sizeof(de)) != sizeof(de))\\n      panic(\\\"dirlink read\\\");\\n    if(de.inum == 0)\\n      break;\\n  }\\n\\n  strncpy(de.name, name, DIRSIZ);\\n  de.inum = inum;\\n  if(writei(dp, (char*)&#x26;de, off, sizeof(de)) != sizeof(de))\\n    panic(\\\"dirlink\\\");\\n\\n  return 0;\\n}\\n</code></pre>\\n<h3>Слой путей</h3>\\n<pre><code class=\\\"language-c\\\">// Copy the next path element from path into name.\\n// Return a pointer to the element following the copied one.\\n// The returned path has no leading slashes,\\n// so the caller can check *path=='\\\\0' to see if the name is the last one.\\n// If no name to remove, return 0.\\n//\\n// Examples:\\n//   skipelem(\\\"a/bb/c\\\", name) = \\\"bb/c\\\", setting name = \\\"a\\\"\\n//   skipelem(\\\"///a//bb\\\", name) = \\\"bb\\\", setting name = \\\"a\\\"\\n//   skipelem(\\\"a\\\", name) = \\\"\\\", setting name = \\\"a\\\"\\n//   skipelem(\\\"\\\", name) = skipelem(\\\"////\\\", name) = 0\\n//\\nstatic char*\\nskipelem(char *path, char *name)\\n{\\n  char *s;\\n  int len;\\n\\n  while(*path == '/')\\n    path++;\\n  if(*path == 0)\\n    return 0;\\n  s = path;\\n  while(*path != '/' &#x26;&#x26; *path != 0)\\n    path++;\\n  len = path - s;\\n  if(len >= DIRSIZ)\\n    memmove(name, s, DIRSIZ);\\n  else {\\n    memmove(name, s, len);\\n    name[len] = 0;\\n  }\\n  while(*path == '/')\\n    path++;\\n  return path;\\n}\\n\\n// Look up and return the inode for a path name.\\n// If parent != 0, return the inode for the parent and copy the final\\n// path element into name, which must have room for DIRSIZ bytes.\\n// Must be called inside a transaction since it calls iput().\\nstatic struct inode*\\nnamex(char *path, int nameiparent, char *name)\\n{\\n  struct inode *ip, *next;\\n\\n  if(*path == '/')\\n    ip = iget(ROOTDEV, ROOTINO);\\n  else\\n    ip = idup(myproc()->cwd);\\n\\n  while((path = skipelem(path, name)) != 0){\\n    ilock(ip);\\n    if(ip->type != T_DIR){\\n      iunlockput(ip);\\n      return 0;\\n    }\\n    if(nameiparent &#x26;&#x26; *path == '\\\\0'){\\n      // Stop one level early.\\n      iunlock(ip);\\n      return ip;\\n    }\\n    if((next = dirlookup(ip, name, 0)) == 0){\\n      iunlockput(ip);\\n      return 0;\\n    }\\n    iunlockput(ip);\\n    ip = next;\\n  }\\n  if(nameiparent){\\n    iput(ip);\\n    return 0;\\n  }\\n  return ip;\\n}\\n\\nstruct inode*\\nnamei(char *path)\\n{\\n  char name[DIRSIZ];\\n  return namex(path, 0, name);\\n}\\n\\nstruct inode*\\nnameiparent(char *path, char *name)\\n{\\n  return namex(path, 1, name);\\n}\\n</code></pre>\\n<h3>Слой дескрипторов файлов</h3>\\n<pre><code class=\\\"language-c\\\">// Allocate a file structure.\\nstruct file*\\nfilealloc(void)\\n{\\n  struct file *f;\\n\\n  acquire(&#x26;ftable.lock);\\n  for(f = ftable.file; f &#x3C; ftable.file + NFILE; f++){\\n    if(f->ref == 0){\\n      f->ref = 1;\\n      release(&#x26;ftable.lock);\\n      return f;\\n    }\\n  }\\n  release(&#x26;ftable.lock);\\n  return 0;\\n}\\n\\n// Close file f.  (Decrement ref count, close when reaches 0.)\\nvoid\\nfileclose(struct file *f)\\n{\\n  struct file ff;\\n\\n  acquire(&#x26;ftable.lock);\\n  if(f->ref &#x3C; 1)\\n    panic(\\\"fileclose\\\");\\n  if(--f->ref > 0){\\n    release(&#x26;ftable.lock);\\n    return;\\n  }\\n  ff = *f;\\n  f->ref = 0;\\n  f->type = FD_NONE;\\n  release(&#x26;ftable.lock);\\n\\n  if(ff.type == FD_PIPE)\\n    pipeclose(ff.pipe, ff.writable);\\n  else if(ff.type == FD_INODE){\\n    begin_op();\\n    iput(ff.ip);\\n    end_op();\\n  }\\n}\\n\\n// Read from file f.\\nint\\nfileread(struct file *f, char *addr, int n)\\n{\\n  int r;\\n\\n  if(f->readable == 0)\\n    return -1;\\n  if(f->type == FD_PIPE)\\n    return piperead(f->pipe, addr, n);\\n  if(f->type == FD_INODE){\\n    ilock(f->ip);\\n    if((r = readi(f->ip, addr, f->off, n)) > 0)\\n      f->off += r;\\n    iunlock(f->ip);\\n    return r;\\n  }\\n  panic(\\\"fileread\\\");\\n}\\n\\n//PAGEBREAK!\\n// Write to file f.\\nint\\nfilewrite(struct file *f, char *addr, int n)\\n{\\n  int r;\\n\\n  if(f->writable == 0)\\n    return -1;\\n  if(f->type == FD_PIPE)\\n    return pipewrite(f->pipe, addr, n);\\n  if(f->type == FD_INODE){\\n    // write a few blocks at a time to avoid exceeding\\n    // the maximum log transaction size, including\\n    // i-node, indirect block, allocation blocks,\\n    // and 2 blocks of slop for non-aligned writes.\\n    // this really belongs lower down, since writei()\\n    // might be writing a device like the console.\\n    int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;\\n    int i = 0;\\n    while(i &#x3C; n){\\n      int n1 = n - i;\\n      if(n1 > max)\\n        n1 = max;\\n\\n      begin_op();\\n      ilock(f->ip);\\n      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)\\n        f->off += r;\\n      iunlock(f->ip);\\n      end_op();\\n\\n      if(r &#x3C; 0)\\n        break;\\n      if(r != n1)\\n        panic(\\\"short filewrite\\\");\\n      i += r;\\n    }\\n    return i == n ? n : -1;\\n  }\\n  panic(\\\"filewrite\\\");\\n}\\n</code></pre>\",\"frontmatter\":{\"path\":\"/blog/books/xv6\",\"title\":\"xv6\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/blog-books-xv-6.json\n// module id = 415\n// module chunks = 160831456888542"],"sourceRoot":""}