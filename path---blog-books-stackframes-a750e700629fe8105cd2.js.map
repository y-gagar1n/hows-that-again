{"version":3,"sources":["webpack:///path---blog-books-stackframes-a750e700629fe8105cd2.js","webpack:///./.cache/json/blog-books-stackframes.json"],"names":["webpackJsonp","423","module","exports","data","markdownRemark","html","frontmatter","path","title","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,y1HAAoXC,aAAuhHC,KAAA,0BAAAC,MAAA,kBAA0DC","file":"path---blog-books-stackframes-a750e700629fe8105cd2.js","sourcesContent":["webpackJsonp([65468590155737],{\n\n/***/ 423:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>Stack Frames</h1>\\n<h2>Executables and Libraries</h2>\\n<p>Пусть у нас есть 2 файла.</p>\\n<pre><code class=\\\"language-c\\\">//p1.c\\n\\nint g1 = 1;\\nextern int g2;\\nint f(void);\\nint main(void) { int v1=0x11; return f()+v1+g1+g2; }\\n</code></pre>\\n<pre><code class=\\\"language-c\\\">//p2.c\\n\\nextern int g1; \\nint g2 = 2;\\nint f(void) { int v2=0x22; return v2+g1+g2; }\\n</code></pre>\\n<p>Скомпилируем их:</p>\\n<pre><code class=\\\"language-sh\\\">gcc -c p1.c p2.c\\n</code></pre>\\n<p>Получаем файлы <strong>p1.o</strong> и <strong>p2.o</strong>. Посмотрим их таблицу символов:</p>\\n<pre><code class=\\\"language-sh\\\">$ nm p1.o\\n                 U _f       # U = undefined, так как f не определена в p1.c\\n0000000000000034 D _g1      # D = data section, так как g1 определен \\n0000000000000004 C _g2      # C = common symbol, почти то же, что и undefined\\n0000000000000000 T _main    # T = text section, так как main - функция, определенная в p1.c\\n\\n$ nm p2.o\\n0000000000000000 T _f       # T = text section\\n                 U _g1      # U = undefined\\n0000000000000024 D _g2      # D = data section\\n</code></pre>\\n<p>В секции Text содержится код функций на ассемблере и его можно посмотреть вот так:</p>\\n<pre><code class=\\\"language-sh\\\">objdump -D p1.o\\n</code></pre>\\n<p>Вывод objdump показывает, что в обоих объектных файлах адреса начинаются с 0, а это значит, что их нужно слинковать и в процессе отрелоцировать.</p>\\n<p>В процессе работы линкера имена переменных исчезают, заменяясь адресами в памяти.</p>\\n<p>Слинкуем наши объектные файлы:</p>\\n<pre><code class=\\\"language-sh\\\">ld -o t1.bin p1.o p2.o\\n</code></pre>\\n<p>На маке правда пришлось указать пару дополнительных параметров:</p>\\n<pre><code class=\\\"language-sh\\\">ld -o t1.bin p1.o p2.o -lSystem -macosx_version_min 10.14 \\n</code></pre>\\n<p>Проверим, что получилось:</p>\\n<pre><code class=\\\"language-sh\\\">$ nm t1.bin\\n0000000000001000 A __mh_execute_header\\n0000000000001fa0 T _f\\n0000000000002000 D _g1\\n0000000000002004 D _g2\\n0000000000001f60 T _main\\n                 U dyld_stub_binder\\n</code></pre>\\n<p>Как видим, здесь все наши функции и переменные на месте.</p>\\n<p>Однако чтобы подключить все необходимые библиотеки, нужно в <strong>ld</strong> указать еще кучу всяких флагов, поэтому проще восползоваться <strong>gcc</strong>, чтобы он сам их указал:</p>\\n<pre><code class=\\\"language-sh\\\">gcc -o t1.bin p1.o p2.o`\\n</code></pre>\\n<p>Если хотим слинковать все статически (на маке не работает\\t):</p>\\n<pre><code class=\\\"language-sh\\\">gcc -static -o t1.bin p1.o p2.o`\\n</code></pre>\\n<p>Можно указать флаг <code>-v</code> чтобы увидеть, с какими аргум ентами вызывается <strong>ld</strong>.</p>\\n<p>Cкомпилим наш код как разделяемую библиотеку:</p>\\n<pre><code class=\\\"language-sh\\\">$ gcc -fpic -shared -o libp2.so p2.c\\n$ gcc -o p.bin p1.c -L\\\".\\\" -lp2\\n$ LD_LIBRARY_PATH=\\\".\\\" ./p.bin\\n$ echo $?   # 57\\n</code></pre>\\n<ul>\\n<li><code>-fpic</code> - указывает создать position-independent code, это код, который может быть загружен в память в произвольный адрес без необходимости релоцироваться</li>\\n<li><code>-shared</code> - указывает создать динамическую библиотеку</li>\\n<li><code>-o libp2.so</code> - указывает целевой файл, имя составляется по правилу <code>lib+name+.so+.version</code></li>\\n<li><code>-L\\\".\\\"</code> - линкуем текущую директорию, чтобы либы-зависимости искались в ней</li>\\n<li><code>-lp2</code> - указывает слинковать с библиотекой <code>libp2.so</code>, чье имя будет составлено автоматически</li>\\n<li><code>LD_LIBRARY_PATH</code> - нужна, чтобы указать адрес, в котором искать зависимость <code>libp2.so</code>, иначе она будет искаться в стандартных папках, перечисленных в <code>/etc/ld.so.conf</code>.</li>\\n</ul>\\n<p>Теперь, если сделать <code>objdump -d p.bin</code> или <code>nm p.bin</code>, то мы увидим, что в ней есть <strong>main</strong>, но нет <strong>f</strong>. </p>\\n<p>А вот в <code>nm libp2.so</code> функция <strong>f</strong> есть!</p>\",\"frontmatter\":{\"path\":\"/blog/books/stackframes\",\"title\":\"Stack Frames\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---blog-books-stackframes-a750e700629fe8105cd2.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>Stack Frames</h1>\\n<h2>Executables and Libraries</h2>\\n<p>Пусть у нас есть 2 файла.</p>\\n<pre><code class=\\\"language-c\\\">//p1.c\\n\\nint g1 = 1;\\nextern int g2;\\nint f(void);\\nint main(void) { int v1=0x11; return f()+v1+g1+g2; }\\n</code></pre>\\n<pre><code class=\\\"language-c\\\">//p2.c\\n\\nextern int g1; \\nint g2 = 2;\\nint f(void) { int v2=0x22; return v2+g1+g2; }\\n</code></pre>\\n<p>Скомпилируем их:</p>\\n<pre><code class=\\\"language-sh\\\">gcc -c p1.c p2.c\\n</code></pre>\\n<p>Получаем файлы <strong>p1.o</strong> и <strong>p2.o</strong>. Посмотрим их таблицу символов:</p>\\n<pre><code class=\\\"language-sh\\\">$ nm p1.o\\n                 U _f       # U = undefined, так как f не определена в p1.c\\n0000000000000034 D _g1      # D = data section, так как g1 определен \\n0000000000000004 C _g2      # C = common symbol, почти то же, что и undefined\\n0000000000000000 T _main    # T = text section, так как main - функция, определенная в p1.c\\n\\n$ nm p2.o\\n0000000000000000 T _f       # T = text section\\n                 U _g1      # U = undefined\\n0000000000000024 D _g2      # D = data section\\n</code></pre>\\n<p>В секции Text содержится код функций на ассемблере и его можно посмотреть вот так:</p>\\n<pre><code class=\\\"language-sh\\\">objdump -D p1.o\\n</code></pre>\\n<p>Вывод objdump показывает, что в обоих объектных файлах адреса начинаются с 0, а это значит, что их нужно слинковать и в процессе отрелоцировать.</p>\\n<p>В процессе работы линкера имена переменных исчезают, заменяясь адресами в памяти.</p>\\n<p>Слинкуем наши объектные файлы:</p>\\n<pre><code class=\\\"language-sh\\\">ld -o t1.bin p1.o p2.o\\n</code></pre>\\n<p>На маке правда пришлось указать пару дополнительных параметров:</p>\\n<pre><code class=\\\"language-sh\\\">ld -o t1.bin p1.o p2.o -lSystem -macosx_version_min 10.14 \\n</code></pre>\\n<p>Проверим, что получилось:</p>\\n<pre><code class=\\\"language-sh\\\">$ nm t1.bin\\n0000000000001000 A __mh_execute_header\\n0000000000001fa0 T _f\\n0000000000002000 D _g1\\n0000000000002004 D _g2\\n0000000000001f60 T _main\\n                 U dyld_stub_binder\\n</code></pre>\\n<p>Как видим, здесь все наши функции и переменные на месте.</p>\\n<p>Однако чтобы подключить все необходимые библиотеки, нужно в <strong>ld</strong> указать еще кучу всяких флагов, поэтому проще восползоваться <strong>gcc</strong>, чтобы он сам их указал:</p>\\n<pre><code class=\\\"language-sh\\\">gcc -o t1.bin p1.o p2.o`\\n</code></pre>\\n<p>Если хотим слинковать все статически (на маке не работает\\t):</p>\\n<pre><code class=\\\"language-sh\\\">gcc -static -o t1.bin p1.o p2.o`\\n</code></pre>\\n<p>Можно указать флаг <code>-v</code> чтобы увидеть, с какими аргум ентами вызывается <strong>ld</strong>.</p>\\n<p>Cкомпилим наш код как разделяемую библиотеку:</p>\\n<pre><code class=\\\"language-sh\\\">$ gcc -fpic -shared -o libp2.so p2.c\\n$ gcc -o p.bin p1.c -L\\\".\\\" -lp2\\n$ LD_LIBRARY_PATH=\\\".\\\" ./p.bin\\n$ echo $?   # 57\\n</code></pre>\\n<ul>\\n<li><code>-fpic</code> - указывает создать position-independent code, это код, который может быть загружен в память в произвольный адрес без необходимости релоцироваться</li>\\n<li><code>-shared</code> - указывает создать динамическую библиотеку</li>\\n<li><code>-o libp2.so</code> - указывает целевой файл, имя составляется по правилу <code>lib+name+.so+.version</code></li>\\n<li><code>-L\\\".\\\"</code> - линкуем текущую директорию, чтобы либы-зависимости искались в ней</li>\\n<li><code>-lp2</code> - указывает слинковать с библиотекой <code>libp2.so</code>, чье имя будет составлено автоматически</li>\\n<li><code>LD_LIBRARY_PATH</code> - нужна, чтобы указать адрес, в котором искать зависимость <code>libp2.so</code>, иначе она будет искаться в стандартных папках, перечисленных в <code>/etc/ld.so.conf</code>.</li>\\n</ul>\\n<p>Теперь, если сделать <code>objdump -d p.bin</code> или <code>nm p.bin</code>, то мы увидим, что в ней есть <strong>main</strong>, но нет <strong>f</strong>. </p>\\n<p>А вот в <code>nm libp2.so</code> функция <strong>f</strong> есть!</p>\",\"frontmatter\":{\"path\":\"/blog/books/stackframes\",\"title\":\"Stack Frames\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/blog-books-stackframes.json\n// module id = 423\n// module chunks = 65468590155737"],"sourceRoot":""}