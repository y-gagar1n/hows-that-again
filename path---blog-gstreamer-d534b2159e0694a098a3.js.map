{"version":3,"sources":["webpack:///path---blog-gstreamer-d534b2159e0694a098a3.js","webpack:///./.cache/json/blog-gstreamer.json"],"names":["webpackJsonp","436","module","exports","data","markdownRemark","html","frontmatter","path","title","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,u1YAA0rYC,aAA0SC,KAAA,kBAAAC,MAAA,eAA+CC","file":"path---blog-gstreamer-d534b2159e0694a098a3.js","sourcesContent":["webpackJsonp([76495366757855],{\n\n/***/ 436:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p><a href=\\\"https://habr.com/ru/post/251427/\\\">https://habr.com/ru/post/251427/</a></p>\\n<pre><code class=\\\"language-cpp\\\">#include &#x3C;gst/gst.h>\\nint main (int argc, char * argv[]) {\\n\\n    if (argc != 3) {\\n        g_print (\\\"Syntax error\\\\n\\\");\\n        return -1;\\n    }\\n\\n    GstElement *pipeline, *src, *dst;\\n    /* Сюда будет читаться результат попытки запуска потока. */\\n    GstStateChangeReturn ret;\\n    /* bus - это шина конвейера. Через нее мы можем получать сообщения о событиях. */\\n    GstBus *bus;\\n    GstMessage *msg;\\n\\n    /* Инициализация GStreamer */\\n    gst_init (NULL, NULL);\\n\\n    /* Создаем элементы */\\n    pipeline = gst_element_factory_make (\\\"pipeline\\\", \\\"pipe\\\");\\n    src = gst_element_factory_make (\\\"filesrc\\\", \\\"src\\\");\\n    dst = gst_element_factory_make (\\\"filesink\\\", \\\"dst\\\");\\n    if ( !pipeline || !src || !dst ) {\\n        g_printerr (\\\"Unable to create some elements\\\\n\\\");\\n        return -1;\\n    }\\n\\n    /* Добавляем элементы в конвейер */\\n    gst_bin_add_many (GST_BIN(pipeline), src, dst, NULL);\\n\\n    /* И связываем их */\\n    if ( gst_element_link (src, dst) != TRUE )  {\\n        g_printerr (\\\"Elements can not be linked\\\\n\\\");\\n        gst_object_unref (pipeline);\\n        return -1;\\n    }\\n\\n    /* Задаем элементам свойства */\\n    g_object_set (src, \\\"location\\\", argv[1], NULL);\\n    g_object_set (dst, \\\"location\\\", argv[2], NULL);\\n\\n    /* Запускаем конвейер */\\n    ret = gst_element_set_state (pipeline, GST_STATE_PLAYING);\\n    if ( ret == GST_STATE_CHANGE_FAILURE ) {\\n        g_printerr (\\\"Unable to set pipeline to the playing state\\\\n\\\");\\n        gst_object_unref (pipeline);\\n        return -1;\\n    }\\n\\n    /* Мало просто установить режим PLAYING. Нужно ждать либо конца потока, либо \\n     * ошибок. Для начала подключаемся к шине конвейера (эти манипуляции будут \\n     * описаны в следующей статье) */\\n    bus = gst_element_get_bus (pipeline);\\n\\n    /* И ожидаем события на шине. Когда событие произойдет, функция вернет \\n     * сообщение, которое мы будем парсить. */\\n    msg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE, GST_MESSAGE_ERROR | GST_MESSAGE_EOS);\\n\\n    /* Парсим сообщение */\\n    if (msg != NULL)\\n    {\\n        GError *err;\\n        gchar *debug_info;\\n\\n        switch ( GST_MESSAGE_TYPE (msg) )\\n        {\\n            case GST_MESSAGE_ERROR:\\n                gst_message_parse_error (msg, &#x26;err, &#x26;debug_info);\\n                g_printerr (\\\"Error received from element %s: %s\\\\n\\\", GST_OBJECT_NAME (msg->src), err->message);\\n                g_printerr (\\\"Debugging information: %s\\\\n\\\", debug_info ? debug_info : \\\"none\\\");\\n                g_clear_error (&#x26;err);\\n                g_free (debug_info);\\n                break;\\n\\n            case GST_MESSAGE_EOS:\\n                g_print (\\\"We reach End-Of-Stream\\\\n\\\");\\n                break;\\n\\n            default:\\n                g_printerr (\\\"Unexpected message received\\\\n\\\");\\n                break;\\n        }\\n        gst_message_unref (msg);\\n    }\\n\\n    /* Освобождаем ресурсы */\\n    gst_object_unref (bus);\\n    gst_element_set_state (pipeline, GST_STATE_NULL);\\n    gst_object_unref (pipeline);\\n\\n    return 0;\\n}\\n</code></pre>\\n<h2>Типичное создание пайплайна</h2>\\n<pre><code class=\\\"language-cpp\\\">pipeline = gst_pipeline_new (\\\"my-pipeline\\\");\\n\\nbus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));\\ngst_bus_add_signal_watch (bus);\\ng_signal_connect (bus, \\\"message\\\", (GCallback) cb_message,\\n  pipeline);\\n\\nsrc = gst_element_factory_make (\\\"uridecodebin\\\", \\\"src\\\");\\nif (src == NULL)\\ng_error (\\\"Could not create 'uridecodebin' element\\\");\\n\\ng_object_set (src, \\\"uri\\\", argv[1], NULL);\\n\\ncsp = gst_element_factory_make (\\\"videoconvert\\\", \\\"csp\\\");\\nif (csp == NULL)\\ng_error (\\\"Could not create 'videoconvert' element\\\");\\n\\nvs = gst_element_factory_make (\\\"videoscale\\\", \\\"vs\\\");\\nif (csp == NULL)\\ng_error (\\\"Could not create 'videoscale' element\\\");\\n\\nsink = gst_element_factory_make (\\\"autovideosink\\\", \\\"sink\\\");\\nif (sink == NULL)\\ng_error (\\\"Could not create 'autovideosink' element\\\");\\n\\ngst_bin_add_many (GST_BIN (pipeline), src, csp, vs, sink, NULL);\\n</code></pre>\\n<h1>API</h1>\\n<p><code>gst_buffer_map</code> позволяет доставать <code>GstMapInfo</code> из <code>GstBuffer</code></p>\\n<p>У GstMapInfo есть поля:</p>\\n<pre><code class=\\\"language-cpp\\\">guint8 *data;\\ngsize size;\\n</code></pre>\\n<p>Pad probes are best suited for looking at data as it passes through the pipeline. If you need to modify data, you should rather write your own GStreamer element. Base classes like GstAudioFilter, GstVideoFilter or GstBaseTransform make this fairly easy.</p>\\n<p>If you just want to inspect buffers as they pass through the pipeline, you don't even need to set up pad probes. You could also just insert an identity element into the pipeline and connect to its \\\"handoff\\\" signal. The identity element also provides a few useful debugging tools like the dump and last-message properties; the latter is enabled by passing the '-v' switch to gst-launch and setting the silent property on the identity to FALSE.</p>\\n<h1>tcp</h1>\\n<h2>multifdsink</h2>\\n<p><a href=\\\"https://gstreamer.freedesktop.org/documentation/tcp/multifdsink.html?gi-language=c#multifdsink\\\">https://gstreamer.freedesktop.org/documentation/tcp/multifdsink.html?gi-language=c#multifdsink</a></p>\\n<p>Может писать поток в указанные файловые дескрипторы. Дескрипторы добавляются и удаляются через сигналы (<code>add</code>, <code>remove</code>)</p>\\n<h2>tcpclientsink/tcpserversrc</h2>\\n<p>Сами создают сокеты, достаточно передать лишь номер порта</p>\\n<pre><code class=\\\"language-shell\\\">gst-launch-1.0 tcpserversrc port=9999 ! decodebin ! alsasink\\ngst-launch-1.0 filesrc location=/home/yury-timofeev/samples/1.mp3 ! tcpclientsink port=9999\\n</code></pre>\\n<p>Можно и микшировать сразу:</p>\\n<pre><code class=\\\"language-cpp\\\">gst-launch-1.0 tcpserversrc port=9999 ! decodebin ! audiomixer name=mix ! alsasink tcpserversrc port=9998 ! decodebin ! mix.\\ngst-launch-1.0 filesrc location=/home/yury-timofeev/samples/1.mp3 ! tcpclientsink port=9999\\ngst-launch-1.0 filesrc location=/home/yury-timofeev/samples/2.mp3 ! tcpclientsink port=9998\\n</code></pre>\\n<p>При этом если мы хотим использовать <code>decodebin</code> на отправляющей стороне, то нужно поизвращаться:</p>\\n<pre><code class=\\\"language-cpp\\\">gst-launch-1.0 tcpserversrc port=9999 ! audio/x-raw,format=S8,channels=2,rate=48000 ! audioconvert ! alsasink\\n\\ngst-launch-1.0 filesrc location=/home/yury-timofeev/samples/1.mp3 ! decodebin ! audioconvert ! audioresample ! audio/x-raw,format=S8,channels=2,rate=48000 ! tcpclientsink port=9999\\n</code></pre>\\n<h1>Сигналы</h1>\\n<p>Используется концепция сигналов из GObjects (не имеют ничего общего с UNIX-сигналами): <a href=\\\"https://developer.gnome.org/gobject/stable/signal.html\\\">https://developer.gnome.org/gobject/stable/signal.html</a></p>\\n<p>Вот так мы посылаем сигнал в элемент:</p>\\n<pre><code class=\\\"language-cpp\\\">GstElement *sink = gst_bin_get_by_name(GST_BIN(pipeline), \\\"dest\\\");\\ng_signal_emit_by_name(sink, \\\"add\\\", \\\"192.168.1.25\\\", 5004, NULL);\\ng_object_unref(sink);\\n</code></pre>\\n<h1>decodebin, oggdemux</h1>\\n<p><a href=\\\"https://gstreamer.freedesktop.org/documentation/application-development/basics/pads.html#dynamic-or-sometimes-pads\\\">https://gstreamer.freedesktop.org/documentation/application-development/basics/pads.html#dynamic-or-sometimes-pads</a></p>\\n<p>Декодирующие элементы <code>decodebin</code> и <code>oggdemux</code> имеют особую природу. Так как <code>decodebin</code> может работать со многими форматами, а <code>oggdemux</code> может работать с аудио- и видео-потоком, то их синки становятся известны лишь во время выполнения. Поэтому они не могут быть связаны обычным образом и их нужно добавлять динамически. Делается это так:</p>\\n<pre><code class=\\\"language-cpp\\\">#include &#x3C;gobject/gsignal.h>\\n...\\nGstElement *pipeline = gst_pipeline_new(\\\"audio-sender\\\");\\nGstElement *source = gst_element_factory_make(\\\"filesrc\\\", \\\"file-source\\\");\\nGstElement *decodebin = gst_element_factory_make(\\\"decodebin\\\", \\\"decodebin\\\");\\nGstElement *alsasink = gst_element_factory_make(\\\"alsasink\\\", \\\"alsasink\\\");\\n\\nGstBus* bus = gst_pipeline_get_bus(GST_PIPELINE(pipeline));\\nguint bus_watch_id = gst_bus_add_watch(bus, bus_call, loop);\\ngst_object_unref(bus);\\n\\ngst_bin_add_many(GST_BIN(pipeline), source, decodebin, alsasink, nullptr); // в бин добавляем все 3 элемента\\ngst_element_link(source, decodebin);  // связываем только первые 2 элемента: filesrc ! decodebin\\n\\ng_signal_connect(decodebin, \\\"pad-added\\\", G_CALLBACK(on_pad_added), alsasink);   // на decodebin привязываемся к сигналу pad-added, который будет вызван, когда у decodebin появился pad, который sink (в начале работы такого пада у него нет)\\n</code></pre>\\n<p>Коллбэк выглядит так:</p>\\n<pre><code class=\\\"language-cpp\\\">static void on_pad_added (GstElement *element,\\n              GstPad     *pad,\\n              gpointer    data)\\n{\\n    GstPad *sinkpad;\\n    GstElement *alsasink = (GstElement *) data;\\n\\n    sinkpad = gst_element_get_static_pad (alsasink, \\\"sink\\\");    // берем пад, равный синку (то есть входной) у элемента alsasink\\n\\n    gst_pad_link (pad, sinkpad);    // связываем наш пад (т.е. decodebin) с синком алсасинка\\n\\n    gst_object_unref (sinkpad);\\n}\\n</code></pre>\\n<h1>capsfilter</h1>\\n<p>Когда вместо элемента в пайплайне начинает идти формат: </p>\\n<pre><code class=\\\"language-cpp\\\">gst-launch-1.0 tcpserversrc port=9999 ! audio/x-raw,format=S8,channels=2,rate=48000 ! audioconvert ! alsasink\\n</code></pre>\\n<p>то это алиас для:</p>\\n<pre><code class=\\\"language-cpp\\\">gst-launch-1.0 tcpserversrc port=9999 ! capsfilter caps=audio/x-raw,format=S8,channels=2,rate=48000 ! audioconvert ! alsasink\\n</code></pre>\\n<p>Я так до конца и не понял, что делает <code>capsfilter</code>, но вроде как он устанавливает ограничения для связи между двумя элементами. </p>\\n<h1>Итерирование по элементам бина</h1>\\n<pre><code class=\\\"language-cpp\\\">g_print(\\\"Pipeline contains the following elements:\\\\n\\\");\\nGstIterator *it;\\nGValue elem = G_VALUE_INIT;\\nit = gst_bin_iterate_elements(GST_BIN(pipeline));\\nwhile (gst_iterator_next(it, &#x26;elem) == GST_ITERATOR_OK)\\n{\\n    g_print(\\\"%s\\\\n\\\",\\n        gst_element_get_name(g_value_get_object(&#x26;elem)));\\n    g_value_reset(&#x26;elem);\\n}\\n\\ng_value_unset(&#x26;elem);\\ngst_iterator_free(it);\\n</code></pre>\\n<h1>queue2</h1>\\n<ul>\\n<li>\\n<p><code>buffering_level</code> - текущий уровень заполненности очереди. Нормализованный, принимает значения от 0 до 1.000.000</p>\\n</li>\\n<li>\\n<p><code>buffering_percent</code> - уровень заполненности промежутка между high и low вотермарками. 0% означает, что <code>buffering_level == low_watermark</code>, 100% означает, что <code>buffering_level == high_watermark</code>. Принимает значения от 0 до 100.</p>\\n</li>\\n<li>\\n<p><code>BUF_LEVEL_PERCENT_FACTOR</code> - чему в абсолютных значениях равен 1% buffering level, то есть <code>BUF_LEVEL_PERCENT_FACTOR ((MAX_BUFFERING_LEVEL) / 100) = 10.000</code></p>\\n</li>\\n</ul>\\n<p><code>gst_queue2_chain</code> - сюда поступают, здесь процессятся и отсюда выходят данные пайплайна. Это основная функция.</p>\\n<p>Она форвардит вызов к <code>gst_queue2_chain_buffer_or_buffer_list</code>. Там поступивший буфер кладется во внутреннюю очередь строчкой <code>gst_queue2_locked_enqueue</code></p>\\n<p>Следующие строки в методе <code>get_buffering_level</code>, кажется, наконец выставляют <code>buffering_level</code>:</p>\\n<pre><code class=\\\"language-cpp\\\">#define GET_BUFFER_LEVEL_FOR_QUANTITY(format,alt_max) \\\\\\n    normalize_to_buffering_level (queue->cur_level.format,queue->max_level.format,(alt_max))\\n\\n/* figure out the buffering level we are filled, we take the max of all formats. */\\nif (!QUEUE_IS_USING_RING_BUFFER (queue)) {\\n  buflevel = GET_BUFFER_LEVEL_FOR_QUANTITY (bytes, 0);\\n} else {\\n  guint64 rb_size = queue->ring_buffer_max_size;\\n  buflevel = GET_BUFFER_LEVEL_FOR_QUANTITY (bytes, rb_size);\\n}\\n\\nbuflevel2 = GET_BUFFER_LEVEL_FOR_QUANTITY (time, 0);\\nbuflevel = MAX (buflevel, buflevel2);\\n\\nbuflevel2 = GET_BUFFER_LEVEL_FOR_QUANTITY (buffers, 0);\\nbuflevel = MAX (buflevel, buflevel2);\\n\\n/* also apply the rate estimate when we need to */\\nif (queue->use_rate_estimate) {\\n  buflevel2 = GET_BUFFER_LEVEL_FOR_QUANTITY (rate_time, 0);\\n  buflevel = MAX (buflevel, buflevel2);\\n}\\n</code></pre>\\n<p>И она вычисляют уровень для байт, времени, буферов и rate_time, а потом берут из них максимальный.</p>\\n<h1>Написание плагина</h1>\\n<p>Лучшая статья по этой теме, что я видел: <a href=\\\"https://habr.com/ru/post/221483/\\\">https://habr.com/ru/post/221483/</a></p>\",\"frontmatter\":{\"path\":\"/blog/gstreamer\",\"title\":\"Gstreamer\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---blog-gstreamer-d534b2159e0694a098a3.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p><a href=\\\"https://habr.com/ru/post/251427/\\\">https://habr.com/ru/post/251427/</a></p>\\n<pre><code class=\\\"language-cpp\\\">#include &#x3C;gst/gst.h>\\nint main (int argc, char * argv[]) {\\n\\n    if (argc != 3) {\\n        g_print (\\\"Syntax error\\\\n\\\");\\n        return -1;\\n    }\\n\\n    GstElement *pipeline, *src, *dst;\\n    /* Сюда будет читаться результат попытки запуска потока. */\\n    GstStateChangeReturn ret;\\n    /* bus - это шина конвейера. Через нее мы можем получать сообщения о событиях. */\\n    GstBus *bus;\\n    GstMessage *msg;\\n\\n    /* Инициализация GStreamer */\\n    gst_init (NULL, NULL);\\n\\n    /* Создаем элементы */\\n    pipeline = gst_element_factory_make (\\\"pipeline\\\", \\\"pipe\\\");\\n    src = gst_element_factory_make (\\\"filesrc\\\", \\\"src\\\");\\n    dst = gst_element_factory_make (\\\"filesink\\\", \\\"dst\\\");\\n    if ( !pipeline || !src || !dst ) {\\n        g_printerr (\\\"Unable to create some elements\\\\n\\\");\\n        return -1;\\n    }\\n\\n    /* Добавляем элементы в конвейер */\\n    gst_bin_add_many (GST_BIN(pipeline), src, dst, NULL);\\n\\n    /* И связываем их */\\n    if ( gst_element_link (src, dst) != TRUE )  {\\n        g_printerr (\\\"Elements can not be linked\\\\n\\\");\\n        gst_object_unref (pipeline);\\n        return -1;\\n    }\\n\\n    /* Задаем элементам свойства */\\n    g_object_set (src, \\\"location\\\", argv[1], NULL);\\n    g_object_set (dst, \\\"location\\\", argv[2], NULL);\\n\\n    /* Запускаем конвейер */\\n    ret = gst_element_set_state (pipeline, GST_STATE_PLAYING);\\n    if ( ret == GST_STATE_CHANGE_FAILURE ) {\\n        g_printerr (\\\"Unable to set pipeline to the playing state\\\\n\\\");\\n        gst_object_unref (pipeline);\\n        return -1;\\n    }\\n\\n    /* Мало просто установить режим PLAYING. Нужно ждать либо конца потока, либо \\n     * ошибок. Для начала подключаемся к шине конвейера (эти манипуляции будут \\n     * описаны в следующей статье) */\\n    bus = gst_element_get_bus (pipeline);\\n\\n    /* И ожидаем события на шине. Когда событие произойдет, функция вернет \\n     * сообщение, которое мы будем парсить. */\\n    msg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE, GST_MESSAGE_ERROR | GST_MESSAGE_EOS);\\n\\n    /* Парсим сообщение */\\n    if (msg != NULL)\\n    {\\n        GError *err;\\n        gchar *debug_info;\\n\\n        switch ( GST_MESSAGE_TYPE (msg) )\\n        {\\n            case GST_MESSAGE_ERROR:\\n                gst_message_parse_error (msg, &#x26;err, &#x26;debug_info);\\n                g_printerr (\\\"Error received from element %s: %s\\\\n\\\", GST_OBJECT_NAME (msg->src), err->message);\\n                g_printerr (\\\"Debugging information: %s\\\\n\\\", debug_info ? debug_info : \\\"none\\\");\\n                g_clear_error (&#x26;err);\\n                g_free (debug_info);\\n                break;\\n\\n            case GST_MESSAGE_EOS:\\n                g_print (\\\"We reach End-Of-Stream\\\\n\\\");\\n                break;\\n\\n            default:\\n                g_printerr (\\\"Unexpected message received\\\\n\\\");\\n                break;\\n        }\\n        gst_message_unref (msg);\\n    }\\n\\n    /* Освобождаем ресурсы */\\n    gst_object_unref (bus);\\n    gst_element_set_state (pipeline, GST_STATE_NULL);\\n    gst_object_unref (pipeline);\\n\\n    return 0;\\n}\\n</code></pre>\\n<h2>Типичное создание пайплайна</h2>\\n<pre><code class=\\\"language-cpp\\\">pipeline = gst_pipeline_new (\\\"my-pipeline\\\");\\n\\nbus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));\\ngst_bus_add_signal_watch (bus);\\ng_signal_connect (bus, \\\"message\\\", (GCallback) cb_message,\\n  pipeline);\\n\\nsrc = gst_element_factory_make (\\\"uridecodebin\\\", \\\"src\\\");\\nif (src == NULL)\\ng_error (\\\"Could not create 'uridecodebin' element\\\");\\n\\ng_object_set (src, \\\"uri\\\", argv[1], NULL);\\n\\ncsp = gst_element_factory_make (\\\"videoconvert\\\", \\\"csp\\\");\\nif (csp == NULL)\\ng_error (\\\"Could not create 'videoconvert' element\\\");\\n\\nvs = gst_element_factory_make (\\\"videoscale\\\", \\\"vs\\\");\\nif (csp == NULL)\\ng_error (\\\"Could not create 'videoscale' element\\\");\\n\\nsink = gst_element_factory_make (\\\"autovideosink\\\", \\\"sink\\\");\\nif (sink == NULL)\\ng_error (\\\"Could not create 'autovideosink' element\\\");\\n\\ngst_bin_add_many (GST_BIN (pipeline), src, csp, vs, sink, NULL);\\n</code></pre>\\n<h1>API</h1>\\n<p><code>gst_buffer_map</code> позволяет доставать <code>GstMapInfo</code> из <code>GstBuffer</code></p>\\n<p>У GstMapInfo есть поля:</p>\\n<pre><code class=\\\"language-cpp\\\">guint8 *data;\\ngsize size;\\n</code></pre>\\n<p>Pad probes are best suited for looking at data as it passes through the pipeline. If you need to modify data, you should rather write your own GStreamer element. Base classes like GstAudioFilter, GstVideoFilter or GstBaseTransform make this fairly easy.</p>\\n<p>If you just want to inspect buffers as they pass through the pipeline, you don't even need to set up pad probes. You could also just insert an identity element into the pipeline and connect to its \\\"handoff\\\" signal. The identity element also provides a few useful debugging tools like the dump and last-message properties; the latter is enabled by passing the '-v' switch to gst-launch and setting the silent property on the identity to FALSE.</p>\\n<h1>tcp</h1>\\n<h2>multifdsink</h2>\\n<p><a href=\\\"https://gstreamer.freedesktop.org/documentation/tcp/multifdsink.html?gi-language=c#multifdsink\\\">https://gstreamer.freedesktop.org/documentation/tcp/multifdsink.html?gi-language=c#multifdsink</a></p>\\n<p>Может писать поток в указанные файловые дескрипторы. Дескрипторы добавляются и удаляются через сигналы (<code>add</code>, <code>remove</code>)</p>\\n<h2>tcpclientsink/tcpserversrc</h2>\\n<p>Сами создают сокеты, достаточно передать лишь номер порта</p>\\n<pre><code class=\\\"language-shell\\\">gst-launch-1.0 tcpserversrc port=9999 ! decodebin ! alsasink\\ngst-launch-1.0 filesrc location=/home/yury-timofeev/samples/1.mp3 ! tcpclientsink port=9999\\n</code></pre>\\n<p>Можно и микшировать сразу:</p>\\n<pre><code class=\\\"language-cpp\\\">gst-launch-1.0 tcpserversrc port=9999 ! decodebin ! audiomixer name=mix ! alsasink tcpserversrc port=9998 ! decodebin ! mix.\\ngst-launch-1.0 filesrc location=/home/yury-timofeev/samples/1.mp3 ! tcpclientsink port=9999\\ngst-launch-1.0 filesrc location=/home/yury-timofeev/samples/2.mp3 ! tcpclientsink port=9998\\n</code></pre>\\n<p>При этом если мы хотим использовать <code>decodebin</code> на отправляющей стороне, то нужно поизвращаться:</p>\\n<pre><code class=\\\"language-cpp\\\">gst-launch-1.0 tcpserversrc port=9999 ! audio/x-raw,format=S8,channels=2,rate=48000 ! audioconvert ! alsasink\\n\\ngst-launch-1.0 filesrc location=/home/yury-timofeev/samples/1.mp3 ! decodebin ! audioconvert ! audioresample ! audio/x-raw,format=S8,channels=2,rate=48000 ! tcpclientsink port=9999\\n</code></pre>\\n<h1>Сигналы</h1>\\n<p>Используется концепция сигналов из GObjects (не имеют ничего общего с UNIX-сигналами): <a href=\\\"https://developer.gnome.org/gobject/stable/signal.html\\\">https://developer.gnome.org/gobject/stable/signal.html</a></p>\\n<p>Вот так мы посылаем сигнал в элемент:</p>\\n<pre><code class=\\\"language-cpp\\\">GstElement *sink = gst_bin_get_by_name(GST_BIN(pipeline), \\\"dest\\\");\\ng_signal_emit_by_name(sink, \\\"add\\\", \\\"192.168.1.25\\\", 5004, NULL);\\ng_object_unref(sink);\\n</code></pre>\\n<h1>decodebin, oggdemux</h1>\\n<p><a href=\\\"https://gstreamer.freedesktop.org/documentation/application-development/basics/pads.html#dynamic-or-sometimes-pads\\\">https://gstreamer.freedesktop.org/documentation/application-development/basics/pads.html#dynamic-or-sometimes-pads</a></p>\\n<p>Декодирующие элементы <code>decodebin</code> и <code>oggdemux</code> имеют особую природу. Так как <code>decodebin</code> может работать со многими форматами, а <code>oggdemux</code> может работать с аудио- и видео-потоком, то их синки становятся известны лишь во время выполнения. Поэтому они не могут быть связаны обычным образом и их нужно добавлять динамически. Делается это так:</p>\\n<pre><code class=\\\"language-cpp\\\">#include &#x3C;gobject/gsignal.h>\\n...\\nGstElement *pipeline = gst_pipeline_new(\\\"audio-sender\\\");\\nGstElement *source = gst_element_factory_make(\\\"filesrc\\\", \\\"file-source\\\");\\nGstElement *decodebin = gst_element_factory_make(\\\"decodebin\\\", \\\"decodebin\\\");\\nGstElement *alsasink = gst_element_factory_make(\\\"alsasink\\\", \\\"alsasink\\\");\\n\\nGstBus* bus = gst_pipeline_get_bus(GST_PIPELINE(pipeline));\\nguint bus_watch_id = gst_bus_add_watch(bus, bus_call, loop);\\ngst_object_unref(bus);\\n\\ngst_bin_add_many(GST_BIN(pipeline), source, decodebin, alsasink, nullptr); // в бин добавляем все 3 элемента\\ngst_element_link(source, decodebin);  // связываем только первые 2 элемента: filesrc ! decodebin\\n\\ng_signal_connect(decodebin, \\\"pad-added\\\", G_CALLBACK(on_pad_added), alsasink);   // на decodebin привязываемся к сигналу pad-added, который будет вызван, когда у decodebin появился pad, который sink (в начале работы такого пада у него нет)\\n</code></pre>\\n<p>Коллбэк выглядит так:</p>\\n<pre><code class=\\\"language-cpp\\\">static void on_pad_added (GstElement *element,\\n              GstPad     *pad,\\n              gpointer    data)\\n{\\n    GstPad *sinkpad;\\n    GstElement *alsasink = (GstElement *) data;\\n\\n    sinkpad = gst_element_get_static_pad (alsasink, \\\"sink\\\");    // берем пад, равный синку (то есть входной) у элемента alsasink\\n\\n    gst_pad_link (pad, sinkpad);    // связываем наш пад (т.е. decodebin) с синком алсасинка\\n\\n    gst_object_unref (sinkpad);\\n}\\n</code></pre>\\n<h1>capsfilter</h1>\\n<p>Когда вместо элемента в пайплайне начинает идти формат: </p>\\n<pre><code class=\\\"language-cpp\\\">gst-launch-1.0 tcpserversrc port=9999 ! audio/x-raw,format=S8,channels=2,rate=48000 ! audioconvert ! alsasink\\n</code></pre>\\n<p>то это алиас для:</p>\\n<pre><code class=\\\"language-cpp\\\">gst-launch-1.0 tcpserversrc port=9999 ! capsfilter caps=audio/x-raw,format=S8,channels=2,rate=48000 ! audioconvert ! alsasink\\n</code></pre>\\n<p>Я так до конца и не понял, что делает <code>capsfilter</code>, но вроде как он устанавливает ограничения для связи между двумя элементами. </p>\\n<h1>Итерирование по элементам бина</h1>\\n<pre><code class=\\\"language-cpp\\\">g_print(\\\"Pipeline contains the following elements:\\\\n\\\");\\nGstIterator *it;\\nGValue elem = G_VALUE_INIT;\\nit = gst_bin_iterate_elements(GST_BIN(pipeline));\\nwhile (gst_iterator_next(it, &#x26;elem) == GST_ITERATOR_OK)\\n{\\n    g_print(\\\"%s\\\\n\\\",\\n        gst_element_get_name(g_value_get_object(&#x26;elem)));\\n    g_value_reset(&#x26;elem);\\n}\\n\\ng_value_unset(&#x26;elem);\\ngst_iterator_free(it);\\n</code></pre>\\n<h1>queue2</h1>\\n<ul>\\n<li>\\n<p><code>buffering_level</code> - текущий уровень заполненности очереди. Нормализованный, принимает значения от 0 до 1.000.000</p>\\n</li>\\n<li>\\n<p><code>buffering_percent</code> - уровень заполненности промежутка между high и low вотермарками. 0% означает, что <code>buffering_level == low_watermark</code>, 100% означает, что <code>buffering_level == high_watermark</code>. Принимает значения от 0 до 100.</p>\\n</li>\\n<li>\\n<p><code>BUF_LEVEL_PERCENT_FACTOR</code> - чему в абсолютных значениях равен 1% buffering level, то есть <code>BUF_LEVEL_PERCENT_FACTOR ((MAX_BUFFERING_LEVEL) / 100) = 10.000</code></p>\\n</li>\\n</ul>\\n<p><code>gst_queue2_chain</code> - сюда поступают, здесь процессятся и отсюда выходят данные пайплайна. Это основная функция.</p>\\n<p>Она форвардит вызов к <code>gst_queue2_chain_buffer_or_buffer_list</code>. Там поступивший буфер кладется во внутреннюю очередь строчкой <code>gst_queue2_locked_enqueue</code></p>\\n<p>Следующие строки в методе <code>get_buffering_level</code>, кажется, наконец выставляют <code>buffering_level</code>:</p>\\n<pre><code class=\\\"language-cpp\\\">#define GET_BUFFER_LEVEL_FOR_QUANTITY(format,alt_max) \\\\\\n    normalize_to_buffering_level (queue->cur_level.format,queue->max_level.format,(alt_max))\\n\\n/* figure out the buffering level we are filled, we take the max of all formats. */\\nif (!QUEUE_IS_USING_RING_BUFFER (queue)) {\\n  buflevel = GET_BUFFER_LEVEL_FOR_QUANTITY (bytes, 0);\\n} else {\\n  guint64 rb_size = queue->ring_buffer_max_size;\\n  buflevel = GET_BUFFER_LEVEL_FOR_QUANTITY (bytes, rb_size);\\n}\\n\\nbuflevel2 = GET_BUFFER_LEVEL_FOR_QUANTITY (time, 0);\\nbuflevel = MAX (buflevel, buflevel2);\\n\\nbuflevel2 = GET_BUFFER_LEVEL_FOR_QUANTITY (buffers, 0);\\nbuflevel = MAX (buflevel, buflevel2);\\n\\n/* also apply the rate estimate when we need to */\\nif (queue->use_rate_estimate) {\\n  buflevel2 = GET_BUFFER_LEVEL_FOR_QUANTITY (rate_time, 0);\\n  buflevel = MAX (buflevel, buflevel2);\\n}\\n</code></pre>\\n<p>И она вычисляют уровень для байт, времени, буферов и rate_time, а потом берут из них максимальный.</p>\\n<h1>Написание плагина</h1>\\n<p>Лучшая статья по этой теме, что я видел: <a href=\\\"https://habr.com/ru/post/221483/\\\">https://habr.com/ru/post/221483/</a></p>\",\"frontmatter\":{\"path\":\"/blog/gstreamer\",\"title\":\"Gstreamer\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/blog-gstreamer.json\n// module id = 436\n// module chunks = 76495366757855"],"sourceRoot":""}