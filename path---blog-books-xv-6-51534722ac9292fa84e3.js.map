{"version":3,"sources":["webpack:///path---blog-books-xv-6-51534722ac9292fa84e3.js","webpack:///./.cache/json/blog-books-xv-6.json"],"names":["webpackJsonp","421","module","exports","data","markdownRemark","html","frontmatter","path","title","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,mrqBAAi2nBC,aAAi+CC,KAAA,kBAAAC,MAAA,SAAyCC","file":"path---blog-books-xv-6-51534722ac9292fa84e3.js","sourcesContent":["webpackJsonp([160831456888542],{\n\n/***/ 421:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p><a href=\\\"https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf\\\">Комментарии к исходному коду</a></p>\\n<p><a href=\\\"https://pdos.csail.mit.edu/6.828/2018/xv6/xv6-rev11.pdf\\\">Исходный код</a></p>\\n<h1>xv6</h1>\\n<h2>Основные понятия</h2>\\n<h3>Процесс</h3>\\n<p>Память любого процесса состоит из 3 частей: инструкции, данные, стек.</p>\\n<h3>fork</h3>\\n<p>Создает новый процесс (child process), содержимое памяти которого идентично содержимому памяти вызывающего процесса (parent process). Но это не одна и та же память, это копия. Так как память у процессов одинаковая, значит одинаковые и инструкции, значит в обоих процессах выполнение продолжается со следующей инструкции. Только в child process функция fork возвращает 0, а в родительском - pid созданного процесса.</p>\\n<pre><code class=\\\"language-c\\\">int pid = fork();\\nif(pid > 0){\\n    printf(\\\"parent: child=%d\\\\n\\\", pid);\\n    pid = wait();\\n    printf(\\\"child %d is done\\\\n\\\", pid);\\n} else if(pid == 0){\\n    printf(\\\"child: exiting\\\\n\\\");\\n    exit();\\n} else {\\n    printf(\\\"fork error\\\\n\\\");\\n}\\n</code></pre>\\n<p><code>exit</code> - запускает процедуру выхода из процесса и освобождает ресурсы (память, открытые файлы)</p>\\n<p><code>wait</code> - ожидает завершения дочернего процесса и возвращает его pid.</p>\\n<p>В приведенном примере на экран будет выдано:</p>\\n<pre><code>parent: child=1234\\nchild: exiting\\nchild 1234 is done\\n</code></pre>\\n<h3>exec</h3>\\n<p>Принимает в качестве аргумента путь к исполняемому файлу и заменяет память вызывающего процесса на память, загруженную из этого файла. Файл должен быть в специальном формате (ELF), в котором указано начало секции инструкций, начало секции данных, с какой инструкции начать выполнение и т.д. Если вызов exec совершен удачно, то выполнение продолжится с той инструкции, которая указана первой к исполнению в загруженном файле.</p>\\n<p>Пример:</p>\\n<pre><code class=\\\"language-c\\\">char *argv[3];\\nargv[0] = \\\"echo\\\";\\nargv[1] = \\\"hello\\\";\\nargv[2] = 0;\\nexec(\\\"/bin/echo\\\", argv);\\nprintf(\\\"exec error\\\\n\\\");\\n</code></pre>\\n<p>Здесь исполняемая программа заменяется программой <code>/bin/echo</code>, которая получает в качестве списка аргументов <code>echo hello</code>.</p>\\n<h3>sh</h3>\\n<p>Шелл использует <code>fork</code> и <code>exec</code> для исполнения программ. В общем структура выполнения выглядит так:</p>\\n<pre><code class=\\\"language-c\\\">int\\nmain(void)\\n{\\n  static char buf[100];\\n\\n  while(getcmd(buf, sizeof(buf)) >= 0){\\n    if(fork1() == 0)\\n      runcmd(parsecmd(buf));\\n    wait();\\n  }\\n  exit();\\n}\\n\\nvoid\\nruncmd(struct cmd *cmd)\\n{\\n  struct execcmd *ecmd;\\n\\n  switch(cmd->type){  \\n    ...\\n  case EXEC:\\n    ecmd = (struct execcmd*)cmd;\\n    exec(ecmd->argv[0], ecmd->argv);\\n    printf(2, \\\"exec %s failed\\\\n\\\", ecmd->argv[0]);\\n    break;\\n    ...\\n  }\\n  exit();\\n}\\n</code></pre>\\n<ul>\\n<li><code>main</code> - делает дочерний процесс, в нем парсит команду, подает на выполнение</li>\\n<li><code>runcmd</code> - делает <code>exec</code>, заменяя текущий процесс (тот, который был создан форком в <code>main</code>) на исполняемый файл, указанный в команде</li>\\n</ul>\\n<p>После завершения дочернего процесса исполнение продолжается на инструкции, следующей за <code>wait()</code>.</p>\\n<h3>Дескрипторы файлов</h3>\\n<p>У каждого процесса свой набор дескрипторов файлов, начинающийся с 0. По соглашению, 0 - дескриптор стандартного ввода/stdin, 1 - стандартного вывода/stdout, 2 - дескриптор канала ошибок/stderr.</p>\\n<p>При открытии файла он всегда получает наименьший из неиспользуемых в текущем процессе дексрипторов.</p>\\n<p>Вот так, например, выглядит <code>cat</code>:</p>\\n<pre><code class=\\\"language-c\\\">char buf[512];\\n\\nvoid\\ncat(int fd)\\n{\\n  int n;\\n\\n  while((n = read(fd, buf, sizeof(buf))) > 0) { // читаем из указанного дескриптора\\n    if (write(1, buf, n) != n) {  // пишем в 1, то есть stdout\\n      printf(1, \\\"cat: write error\\\\n\\\");\\n      exit();\\n    }\\n  }\\n\\n  // error handling\\n  if(n &#x3C; 0){\\n    printf(1, \\\"cat: read error\\\\n\\\");\\n    exit();\\n  }\\n}\\n\\nint\\nmain(int argc, char *argv[])\\n{\\n  int fd, i;\\n\\n  if(argc &#x3C;= 1){ // если аргументов не указано, то читаем из 0, то есть stdin\\n    cat(0);\\n    exit();\\n  }\\n\\n  for(i = 1; i &#x3C; argc; i++){ // если аргументы есть, то открываем файлы по этим путям и читаем из дескрипторов этих файлов\\n    if((fd = open(argv[i], 0)) &#x3C; 0){\\n      printf(1, \\\"cat: cannot open %s\\\\n\\\", argv[i]);\\n      exit();\\n    }\\n    cat(fd);\\n    close(fd);\\n  }\\n  exit();\\n}\\n</code></pre>\\n<h4>Перенаправление I/O</h4>\\n<p><code>exec</code> заменяет содержимое памяти вызывающего процесса, но при этом <strong>оставляет неизменной его таблицу дескрипторов</strong>. Это позволяет реализовать перенаправление I/O. Вот, что происходит при вызове <code>cat &#x3C; input.txt</code>:</p>\\n<pre><code class=\\\"language-c\\\">char *argv[2];\\nargv[0] = \\\"cat\\\";\\nargv[1] = 0;\\nif(fork() == 0) {\\n    close(0);\\n    open(\\\"input.txt\\\", O_RDONLY);\\n    exec(\\\"cat\\\", argv);\\n}\\n</code></pre>\\n<p>Здесь используется правило \\\"При открытии файла он всегда получает наименьший из неиспользуемых в текущем процессе дексрипторов\\\". Когда вызывается <code>close(0)</code>, дескриптор 0 (stdin) освобождается, а значит следующая инструкция <code>open</code> назначит открытому файлу <code>input.txt</code> дексриптор 0. Затем вызывается программа <code>cat</code>, которая при вызове без аргументов читает содержимое из дескриптора 0.</p>\\n<p>В коде шелла этот кусок выглядит так:</p>\\n<pre><code class=\\\"language-c\\\">void\\nruncmd(struct cmd *cmd)\\n{\\n  struct redircmd *rcmd;\\n\\n    switch(cmd->type){\\n  ...\\n\\n  case REDIR:\\n    rcmd = (struct redircmd*)cmd;\\n    close(rcmd->fd);\\n    if(open(rcmd->file, rcmd->mode) &#x3C; 0){\\n      printf(2, \\\"open %s failed\\\\n\\\", rcmd->file);\\n      exit();\\n    }\\n    runcmd(rcmd->cmd);\\n    break;\\n    ...\\n  }\\n  exit();\\n}\\n\\n...\\n\\nstruct cmd*\\nparseredirs(struct cmd *cmd, char **ps, char *es)\\n{\\n  int tok;\\n  char *q, *eq;\\n\\n  while(peek(ps, es, \\\"&#x3C;>\\\")){\\n    tok = gettoken(ps, es, 0, 0);\\n    switch(tok){\\n    case '&#x3C;':\\n      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);\\n      break;\\n    case '>':\\n      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);\\n      break;\\n    case '+':  // >>\\n      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);\\n      break;\\n    }\\n  }\\n  return cmd;\\n}\\n</code></pre>\\n<p><code>rcmd</code> при парсинге получит <code>fd</code>, равный 0, при использовании <code>&#x3C;</code> и равный 1 при использовании <code>></code>. В ветке <code>REDIR</code> мы закрыли дексриптор, на который будем перенаправлять ввод или вывод, открыли нужный файл и вызвали <code>runcmd</code>, внутри которого будет использован <code>exec</code>.</p>\\n<h4>Использование дескрипторов в fork</h4>\\n<p>При форке таблица дескрипторов копируется, а сдвиги - шарятся между процессами. То есть следующий пример:</p>\\n<pre><code class=\\\"language-c\\\">if(fork() == 0) {\\n    write(1, \\\"hello \\\", 6);\\n    exit();\\n} else {\\n    wait();\\n    write(1, \\\"world\\\\n\\\", 6);\\n}\\n</code></pre>\\n<p>Выведет на экран <code>hello world</code>. </p>\\n<p>Благодаря этому мы можем писать: <code>(echo hello; echo world)>output.txt</code>. (хотя пока непонятно, почему тут должен вызываться fork, а не exec).</p>\\n<h4>dup</h4>\\n<p>Копирует дескриптор, после чего оба дескриптора шарят сдвиг.</p>\\n<p>То есть:</p>\\n<pre><code class=\\\"language-c\\\">fd = dup(1);\\nwrite(1, \\\"hello \\\", 6);\\nwrite(fd, \\\"world\\\\n\\\", 6);\\n</code></pre>\\n<p>тоже выведет <code>hello world</code>.</p>\\n<p>Таким образом, два дексриптора файла шарят между собой сдвиг только в том случае, если они были получены из одного и того же дескриптора вызовами <code>fork</code> и <code>dup</code>. Во всех остальных случаях сдвиги не шарятся.</p>\\n<p><code>dup</code> позволяет писать такие команды:</p>\\n<pre><code class=\\\"language-shell\\\">ls existing-file non-existing-file > tmp1 2>&#x26;1\\n</code></pre>\\n<p>Здесь <code>2>&#x26;1</code> как раз копирует дексриптор 1 в дескриптор 2, чтобы все ошибки выводились в stdout.</p>\\n<h3>pipes</h3>\\n<p>Вызов <code>pipe</code> принимает массив из двух элементов и записывает в него 2 дексриптора: первый - для чтения и второй - для записи. Все, что будет записано в дексриптор для записи, можно будет прочитать из дескриптора для чтения.</p>\\n<p>Пример использования <code>pipe</code>:</p>\\n<pre><code class=\\\"language-c\\\">int p[2];\\nchar *argv[2];\\nargv[0] = \\\"wc\\\";\\nargv[1] = 0;\\n\\npipe(p);\\nif(fork() == 0) {\\n    close(0);\\n    dup(p[0]);\\n    close(p[0]);\\n    close(p[1]);\\n    exec(\\\"/bin/wc\\\", argv);\\n} else {\\n    close(p[0]);\\n    write(p[1], \\\"hello world\\\\n\\\", 12);\\n    close(p[1]);\\n}\\n</code></pre>\\n<p>Здесь дочерний процесс закрывает <code>stdin</code>, дублирует дескриптор чтения из пайпа в дескриптор 0, закрывает дескриптор чтения и записи и запускает <code>wc</code>, который будет принимать ввод от дескриптора 0, то есть будет читать из пайпа.</p>\\n<p>Родительский процесс пишет в дескриптор записи и закрывает оба дескриптора пайпа.</p>\\n<p>Приблизительно так же выглядит и ветка <code>PIPE</code> в <code>runcmd</code>, только она создает 2 дочерних процесса:</p>\\n<pre><code class=\\\"language-c\\\">void\\nruncmd(struct cmd *cmd)\\n{\\n   struct pipecmd *pcmd;\\n \\n  switch(cmd->type){\\n    ...\\n  case PIPE:\\n    pcmd = (struct pipecmd*)cmd;\\n    if(pipe(p) &#x3C; 0)\\n      panic(\\\"pipe\\\");\\n    if(fork1() == 0){\\n      close(1);\\n      dup(p[1]);\\n      close(p[0]);\\n      close(p[1]);\\n      runcmd(pcmd->left);\\n    }\\n    if(fork1() == 0){\\n      close(0);\\n      dup(p[0]);\\n      close(p[0]);\\n      close(p[1]);\\n      runcmd(pcmd->right);\\n    }\\n    close(p[0]);\\n    close(p[1]);\\n    wait();\\n    wait();\\n    break;\\n    ...\\n  }\\n  exit();\\n}\\n</code></pre>\\n<p>В шелле пайпы используются при выполнении команд вида <code>grep fork sh.c | wc -l</code>.</p>\\n<p>Преимущества пайпов перед временными файлами:</p>\\n<ul>\\n<li>автоматическое очищение</li>\\n<li>можно передавать очень длинные потоки данных, не беспокоясь, что на диске кончится место</li>\\n<li>возможно параллельное выполнение левой и правой команды</li>\\n<li>для межпроцессного общения блокирующая модель записи и чтения пайпов удобнее, чем неблокирующая модель файлов</li>\\n</ul>\\n<h3>Файловая система</h3>\\n<p><code>fstat</code> - возвращает информацию о файле, на который указывает дескрриптор</p>\\n<p>У файла может быть несколько имен, или \\\"линков\\\". Сам файл называется <code>inode</code>. Линки создаются командой <code>link</code>, например:</p>\\n<pre><code class=\\\"language-c\\\">open(\\\"a\\\", O_CREATE|O_WRONLY);\\nlink(\\\"a\\\", \\\"b\\\");\\n</code></pre>\\n<p>После этого <code>a</code> и <code>b</code> ссылаются на один и тот же <code>inode</code> и запись/чтение в <code>a</code> равносильно записи/чтению в <code>b</code>.</p>\\n<p>Каждый айнод идентифицируется своим <code>inode number</code>. Его можно получить вызовом <code>fstat</code>.</p>\\n<p>Линки удаляются командой <code>unlink</code>. Айнод и место на диске очищаются только когда количество линков уменьшится до 0 и не останется дескрипторов, ссылающихся на него.</p>\\n<h2>Организация операционной системы</h2>\\n<h3>Загрузчик</h3>\\n<p>Загрузчик состоит из 2 частей: <code>bootasm.s</code>, написанный на ассемблере и <code>bootmain.c</code>, написанный на С.</p>\\n<p>Когда компьютер стартует, он выполняет программу BIOS, которая записана в энергонезависимой памяти материнской платы. BIOS подготавливает аппаратное обеспечение к работе и передает управление коду, записанному в загрузочный сектор, т.е. первый 512-байтовый сектор загрузочного диска. В этом секторе содержится загрузчик: инструкции по загрузке ядра в память. BIOS загружает содержимое загрузочного сектора в адрес <code>0x7c00</code> и переходит на этот адрес. Начинается исполнение файла <code>bootasm.s</code>.</p>\\n<p>Первая инструкция загрузчика - <code>cli</code>, которая отключает прерывания. BIOS возможно установил какие-то свои обработчики прерываний, чтобы инициализировать устройства, но мы уже покинули BIOS, поэтому они нам больше не нужны. Когда операционная система загрузится, она включит прерывания обратно.</p>\\n<p>Затем загрузчик должен перевести процессор из реального режима работы в защищенный.</p>\\n<p>После этого загрузчик переходит в <code>bootmain.c</code>.</p>\\n<p>Задача <code>bootmain.c</code> - загрузить и запустить ядро. Ядро должно быть в формате ELF. <code>bootmain</code> загружает первые 4096 байт из бинарника ELF и кладет их копию по адресу <code>0x10000</code>. Затем он проверяет, что это действительно ELF путем проверки магического числа в заголовке файла. Затем он проходит по всем сегментам файла, загружает их в память и переходит в точку входа в ядро, а именно <code>0x10000c</code>.</p>\\n<h3>Старт ядра</h3>\\n<p>Когда загрузчик передает управления в ядро, первая выполняемая инструкция - это <code>entry:</code> в файле <code>entry.s</code>. Первое, что делает ядро - это настраивает аппаратный пэйджинг. Добавляется маппинг виртуальных адресов, начинающихся с <code>0x80000000</code> на физические, начинающиеся с <code>0x0</code>:</p>\\n<pre><code class=\\\"language-asm\\\">  movl    $(V2P_WO(entrypgdir)), %eax\\n  movl    %eax, %cr3\\n</code></pre>\\n<p><code>V2P_WO</code>(virtual to physical) - это макрос, который отнимает от \\\"высокого\\\" адреса <code>entrypgdir</code> константу <code>0x80000000</code>. Это нужно, потому что у нас еще не работает маппинг виртуальных адресов, но ядро слинковано с их использованием.</p>\\n<p>Таблица страниц entrypgdir описана в main.c:</p>\\n<pre><code class=\\\"language-c\\\">__attribute__((__aligned__(PGSIZE)))\\npde_t entrypgdir[NPDENTRIES] = {\\n  // Map VA's [0, 4MB) to PA's [0, 4MB)\\n  [0] = (0) | PTE_P | PTE_W | PTE_PS,\\n  // Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)\\n  [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,\\n};\\n</code></pre>\\n<p>Затем ядро включает аппаратный пейджинг:</p>\\n<pre><code>  orl     $(CR0_PG|CR0_WP), %eax\\n  movl    %eax, %cr0\\n</code></pre>\\n<p>Ну и наконец мы переходим в <code>main.c</code>:</p>\\n<pre><code class=\\\"language-asm\\\">  # Set up the stack pointer.\\n  movl $(stack + KSTACKSIZE), %esp\\n\\n  # Jump to main(), and switch to executing at\\n  # high addresses. The indirect call is needed because\\n  # the assembler produces a PC-relative instruction\\n  # for a direct jump.\\n  mov $main, %eax\\n  jmp *%eax\\n</code></pre>\\n<h3>Создание первого процесса</h3>\\n<p>Процесс описывается следующей структурой:</p>\\n<pre><code class=\\\"language-c\\\">// Per-process state\\nstruct proc {\\n  uint sz;                     // Size of process memory (bytes)\\n  pde_t* pgdir;                // Page table\\n  char *kstack;                // Bottom of kernel stack for this process\\n  enum procstate state;        // Process state\\n  int pid;                     // Process ID\\n  struct proc *parent;         // Parent process\\n  struct trapframe *tf;        // Trap frame for current syscall\\n  struct context *context;     // swtch() here to run process\\n  void *chan;                  // If non-zero, sleeping on chan\\n  int killed;                  // If non-zero, have been killed\\n  struct file *ofile[NOFILE];  // Open files\\n  struct inode *cwd;           // Current directory\\n  char name[16];               // Process name (debugging)\\n};\\n\\nstruct context {\\n  uint edi;\\n  uint esi;\\n  uint ebx;\\n  uint ebp;\\n  uint eip;\\n};\\n</code></pre>\\n<p><code>main</code> инициализирует кучу устройств и подсистем:</p>\\n<pre><code class=\\\"language-c\\\">// Bootstrap processor starts running C code here.\\n// Allocate a real stack and switch to it, first\\n// doing some setup required for memory allocator to work.\\nint\\nmain(void)\\n{\\n  kinit1(end, P2V(4*1024*1024)); // phys page allocator\\n  kvmalloc();      // kernel page table\\n  mpinit();        // detect other processors\\n  lapicinit();     // interrupt controller\\n  seginit();       // segment descriptors\\n  picinit();       // disable pic\\n  ioapicinit();    // another interrupt controller\\n  consoleinit();   // console hardware\\n  uartinit();      // serial port\\n  pinit();         // process table\\n  tvinit();        // trap vectors\\n  binit();         // buffer cache\\n  fileinit();      // file table\\n  ideinit();       // disk \\n  startothers();   // start other processors\\n  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()\\n  userinit();      // first user process\\n  mpmain();        // finish this processor's setup\\n}\\n</code></pre>\\n<p>Первый процесс создается вызовом <code>userinit()</code>, который вызывает <code>allocproc()</code>. Задача <code>allocproc()</code> - аллоцировать структуру типа <code>proc</code> в системной таблице процессов и инициализировать части состояния процесса, чтобы он мог запуститься. <code>allocproc()</code> запускается для каждого нового процесса, а <code>userinit()</code> - только для первого.</p>\\n<pre><code class=\\\"language-c\\\">// Look in the process table for an UNUSED proc.\\n// If found, change state to EMBRYO and initialize\\n// state required to run in the kernel.\\n// Otherwise return 0.\\nstatic struct proc*\\nallocproc(void)\\n{\\n  struct proc *p;\\n  char *sp;\\n\\n  acquire(&#x26;ptable.lock);\\n\\n  for(p = ptable.proc; p &#x3C; &#x26;ptable.proc[NPROC]; p++)\\n    if(p->state == UNUSED)\\n      goto found;\\n\\n  release(&#x26;ptable.lock);\\n  return 0;\\n\\nfound:\\n  p->state = EMBRYO;\\n  p->pid = nextpid++;\\n\\n  release(&#x26;ptable.lock);\\n\\n  // Allocate kernel stack.\\n  if((p->kstack = kalloc()) == 0){\\n    p->state = UNUSED;\\n    return 0;\\n  }\\n  sp = p->kstack + KSTACKSIZE;\\n\\n  // Leave room for trap frame.\\n  sp -= sizeof *p->tf;\\n  p->tf = (struct trapframe*)sp;\\n\\n  // Set up new context to start executing at forkret,\\n  // which returns to trapret.\\n  sp -= 4;\\n  *(uint*)sp = (uint)trapret;\\n\\n  sp -= sizeof *p->context;\\n  p->context = (struct context*)sp;\\n  memset(p->context, 0, sizeof *p->context);\\n  p->context->eip = (uint)forkret;\\n\\n  return p;\\n}\\n</code></pre>\\n<ul>\\n<li>регистр EIP в x86 означает Extended Instruction Pointer</li>\\n</ul>\\n<p>Allocproc:</p>\\n<ol>\\n<li>ищет в таблице процессов слот с состоянием UNUSED</li>\\n<li>когда находит, устанавливает ему состояние EMBRYO и дает процессу уникальный pid.</li>\\n<li>затем пытается выделить в памяти 4096 байт для ядерного стека процесса. Если не получается, то выставляет состояние обратно в UNUSED и возвращает 0.</li>\\n<li>если получилось, то поля структуры proc инициализируются адресами в стеке для trap frame, trapret, context. В результате полученный ядерный стек выглядит так:</li>\\n</ol>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/d05989cf0b10a4cc4b2d7a61cf6fb487/f7060/new-kernel-stack.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 325px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 105.23076923076921%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsSAAALEgHS3X78AAACPElEQVQ4y5VVia7iMAzk/38NCR4rbomr9L6gB6XlmvX4vfLYcm6kyGlCJvZ4bFr4GZfLRe3pdITnuYjCEI7rwfN9eK4Lx3FQlhWyLENVVTgcDnqHlt/H41Hvtx4BmuYaYeDDth0FWq8NWKaJNM3Q+/pCFEWIZY7HY8SbjeynCIJAQa+At6CvRlEUCriJY/T7fSQCVhQ7+BJJWZb3HtI+mufzWc834pFlWQoaBCFiAebatm0NvfXKmxrs9sEkSbDdbtXDTqeDPN9hv98jFM4/AmwCE4yXmRyu8zzXyZAV8FmIt/N28HIggEmyhWGskAow9zzPe+9hPdI0wXKx1EwOBgPNvCVKaLfbcD1feb1yuFqtsFjM5TVDyV7MuTZhyutr04L5s0dL/obDoUgqwHQ6xZ9eTx8oir3uKaAromX8tNSU73vqCYUdRbHyxfVWwBgaAfm7MAzQ7XZVNrvd7pdD/OeoLzMhhrFWUTNBVw4/TcZtUsgh9UfeyB/BuffQw98SPEnIofI6XyywXK7Um9lsho0AxHLWEw7TjDoslKaXgKyMLEs1EcqjVAO9G41G+s0SZPjce8vhq5rmJdZsc5DHf2r5k5r+1mSq3jUHI3kI+K4Ms4wh5nAdG9PJBOPJFJX0xKcePvOy7ja8WAhnBGVPDEWrPKfnCtgMqWkfyYbd5b4803sPm2Bl+V1SFC0rqKwOor9Is1orofacWlRA6o0AtM1WxabgCFdzqeWlaDEII+3S7DYUdj31L0Eswf8C0/9bMV1u3ygAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"New kernel stack\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/d05989cf0b10a4cc4b2d7a61cf6fb487/f7060/new-kernel-stack.png\\\"\\n        srcset=\\\"/hows-that-again/static/d05989cf0b10a4cc4b2d7a61cf6fb487/c5e8e/new-kernel-stack.png 163w,\\n/hows-that-again/static/d05989cf0b10a4cc4b2d7a61cf6fb487/f7060/new-kernel-stack.png 325w\\\"\\n        sizes=\\\"(max-width: 325px) 100vw, 325px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>После заполнения стэка в <code>p->context->eip</code> будет адрес функции <code>forkret</code>, а над контекстом, там, где обычно пишется адрес возврата - будет адрес функции <code>trapret</code>. Созданный поток начинает выполнение со значениями регистров, скопированными из <code>p->context</code>, поэтому при старте потока в регистре EIP будет адрес <code>forkret</code> и начнет выполняться она. После выполнения будет переход к инструкции, которая располагается сразу над <code>p->context</code>, то есть <code>trapret</code>. <code>trapret</code> восстанавливает значение регистров из значений, сохраненных наверху стэка и прыгает внутрь процесса.</p>\\n<p>Такая сложная конструкция нужна, потому что этот же код используется и для форков. А <code>trapret</code> нужен потому что переход из юзерспейса в ядро происходит через исключения, или, как они называются в x86, трэпы.</p>\\n<p>После создания процесса, ему указывается программа для выполнения, и в случае userinit это программа <code>initcode.s</code>.</p>\",\"frontmatter\":{\"path\":\"/blog/books/xv6\",\"title\":\"xv6\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---blog-books-xv-6-51534722ac9292fa84e3.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p><a href=\\\"https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf\\\">Комментарии к исходному коду</a></p>\\n<p><a href=\\\"https://pdos.csail.mit.edu/6.828/2018/xv6/xv6-rev11.pdf\\\">Исходный код</a></p>\\n<h1>xv6</h1>\\n<h2>Основные понятия</h2>\\n<h3>Процесс</h3>\\n<p>Память любого процесса состоит из 3 частей: инструкции, данные, стек.</p>\\n<h3>fork</h3>\\n<p>Создает новый процесс (child process), содержимое памяти которого идентично содержимому памяти вызывающего процесса (parent process). Но это не одна и та же память, это копия. Так как память у процессов одинаковая, значит одинаковые и инструкции, значит в обоих процессах выполнение продолжается со следующей инструкции. Только в child process функция fork возвращает 0, а в родительском - pid созданного процесса.</p>\\n<pre><code class=\\\"language-c\\\">int pid = fork();\\nif(pid > 0){\\n    printf(\\\"parent: child=%d\\\\n\\\", pid);\\n    pid = wait();\\n    printf(\\\"child %d is done\\\\n\\\", pid);\\n} else if(pid == 0){\\n    printf(\\\"child: exiting\\\\n\\\");\\n    exit();\\n} else {\\n    printf(\\\"fork error\\\\n\\\");\\n}\\n</code></pre>\\n<p><code>exit</code> - запускает процедуру выхода из процесса и освобождает ресурсы (память, открытые файлы)</p>\\n<p><code>wait</code> - ожидает завершения дочернего процесса и возвращает его pid.</p>\\n<p>В приведенном примере на экран будет выдано:</p>\\n<pre><code>parent: child=1234\\nchild: exiting\\nchild 1234 is done\\n</code></pre>\\n<h3>exec</h3>\\n<p>Принимает в качестве аргумента путь к исполняемому файлу и заменяет память вызывающего процесса на память, загруженную из этого файла. Файл должен быть в специальном формате (ELF), в котором указано начало секции инструкций, начало секции данных, с какой инструкции начать выполнение и т.д. Если вызов exec совершен удачно, то выполнение продолжится с той инструкции, которая указана первой к исполнению в загруженном файле.</p>\\n<p>Пример:</p>\\n<pre><code class=\\\"language-c\\\">char *argv[3];\\nargv[0] = \\\"echo\\\";\\nargv[1] = \\\"hello\\\";\\nargv[2] = 0;\\nexec(\\\"/bin/echo\\\", argv);\\nprintf(\\\"exec error\\\\n\\\");\\n</code></pre>\\n<p>Здесь исполняемая программа заменяется программой <code>/bin/echo</code>, которая получает в качестве списка аргументов <code>echo hello</code>.</p>\\n<h3>sh</h3>\\n<p>Шелл использует <code>fork</code> и <code>exec</code> для исполнения программ. В общем структура выполнения выглядит так:</p>\\n<pre><code class=\\\"language-c\\\">int\\nmain(void)\\n{\\n  static char buf[100];\\n\\n  while(getcmd(buf, sizeof(buf)) >= 0){\\n    if(fork1() == 0)\\n      runcmd(parsecmd(buf));\\n    wait();\\n  }\\n  exit();\\n}\\n\\nvoid\\nruncmd(struct cmd *cmd)\\n{\\n  struct execcmd *ecmd;\\n\\n  switch(cmd->type){  \\n    ...\\n  case EXEC:\\n    ecmd = (struct execcmd*)cmd;\\n    exec(ecmd->argv[0], ecmd->argv);\\n    printf(2, \\\"exec %s failed\\\\n\\\", ecmd->argv[0]);\\n    break;\\n    ...\\n  }\\n  exit();\\n}\\n</code></pre>\\n<ul>\\n<li><code>main</code> - делает дочерний процесс, в нем парсит команду, подает на выполнение</li>\\n<li><code>runcmd</code> - делает <code>exec</code>, заменяя текущий процесс (тот, который был создан форком в <code>main</code>) на исполняемый файл, указанный в команде</li>\\n</ul>\\n<p>После завершения дочернего процесса исполнение продолжается на инструкции, следующей за <code>wait()</code>.</p>\\n<h3>Дескрипторы файлов</h3>\\n<p>У каждого процесса свой набор дескрипторов файлов, начинающийся с 0. По соглашению, 0 - дескриптор стандартного ввода/stdin, 1 - стандартного вывода/stdout, 2 - дескриптор канала ошибок/stderr.</p>\\n<p>При открытии файла он всегда получает наименьший из неиспользуемых в текущем процессе дексрипторов.</p>\\n<p>Вот так, например, выглядит <code>cat</code>:</p>\\n<pre><code class=\\\"language-c\\\">char buf[512];\\n\\nvoid\\ncat(int fd)\\n{\\n  int n;\\n\\n  while((n = read(fd, buf, sizeof(buf))) > 0) { // читаем из указанного дескриптора\\n    if (write(1, buf, n) != n) {  // пишем в 1, то есть stdout\\n      printf(1, \\\"cat: write error\\\\n\\\");\\n      exit();\\n    }\\n  }\\n\\n  // error handling\\n  if(n &#x3C; 0){\\n    printf(1, \\\"cat: read error\\\\n\\\");\\n    exit();\\n  }\\n}\\n\\nint\\nmain(int argc, char *argv[])\\n{\\n  int fd, i;\\n\\n  if(argc &#x3C;= 1){ // если аргументов не указано, то читаем из 0, то есть stdin\\n    cat(0);\\n    exit();\\n  }\\n\\n  for(i = 1; i &#x3C; argc; i++){ // если аргументы есть, то открываем файлы по этим путям и читаем из дескрипторов этих файлов\\n    if((fd = open(argv[i], 0)) &#x3C; 0){\\n      printf(1, \\\"cat: cannot open %s\\\\n\\\", argv[i]);\\n      exit();\\n    }\\n    cat(fd);\\n    close(fd);\\n  }\\n  exit();\\n}\\n</code></pre>\\n<h4>Перенаправление I/O</h4>\\n<p><code>exec</code> заменяет содержимое памяти вызывающего процесса, но при этом <strong>оставляет неизменной его таблицу дескрипторов</strong>. Это позволяет реализовать перенаправление I/O. Вот, что происходит при вызове <code>cat &#x3C; input.txt</code>:</p>\\n<pre><code class=\\\"language-c\\\">char *argv[2];\\nargv[0] = \\\"cat\\\";\\nargv[1] = 0;\\nif(fork() == 0) {\\n    close(0);\\n    open(\\\"input.txt\\\", O_RDONLY);\\n    exec(\\\"cat\\\", argv);\\n}\\n</code></pre>\\n<p>Здесь используется правило \\\"При открытии файла он всегда получает наименьший из неиспользуемых в текущем процессе дексрипторов\\\". Когда вызывается <code>close(0)</code>, дескриптор 0 (stdin) освобождается, а значит следующая инструкция <code>open</code> назначит открытому файлу <code>input.txt</code> дексриптор 0. Затем вызывается программа <code>cat</code>, которая при вызове без аргументов читает содержимое из дескриптора 0.</p>\\n<p>В коде шелла этот кусок выглядит так:</p>\\n<pre><code class=\\\"language-c\\\">void\\nruncmd(struct cmd *cmd)\\n{\\n  struct redircmd *rcmd;\\n\\n    switch(cmd->type){\\n  ...\\n\\n  case REDIR:\\n    rcmd = (struct redircmd*)cmd;\\n    close(rcmd->fd);\\n    if(open(rcmd->file, rcmd->mode) &#x3C; 0){\\n      printf(2, \\\"open %s failed\\\\n\\\", rcmd->file);\\n      exit();\\n    }\\n    runcmd(rcmd->cmd);\\n    break;\\n    ...\\n  }\\n  exit();\\n}\\n\\n...\\n\\nstruct cmd*\\nparseredirs(struct cmd *cmd, char **ps, char *es)\\n{\\n  int tok;\\n  char *q, *eq;\\n\\n  while(peek(ps, es, \\\"&#x3C;>\\\")){\\n    tok = gettoken(ps, es, 0, 0);\\n    switch(tok){\\n    case '&#x3C;':\\n      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);\\n      break;\\n    case '>':\\n      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);\\n      break;\\n    case '+':  // >>\\n      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);\\n      break;\\n    }\\n  }\\n  return cmd;\\n}\\n</code></pre>\\n<p><code>rcmd</code> при парсинге получит <code>fd</code>, равный 0, при использовании <code>&#x3C;</code> и равный 1 при использовании <code>></code>. В ветке <code>REDIR</code> мы закрыли дексриптор, на который будем перенаправлять ввод или вывод, открыли нужный файл и вызвали <code>runcmd</code>, внутри которого будет использован <code>exec</code>.</p>\\n<h4>Использование дескрипторов в fork</h4>\\n<p>При форке таблица дескрипторов копируется, а сдвиги - шарятся между процессами. То есть следующий пример:</p>\\n<pre><code class=\\\"language-c\\\">if(fork() == 0) {\\n    write(1, \\\"hello \\\", 6);\\n    exit();\\n} else {\\n    wait();\\n    write(1, \\\"world\\\\n\\\", 6);\\n}\\n</code></pre>\\n<p>Выведет на экран <code>hello world</code>. </p>\\n<p>Благодаря этому мы можем писать: <code>(echo hello; echo world)>output.txt</code>. (хотя пока непонятно, почему тут должен вызываться fork, а не exec).</p>\\n<h4>dup</h4>\\n<p>Копирует дескриптор, после чего оба дескриптора шарят сдвиг.</p>\\n<p>То есть:</p>\\n<pre><code class=\\\"language-c\\\">fd = dup(1);\\nwrite(1, \\\"hello \\\", 6);\\nwrite(fd, \\\"world\\\\n\\\", 6);\\n</code></pre>\\n<p>тоже выведет <code>hello world</code>.</p>\\n<p>Таким образом, два дексриптора файла шарят между собой сдвиг только в том случае, если они были получены из одного и того же дескриптора вызовами <code>fork</code> и <code>dup</code>. Во всех остальных случаях сдвиги не шарятся.</p>\\n<p><code>dup</code> позволяет писать такие команды:</p>\\n<pre><code class=\\\"language-shell\\\">ls existing-file non-existing-file > tmp1 2>&#x26;1\\n</code></pre>\\n<p>Здесь <code>2>&#x26;1</code> как раз копирует дексриптор 1 в дескриптор 2, чтобы все ошибки выводились в stdout.</p>\\n<h3>pipes</h3>\\n<p>Вызов <code>pipe</code> принимает массив из двух элементов и записывает в него 2 дексриптора: первый - для чтения и второй - для записи. Все, что будет записано в дексриптор для записи, можно будет прочитать из дескриптора для чтения.</p>\\n<p>Пример использования <code>pipe</code>:</p>\\n<pre><code class=\\\"language-c\\\">int p[2];\\nchar *argv[2];\\nargv[0] = \\\"wc\\\";\\nargv[1] = 0;\\n\\npipe(p);\\nif(fork() == 0) {\\n    close(0);\\n    dup(p[0]);\\n    close(p[0]);\\n    close(p[1]);\\n    exec(\\\"/bin/wc\\\", argv);\\n} else {\\n    close(p[0]);\\n    write(p[1], \\\"hello world\\\\n\\\", 12);\\n    close(p[1]);\\n}\\n</code></pre>\\n<p>Здесь дочерний процесс закрывает <code>stdin</code>, дублирует дескриптор чтения из пайпа в дескриптор 0, закрывает дескриптор чтения и записи и запускает <code>wc</code>, который будет принимать ввод от дескриптора 0, то есть будет читать из пайпа.</p>\\n<p>Родительский процесс пишет в дескриптор записи и закрывает оба дескриптора пайпа.</p>\\n<p>Приблизительно так же выглядит и ветка <code>PIPE</code> в <code>runcmd</code>, только она создает 2 дочерних процесса:</p>\\n<pre><code class=\\\"language-c\\\">void\\nruncmd(struct cmd *cmd)\\n{\\n   struct pipecmd *pcmd;\\n \\n  switch(cmd->type){\\n    ...\\n  case PIPE:\\n    pcmd = (struct pipecmd*)cmd;\\n    if(pipe(p) &#x3C; 0)\\n      panic(\\\"pipe\\\");\\n    if(fork1() == 0){\\n      close(1);\\n      dup(p[1]);\\n      close(p[0]);\\n      close(p[1]);\\n      runcmd(pcmd->left);\\n    }\\n    if(fork1() == 0){\\n      close(0);\\n      dup(p[0]);\\n      close(p[0]);\\n      close(p[1]);\\n      runcmd(pcmd->right);\\n    }\\n    close(p[0]);\\n    close(p[1]);\\n    wait();\\n    wait();\\n    break;\\n    ...\\n  }\\n  exit();\\n}\\n</code></pre>\\n<p>В шелле пайпы используются при выполнении команд вида <code>grep fork sh.c | wc -l</code>.</p>\\n<p>Преимущества пайпов перед временными файлами:</p>\\n<ul>\\n<li>автоматическое очищение</li>\\n<li>можно передавать очень длинные потоки данных, не беспокоясь, что на диске кончится место</li>\\n<li>возможно параллельное выполнение левой и правой команды</li>\\n<li>для межпроцессного общения блокирующая модель записи и чтения пайпов удобнее, чем неблокирующая модель файлов</li>\\n</ul>\\n<h3>Файловая система</h3>\\n<p><code>fstat</code> - возвращает информацию о файле, на который указывает дескрриптор</p>\\n<p>У файла может быть несколько имен, или \\\"линков\\\". Сам файл называется <code>inode</code>. Линки создаются командой <code>link</code>, например:</p>\\n<pre><code class=\\\"language-c\\\">open(\\\"a\\\", O_CREATE|O_WRONLY);\\nlink(\\\"a\\\", \\\"b\\\");\\n</code></pre>\\n<p>После этого <code>a</code> и <code>b</code> ссылаются на один и тот же <code>inode</code> и запись/чтение в <code>a</code> равносильно записи/чтению в <code>b</code>.</p>\\n<p>Каждый айнод идентифицируется своим <code>inode number</code>. Его можно получить вызовом <code>fstat</code>.</p>\\n<p>Линки удаляются командой <code>unlink</code>. Айнод и место на диске очищаются только когда количество линков уменьшится до 0 и не останется дескрипторов, ссылающихся на него.</p>\\n<h2>Организация операционной системы</h2>\\n<h3>Загрузчик</h3>\\n<p>Загрузчик состоит из 2 частей: <code>bootasm.s</code>, написанный на ассемблере и <code>bootmain.c</code>, написанный на С.</p>\\n<p>Когда компьютер стартует, он выполняет программу BIOS, которая записана в энергонезависимой памяти материнской платы. BIOS подготавливает аппаратное обеспечение к работе и передает управление коду, записанному в загрузочный сектор, т.е. первый 512-байтовый сектор загрузочного диска. В этом секторе содержится загрузчик: инструкции по загрузке ядра в память. BIOS загружает содержимое загрузочного сектора в адрес <code>0x7c00</code> и переходит на этот адрес. Начинается исполнение файла <code>bootasm.s</code>.</p>\\n<p>Первая инструкция загрузчика - <code>cli</code>, которая отключает прерывания. BIOS возможно установил какие-то свои обработчики прерываний, чтобы инициализировать устройства, но мы уже покинули BIOS, поэтому они нам больше не нужны. Когда операционная система загрузится, она включит прерывания обратно.</p>\\n<p>Затем загрузчик должен перевести процессор из реального режима работы в защищенный.</p>\\n<p>После этого загрузчик переходит в <code>bootmain.c</code>.</p>\\n<p>Задача <code>bootmain.c</code> - загрузить и запустить ядро. Ядро должно быть в формате ELF. <code>bootmain</code> загружает первые 4096 байт из бинарника ELF и кладет их копию по адресу <code>0x10000</code>. Затем он проверяет, что это действительно ELF путем проверки магического числа в заголовке файла. Затем он проходит по всем сегментам файла, загружает их в память и переходит в точку входа в ядро, а именно <code>0x10000c</code>.</p>\\n<h3>Старт ядра</h3>\\n<p>Когда загрузчик передает управления в ядро, первая выполняемая инструкция - это <code>entry:</code> в файле <code>entry.s</code>. Первое, что делает ядро - это настраивает аппаратный пэйджинг. Добавляется маппинг виртуальных адресов, начинающихся с <code>0x80000000</code> на физические, начинающиеся с <code>0x0</code>:</p>\\n<pre><code class=\\\"language-asm\\\">  movl    $(V2P_WO(entrypgdir)), %eax\\n  movl    %eax, %cr3\\n</code></pre>\\n<p><code>V2P_WO</code>(virtual to physical) - это макрос, который отнимает от \\\"высокого\\\" адреса <code>entrypgdir</code> константу <code>0x80000000</code>. Это нужно, потому что у нас еще не работает маппинг виртуальных адресов, но ядро слинковано с их использованием.</p>\\n<p>Таблица страниц entrypgdir описана в main.c:</p>\\n<pre><code class=\\\"language-c\\\">__attribute__((__aligned__(PGSIZE)))\\npde_t entrypgdir[NPDENTRIES] = {\\n  // Map VA's [0, 4MB) to PA's [0, 4MB)\\n  [0] = (0) | PTE_P | PTE_W | PTE_PS,\\n  // Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)\\n  [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,\\n};\\n</code></pre>\\n<p>Затем ядро включает аппаратный пейджинг:</p>\\n<pre><code>  orl     $(CR0_PG|CR0_WP), %eax\\n  movl    %eax, %cr0\\n</code></pre>\\n<p>Ну и наконец мы переходим в <code>main.c</code>:</p>\\n<pre><code class=\\\"language-asm\\\">  # Set up the stack pointer.\\n  movl $(stack + KSTACKSIZE), %esp\\n\\n  # Jump to main(), and switch to executing at\\n  # high addresses. The indirect call is needed because\\n  # the assembler produces a PC-relative instruction\\n  # for a direct jump.\\n  mov $main, %eax\\n  jmp *%eax\\n</code></pre>\\n<h3>Создание первого процесса</h3>\\n<p>Процесс описывается следующей структурой:</p>\\n<pre><code class=\\\"language-c\\\">// Per-process state\\nstruct proc {\\n  uint sz;                     // Size of process memory (bytes)\\n  pde_t* pgdir;                // Page table\\n  char *kstack;                // Bottom of kernel stack for this process\\n  enum procstate state;        // Process state\\n  int pid;                     // Process ID\\n  struct proc *parent;         // Parent process\\n  struct trapframe *tf;        // Trap frame for current syscall\\n  struct context *context;     // swtch() here to run process\\n  void *chan;                  // If non-zero, sleeping on chan\\n  int killed;                  // If non-zero, have been killed\\n  struct file *ofile[NOFILE];  // Open files\\n  struct inode *cwd;           // Current directory\\n  char name[16];               // Process name (debugging)\\n};\\n\\nstruct context {\\n  uint edi;\\n  uint esi;\\n  uint ebx;\\n  uint ebp;\\n  uint eip;\\n};\\n</code></pre>\\n<p><code>main</code> инициализирует кучу устройств и подсистем:</p>\\n<pre><code class=\\\"language-c\\\">// Bootstrap processor starts running C code here.\\n// Allocate a real stack and switch to it, first\\n// doing some setup required for memory allocator to work.\\nint\\nmain(void)\\n{\\n  kinit1(end, P2V(4*1024*1024)); // phys page allocator\\n  kvmalloc();      // kernel page table\\n  mpinit();        // detect other processors\\n  lapicinit();     // interrupt controller\\n  seginit();       // segment descriptors\\n  picinit();       // disable pic\\n  ioapicinit();    // another interrupt controller\\n  consoleinit();   // console hardware\\n  uartinit();      // serial port\\n  pinit();         // process table\\n  tvinit();        // trap vectors\\n  binit();         // buffer cache\\n  fileinit();      // file table\\n  ideinit();       // disk \\n  startothers();   // start other processors\\n  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()\\n  userinit();      // first user process\\n  mpmain();        // finish this processor's setup\\n}\\n</code></pre>\\n<p>Первый процесс создается вызовом <code>userinit()</code>, который вызывает <code>allocproc()</code>. Задача <code>allocproc()</code> - аллоцировать структуру типа <code>proc</code> в системной таблице процессов и инициализировать части состояния процесса, чтобы он мог запуститься. <code>allocproc()</code> запускается для каждого нового процесса, а <code>userinit()</code> - только для первого.</p>\\n<pre><code class=\\\"language-c\\\">// Look in the process table for an UNUSED proc.\\n// If found, change state to EMBRYO and initialize\\n// state required to run in the kernel.\\n// Otherwise return 0.\\nstatic struct proc*\\nallocproc(void)\\n{\\n  struct proc *p;\\n  char *sp;\\n\\n  acquire(&#x26;ptable.lock);\\n\\n  for(p = ptable.proc; p &#x3C; &#x26;ptable.proc[NPROC]; p++)\\n    if(p->state == UNUSED)\\n      goto found;\\n\\n  release(&#x26;ptable.lock);\\n  return 0;\\n\\nfound:\\n  p->state = EMBRYO;\\n  p->pid = nextpid++;\\n\\n  release(&#x26;ptable.lock);\\n\\n  // Allocate kernel stack.\\n  if((p->kstack = kalloc()) == 0){\\n    p->state = UNUSED;\\n    return 0;\\n  }\\n  sp = p->kstack + KSTACKSIZE;\\n\\n  // Leave room for trap frame.\\n  sp -= sizeof *p->tf;\\n  p->tf = (struct trapframe*)sp;\\n\\n  // Set up new context to start executing at forkret,\\n  // which returns to trapret.\\n  sp -= 4;\\n  *(uint*)sp = (uint)trapret;\\n\\n  sp -= sizeof *p->context;\\n  p->context = (struct context*)sp;\\n  memset(p->context, 0, sizeof *p->context);\\n  p->context->eip = (uint)forkret;\\n\\n  return p;\\n}\\n</code></pre>\\n<ul>\\n<li>регистр EIP в x86 означает Extended Instruction Pointer</li>\\n</ul>\\n<p>Allocproc:</p>\\n<ol>\\n<li>ищет в таблице процессов слот с состоянием UNUSED</li>\\n<li>когда находит, устанавливает ему состояние EMBRYO и дает процессу уникальный pid.</li>\\n<li>затем пытается выделить в памяти 4096 байт для ядерного стека процесса. Если не получается, то выставляет состояние обратно в UNUSED и возвращает 0.</li>\\n<li>если получилось, то поля структуры proc инициализируются адресами в стеке для trap frame, trapret, context. В результате полученный ядерный стек выглядит так:</li>\\n</ol>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/d05989cf0b10a4cc4b2d7a61cf6fb487/f7060/new-kernel-stack.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 325px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 105.23076923076921%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsSAAALEgHS3X78AAACPElEQVQ4y5VVia7iMAzk/38NCR4rbomr9L6gB6XlmvX4vfLYcm6kyGlCJvZ4bFr4GZfLRe3pdITnuYjCEI7rwfN9eK4Lx3FQlhWyLENVVTgcDnqHlt/H41Hvtx4BmuYaYeDDth0FWq8NWKaJNM3Q+/pCFEWIZY7HY8SbjeynCIJAQa+At6CvRlEUCriJY/T7fSQCVhQ7+BJJWZb3HtI+mufzWc834pFlWQoaBCFiAebatm0NvfXKmxrs9sEkSbDdbtXDTqeDPN9hv98jFM4/AmwCE4yXmRyu8zzXyZAV8FmIt/N28HIggEmyhWGskAow9zzPe+9hPdI0wXKx1EwOBgPNvCVKaLfbcD1feb1yuFqtsFjM5TVDyV7MuTZhyutr04L5s0dL/obDoUgqwHQ6xZ9eTx8oir3uKaAromX8tNSU73vqCYUdRbHyxfVWwBgaAfm7MAzQ7XZVNrvd7pdD/OeoLzMhhrFWUTNBVw4/TcZtUsgh9UfeyB/BuffQw98SPEnIofI6XyywXK7Um9lsho0AxHLWEw7TjDoslKaXgKyMLEs1EcqjVAO9G41G+s0SZPjce8vhq5rmJdZsc5DHf2r5k5r+1mSq3jUHI3kI+K4Ms4wh5nAdG9PJBOPJFJX0xKcePvOy7ja8WAhnBGVPDEWrPKfnCtgMqWkfyYbd5b4803sPm2Bl+V1SFC0rqKwOor9Is1orofacWlRA6o0AtM1WxabgCFdzqeWlaDEII+3S7DYUdj31L0Eswf8C0/9bMV1u3ygAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"New kernel stack\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/d05989cf0b10a4cc4b2d7a61cf6fb487/f7060/new-kernel-stack.png\\\"\\n        srcset=\\\"/hows-that-again/static/d05989cf0b10a4cc4b2d7a61cf6fb487/c5e8e/new-kernel-stack.png 163w,\\n/hows-that-again/static/d05989cf0b10a4cc4b2d7a61cf6fb487/f7060/new-kernel-stack.png 325w\\\"\\n        sizes=\\\"(max-width: 325px) 100vw, 325px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>После заполнения стэка в <code>p->context->eip</code> будет адрес функции <code>forkret</code>, а над контекстом, там, где обычно пишется адрес возврата - будет адрес функции <code>trapret</code>. Созданный поток начинает выполнение со значениями регистров, скопированными из <code>p->context</code>, поэтому при старте потока в регистре EIP будет адрес <code>forkret</code> и начнет выполняться она. После выполнения будет переход к инструкции, которая располагается сразу над <code>p->context</code>, то есть <code>trapret</code>. <code>trapret</code> восстанавливает значение регистров из значений, сохраненных наверху стэка и прыгает внутрь процесса.</p>\\n<p>Такая сложная конструкция нужна, потому что этот же код используется и для форков. А <code>trapret</code> нужен потому что переход из юзерспейса в ядро происходит через исключения, или, как они называются в x86, трэпы.</p>\\n<p>После создания процесса, ему указывается программа для выполнения, и в случае userinit это программа <code>initcode.s</code>.</p>\",\"frontmatter\":{\"path\":\"/blog/books/xv6\",\"title\":\"xv6\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/blog-books-xv-6.json\n// module id = 421\n// module chunks = 160831456888542"],"sourceRoot":""}