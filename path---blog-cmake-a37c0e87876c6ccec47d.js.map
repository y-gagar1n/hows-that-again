{"version":3,"sources":["webpack:///path---blog-cmake-a37c0e87876c6ccec47d.js","webpack:///./.cache/json/blog-cmake.json"],"names":["webpackJsonp","421","module","exports","data","markdownRemark","html","frontmatter","path","title","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,kijBAA09hBC,aAAgrBC,KAAA,cAAAC,MAAA,WAAuCC","file":"path---blog-cmake-a37c0e87876c6ccec47d.js","sourcesContent":["webpackJsonp([226785351346532],{\n\n/***/ 421:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>CMake</h1>\\n<p>Туториал: <a href=\\\"https://cliutils.gitlab.io/modern-cmake/\\\">https://cliutils.gitlab.io/modern-cmake/</a></p>\\n<p>Набор популярных хелперов: <a href=\\\"https://github.com/CLIUtils/cmake\\\">https://github.com/CLIUtils/cmake</a> (добавляется в проект командой <code>set(CMAKE_MODULE_PATH \\\"${PROJECT_SOURCE_DIR}/cmake\\\" ${CMAKE_MODULE_PATH})</code>)</p>\\n<h2>Опции</h2>\\n<p>Опция может быть установлена через <code>-D</code>, например, <code>cmake -DCMAKE_BUILD_TYPE=Build</code>.</p>\\n<p>Полный список опций можно получить через <code>cmake -L</code> или <code>cmake -LH</code>. Второй вариант выдаст комментарии к каждой опции, если они указаны в скриптах. При первом запуске эти команды совершат запуск CMake, сгенерят все артефакты и только после этого выдадут список опций, не пугайтесь.</p>\\n<p>Все опции перечислены <a href=\\\"https://cmake.org/cmake/help/v3.0/manual/cmake-variables.7.html\\\">здесь</a></p>\\n<h3>Основные опции</h3>\\n<ul>\\n<li><code>CMAKE_BUILD_TYPE</code> - тип билда: Release, RelWithDebInfo, Debug и т.д.</li>\\n<li><code>PROJECT_SOURCE_DIR</code> - полный путь к текущему проекту. Будет итерироваться по папкам вверх, пока не найдет CMakeLists.txt, в котором есть инструкция <strong>project</strong></li>\\n<li><code>CMAKE_CURRENT_SOURCE_DIR</code> - полный путь к папке, которая обрабатывается cmake-ом (то есть если вызвали <strong>cmake /proj/a</strong>, то там будет <strong>/proj/a</strong>). Когда делаем библиотеку, лучше использовать эту опцию вместо <code>PROJECT_SOURCE_DIR</code>, чтобы облегчить клиентам включение нашего CMake проекта как субмодуля.</li>\\n<li><code>PROJECT_BINARY_DIR</code> - полный путь к папке билда проекта. Обычно это папка, откуда запускаем cmake.</li>\\n<li><code>CMAKE_INSTALL_PREFIX</code> - путь, куда будет установлена программа при <strong>make install</strong></li>\\n<li><code>CMAKE_COMMAND</code> - полный путь к cmake</li>\\n<li><code>PROJECT_NAME</code> - имя проекта, указанное в команде <code>project</code></li>\\n</ul>\\n<h2>Команды</h2>\\n<h3>Основные команды</h3>\\n<ul>\\n<li><code>project(learncmake C)</code> - устанавливает переменную <code>$PROJECT_NAME</code>. Вторым аргументов передается язык.</li>\\n<li><code>include_directories( include )</code> - подключает инклюды, то есть папки, в которых искать заголовочные файлы. Равнозначно <code>-I</code> в <strong>GCC</strong>. Это глобальная команда, поэтому не рекомендуется к использованию.</li>\\n<li><code>target_include_directories(one PUBLIC include)</code> - подключает инклюды для указанного первым аргументом таргета. <code>PUBLIC</code> означает, что все таргеты, которые ссылаются на этот, должны так же включать эту директорию. Другие варианты - <code>PRIVATE</code> (только текущий таргет) и <code>INTERFACE</code> (только зависимости).</li>\\n<li><code>include(ext.cmake)</code> - загружает и запускает скрипт cmake из указанного файла</li>\\n<li><code>set(KEY VALUE)</code> - установка переменных</li>\\n<li><code>set(SOURCES main.c a.c b.c)</code> - установка списка <code>[main.c a.c b.c]</code> в качестве значения переменной SOURCES</li>\\n<li><code>${SOURCES}</code> - обращение к значению переменной SOURCES</li>\\n<li><code>configure_file ( \\\"a.h.in\\\" \\\"a.h\\\" )</code> - берет файл <strong>a.h.in</strong>, подставляет туда значения переменных CMake и сохраняет как <strong>a.h</strong>. В файлах на них нужно ссылаться как: <code>${PROJECT_SOURCE_DIR}</code> или <code>@PROJECT_SOURCE_DIR@</code>. Строчки вида <code>#cmakedefine VAR ...</code> будут заменены либо на <code>#define VAR ...</code> либо на <code>/* #undef VAR */</code> в зависимости от того, установлено ли значение <code>VAR</code> в ложь (в том смысле, в котором if считает выражения ложью)</li>\\n<li><code>add_subdirectory(source_dir)</code> - включение папки со своим CMakeLists.txt в билд. Путь может быть относительным или абсолютным. Если CMakeLists.txt найден в папке, то CMake его обработает сразу же, прежде чем перейдет к следующей команде.</li>\\n<li><code>find_program(YASM_EXE NAMES yasm)</code> - ищет программу yasm и сохраняет путь к ней в переменной <strong>YASM_EXE</strong></li>\\n<li><code>find_package(SWIG REQUIRED)</code> - находит внешний проект и загружает оттуда его переменные. Например, после загрузки SWIG будет проинициализирована <strong>SWIG_EXECUTABLE</strong>. Список экспортируемых переменных можно найти на странице <strong>Find[package_name]</strong> в <a href=\\\"https://cmake.org/cmake/help/v3.2/module/FindSWIG.html\\\">документации CMake</a>, или в <a href=\\\"https://github.com/Kitware/CMake/blob/master/Modules/FindSWIG.cmake\\\">исходниках</a></li>\\n<li><code>message(STATUS \\\"hello\\\")</code> - вывод сообщения, первый аргумент задает уровень из списка STATUS/WARNING/AUTHOR_WARNING/SEND_ERROR/FATAL_ERROR</li>\\n<li><code>option(VSDK_CPU_ONLY \\\"set to true in only cpu should be used\\\" OFF)</code> - опция, которую пользователь может задать при вызове cmake: <code>cmake . -DVSDK_CPU_ONLY=On</code>. Второй аргумент - словесное описание, третий - дефолтное значение. Обращаться к опции потом можно по имени: <code>if(VSDK_CPU_ONLY) ...</code></li>\\n<li><code>install( TARGETS ${PROJECT_NAME}_firbuilder DESTINATION bin)</code> - задает правила установки. Первый аргумент задает таргет, второй - задает путь установки. Если относительный, то будет аппенднут к <code>$CMAKE_INSTALL_PREFIX</code></li>\\n<li><code>find_package(package [REQUIRED])</code> - ищет и загружает свойства внешнего проекта. В папке <code>${CMAKE_MODULE_PATH}</code> будет искаться файл <code>Find&#x3C;package>.cmake</code>. Если найден, то будет тут же обработан cmake-ом. Если такой файл не найден, то ищется конфиг под именем <code>&#x3C;name>Config.cmake</code> или <code>&#x3C;lower-case-name>-config.cmake</code></li>\\n<li><code>list(APPEND LIBS ${vsd_LIBRARY})</code> - функция list описывает операции со списками. Первый аргумент обозначает операцию, в данном случае - append.</li>\\n<li><code>add_custom_target(makedir1 ALL COMMAND ${CMAKE_COMMAND} DEPENDS target1 -E make_directory \\\"${PROJECT_BINARY_DIR}/src/ssd\\\")</code> - добавляет таргет без аутпута, то есть он будет выполняться всегда. Первый аргумент - имя таргета. <code>ALL</code> означает, что таргет будет добавлен в таргет all. <code>COMMAND</code> - задает команду, все что после нее - тело команды. <code>DEPENDS</code> - задает другие таргеты, от которых зависит этот. Когда строится этот таргет, будут построены и все, перечисленные в <code>DEPENDS</code>. <code>-E</code> означает запуск cmake в командном режиме, <code>make_directory</code> - команда создания папки.</li>\\n<li><code>add_custom_command( OUTPUT ${SRC_ASM}.o COMMAND ${YASM_EXE} ARGS -p ${SRC_ASM_INPUT}.asm DEPENDS source.cpp)</code> - работает на этапе генерации, добавляет кастомную команду для генерации аутпута. <code>OUTPUT</code> задает аутпут, для генерации которого указывается команда (команда не обязательно должна создавать этот аутпут, здесь мы всего лишь указываем, какого аутпута мы от нее ожидаем), <code>COMMAND</code> - команду, а <code>ARGS</code> - аргументы. <code>DEPENDS</code> - задает список файлов или таргетов, от которых зависит эта команда.</li>\\n<li><code>string(TOUPPER ${STR_INPUT} STR_OUTPUT)</code> - провести операцию, указанную первым аргументом, на значении, указанном во втором аргументе, и сохранить результат в переменную, указанную в третьем.</li>\\n<li><code>execute_process(COMMAND ${GIT_EXECUTABLE} submodule update --init --recursive WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} RESULT_VARIABLE GIT_SUBMOD_RESULT)</code> - работает на этапе конфигурации, запускает внешний процесс, в данном случае обновляет сабмодули гита. Путь к файлу процесса лучше не хардкодить, а найти заранее командой типа <code>find_package(Git)</code>. Если же нужно запустить команду на этапе генерации, например, скопировать папку или запустить скрипт для генерации каких-то файлов, то нужно использовать команду <code>add_custom_command</code>.</li>\\n</ul>\\n<h3>Вызовы компилятора</h3>\\n<ul>\\n<li><code>add_executable( ${EXE_NAME} ${SOURCES} )</code> - создает вызываемый файл на основании файлов, перечисленных в <code>SOURCES</code>. Первый аргумент будет использован как имя таргета и имя полученного исполняемого файла.</li>\\n<li><code>add_library( ${LIB_NAME} ${LIBS_SOURCES})</code> - создает библиотеку на основании файлов, перечисленных в <code>SOURCES</code>. По умолчанию создает статическую (если не указана опция <code>BUILD_SHARED_LIBS</code>). Если нужно разделяемую, то нужно указать тип: <code>add_library( ${LIB_NAME} SHARED ${LIBS_SOURCES})</code></li>\\n<li><code>target_link_libraries( ${TARGET_NAME} ${LIB_NAME} )</code> - линкует библиотеки и исполняемые файлы. Первый аргумент - это таргет, он должен предварительно быть создан командой <code>add_executable()</code> или <code>add_library()</code>. Остальные аргументы - имена таргетов или библиотек. В результате <code>TARGET_NAME</code> будет зависеть от <code>LIB_NAME</code>.</li>\\n<li><code>add_definitions( --std=c99)</code> - добавление флагов для компилятора</li>\\n</ul>\\n<h3>Условия</h3>\\n<ul>\\n<li><code>if( CAFFE_ROOT)</code> - проверка, установлена ли переменная CAFFE_ROOT</li>\\n<li><code>if( NOT CAFFE_ROOT)</code> - проверка, что не установлена переменная CAFFE_ROOT</li>\\n<li><code>if( CAFFE_ROOT STREQUAL \\\"\\\")</code> - проверка, что переменная CAFFE_ROOT равна \\\"\\\"</li>\\n</ul>\\n<h2>Generator expressions</h2>\\n<p>Билд состоит из 2 шагов:</p>\\n<ol>\\n<li>Этап конфигурации</li>\\n<li>Этап генерации</li>\\n</ol>\\n<p>Когда мы билдим для нескольких платформ или для нескольких конфигураций, некоторые значения (имена, пути аутпутов) нам могут быть известны только на этапе генерации. Для работы с ними существуют т.н. generator expressions, имеющие форму <code>$&#x3C;KEYWORD></code> или <code>$&#x3C;KEYWORD:value></code>. Keywords берутся из константного множества и у всех этих выражений разная семантика, смотреть <a href=\\\"https://cmake.org/cmake/help/v3.4/manual/cmake-generator-expressions.7.html#id4\\\">здесь</a></p>\\n<p>Некоторые из выражений возвращают 0 или 1 и тогда они могут быть сами использованы в качестве keyword:</p>\\n<pre><code>target_compile_options(MyTarget PRIVATE \\\"$&#x3C;$&#x3C;CONFIG:Debug>:--my-flag>\\\")\\n</code></pre>\\n<p>Здесь флаг <code>--my-flag</code> будет применен, если использована конфигурация билда Debug.</p>\\n<p>Когда используются:</p>\\n<ul>\\n<li>когда нужно что-то сделать только для конкретного языка</li>\\n<li>когда нужно что-то сделать в зависимости от конфигурации билда</li>\\n<li>когда нужно указать различные локации для построения и установки</li>\\n</ul>\\n<h2>Функции</h2>\\n<pre><code>function(SIMPLE REQUIRED_ARG)\\n    message(STATUS \\\"Simple arguments: ${REQUIRED_ARG}, followed by ${ARGV}\\\")\\n    set(${REQUIRED_ARG} \\\"From SIMPLE\\\" PARENT_SCOPE)\\nendfunction()\\n\\nsimple(This)\\nmessage(\\\"Output: ${This}\\\")\\n</code></pre>\\n<p>Аргументы внутри функции можно специфицировать командой <code>cmake_parse_arguments</code>:</p>\\n<pre><code>function(COMPLEX)\\ncmake_parse_arguments(\\n    COMPLEX_PREFIX\\n    \\\"SINGLE;ANOTHER\\\"\\n    \\\"ONE_VALUE;ALSO_ONE_VALUE\\\"\\n    \\\"MULTI_VALUES\\\"\\n    ${ARGN}\\n)\\n\\nendfunction()\\n\\ncomplex(SINGLE ONE_VALUE value MULTI_VALUES some other values)\\n</code></pre>\\n<p>После вызова внутри функции <code>simple</code> будут следующие аргументы:</p>\\n<pre><code>COMPLEX_PREFIX_SINGLE = TRUE\\nCOMPLEX_PREFIX_ANOTHER = FALSE\\nCOMPLEX_PREFIX_ONE_VALUE = \\\"value\\\"\\nCOMPLEX_PREFIX_ALSO_ONE_VALUE = &#x3C;UNDEFINED>\\nCOMPLEX_PREFIX_MULTI_VALUES = \\\"some;other;values\\\"\\n</code></pre>\\n<p>Все оставшиеся аргументы будут в переменной <code>COMPLEX_PREFIX_UNPARSED_ARGUMENTS</code>.</p>\\n<h2>Чтение опций из файлов</h2>\\n<p>Допустим, версия проекта хранится в файле <code>Version.hpp</code> и мы хотим ее оттуда прочитать в наш скрипт CMake.</p>\\n<pre><code>set(VERSION_REGEX \\\"#define MY_VERSION[ \\\\t]+\\\\\\\"(.+)\\\\\\\"\\\")   // создаем регэксп для чтения и сохраняем в переменной VERSION_REGEX\\n\\nfile(STRINGS \\\"${CMAKE_CURRENT_SOURCE_DIR}/include/My/Version.hpp\\\"\\n    VERSION_STRING REGEX ${VERSION_REGEX})  // читаем файл, обрабатываем нашим регэкспом, результат сохраняем в переменную VERSION_STRING\\n\\nstring(REGEX REPLACE ${VERSION_REGEX} \\\"\\\\\\\\1\\\" VERSION_STRING \\\"${VERSION_STRING}\\\") // если найдено несколько версий, берем первую\\n\\nproject(My LANGUAGES CXX VERSION ${VERSION_STRING}) // задаем версию проекта\\n</code></pre>\\n<h2>C++11</h2>\\n<p>вот так можно установить версию языка (выбор между <code>cxx_std_11</code>, <code>cxx_std_14</code>, <code>cxx_std_17</code>):</p>\\n<pre><code>target_compile_features(myTarget PUBLIC cxx_std_11)\\nset_target_properties(myTarget PROPERTIES CXX_EXTENSIONS OFF)\\n</code></pre>\\n<p>Вторая строчка необязательна, но облегчит жизнь, без нее будет использован флаг <code>-std=g++11</code> вместо <code>-std=c++11</code>.</p>\\n<p>Есть и другой способ:</p>\\n<pre><code>set(CMAKE_CXX_STANDARD 11)\\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\\nset(CMAKE_CXX_EXTENSIONS OFF)\\n</code></pre>\\n<p>первая строчка устанавливает стандарт, а вторая указывает, что нужно его использовать. Однако этот метод не стоит использовать для сборки библиотек.</p>\\n<h2>Субмодули гита</h2>\\n<p>Вот так выкачиваем субмодули при построении:</p>\\n<pre><code>find_package(Git QUIET)\\nif(GIT_FOUND AND EXISTS \\\"${PROJECT_SOURCE_DIR}/.git\\\")\\n# Update submodules as needed\\n    option(GIT_SUBMODULE \\\"Check submodules during build\\\" ON)\\n    if(GIT_SUBMODULE)\\n        message(STATUS \\\"Submodule update\\\")\\n        execute_process(COMMAND ${GIT_EXECUTABLE} submodule update --init --recursive\\n                        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\\n                        RESULT_VARIABLE GIT_SUBMOD_RESULT)\\n        if(NOT GIT_SUBMOD_RESULT EQUAL \\\"0\\\")\\n            message(FATAL_ERROR \\\"git submodule update --init failed with ${GIT_SUBMOD_RESULT}, please checkout submodules\\\")\\n        endif()\\n    endif()\\nendif()\\n\\nif(NOT EXISTS \\\"${PROJECT_SOURCE_DIR}/extern/repo/CMakeLists.txt\\\")\\n    message(FATAL_ERROR \\\"The submodules were not downloaded! GIT_SUBMODULE was turned off or failed. Please update submodules and try again.\\\")\\nendif()\\n</code></pre>\\n<p>А так включаем проект в процесс билда:</p>\\n<pre><code>add_subdirectory(extern/repo)\\n</code></pre>\\n<h3>Бонус: сохранение версии субмодуля в переменную</h3>\\n<pre><code>execute_process(COMMAND ${GIT_EXECUTABLE} rev-parse --short HEAD\\n                WORKING_DIRECTORY \\\"${CMAKE_CURRENT_SOURCE_DIR}\\\"\\n                OUTPUT_VARIABLE PACKAGE_GIT_VERSION\\n                ERROR_QUIET\\n                OUTPUT_STRIP_TRAILING_WHITESPACE)\\n</code></pre>\\n<h2>Часто используемые утилиты</h2>\\n<p>Набор часто используемых утилит можно использовать через команду <code>cmake -E &#x3C;mode></code> в <code>add_custom_command</code>. </p>\\n<p>Список утилит можно найти <a href=\\\"https://cmake.org/cmake/help/latest/manual/cmake.1.html#run-a-command-line-tool\\\">здесь</a>.</p>\\n<h2>Рекомендуемая структура проекта</h2>\\n<p>Если наш проект называется <code>projects</code>, библиотека в нем называется <code>lib</code>, а исполняемый файл - <code>app</code>, то рекомендуется следующая структура:</p>\\n<pre><code>- project\\n  - .gitignore\\n  - README.md\\n  - LICENCE.md\\n  - CMakeLists.txt\\n  - cmake\\n    - FindSomeLib.cmake\\n  - include\\n    - project\\n      - lib.hpp\\n  - src\\n    - CMakeLists.txt\\n    - lib.cpp\\n  - apps\\n    - CMakeLists.txt\\n    - app.cpp\\n  - tests\\n    - testlib.cpp\\n  - docs\\n    - Doxyfile.in\\n  - extern\\n    - googletest\\n  - scripts\\n    - helper.py\\n</code></pre>\\n<p><code>CMakeLists.txt</code> есть почти во всех папках с <strong>.cpp</strong> и нет в папке <code>include</code>. Это потому что содержимое папки <code>include</code> должно копироваться в <code>/usr/include</code> как есть и не содержать никаких лишних файлов. По этой же причине, в папке <code>include</code> выделена папка для нашего проекта - чтобы наверняка не было конфликтов.</p>\\n<p>В папке <code>extern</code> должны лежать внешние зависимости в виде субмодулей гита.</p>\\n<p>В <code>.gitignore</code> должна быть строчка <code>/build*</code>.</p>\\n<h2>Пример</h2>\\n<pre><code>cmake_minimum_required(VERSION 3.8)\\n\\nproject(Calculator LANGUAGES CXX)\\n\\nadd_library(calclib STATIC src/calclib.cpp include/calc/lib.hpp)   // создаем таргет calclib, который будет статической библиотекой, собираемой из файлов src/calclib.cpp и include/calc/lib.hpp\\n\\ntarget_include_directories(calclib PUBLIC include)  // подключаем папку include с заголовками, которые могут понадобиться при билде таргета/библиотеки calclib\\n\\ntarget_compile_features(calclib PUBLIC cxx_std_11)  // указываем флаги компиляции для таргета calclib\\n\\nadd_executable(calc apps/calc.cpp)  // создаем таргет calc, который будет исполняемым файлом, собираемым из файла apps/calc.cpp\\n\\ntarget_link_libraries(calc PUBLIC calclib)  // указываем, что таргет/исполняемый файл calc зависит от таргета/либы calclib\\n</code></pre>\\n<p>Другой пример:</p>\\n<pre><code>find_package(PythonInterp REQUIRED)\\nadd_custom_command(OUTPUT \\\"${CMAKE_CURRENT_BINARY_DIR}/include/Generated.hpp\\\"\\n    COMMAND \\\"${PYTHON_EXECUTABLE}\\\" \\\"${CMAKE_CURRENT_SOURCE_DIR}/scripts/GenerateHeader.py\\\" --argument\\n    DEPENDS some_target)\\n\\nadd_custom_target(generate_header ALL\\n    DEPENDS \\\"${CMAKE_CURRENT_BINARY_DIR}/include/Generated.hpp\\\")\\n\\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/include/Generated.hpp DESTINATION include)\\n</code></pre>\\n<p>Здесь, при запуске <code>cmake</code> без указания таргета будет запущен таргет <code>generate_header</code> (так как ему указано <code>ALL</code>). Он зависит от <code>Generated.hpp</code>, который указан как <code>OUTPUT</code> команды во второй строчке. Но эта команда сама зависит от таргета <code>some_target</code> (здесь не указан). Когда будет построен <code>some_target</code>, команда запуститься, запустит процесс питона, подаст в него скрипт <code>GenerateHeader.py</code>, питон сгенерит файл <code>include/Generated.hpp</code>, после чего таргет <code>generate_header</code> будет завершен.</p>\",\"frontmatter\":{\"path\":\"/blog/cmake\",\"title\":\"CMake\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---blog-cmake-a37c0e87876c6ccec47d.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>CMake</h1>\\n<p>Туториал: <a href=\\\"https://cliutils.gitlab.io/modern-cmake/\\\">https://cliutils.gitlab.io/modern-cmake/</a></p>\\n<p>Набор популярных хелперов: <a href=\\\"https://github.com/CLIUtils/cmake\\\">https://github.com/CLIUtils/cmake</a> (добавляется в проект командой <code>set(CMAKE_MODULE_PATH \\\"${PROJECT_SOURCE_DIR}/cmake\\\" ${CMAKE_MODULE_PATH})</code>)</p>\\n<h2>Опции</h2>\\n<p>Опция может быть установлена через <code>-D</code>, например, <code>cmake -DCMAKE_BUILD_TYPE=Build</code>.</p>\\n<p>Полный список опций можно получить через <code>cmake -L</code> или <code>cmake -LH</code>. Второй вариант выдаст комментарии к каждой опции, если они указаны в скриптах. При первом запуске эти команды совершат запуск CMake, сгенерят все артефакты и только после этого выдадут список опций, не пугайтесь.</p>\\n<p>Все опции перечислены <a href=\\\"https://cmake.org/cmake/help/v3.0/manual/cmake-variables.7.html\\\">здесь</a></p>\\n<h3>Основные опции</h3>\\n<ul>\\n<li><code>CMAKE_BUILD_TYPE</code> - тип билда: Release, RelWithDebInfo, Debug и т.д.</li>\\n<li><code>PROJECT_SOURCE_DIR</code> - полный путь к текущему проекту. Будет итерироваться по папкам вверх, пока не найдет CMakeLists.txt, в котором есть инструкция <strong>project</strong></li>\\n<li><code>CMAKE_CURRENT_SOURCE_DIR</code> - полный путь к папке, которая обрабатывается cmake-ом (то есть если вызвали <strong>cmake /proj/a</strong>, то там будет <strong>/proj/a</strong>). Когда делаем библиотеку, лучше использовать эту опцию вместо <code>PROJECT_SOURCE_DIR</code>, чтобы облегчить клиентам включение нашего CMake проекта как субмодуля.</li>\\n<li><code>PROJECT_BINARY_DIR</code> - полный путь к папке билда проекта. Обычно это папка, откуда запускаем cmake.</li>\\n<li><code>CMAKE_INSTALL_PREFIX</code> - путь, куда будет установлена программа при <strong>make install</strong></li>\\n<li><code>CMAKE_COMMAND</code> - полный путь к cmake</li>\\n<li><code>PROJECT_NAME</code> - имя проекта, указанное в команде <code>project</code></li>\\n</ul>\\n<h2>Команды</h2>\\n<h3>Основные команды</h3>\\n<ul>\\n<li><code>project(learncmake C)</code> - устанавливает переменную <code>$PROJECT_NAME</code>. Вторым аргументов передается язык.</li>\\n<li><code>include_directories( include )</code> - подключает инклюды, то есть папки, в которых искать заголовочные файлы. Равнозначно <code>-I</code> в <strong>GCC</strong>. Это глобальная команда, поэтому не рекомендуется к использованию.</li>\\n<li><code>target_include_directories(one PUBLIC include)</code> - подключает инклюды для указанного первым аргументом таргета. <code>PUBLIC</code> означает, что все таргеты, которые ссылаются на этот, должны так же включать эту директорию. Другие варианты - <code>PRIVATE</code> (только текущий таргет) и <code>INTERFACE</code> (только зависимости).</li>\\n<li><code>include(ext.cmake)</code> - загружает и запускает скрипт cmake из указанного файла</li>\\n<li><code>set(KEY VALUE)</code> - установка переменных</li>\\n<li><code>set(SOURCES main.c a.c b.c)</code> - установка списка <code>[main.c a.c b.c]</code> в качестве значения переменной SOURCES</li>\\n<li><code>${SOURCES}</code> - обращение к значению переменной SOURCES</li>\\n<li><code>configure_file ( \\\"a.h.in\\\" \\\"a.h\\\" )</code> - берет файл <strong>a.h.in</strong>, подставляет туда значения переменных CMake и сохраняет как <strong>a.h</strong>. В файлах на них нужно ссылаться как: <code>${PROJECT_SOURCE_DIR}</code> или <code>@PROJECT_SOURCE_DIR@</code>. Строчки вида <code>#cmakedefine VAR ...</code> будут заменены либо на <code>#define VAR ...</code> либо на <code>/* #undef VAR */</code> в зависимости от того, установлено ли значение <code>VAR</code> в ложь (в том смысле, в котором if считает выражения ложью)</li>\\n<li><code>add_subdirectory(source_dir)</code> - включение папки со своим CMakeLists.txt в билд. Путь может быть относительным или абсолютным. Если CMakeLists.txt найден в папке, то CMake его обработает сразу же, прежде чем перейдет к следующей команде.</li>\\n<li><code>find_program(YASM_EXE NAMES yasm)</code> - ищет программу yasm и сохраняет путь к ней в переменной <strong>YASM_EXE</strong></li>\\n<li><code>find_package(SWIG REQUIRED)</code> - находит внешний проект и загружает оттуда его переменные. Например, после загрузки SWIG будет проинициализирована <strong>SWIG_EXECUTABLE</strong>. Список экспортируемых переменных можно найти на странице <strong>Find[package_name]</strong> в <a href=\\\"https://cmake.org/cmake/help/v3.2/module/FindSWIG.html\\\">документации CMake</a>, или в <a href=\\\"https://github.com/Kitware/CMake/blob/master/Modules/FindSWIG.cmake\\\">исходниках</a></li>\\n<li><code>message(STATUS \\\"hello\\\")</code> - вывод сообщения, первый аргумент задает уровень из списка STATUS/WARNING/AUTHOR_WARNING/SEND_ERROR/FATAL_ERROR</li>\\n<li><code>option(VSDK_CPU_ONLY \\\"set to true in only cpu should be used\\\" OFF)</code> - опция, которую пользователь может задать при вызове cmake: <code>cmake . -DVSDK_CPU_ONLY=On</code>. Второй аргумент - словесное описание, третий - дефолтное значение. Обращаться к опции потом можно по имени: <code>if(VSDK_CPU_ONLY) ...</code></li>\\n<li><code>install( TARGETS ${PROJECT_NAME}_firbuilder DESTINATION bin)</code> - задает правила установки. Первый аргумент задает таргет, второй - задает путь установки. Если относительный, то будет аппенднут к <code>$CMAKE_INSTALL_PREFIX</code></li>\\n<li><code>find_package(package [REQUIRED])</code> - ищет и загружает свойства внешнего проекта. В папке <code>${CMAKE_MODULE_PATH}</code> будет искаться файл <code>Find&#x3C;package>.cmake</code>. Если найден, то будет тут же обработан cmake-ом. Если такой файл не найден, то ищется конфиг под именем <code>&#x3C;name>Config.cmake</code> или <code>&#x3C;lower-case-name>-config.cmake</code></li>\\n<li><code>list(APPEND LIBS ${vsd_LIBRARY})</code> - функция list описывает операции со списками. Первый аргумент обозначает операцию, в данном случае - append.</li>\\n<li><code>add_custom_target(makedir1 ALL COMMAND ${CMAKE_COMMAND} DEPENDS target1 -E make_directory \\\"${PROJECT_BINARY_DIR}/src/ssd\\\")</code> - добавляет таргет без аутпута, то есть он будет выполняться всегда. Первый аргумент - имя таргета. <code>ALL</code> означает, что таргет будет добавлен в таргет all. <code>COMMAND</code> - задает команду, все что после нее - тело команды. <code>DEPENDS</code> - задает другие таргеты, от которых зависит этот. Когда строится этот таргет, будут построены и все, перечисленные в <code>DEPENDS</code>. <code>-E</code> означает запуск cmake в командном режиме, <code>make_directory</code> - команда создания папки.</li>\\n<li><code>add_custom_command( OUTPUT ${SRC_ASM}.o COMMAND ${YASM_EXE} ARGS -p ${SRC_ASM_INPUT}.asm DEPENDS source.cpp)</code> - работает на этапе генерации, добавляет кастомную команду для генерации аутпута. <code>OUTPUT</code> задает аутпут, для генерации которого указывается команда (команда не обязательно должна создавать этот аутпут, здесь мы всего лишь указываем, какого аутпута мы от нее ожидаем), <code>COMMAND</code> - команду, а <code>ARGS</code> - аргументы. <code>DEPENDS</code> - задает список файлов или таргетов, от которых зависит эта команда.</li>\\n<li><code>string(TOUPPER ${STR_INPUT} STR_OUTPUT)</code> - провести операцию, указанную первым аргументом, на значении, указанном во втором аргументе, и сохранить результат в переменную, указанную в третьем.</li>\\n<li><code>execute_process(COMMAND ${GIT_EXECUTABLE} submodule update --init --recursive WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} RESULT_VARIABLE GIT_SUBMOD_RESULT)</code> - работает на этапе конфигурации, запускает внешний процесс, в данном случае обновляет сабмодули гита. Путь к файлу процесса лучше не хардкодить, а найти заранее командой типа <code>find_package(Git)</code>. Если же нужно запустить команду на этапе генерации, например, скопировать папку или запустить скрипт для генерации каких-то файлов, то нужно использовать команду <code>add_custom_command</code>.</li>\\n</ul>\\n<h3>Вызовы компилятора</h3>\\n<ul>\\n<li><code>add_executable( ${EXE_NAME} ${SOURCES} )</code> - создает вызываемый файл на основании файлов, перечисленных в <code>SOURCES</code>. Первый аргумент будет использован как имя таргета и имя полученного исполняемого файла.</li>\\n<li><code>add_library( ${LIB_NAME} ${LIBS_SOURCES})</code> - создает библиотеку на основании файлов, перечисленных в <code>SOURCES</code>. По умолчанию создает статическую (если не указана опция <code>BUILD_SHARED_LIBS</code>). Если нужно разделяемую, то нужно указать тип: <code>add_library( ${LIB_NAME} SHARED ${LIBS_SOURCES})</code></li>\\n<li><code>target_link_libraries( ${TARGET_NAME} ${LIB_NAME} )</code> - линкует библиотеки и исполняемые файлы. Первый аргумент - это таргет, он должен предварительно быть создан командой <code>add_executable()</code> или <code>add_library()</code>. Остальные аргументы - имена таргетов или библиотек. В результате <code>TARGET_NAME</code> будет зависеть от <code>LIB_NAME</code>.</li>\\n<li><code>add_definitions( --std=c99)</code> - добавление флагов для компилятора</li>\\n</ul>\\n<h3>Условия</h3>\\n<ul>\\n<li><code>if( CAFFE_ROOT)</code> - проверка, установлена ли переменная CAFFE_ROOT</li>\\n<li><code>if( NOT CAFFE_ROOT)</code> - проверка, что не установлена переменная CAFFE_ROOT</li>\\n<li><code>if( CAFFE_ROOT STREQUAL \\\"\\\")</code> - проверка, что переменная CAFFE_ROOT равна \\\"\\\"</li>\\n</ul>\\n<h2>Generator expressions</h2>\\n<p>Билд состоит из 2 шагов:</p>\\n<ol>\\n<li>Этап конфигурации</li>\\n<li>Этап генерации</li>\\n</ol>\\n<p>Когда мы билдим для нескольких платформ или для нескольких конфигураций, некоторые значения (имена, пути аутпутов) нам могут быть известны только на этапе генерации. Для работы с ними существуют т.н. generator expressions, имеющие форму <code>$&#x3C;KEYWORD></code> или <code>$&#x3C;KEYWORD:value></code>. Keywords берутся из константного множества и у всех этих выражений разная семантика, смотреть <a href=\\\"https://cmake.org/cmake/help/v3.4/manual/cmake-generator-expressions.7.html#id4\\\">здесь</a></p>\\n<p>Некоторые из выражений возвращают 0 или 1 и тогда они могут быть сами использованы в качестве keyword:</p>\\n<pre><code>target_compile_options(MyTarget PRIVATE \\\"$&#x3C;$&#x3C;CONFIG:Debug>:--my-flag>\\\")\\n</code></pre>\\n<p>Здесь флаг <code>--my-flag</code> будет применен, если использована конфигурация билда Debug.</p>\\n<p>Когда используются:</p>\\n<ul>\\n<li>когда нужно что-то сделать только для конкретного языка</li>\\n<li>когда нужно что-то сделать в зависимости от конфигурации билда</li>\\n<li>когда нужно указать различные локации для построения и установки</li>\\n</ul>\\n<h2>Функции</h2>\\n<pre><code>function(SIMPLE REQUIRED_ARG)\\n    message(STATUS \\\"Simple arguments: ${REQUIRED_ARG}, followed by ${ARGV}\\\")\\n    set(${REQUIRED_ARG} \\\"From SIMPLE\\\" PARENT_SCOPE)\\nendfunction()\\n\\nsimple(This)\\nmessage(\\\"Output: ${This}\\\")\\n</code></pre>\\n<p>Аргументы внутри функции можно специфицировать командой <code>cmake_parse_arguments</code>:</p>\\n<pre><code>function(COMPLEX)\\ncmake_parse_arguments(\\n    COMPLEX_PREFIX\\n    \\\"SINGLE;ANOTHER\\\"\\n    \\\"ONE_VALUE;ALSO_ONE_VALUE\\\"\\n    \\\"MULTI_VALUES\\\"\\n    ${ARGN}\\n)\\n\\nendfunction()\\n\\ncomplex(SINGLE ONE_VALUE value MULTI_VALUES some other values)\\n</code></pre>\\n<p>После вызова внутри функции <code>simple</code> будут следующие аргументы:</p>\\n<pre><code>COMPLEX_PREFIX_SINGLE = TRUE\\nCOMPLEX_PREFIX_ANOTHER = FALSE\\nCOMPLEX_PREFIX_ONE_VALUE = \\\"value\\\"\\nCOMPLEX_PREFIX_ALSO_ONE_VALUE = &#x3C;UNDEFINED>\\nCOMPLEX_PREFIX_MULTI_VALUES = \\\"some;other;values\\\"\\n</code></pre>\\n<p>Все оставшиеся аргументы будут в переменной <code>COMPLEX_PREFIX_UNPARSED_ARGUMENTS</code>.</p>\\n<h2>Чтение опций из файлов</h2>\\n<p>Допустим, версия проекта хранится в файле <code>Version.hpp</code> и мы хотим ее оттуда прочитать в наш скрипт CMake.</p>\\n<pre><code>set(VERSION_REGEX \\\"#define MY_VERSION[ \\\\t]+\\\\\\\"(.+)\\\\\\\"\\\")   // создаем регэксп для чтения и сохраняем в переменной VERSION_REGEX\\n\\nfile(STRINGS \\\"${CMAKE_CURRENT_SOURCE_DIR}/include/My/Version.hpp\\\"\\n    VERSION_STRING REGEX ${VERSION_REGEX})  // читаем файл, обрабатываем нашим регэкспом, результат сохраняем в переменную VERSION_STRING\\n\\nstring(REGEX REPLACE ${VERSION_REGEX} \\\"\\\\\\\\1\\\" VERSION_STRING \\\"${VERSION_STRING}\\\") // если найдено несколько версий, берем первую\\n\\nproject(My LANGUAGES CXX VERSION ${VERSION_STRING}) // задаем версию проекта\\n</code></pre>\\n<h2>C++11</h2>\\n<p>вот так можно установить версию языка (выбор между <code>cxx_std_11</code>, <code>cxx_std_14</code>, <code>cxx_std_17</code>):</p>\\n<pre><code>target_compile_features(myTarget PUBLIC cxx_std_11)\\nset_target_properties(myTarget PROPERTIES CXX_EXTENSIONS OFF)\\n</code></pre>\\n<p>Вторая строчка необязательна, но облегчит жизнь, без нее будет использован флаг <code>-std=g++11</code> вместо <code>-std=c++11</code>.</p>\\n<p>Есть и другой способ:</p>\\n<pre><code>set(CMAKE_CXX_STANDARD 11)\\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\\nset(CMAKE_CXX_EXTENSIONS OFF)\\n</code></pre>\\n<p>первая строчка устанавливает стандарт, а вторая указывает, что нужно его использовать. Однако этот метод не стоит использовать для сборки библиотек.</p>\\n<h2>Субмодули гита</h2>\\n<p>Вот так выкачиваем субмодули при построении:</p>\\n<pre><code>find_package(Git QUIET)\\nif(GIT_FOUND AND EXISTS \\\"${PROJECT_SOURCE_DIR}/.git\\\")\\n# Update submodules as needed\\n    option(GIT_SUBMODULE \\\"Check submodules during build\\\" ON)\\n    if(GIT_SUBMODULE)\\n        message(STATUS \\\"Submodule update\\\")\\n        execute_process(COMMAND ${GIT_EXECUTABLE} submodule update --init --recursive\\n                        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\\n                        RESULT_VARIABLE GIT_SUBMOD_RESULT)\\n        if(NOT GIT_SUBMOD_RESULT EQUAL \\\"0\\\")\\n            message(FATAL_ERROR \\\"git submodule update --init failed with ${GIT_SUBMOD_RESULT}, please checkout submodules\\\")\\n        endif()\\n    endif()\\nendif()\\n\\nif(NOT EXISTS \\\"${PROJECT_SOURCE_DIR}/extern/repo/CMakeLists.txt\\\")\\n    message(FATAL_ERROR \\\"The submodules were not downloaded! GIT_SUBMODULE was turned off or failed. Please update submodules and try again.\\\")\\nendif()\\n</code></pre>\\n<p>А так включаем проект в процесс билда:</p>\\n<pre><code>add_subdirectory(extern/repo)\\n</code></pre>\\n<h3>Бонус: сохранение версии субмодуля в переменную</h3>\\n<pre><code>execute_process(COMMAND ${GIT_EXECUTABLE} rev-parse --short HEAD\\n                WORKING_DIRECTORY \\\"${CMAKE_CURRENT_SOURCE_DIR}\\\"\\n                OUTPUT_VARIABLE PACKAGE_GIT_VERSION\\n                ERROR_QUIET\\n                OUTPUT_STRIP_TRAILING_WHITESPACE)\\n</code></pre>\\n<h2>Часто используемые утилиты</h2>\\n<p>Набор часто используемых утилит можно использовать через команду <code>cmake -E &#x3C;mode></code> в <code>add_custom_command</code>. </p>\\n<p>Список утилит можно найти <a href=\\\"https://cmake.org/cmake/help/latest/manual/cmake.1.html#run-a-command-line-tool\\\">здесь</a>.</p>\\n<h2>Рекомендуемая структура проекта</h2>\\n<p>Если наш проект называется <code>projects</code>, библиотека в нем называется <code>lib</code>, а исполняемый файл - <code>app</code>, то рекомендуется следующая структура:</p>\\n<pre><code>- project\\n  - .gitignore\\n  - README.md\\n  - LICENCE.md\\n  - CMakeLists.txt\\n  - cmake\\n    - FindSomeLib.cmake\\n  - include\\n    - project\\n      - lib.hpp\\n  - src\\n    - CMakeLists.txt\\n    - lib.cpp\\n  - apps\\n    - CMakeLists.txt\\n    - app.cpp\\n  - tests\\n    - testlib.cpp\\n  - docs\\n    - Doxyfile.in\\n  - extern\\n    - googletest\\n  - scripts\\n    - helper.py\\n</code></pre>\\n<p><code>CMakeLists.txt</code> есть почти во всех папках с <strong>.cpp</strong> и нет в папке <code>include</code>. Это потому что содержимое папки <code>include</code> должно копироваться в <code>/usr/include</code> как есть и не содержать никаких лишних файлов. По этой же причине, в папке <code>include</code> выделена папка для нашего проекта - чтобы наверняка не было конфликтов.</p>\\n<p>В папке <code>extern</code> должны лежать внешние зависимости в виде субмодулей гита.</p>\\n<p>В <code>.gitignore</code> должна быть строчка <code>/build*</code>.</p>\\n<h2>Пример</h2>\\n<pre><code>cmake_minimum_required(VERSION 3.8)\\n\\nproject(Calculator LANGUAGES CXX)\\n\\nadd_library(calclib STATIC src/calclib.cpp include/calc/lib.hpp)   // создаем таргет calclib, который будет статической библиотекой, собираемой из файлов src/calclib.cpp и include/calc/lib.hpp\\n\\ntarget_include_directories(calclib PUBLIC include)  // подключаем папку include с заголовками, которые могут понадобиться при билде таргета/библиотеки calclib\\n\\ntarget_compile_features(calclib PUBLIC cxx_std_11)  // указываем флаги компиляции для таргета calclib\\n\\nadd_executable(calc apps/calc.cpp)  // создаем таргет calc, который будет исполняемым файлом, собираемым из файла apps/calc.cpp\\n\\ntarget_link_libraries(calc PUBLIC calclib)  // указываем, что таргет/исполняемый файл calc зависит от таргета/либы calclib\\n</code></pre>\\n<p>Другой пример:</p>\\n<pre><code>find_package(PythonInterp REQUIRED)\\nadd_custom_command(OUTPUT \\\"${CMAKE_CURRENT_BINARY_DIR}/include/Generated.hpp\\\"\\n    COMMAND \\\"${PYTHON_EXECUTABLE}\\\" \\\"${CMAKE_CURRENT_SOURCE_DIR}/scripts/GenerateHeader.py\\\" --argument\\n    DEPENDS some_target)\\n\\nadd_custom_target(generate_header ALL\\n    DEPENDS \\\"${CMAKE_CURRENT_BINARY_DIR}/include/Generated.hpp\\\")\\n\\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/include/Generated.hpp DESTINATION include)\\n</code></pre>\\n<p>Здесь, при запуске <code>cmake</code> без указания таргета будет запущен таргет <code>generate_header</code> (так как ему указано <code>ALL</code>). Он зависит от <code>Generated.hpp</code>, который указан как <code>OUTPUT</code> команды во второй строчке. Но эта команда сама зависит от таргета <code>some_target</code> (здесь не указан). Когда будет построен <code>some_target</code>, команда запуститься, запустит процесс питона, подаст в него скрипт <code>GenerateHeader.py</code>, питон сгенерит файл <code>include/Generated.hpp</code>, после чего таргет <code>generate_header</code> будет завершен.</p>\",\"frontmatter\":{\"path\":\"/blog/cmake\",\"title\":\"CMake\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/blog-cmake.json\n// module id = 421\n// module chunks = 226785351346532"],"sourceRoot":""}