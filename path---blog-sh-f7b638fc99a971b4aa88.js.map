{"version":3,"sources":["webpack:///path---blog-sh-f7b638fc99a971b4aa88.js","webpack:///./.cache/json/blog-sh.json"],"names":["webpackJsonp","486","module","exports","data","markdownRemark","html","frontmatter","path","title","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,slYAAk/XC,aAA2OC,KAAA,WAAAC,MAAA,QAAiCC","file":"path---blog-sh-f7b638fc99a971b4aa88.js","sourcesContent":["webpackJsonp([186644301018450],{\n\n/***/ 486:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>sh</h1>\\n<h2>Parameter expansion</h2>\\n<pre><code>for i in 1 2 \\ndo\\n    my_secret_process ${i}_tmp\\ndone\\n</code></pre>\\n<p>Такая форма записи позволит подставить 1<em>tmp и 2</em>tmp. Если делать без скобок, то получится пустота, так как у нас нет переменной i_tmp</p>\\n<h2>Чтение переменных</h2>\\n<pre><code class=\\\"language-sh\\\">FOO=bar\\necho \\\"Hello, $FOO!\\\"   # Hello, bar! - сработает только с двойными кавычками, так как они слабые\\necho 'Hello, $FOO!'   # Hello, $FOO! - не сработает, так как одинарные кавычки - строгие\\n</code></pre>\\n<h2>Специальные переменные</h2>\\n<ul>\\n<li><code>$0</code> - название скрипта</li>\\n<li><code>$1, $2, $3...</code> - первый, второй, третий аргумент</li>\\n<li><code>$#</code> - количество аргументов</li>\\n<li><code>$@</code> - все аргументы</li>\\n<li><code>$$</code> - текущий PID</li>\\n<li><code>$?</code> - exit code последней выполненной команды</li>\\n</ul>\\n<h2>Условия</h2>\\n<pre><code class=\\\"language-sh\\\">if [ \\\"$1\\\" = \\\"hi\\\" ]; then\\n    echo \\\"hello\\\"\\nelse\\n    echo \\\"bye\\\"\\nfi\\n</code></pre>\\n<p>Кавычки вокруг <code>$1</code> и <code>hi</code> не обязательнц, но нужны на случай, если в <code>$1</code> будет пустота, либо слова со спец. символами.</p>\\n<p>Причем <strong>[</strong> здесь - это симлинк к команде  <strong>test</strong>:</p>\\n<pre><code class=\\\"language-sh\\\">$ type -a [\\n[ is a shell builtin\\n[ is /bin/[\\n</code></pre>\\n<p>Таким образом, <code>if</code> просто проверяет, равен ли 0 результат следующего за ним <code>test</code>.</p>\\n<p><strong>Проверки для файлов:</strong></p>\\n<ul>\\n<li><code>-f</code>: есть ли такой обычный файл на диске (<code>if [ -f 'filename.txt' ]</code>)</li>\\n<li><code>-d</code>: есть ли такая директория</li>\\n<li><code>-e</code>: есть ли такой файловый дескриптор</li>\\n<li><code>-s</code>: true, если файл есть и не пустой</li>\\n<li><code>-h</code>: есть ли такой симлинк</li>\\n<li><code>-a</code>: логическое \\\"и\\\" (<code>if [ -f file1 -a file2 ]</code>)</li>\\n<li><code>-o</code>: логическое \\\"или\\\"</li>\\n<li><code>-r</code>: читаемый</li>\\n<li><code>-w</code>: редактируемый</li>\\n<li><code>-x</code>: выполняемый</li>\\n<li><code>-nt</code>: newer than (<code>if [ file1 -nt file2 ]</code>)</li>\\n<li><code>-ot</code>: older than</li>\\n</ul>\\n<p>Все эти команды (кроме <code>-h</code>) поддерживают симлинки. То есть если <strong>link</strong> это симлинк на файл, то <code>[ -f link ]</code> вернет 0.</p>\\n<p><strong>Проверки для строк:</strong></p>\\n<ul>\\n<li><code>-z</code>: true, если строка пуста</li>\\n<li><code>-n</code>: true, если строка не пуста</li>\\n</ul>\\n<p><strong>Арифметические проверки:</strong></p>\\n<p>ВАЖНО: <code>=</code> проверяет на равенство только строки, <strong>но не числа</strong>.</p>\\n<p>Обратить условие можно, добавив <strong>!</strong> перед ним: <code>if [ ! -f 'filename.txt' ]</code>. Для проверки чисел на равенство, нужно использовать <code>-eq</code>.</p>\\n<ul>\\n<li><code>-eq</code>: equal</li>\\n<li><code>-ne</code>: not equal</li>\\n<li><code>-lt</code>: less than</li>\\n<li><code>-gt</code>: greater than</li>\\n<li><code>-le</code>: less than or equal</li>\\n<li><code>-ge</code>: greater than or equal</li>\\n</ul>\\n<p>Вслед за <code>if</code> может идти любая команда, поэтому и нужна \\\";\\\" перед <code>then</code>. Если не указать точку с запятой, то <code>then</code> будет распознана как аргумент команды. Можно не писать точку с запятой, но тогда <code>then</code> должен быть на следующей строчке.</p>\\n<p>Пример другой команды:</p>\\n<pre><code class=\\\"language-sh\\\">if grep -q daemon /etc/passwd; then\\n   echo The daemon user is in the passwd file.\\nelse\\n   echo There is a big problem. daemon is not in the passwd file.\\nfi\\n</code></pre>\\n<h2>switch-case</h2>\\n<pre><code class=\\\"language-sh\\\">case $1 in\\n    bye)\\n        echo Fine, bye.\\n        ;; \\n    hi|hello)\\n        echo Nice to see you.\\n        ;;\\n    what*)\\n        echo Whatever.\\n        ;; \\n    *)\\n        echo 'Huh?'\\n        ;; \\nesac\\n</code></pre>\\n<h2>Циклы</h2>\\n<h3>for</h3>\\n<pre><code class=\\\"language-sh\\\">for str in one two three four; do\\n   echo $str\\ndone\\n</code></pre>\\n<pre><code class=\\\"language-sh\\\">FLAGS=(foo bar baz)\\nfor f in $FLAGS; do\\n    echo $f\\ndone\\n</code></pre>\\n<p>Можно фориться по списку файлов:</p>\\n<pre><code class=\\\"language-sh\\\">for file in *.gif; do\\n    echo $file\\ndone\\n</code></pre>\\n<h3>while</h3>\\n<pre><code class=\\\"language-sh\\\">FILE=/tmp/whiletest.$$;\\necho firstline > $FILE\\nwhile tail -10 $FILE | grep -q firstline; do\\n    # add lines to $FILE until tail -10 $FILE no longer prints \\\"firstline\\\" \\n    echo -n Number of lines in $FILE:' '\\n    wc -l $FILE | awk '{print $1}'\\n    echo newline >> $FILE\\ndone\\n\\nrm -f $FILE\\n</code></pre>\\n<h3>IFS</h3>\\n<p><strong>IFS</strong> = <strong>i</strong>nternal <strong>f</strong>ield <strong>s</strong>eparator. Значение этой переменной используется для представления строки в виде массива.</p>\\n<p>Пример (не сработает в <strong>zsh</strong>, сработает в <strong>bash</strong>):</p>\\n<pre><code class=\\\"language-sh\\\">words=foo,bar,baz\\n\\nfor word in $words\\ndo\\n    echo $word\\ndone\\n</code></pre>\\n<p>В результате будет выведено:</p>\\n<pre><code class=\\\"language-sh\\\">foo\\nbar\\nbaz\\n</code></pre>\\n<h3>Подстроки</h3>\\n<pre><code class=\\\"language-sh\\\">FOO=Hello!\\nBAR={FOO:1:3}   # взять 3 символа, начиная с 1-го. то есть получится \\\"ell\\\"\\n</code></pre>\\n<p>Если второе число не указано, то возьмется до конца строки:</p>\\n<pre><code class=\\\"language-sh\\\">FOO=Hello!\\nBAR={FOO:3} # lo!\\n</code></pre>\\n<h3>Парсинг опций</h3>\\n<pre><code class=\\\"language-sh\\\"># command.sh\\n\\nwhile getopts 'srd:f:' c\\ndo\\n  case $c in\\n    s) ACTION=SAVE ;;\\n    r) ACTION=RESTORE ;;\\n    d) DB_DUMP=$OPTARG ;;\\n    f) TARBALL=$OPTARG ;;\\n  esac\\ndone\\n</code></pre>\\n<p><code>srd:f:</code> - это список флагов, которые могут быть использованы. Причем если после флага стоит двоеточие, то для этого флага можно указать значение.</p>\\n<p>Скрипт из примера можно запускать с такими параметрами:</p>\\n<pre><code class=\\\"language-sh\\\">./command.sh -sr -d dump.db -f ball.TARBALL\\n</code></pre>\\n<h3>Стили и цвета</h3>\\n<p>Для использования стилей текста сильно поможет такая функция:</p>\\n<pre><code class=\\\"language-sh\\\">#!/bin/bash\\n# ANSI color--Use these variables to make output in different colors\\n# and formats. Color names that end with 'f' are foreground colors,\\n# and those ending with 'b' are background colors.\\ninitializeANSI()\\n{\\n esc=\\\"\\\\033\\\" # If this doesn't work, enter an ESC directly.\\n # Foreground colors\\n blackf=\\\"${esc}[30m\\\"; redf=\\\"${esc}[31m\\\"; greenf=\\\"${esc}[32m\\\"\\n yellowf=\\\"${esc}[33m\\\" bluef=\\\"${esc}[34m\\\"; purplef=\\\"${esc}[35m\\\"\\n cyanf=\\\"${esc}[36m\\\"; whitef=\\\"${esc}[37m\\\"\\n # Background colors\\n blackb=\\\"${esc}[40m\\\"; redb=\\\"${esc}[41m\\\"; greenb=\\\"${esc}[42m\\\"\\n yellowb=\\\"${esc}[43m\\\" blueb=\\\"${esc}[44m\\\"; purpleb=\\\"${esc}[45m\\\"\\n cyanb=\\\"${esc}[46m\\\"; whiteb=\\\"${esc}[47m\\\"\\n # Bold, italic, underline, and inverse style toggles\\n boldon=\\\"${esc}[1m\\\"; boldoff=\\\"${esc}[22m\\\"\\n italicson=\\\"${esc}[3m\\\"; italicsoff=\\\"${esc}[23m\\\"\\n ulon=\\\"${esc}[4m\\\"; uloff=\\\"${esc}[24m\\\"\\n invon=\\\"${esc}[7m\\\"; invoff=\\\"${esc}[27m\\\"\\n reset=\\\"${esc}[0m\\\"\\n}\\n</code></pre>\\n<p>Использовать ее можно вот так:</p>\\n<pre><code class=\\\"language-sh\\\">initializeANSI\\n\\necho ${boldon}this is in bold and ${italicson}this is \\\\\\nitalics${italicsoff}within the bold${reset}\\n</code></pre>\\n<h2>Утилиты</h2>\\n<h3>basename</h3>\\n<p>Позволяет получить имя файла без пути, или имя файла без расширения, или и то и то.</p>\\n<pre><code class=\\\"language-sh\\\">basename ~/temp/readme.md # readme.md\\nbasename readme.md .md # readme\\nbasename ~/temp/readme.md .md # readme\\n</code></pre>\\n<h3>awk</h3>\\n<p>Вообще-то это целый язык программирования, но в большинстве случаев он используется просто чтобы распарсить колоночный вывод от других программ:</p>\\n<pre><code class=\\\"language-sh\\\">ls -l | awk '{print $5}'   # выведет 5-ю колонку, то етсь размер\\n</code></pre>\\n<p>Если нужно вывести несколько колонок:</p>\\n<pre><code class=\\\"language-sh\\\">ls -l | awk '{print $6 \\\" \\\" $7 \\\" \\\" $8}'   # выведет 5,6,7 колонку через пробел\\n</code></pre>\\n<h3>sed</h3>\\n<p><strong>sed</strong> принимает первым аргументом адрес и операцию, а вторым - путь к файлу. Либо можно пайплайнить в него вывод другой программы, тогда ворой аргумент не нужен:</p>\\n<pre><code class=\\\"language-sh\\\">ls -l | sed 's/июл/авг/'  # заменяет месяц в выводе с июля на август\\n</code></pre>\\n<p>sed работает построчно, и по умолчанию он будет заменять первое встретившееся значение в каждой строчке. Если нужно чтобы точно заменил все значения, то в конце надо приписывать модификатор <strong>g</strong>:</p>\\n<pre><code class=\\\"language-sh\\\">sed 's/foo/bar/g' tmp.txt\\n</code></pre>\\n<p>В предыдущих примерах адрес был опущен. В качестве адреса могут быть указаны, например, первая и последняя строчка, над которыми проводить операцию:</p>\\n<pre><code class=\\\"language-sh\\\">sed '1,3s/foo/bar/g' tmp.txt    # замена произойдет в строчках 1-3\\nsed '2,4d' tmp.txt              # будут удалены строчки 2-4\\n</code></pre>\\n<p>Вместо адреса может быть использовано даже регулярное выражение:</p>\\n<pre><code class=\\\"language-sh\\\">sed '/exp/d' tmp.txt    # удалит все строки, подходящие под указанный регэксп\\n</code></pre>\\n<h3>xargs</h3>\\n<p>Принимает на вход аргументы и подставляет их в команду последним аргументом</p>\\n<pre><code class=\\\"language-sh\\\">ls | xargs file     # выведет тип для каждого файла в текущей директории\\n</code></pre>\\n<p>Можно подставлять любым аргументом, но тогда нужно использовать такую конструкцию:</p>\\n<pre><code class=\\\"language-sh\\\">ls | xargs -I % file %\\n</code></pre>\\n<p>Здесь <code>-I %</code> означает, что плейсхолдер будет обозначаться знаком процента, а <code>%</code> в конце - это как раз плейсхолдер.</p>\\n<h3>grep</h3>\\n<p><code>grep -R def .</code> - рекурсивно ищет \\\"def\\\" во всех файлах текущей директории</p>\\n<p><code>grep -E [a-z]{10}</code> - регулярное выражение</p>\\n<p><code>grep a[[:blank:]]</code> - ищем все слова, кончающиеся на а</p>\\n<p><code>grep -c PATTERN</code> - выводит не строчки, а количество вхождений паттерна в файле</p>\\n<h3>find</h3>\\n<p><code>find . -name \\\"*setup*\\\"</code> - рекурсивно искать все файлы с именем, содержащим <strong>setup</strong>, начиная с текущей директории</p>\\n<p><code>find -type f -exec grep PATTERN {} \\\\;</code> : <strong>-exec</strong> позволяет выполнить указанную после него команду для каждого найденного файла. {} - плейсхолдер для полного пути файла. ; - конец команды.</p>\\n<h2>Выход из скрипта после первой провалившейся команды</h2>\\n<p>Нужно вставить в начало скрипта:</p>\\n<pre><code class=\\\"language-sh\\\">set -e\\n</code></pre>\\n<h2>Отладка</h2>\\n<p><code>sh -n &#x3C;script></code> -проверка на синтаксические ошибки</p>\\n<p><code>sh -v &#x3C;script></code> - выводит все команды на экран перед выполнением</p>\\n<p><code>sh -x &#x3C;script></code> - тоже выводит, но после подстановки всех переменных и прочей обработки</p>\\n<p><code>sh -u &#x3C;script></code> - выводит ошибку, если используется неопределенная переменная</p>\\n<pre><code>set -o xtrace\\n...\\nset +o xtrace\\n</code></pre>\\n<p>Такой код можно написать вокруг проблемного участка кода, чтобы только в этом коде выводить на экран команды с подстановкой переменных.</p>\\n<p><code>trap ‘echo Exiting: critical variable = $critical_variable’ EXIT</code> - а так мы можем выводить значение интересующей нас переменной перед выходом из скрипта</p>\\n<h2>Tips &#x26; tricks</h2>\\n<h3>Перемещение в директорию, в которой лежит скрипт</h3>\\n<pre><code class=\\\"language-sh\\\">cd \\\"${0%/*}\\\"\\n</code></pre>\\n<p>Если нужно в другую папку, относительно скрипта (например, в корень репозитория), то можно в конце добавлять относительный путь, например:</p>\\n<pre><code class=\\\"language-sh\\\">cd \\\"${0%/*}/..\\\"\\n</code></pre>\\n<p><a href=\\\"https://stackoverflow.com/questions/28894290/what-does-cd-0-mean-in-bash\\\">https://stackoverflow.com/questions/28894290/what-does-cd-0-mean-in-bash</a></p>\\n<h3>here document</h3>\\n<p>Используя специальный синтаксис, можно прямо в команду вставить текст, который будет сохранен в файл:</p>\\n<pre><code class=\\\"language-sh\\\">$ cat > test.txt &#x3C;&#x3C; EOF\\n> hello\\n> this\\n> is\\n> test\\n> file\\n> EOF\\n</code></pre>\\n<p>Здесь <code>EOF</code> - это плейсхолдер, обозначающий последнюю строчку файла. Он необязательно должен быть <code>EOF</code>, может быть любой.</p>\",\"frontmatter\":{\"path\":\"/blog/sh\",\"title\":\"sh\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---blog-sh-f7b638fc99a971b4aa88.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>sh</h1>\\n<h2>Parameter expansion</h2>\\n<pre><code>for i in 1 2 \\ndo\\n    my_secret_process ${i}_tmp\\ndone\\n</code></pre>\\n<p>Такая форма записи позволит подставить 1<em>tmp и 2</em>tmp. Если делать без скобок, то получится пустота, так как у нас нет переменной i_tmp</p>\\n<h2>Чтение переменных</h2>\\n<pre><code class=\\\"language-sh\\\">FOO=bar\\necho \\\"Hello, $FOO!\\\"   # Hello, bar! - сработает только с двойными кавычками, так как они слабые\\necho 'Hello, $FOO!'   # Hello, $FOO! - не сработает, так как одинарные кавычки - строгие\\n</code></pre>\\n<h2>Специальные переменные</h2>\\n<ul>\\n<li><code>$0</code> - название скрипта</li>\\n<li><code>$1, $2, $3...</code> - первый, второй, третий аргумент</li>\\n<li><code>$#</code> - количество аргументов</li>\\n<li><code>$@</code> - все аргументы</li>\\n<li><code>$$</code> - текущий PID</li>\\n<li><code>$?</code> - exit code последней выполненной команды</li>\\n</ul>\\n<h2>Условия</h2>\\n<pre><code class=\\\"language-sh\\\">if [ \\\"$1\\\" = \\\"hi\\\" ]; then\\n    echo \\\"hello\\\"\\nelse\\n    echo \\\"bye\\\"\\nfi\\n</code></pre>\\n<p>Кавычки вокруг <code>$1</code> и <code>hi</code> не обязательнц, но нужны на случай, если в <code>$1</code> будет пустота, либо слова со спец. символами.</p>\\n<p>Причем <strong>[</strong> здесь - это симлинк к команде  <strong>test</strong>:</p>\\n<pre><code class=\\\"language-sh\\\">$ type -a [\\n[ is a shell builtin\\n[ is /bin/[\\n</code></pre>\\n<p>Таким образом, <code>if</code> просто проверяет, равен ли 0 результат следующего за ним <code>test</code>.</p>\\n<p><strong>Проверки для файлов:</strong></p>\\n<ul>\\n<li><code>-f</code>: есть ли такой обычный файл на диске (<code>if [ -f 'filename.txt' ]</code>)</li>\\n<li><code>-d</code>: есть ли такая директория</li>\\n<li><code>-e</code>: есть ли такой файловый дескриптор</li>\\n<li><code>-s</code>: true, если файл есть и не пустой</li>\\n<li><code>-h</code>: есть ли такой симлинк</li>\\n<li><code>-a</code>: логическое \\\"и\\\" (<code>if [ -f file1 -a file2 ]</code>)</li>\\n<li><code>-o</code>: логическое \\\"или\\\"</li>\\n<li><code>-r</code>: читаемый</li>\\n<li><code>-w</code>: редактируемый</li>\\n<li><code>-x</code>: выполняемый</li>\\n<li><code>-nt</code>: newer than (<code>if [ file1 -nt file2 ]</code>)</li>\\n<li><code>-ot</code>: older than</li>\\n</ul>\\n<p>Все эти команды (кроме <code>-h</code>) поддерживают симлинки. То есть если <strong>link</strong> это симлинк на файл, то <code>[ -f link ]</code> вернет 0.</p>\\n<p><strong>Проверки для строк:</strong></p>\\n<ul>\\n<li><code>-z</code>: true, если строка пуста</li>\\n<li><code>-n</code>: true, если строка не пуста</li>\\n</ul>\\n<p><strong>Арифметические проверки:</strong></p>\\n<p>ВАЖНО: <code>=</code> проверяет на равенство только строки, <strong>но не числа</strong>.</p>\\n<p>Обратить условие можно, добавив <strong>!</strong> перед ним: <code>if [ ! -f 'filename.txt' ]</code>. Для проверки чисел на равенство, нужно использовать <code>-eq</code>.</p>\\n<ul>\\n<li><code>-eq</code>: equal</li>\\n<li><code>-ne</code>: not equal</li>\\n<li><code>-lt</code>: less than</li>\\n<li><code>-gt</code>: greater than</li>\\n<li><code>-le</code>: less than or equal</li>\\n<li><code>-ge</code>: greater than or equal</li>\\n</ul>\\n<p>Вслед за <code>if</code> может идти любая команда, поэтому и нужна \\\";\\\" перед <code>then</code>. Если не указать точку с запятой, то <code>then</code> будет распознана как аргумент команды. Можно не писать точку с запятой, но тогда <code>then</code> должен быть на следующей строчке.</p>\\n<p>Пример другой команды:</p>\\n<pre><code class=\\\"language-sh\\\">if grep -q daemon /etc/passwd; then\\n   echo The daemon user is in the passwd file.\\nelse\\n   echo There is a big problem. daemon is not in the passwd file.\\nfi\\n</code></pre>\\n<h2>switch-case</h2>\\n<pre><code class=\\\"language-sh\\\">case $1 in\\n    bye)\\n        echo Fine, bye.\\n        ;; \\n    hi|hello)\\n        echo Nice to see you.\\n        ;;\\n    what*)\\n        echo Whatever.\\n        ;; \\n    *)\\n        echo 'Huh?'\\n        ;; \\nesac\\n</code></pre>\\n<h2>Циклы</h2>\\n<h3>for</h3>\\n<pre><code class=\\\"language-sh\\\">for str in one two three four; do\\n   echo $str\\ndone\\n</code></pre>\\n<pre><code class=\\\"language-sh\\\">FLAGS=(foo bar baz)\\nfor f in $FLAGS; do\\n    echo $f\\ndone\\n</code></pre>\\n<p>Можно фориться по списку файлов:</p>\\n<pre><code class=\\\"language-sh\\\">for file in *.gif; do\\n    echo $file\\ndone\\n</code></pre>\\n<h3>while</h3>\\n<pre><code class=\\\"language-sh\\\">FILE=/tmp/whiletest.$$;\\necho firstline > $FILE\\nwhile tail -10 $FILE | grep -q firstline; do\\n    # add lines to $FILE until tail -10 $FILE no longer prints \\\"firstline\\\" \\n    echo -n Number of lines in $FILE:' '\\n    wc -l $FILE | awk '{print $1}'\\n    echo newline >> $FILE\\ndone\\n\\nrm -f $FILE\\n</code></pre>\\n<h3>IFS</h3>\\n<p><strong>IFS</strong> = <strong>i</strong>nternal <strong>f</strong>ield <strong>s</strong>eparator. Значение этой переменной используется для представления строки в виде массива.</p>\\n<p>Пример (не сработает в <strong>zsh</strong>, сработает в <strong>bash</strong>):</p>\\n<pre><code class=\\\"language-sh\\\">words=foo,bar,baz\\n\\nfor word in $words\\ndo\\n    echo $word\\ndone\\n</code></pre>\\n<p>В результате будет выведено:</p>\\n<pre><code class=\\\"language-sh\\\">foo\\nbar\\nbaz\\n</code></pre>\\n<h3>Подстроки</h3>\\n<pre><code class=\\\"language-sh\\\">FOO=Hello!\\nBAR={FOO:1:3}   # взять 3 символа, начиная с 1-го. то есть получится \\\"ell\\\"\\n</code></pre>\\n<p>Если второе число не указано, то возьмется до конца строки:</p>\\n<pre><code class=\\\"language-sh\\\">FOO=Hello!\\nBAR={FOO:3} # lo!\\n</code></pre>\\n<h3>Парсинг опций</h3>\\n<pre><code class=\\\"language-sh\\\"># command.sh\\n\\nwhile getopts 'srd:f:' c\\ndo\\n  case $c in\\n    s) ACTION=SAVE ;;\\n    r) ACTION=RESTORE ;;\\n    d) DB_DUMP=$OPTARG ;;\\n    f) TARBALL=$OPTARG ;;\\n  esac\\ndone\\n</code></pre>\\n<p><code>srd:f:</code> - это список флагов, которые могут быть использованы. Причем если после флага стоит двоеточие, то для этого флага можно указать значение.</p>\\n<p>Скрипт из примера можно запускать с такими параметрами:</p>\\n<pre><code class=\\\"language-sh\\\">./command.sh -sr -d dump.db -f ball.TARBALL\\n</code></pre>\\n<h3>Стили и цвета</h3>\\n<p>Для использования стилей текста сильно поможет такая функция:</p>\\n<pre><code class=\\\"language-sh\\\">#!/bin/bash\\n# ANSI color--Use these variables to make output in different colors\\n# and formats. Color names that end with 'f' are foreground colors,\\n# and those ending with 'b' are background colors.\\ninitializeANSI()\\n{\\n esc=\\\"\\\\033\\\" # If this doesn't work, enter an ESC directly.\\n # Foreground colors\\n blackf=\\\"${esc}[30m\\\"; redf=\\\"${esc}[31m\\\"; greenf=\\\"${esc}[32m\\\"\\n yellowf=\\\"${esc}[33m\\\" bluef=\\\"${esc}[34m\\\"; purplef=\\\"${esc}[35m\\\"\\n cyanf=\\\"${esc}[36m\\\"; whitef=\\\"${esc}[37m\\\"\\n # Background colors\\n blackb=\\\"${esc}[40m\\\"; redb=\\\"${esc}[41m\\\"; greenb=\\\"${esc}[42m\\\"\\n yellowb=\\\"${esc}[43m\\\" blueb=\\\"${esc}[44m\\\"; purpleb=\\\"${esc}[45m\\\"\\n cyanb=\\\"${esc}[46m\\\"; whiteb=\\\"${esc}[47m\\\"\\n # Bold, italic, underline, and inverse style toggles\\n boldon=\\\"${esc}[1m\\\"; boldoff=\\\"${esc}[22m\\\"\\n italicson=\\\"${esc}[3m\\\"; italicsoff=\\\"${esc}[23m\\\"\\n ulon=\\\"${esc}[4m\\\"; uloff=\\\"${esc}[24m\\\"\\n invon=\\\"${esc}[7m\\\"; invoff=\\\"${esc}[27m\\\"\\n reset=\\\"${esc}[0m\\\"\\n}\\n</code></pre>\\n<p>Использовать ее можно вот так:</p>\\n<pre><code class=\\\"language-sh\\\">initializeANSI\\n\\necho ${boldon}this is in bold and ${italicson}this is \\\\\\nitalics${italicsoff}within the bold${reset}\\n</code></pre>\\n<h2>Утилиты</h2>\\n<h3>basename</h3>\\n<p>Позволяет получить имя файла без пути, или имя файла без расширения, или и то и то.</p>\\n<pre><code class=\\\"language-sh\\\">basename ~/temp/readme.md # readme.md\\nbasename readme.md .md # readme\\nbasename ~/temp/readme.md .md # readme\\n</code></pre>\\n<h3>awk</h3>\\n<p>Вообще-то это целый язык программирования, но в большинстве случаев он используется просто чтобы распарсить колоночный вывод от других программ:</p>\\n<pre><code class=\\\"language-sh\\\">ls -l | awk '{print $5}'   # выведет 5-ю колонку, то етсь размер\\n</code></pre>\\n<p>Если нужно вывести несколько колонок:</p>\\n<pre><code class=\\\"language-sh\\\">ls -l | awk '{print $6 \\\" \\\" $7 \\\" \\\" $8}'   # выведет 5,6,7 колонку через пробел\\n</code></pre>\\n<h3>sed</h3>\\n<p><strong>sed</strong> принимает первым аргументом адрес и операцию, а вторым - путь к файлу. Либо можно пайплайнить в него вывод другой программы, тогда ворой аргумент не нужен:</p>\\n<pre><code class=\\\"language-sh\\\">ls -l | sed 's/июл/авг/'  # заменяет месяц в выводе с июля на август\\n</code></pre>\\n<p>sed работает построчно, и по умолчанию он будет заменять первое встретившееся значение в каждой строчке. Если нужно чтобы точно заменил все значения, то в конце надо приписывать модификатор <strong>g</strong>:</p>\\n<pre><code class=\\\"language-sh\\\">sed 's/foo/bar/g' tmp.txt\\n</code></pre>\\n<p>В предыдущих примерах адрес был опущен. В качестве адреса могут быть указаны, например, первая и последняя строчка, над которыми проводить операцию:</p>\\n<pre><code class=\\\"language-sh\\\">sed '1,3s/foo/bar/g' tmp.txt    # замена произойдет в строчках 1-3\\nsed '2,4d' tmp.txt              # будут удалены строчки 2-4\\n</code></pre>\\n<p>Вместо адреса может быть использовано даже регулярное выражение:</p>\\n<pre><code class=\\\"language-sh\\\">sed '/exp/d' tmp.txt    # удалит все строки, подходящие под указанный регэксп\\n</code></pre>\\n<h3>xargs</h3>\\n<p>Принимает на вход аргументы и подставляет их в команду последним аргументом</p>\\n<pre><code class=\\\"language-sh\\\">ls | xargs file     # выведет тип для каждого файла в текущей директории\\n</code></pre>\\n<p>Можно подставлять любым аргументом, но тогда нужно использовать такую конструкцию:</p>\\n<pre><code class=\\\"language-sh\\\">ls | xargs -I % file %\\n</code></pre>\\n<p>Здесь <code>-I %</code> означает, что плейсхолдер будет обозначаться знаком процента, а <code>%</code> в конце - это как раз плейсхолдер.</p>\\n<h3>grep</h3>\\n<p><code>grep -R def .</code> - рекурсивно ищет \\\"def\\\" во всех файлах текущей директории</p>\\n<p><code>grep -E [a-z]{10}</code> - регулярное выражение</p>\\n<p><code>grep a[[:blank:]]</code> - ищем все слова, кончающиеся на а</p>\\n<p><code>grep -c PATTERN</code> - выводит не строчки, а количество вхождений паттерна в файле</p>\\n<h3>find</h3>\\n<p><code>find . -name \\\"*setup*\\\"</code> - рекурсивно искать все файлы с именем, содержащим <strong>setup</strong>, начиная с текущей директории</p>\\n<p><code>find -type f -exec grep PATTERN {} \\\\;</code> : <strong>-exec</strong> позволяет выполнить указанную после него команду для каждого найденного файла. {} - плейсхолдер для полного пути файла. ; - конец команды.</p>\\n<h2>Выход из скрипта после первой провалившейся команды</h2>\\n<p>Нужно вставить в начало скрипта:</p>\\n<pre><code class=\\\"language-sh\\\">set -e\\n</code></pre>\\n<h2>Отладка</h2>\\n<p><code>sh -n &#x3C;script></code> -проверка на синтаксические ошибки</p>\\n<p><code>sh -v &#x3C;script></code> - выводит все команды на экран перед выполнением</p>\\n<p><code>sh -x &#x3C;script></code> - тоже выводит, но после подстановки всех переменных и прочей обработки</p>\\n<p><code>sh -u &#x3C;script></code> - выводит ошибку, если используется неопределенная переменная</p>\\n<pre><code>set -o xtrace\\n...\\nset +o xtrace\\n</code></pre>\\n<p>Такой код можно написать вокруг проблемного участка кода, чтобы только в этом коде выводить на экран команды с подстановкой переменных.</p>\\n<p><code>trap ‘echo Exiting: critical variable = $critical_variable’ EXIT</code> - а так мы можем выводить значение интересующей нас переменной перед выходом из скрипта</p>\\n<h2>Tips &#x26; tricks</h2>\\n<h3>Перемещение в директорию, в которой лежит скрипт</h3>\\n<pre><code class=\\\"language-sh\\\">cd \\\"${0%/*}\\\"\\n</code></pre>\\n<p>Если нужно в другую папку, относительно скрипта (например, в корень репозитория), то можно в конце добавлять относительный путь, например:</p>\\n<pre><code class=\\\"language-sh\\\">cd \\\"${0%/*}/..\\\"\\n</code></pre>\\n<p><a href=\\\"https://stackoverflow.com/questions/28894290/what-does-cd-0-mean-in-bash\\\">https://stackoverflow.com/questions/28894290/what-does-cd-0-mean-in-bash</a></p>\\n<h3>here document</h3>\\n<p>Используя специальный синтаксис, можно прямо в команду вставить текст, который будет сохранен в файл:</p>\\n<pre><code class=\\\"language-sh\\\">$ cat > test.txt &#x3C;&#x3C; EOF\\n> hello\\n> this\\n> is\\n> test\\n> file\\n> EOF\\n</code></pre>\\n<p>Здесь <code>EOF</code> - это плейсхолдер, обозначающий последнюю строчку файла. Он необязательно должен быть <code>EOF</code>, может быть любой.</p>\",\"frontmatter\":{\"path\":\"/blog/sh\",\"title\":\"sh\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/blog-sh.json\n// module id = 486\n// module chunks = 186644301018450"],"sourceRoot":""}