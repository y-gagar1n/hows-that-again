webpackJsonp([0x5f414e30ac44],{424:function(n,a){n.exports={data:{markdownRemark:{html:'<h1>Effective Modern C++</h1>\n<h2>Вывод типов через auto</h2>\n<p>Тип для <code class="language-text">auto</code> выводится так же, как и для шаблонов. В том выводе типов у нас есть определение шаблона и его вызов:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>\nvoid <span class="token function">f</span><span class="token punctuation">(</span>ParamType param<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">f</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>\n<p>Когда переменная объявляется через <code class="language-text">auto</code>, то <code class="language-text">auto</code> выступает в роли <strong>T</strong>, а спецификатор типа - как <code class="language-text">ParamType</code>. Например:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>\t\t\t<span class="token comment">// auto -> T, auto -> ParamType</span>\nconst auto cx <span class="token operator">=</span> x<span class="token punctuation">;</span>\t\t<span class="token comment">// auto -> T, const auto -> ParamType</span>\nconst auto<span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span>\t\t<span class="token comment">// auto -> T, const auto&amp; -> ParamType</span></code></pre></div>\n<p>Для вывода представим соответствующие им шаблоны и их вызовы:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>\nvoid <span class="token function">func_x</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">func_x</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\t\t<span class="token comment">// ParamTYpe -> int, T -> int</span>\n\ntemplate<span class="token operator">&lt;</span>typename T<span class="token operator">></span>\nvoid <span class="token function">func_cx</span><span class="token punctuation">(</span>const T param<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">func_cx</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>\t\t<span class="token comment">// ParamType -> const int, T -> int</span>\n\ntemplate<span class="token operator">&lt;</span>typename T<span class="token operator">></span>\nvoid <span class="token function">func_rx</span><span class="token punctuation">(</span>const T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">func_rx</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>\t\t<span class="token comment">// ParamType -> const int&amp;, T -> int</span></code></pre></div>\n<p>Во всех остальных случаях логика точно такая же как и для вывода типа шаблона. Но есть одно исключение, о нем дальше.</p>\n<h3>Особый случай для initializer_list</h3>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto x1 <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>\t\t<span class="token comment">// int</span>\nauto <span class="token function">x2</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\t\t<span class="token comment">// int</span>\nauto x3 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">27</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\t\t<span class="token comment">// std::initializer_list&lt;int> = {27}</span>\nauto x4<span class="token punctuation">{</span><span class="token number">27</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\t\t<span class="token comment">// std::initializer_list&lt;int> = {27}</span></code></pre></div>\n<p>Так происходит потому что в выводе типов через <code class="language-text">auto</code> прописано особое правило: <strong>если значение для авто-объявленной переменной заключено в фигурные скобки, то тип ВСЕГДА выводится как std::initializer_list</strong>.</p>\n<p>При этом в выводе типов для шаблонов такого правила нет и это единственное место где алгоритмы различаются:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>\nvoid <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ОШИБКА КОМПИЛЯЦИИ!</span>\n\ntemplate<span class="token operator">&lt;</span>typename T<span class="token operator">></span>\nvoid <span class="token function">f2</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">></span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">fw</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\t\t<span class="token comment">// все ок, тип T выводится как int</span></code></pre></div>\n<h2>decltype</h2>\n<p><strong>decltype</strong> - это функция, которая принимает переменную, а возвращает ее тип. Может быть использована там, где ожидается указание типа.</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">const int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\t\t\t<span class="token comment">// decltype(i) -> const int</span>\nbool <span class="token function">f</span><span class="token punctuation">(</span>const Widget<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\t\t<span class="token comment">// decltype(w) -> const Widget&amp;, decltype(f) -> bool(const Widget&amp;)</span></code></pre></div>\n<p>Обычно используется там, где тип возвращаемого значения зависит от типа аргумента:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename Container<span class="token punctuation">,</span> typename Index<span class="token operator">></span>\nauto <span class="token function">authAndAccess</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">decltype</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token function">authenticateser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token keyword">return</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre></div>\n<p>здесь <code class="language-text">auto</code> не имеет отношения к выводу типов, а лишь указывает, что возвращаемый тип будет указан после списка параметров (trailing return type syntax). Такой синтаксис необходимо использовать, когда тип возвращаемого значения зависит от типов параметров.</p>\n<p>В C++14 можно возвращать из функций <code class="language-text">auto</code>, не указывая тип после стрелочки, но с этим бывают проблемы, поэтому рекомендуется возвращать <code class="language-text">decltype(auto)</code>.</p>\n<p>С <code class="language-text">authAndAccess</code> осталась одна проблема - она не сможет принимать rvalue для контейнера. Модифицируем так, чтобы мог:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename Container<span class="token punctuation">,</span> typename Index<span class="token operator">></span>\nauto <span class="token function">get</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">decltype</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>Container<span class="token operator">></span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">authenticateUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>Container<span class="token operator">></span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre></div>\n<p>Теперь для <strong>c</strong> типа lvalue функция будет возвращать lvalue, а для rvalue - rvalue.</p>\n<h3>Особенность поведения decltype</h3>\n<p>Применение <strong>decltype</strong> к имени переменной возвращает тип этого имени. Однако применение к lvalue, котороя является чем-то более сложным, чем имя, возвращает ссылку на lvalue. То есть <strong>decltype</strong> над выражением не-именем, имеющим тип <strong>T</strong> вернет тип <strong>T&#x26;</strong>. Такое поведение редко на что-либо влияет, однако есть интересное следствие:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">int x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token function">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>\t<span class="token comment">// int</span>\n<span class="token function">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\t<span class="token comment">// int&amp;</span></code></pre></div>\n<p>Как видно, оборачивание значения в скобки может поменять значение, возвращаемое <strong>decltype</strong>. Это особенно важно в C++14, где можно возвращать из функции <code class="language-text">decltype(auto)</code> и случайно можно вернуть ссылку на элемент вместо элемента.</p>\n<h2>Используйте auto вместо явных определений типов</h2>\n<h3>auto не даст создать неинициализированный объект</h3>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">int x<span class="token punctuation">;</span>\t<span class="token comment">// не инициализирован!</span>\n\nauto x<span class="token punctuation">;</span> <span class="token comment">// не скомпилится!</span></code></pre></div>\n<h3>Позволяет не писать сложные типы</h3>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename It<span class="token operator">></span>\nvoid <span class="token function">dwim</span><span class="token punctuation">(</span>It b<span class="token punctuation">,</span> It e<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\ttypename std<span class="token punctuation">:</span><span class="token punctuation">:</span>iterator_traits<span class="token operator">&lt;</span>It<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>value_type currValue <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>\n\tauto currValue2 <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>\n\t<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>\n<h3>Экономить память при использовании функторов</h3>\n<p>Тип лямбды неизвестен до компиляции, поэтому описать его точно - невозможно. Приходится использовать тип <code class="language-text">std::function</code>. </p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">function</span><span class="token operator">&lt;</span><span class="token function">bool</span><span class="token punctuation">(</span>const std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">,</span> const std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">></span>\n\tfuncs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>const std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> const std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\t<span class="token keyword">return</span> <span class="token operator">*</span>a <span class="token operator">&lt;</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span></code></pre></div>\n<p>Но у него есть недостаток - он всегда занимает фиксированный размер в памяти, и если его не хватает, то аллоцирует память в куче. Тогда как реальный тип замыкания, выводимый во время компиляции и используемый с помощью <strong>auto</strong> всегда занимает ровно столько места, сколько ему требуется.</p>\n<p>Плюс к этому, из-за особенностей реализации, при вызове функции через <code class="language-text">std::function</code> запрещается инлайнинг и добавляется непрямой вызов функции (indirect function calls), что ухудшает производительность по сравнению с <strong>auto</strong>.</p>\n<h3>Неявные приведения типов</h3>\n<p>Допустим, есть такой код:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>int<span class="token operator">></span> v<span class="token punctuation">;</span>\nunsigned sz <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>\n<p>Все бы ничего, да только <code class="language-text">v.size()</code> возвращает вовсе не <strong>unsigned</strong>, а <code class="language-text">std::vector&lt;int&gt;::size_type</code>.</p>\n<p>Другой пример:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>unordered_map<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token punctuation">,</span> int<span class="token operator">></span> m<span class="token punctuation">;</span>\n\n<span class="token keyword">for</span><span class="token punctuation">(</span>const std<span class="token punctuation">:</span><span class="token punctuation">:</span>pair<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token punctuation">,</span> int<span class="token operator">></span><span class="token operator">&amp;</span> p<span class="token punctuation">:</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n<span class="token punctuation">}</span></code></pre></div>\n<p>Реальный тип элементов, содержащихся в <code class="language-text">unordered_map</code> - <code class="language-text">std::pair&lt;const std::string, int&gt;</code>. В результате компилятор не сможет привести <code class="language-text">std::pair&lt;const std::string, int&gt;</code> к <code class="language-text">std::pair&lt;std::string, int&gt;</code> и будет для каждого члена создавать временный объект, ссылку на который копировать в <strong>p</strong>. После каждой итерации временный объект будет уничтожен.</p>\n<p>Использование <strong>auto</strong> в этом случае делает код проще и производительнее:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>unordered_map<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token punctuation">,</span> int<span class="token operator">></span> m<span class="token punctuation">;</span>\n\n<span class="token keyword">for</span><span class="token punctuation">(</span>const auto<span class="token operator">&amp;</span> p<span class="token punctuation">:</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre></div>\n<h2>Иногда auto выводит не то, что нужно</h2>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>bool<span class="token operator">></span> <span class="token function">features</span><span class="token punctuation">(</span>const Widget<span class="token operator">&amp;</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nWidget w<span class="token punctuation">;</span>\nauto highPriority <span class="token operator">=</span> <span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token function">processWidget</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> highPriority<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>\n<p>Как ни удивительно, этот код приводит к undefined behavior. Дело в том, что оператор <code class="language-text">[]</code> для <code class="language-text">std::vector&lt;bool&gt;</code> возвращает <code class="language-text">std::vector&lt;bool&gt;::reference</code>. Так происходит потому, что булевого типа у вектора есть специальная реализация, которая хранит по одному биту на элемент. Теперь оператор <code class="language-text">[]</code> должен возвращать ссылку на бит, но в C++ запрещены ссылки на биты. Поэтому приходится возвращать тип, который <em>ведет себя</em> как <code class="language-text">bool&amp;</code>. ЭТо означает, что он, помимо прочего, должен быть неявно приводим к <code class="language-text">bool</code>. </p>\n<p>Получается, что когда мы делаем <code class="language-text">bool highPriority = features(w)[5]</code>, то возвращается <code class="language-text">std::vector&lt;bool&gt;::reference</code>, который приводится к <code class="language-text">bool</code> и дальше все нормально.</p>\n<p>А вот когда мы делаем <code class="language-text">auto highPriority = features(w)[5]</code>, то дальше все зависит от реализации типа <code class="language-text">std::vector&lt;bool&gt;::reference</code>. Одна из реализаций представляет из себя:</p>\n<ul>\n<li>указатель на машинное слово вектора, в котором содержится интересующий бит</li>\n<li>сдвиг в этом слове</li>\n</ul>\n<p>Итак, вызов <code class="language-text">features</code> возвращает временный объект-вектор. Оператор <code class="language-text">[]</code> возвращает <code class="language-text">std::vector&lt;bool&gt;::reference</code>, в котором содержится ссылка на элемент внутри временного объекта-вектора. Мы записываем это в <code class="language-text">highPriority</code>, после чего временный объект уничтожается, а в <code class="language-text">highPriority</code> остается висячая ссылка на уничтоженный объект.</p>\n<p>Здесь <code class="language-text">std::vector&lt;bool&gt;::reference</code> - это прокси-класс, который не предназначен для того, чтобы жить дольше, чем одно выражение. Поэтому <strong>auto</strong> очень плохо дружит с прокси-классами.</p>\n<p>Такие прокси-классы очень тяжело найти заранее, однако когда стало понятно, что проблема в прокси-классе, не стоит избавляться от <strong>auto</strong>. Лучший способ - использовать явное приведение типа:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto highPriority <span class="token operator">=</span> static_cast<span class="token operator">&lt;</span>bool<span class="token operator">></span><span class="token punctuation">(</span><span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>\n<h2>Различия между () и {} при инициализации объектов</h2>\n<p>Для начало важно отличать инициализацию от присвоения:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">Widget w1<span class="token punctuation">;</span>\t\t\t<span class="token comment">// инициализация, вызван дефолтный конструктор</span>\nWidget w2 <span class="token operator">=</span> w1<span class="token punctuation">;</span>\t\t<span class="token comment">// инициализация, вызывается конструктор копирования</span>\nw1 <span class="token operator">=</span> w2<span class="token punctuation">;</span>\t\t\t<span class="token comment">// присвоение, вызывается оператор =</span></code></pre></div>\n<p>В C++ 11 представлена <em>uniform initialization</em> - предпочтительный способ инициализации:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">int x<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\nstd<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>int<span class="token operator">></span> v<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>\n<p>Тот же синтаксис можно использовать и для задания дефолтных значений не-статическим полям классов, наравне с синтаксисом через <strong>=</strong>:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>\nprivate<span class="token punctuation">:</span>\n\tint x<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\t<span class="token comment">// ОК</span>\n\tint y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\t<span class="token comment">// тоже ок</span>\n\tint <span class="token function">z</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\t<span class="token comment">// ошибка компиляции!</span>\n<span class="token punctuation">}</span></code></pre></div>\n<p>Однако если инициализируем не-копируемый тип, то <strong>{}</strong> валиден наравне с синтаксисом через <strong>()</strong>:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>atomic<span class="token operator">&lt;</span>int<span class="token operator">></span>ai1<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\t\t<span class="token comment">// OK</span>\nstd<span class="token punctuation">:</span><span class="token punctuation">:</span>atomic<span class="token operator">&lt;</span>int<span class="token operator">></span><span class="token function">ai2</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\t\t<span class="token comment">// OK</span>\nstd<span class="token punctuation">:</span><span class="token punctuation">:</span>atomic<span class="token operator">&lt;</span>int<span class="token operator">></span>ai3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\t<span class="token comment">// ошибка!</span></code></pre></div>\n<p>Поэтому, чтобы не путаться, лучше всегда использовать универсальную (uniform) инициализацию вида <code class="language-text">int x{0};</code>.</p>\n<h3>{} запрещает преобразование типа с потерей точности</h3>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">double x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">;</span>\nint sum1<span class="token punctuation">{</span> x<span class="token operator">+</span>y<span class="token operator">+</span>z <span class="token punctuation">}</span><span class="token punctuation">;</span>\t\t<span class="token comment">// не скомпилится, так как сумма даблов может быть невыразима через int</span>\nint <span class="token function">sum2</span><span class="token punctuation">(</span> x<span class="token operator">+</span>y<span class="token operator">+</span>z <span class="token punctuation">)</span><span class="token punctuation">;</span>\t\t<span class="token comment">// спокойно компилится и приводит к неожиданному поведению при выполнении</span>\nint sum3 <span class="token operator">=</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>\t<span class="token comment">// аналогично sum2</span></code></pre></div>\n<h3>{} не подвержена most vexing parse</h3>\n<p>В С++ есть такое правило - все, что может быть интерпретировано как объявелние, должно быть интерпретировано как объявление.</p>\n<p>Поэтому часто, когда хотим инициализировать переменную дефолтным конструктором через скобки, вместо этого получается объявление функции:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">Widget <span class="token function">w1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\t<span class="token comment">// когда у конструктора есть параметры, то все норм</span>\nWidget <span class="token function">w2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\t<span class="token comment">// а вот когда хотис использовать дефолтный конструктор, то получается объявление функции</span></code></pre></div>\n<p>С использованием <strong>{}</strong> код выглядит так и не содержит этой проблемы:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">Widget w3<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>\n<h3>Недостаток: опять проблемы с initializer_list</h3>\n<p>Если при инициализации через <strong>{}</strong> имеется конструктор, принимающий <code class="language-text">initializer_list</code>, и он может быть теоретически использован, то будет использован именно он:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>\npublic<span class="token punctuation">:</span>\n\t<span class="token function">Widget</span><span class="token punctuation">(</span>int i<span class="token punctuation">,</span> bool b<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token function">Widget</span><span class="token punctuation">(</span>int i<span class="token punctuation">,</span> double d<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token function">Widget</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>initializer_list<span class="token operator">&lt;</span>long double<span class="token operator">></span> il<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nWidget <span class="token function">w1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\t<span class="token comment">// будет вызван первый конструктор</span>\nWidget w2<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\t<span class="token comment">// 3-й</span>\nWidget <span class="token function">w3</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\t\t<span class="token comment">// 2-й</span>\nWidget w4<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\t\t<span class="token comment">// 3-й</span></code></pre></div>\n<p>Причем иногда путь довольно непрост:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>\npublic<span class="token punctuation">:</span>\n  <span class="token function">Widget</span><span class="token punctuation">(</span>int i<span class="token punctuation">,</span> bool b<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">Widget</span><span class="token punctuation">(</span>int i<span class="token punctuation">,</span> double d<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">Widget</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>initializer_list<span class="token operator">&lt;</span>long double<span class="token operator">></span> il<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  operator <span class="token function">float</span><span class="token punctuation">(</span><span class="token punctuation">)</span> const<span class="token punctuation">;</span>\t\t<span class="token comment">// оператор преобразования Widget во float</span>\n\n  <span class="token comment">// конструктор копирования</span>\n  <span class="token comment">// конструктор перемещения</span>\n<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\nWidget <span class="token function">w5</span><span class="token punctuation">(</span>w4<span class="token punctuation">)</span><span class="token punctuation">;</span>\t\t\t\t<span class="token comment">// вызывается конструктор копирования </span>\nWidget w6<span class="token punctuation">{</span>w4<span class="token punctuation">}</span><span class="token punctuation">;</span>\t\t\t\t<span class="token comment">// вызывается преобразование к float и затем конструктор с initializer_list, так как float может быть преобразован к long double</span>\nWidget <span class="token function">w7</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">move</span><span class="token punctuation">(</span>w4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\t<span class="token comment">// конструктор перемещения</span>\nWidget w8<span class="token punctuation">{</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">move</span><span class="token punctuation">(</span>w4<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\t<span class="token comment">// опять конструктор с initializer_list через преобразование к float</span></code></pre></div>\n<p>Более того, компилятор настолько сильно хочет использовать <code class="language-text">initializer_list</code>, что даже идеально подходящие другие конструкторы ему не помеха:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>\npublic<span class="token punctuation">:</span>\n  <span class="token function">Widget</span><span class="token punctuation">(</span>int i<span class="token punctuation">,</span> bool b<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">Widget</span><span class="token punctuation">(</span>int i<span class="token punctuation">,</span> double d<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">Widget</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>initializer_list<span class="token operator">&lt;</span>bool<span class="token operator">></span> il<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> \n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nWidget w<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\t<span class="token comment">// ошибка компиляции!</span></code></pre></div>\n<p>Компилятор, несмотря на то, что есть конструктор, принимающий <strong>int</strong> и <strong>double</strong>, опять попытался использовать конструктор с <code class="language-text">initializer_list</code> и не смог, потому что для этого требуется сужающее приведение <strong>int</strong> и <strong>double</strong> к <strong>bool</strong>, а сужающие приведения запрещены в инициализации через <strong>{}</strong>.</p>\n<p>Однако и из этого правила есть исключение - если есть дефолтный конструктор и мы вызываем инициализацию без параметров, то дефолтный конструктор имеет высший приоритет над конструктором с <code class="language-text">initializer_list</code>:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"> class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>\npublic<span class="token punctuation">:</span>\n  <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">Widget</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>initializer_list<span class="token operator">&lt;</span>int<span class="token operator">></span> il<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\nWidget w1<span class="token punctuation">;</span>\t\t<span class="token comment">// дефолтный конструктор</span>\nWidget w2<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\t<span class="token comment">// дефолтный конструктор</span>\nWidget <span class="token function">w3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\t<span class="token comment">// most vexing parse! объявляет функцию</span>\n\nWidget <span class="token function">w4</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\t<span class="token comment">// только так мы в этом случае можем вызвать конструктор с initializer_list</span>\nWidget w5<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\t<span class="token comment">// ну или так</span></code></pre></div>\n<p>Один из выводов из всего этого - если вы автор библиотеки, то не стоит добавлять конструктор, принимающий <code class="language-text">initializer_list</code>, так как тогда возможно клиенты не смогут использовать ваши остальные конструкторы.</p>\n<h2>Используйте nullptr вместо 0 и NULL</h2>\n<p>В С++98 использование 0 и NULL приводило к тому, что перегрузки, принимающие указатель, могли не вызываться:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">void <span class="token function">f</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token punctuation">;</span>\nvoid <span class="token function">f</span><span class="token punctuation">(</span>bool<span class="token punctuation">)</span><span class="token punctuation">;</span>\nvoid <span class="token function">f</span><span class="token punctuation">(</span>void<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\t\t\t<span class="token comment">// f(int)</span>\n<span class="token function">f</span><span class="token punctuation">(</span>NULL<span class="token punctuation">)</span><span class="token punctuation">;</span>\t\t<span class="token comment">// могло не скомпилиться, но если компилилось, то вызывало f(int)</span></code></pre></div>\n<p>Все потому, что 0 - это целочисленный тип и NULL часто был определен тоже как численный тип.</p>\n<p>Преимущество <strong>nullptr</strong> - он не может быть интерпретирован как численный тип, только как указатель. Тип <strong>nullptr</strong> - <code class="language-text">std::nullptr_t</code>. ЭТот тип неявно приводит к себе указатели всех типов, поэтому <strong>nullptr</strong> - универсальный указатель.</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token function">f</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>\t\t<span class="token comment">// f(void*)</span></code></pre></div>\n<h2>Используйте alias вместо typedef</h2>\n<p>В С++98 были <strong>typedef</strong>:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">typedef\n     std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>unordered_map<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token operator">></span><span class="token operator">></span>\n     UPtrMapSS<span class="token punctuation">;</span></code></pre></div>\n<p>Они устарели, когда в C++11 появились алиасы:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"> using UPtrMapSS <span class="token operator">=</span>\n     std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>unordered_map<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token operator">></span><span class="token operator">></span><span class="token punctuation">;</span></code></pre></div>\n<p>Еще один пример, демонстрирующий повышенную читаемость алиасов по сравнению с тайпдефом:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">typedef void <span class="token punctuation">(</span><span class="token operator">*</span>FP<span class="token punctuation">)</span><span class="token punctuation">(</span>int<span class="token punctuation">,</span> const std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nusing FP <span class="token operator">=</span> void <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>int<span class="token punctuation">,</span> const std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>\n<p>Основное преимущество - алиасы могут быть шаблонизированы, а тайпдефы - нет. В С++98 приходилось извращаться и определять тайпдефы внутри шаблонизированных структур:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>\nstruct MyAllocList <span class="token punctuation">{</span> \n\ttypedef std<span class="token punctuation">:</span><span class="token punctuation">:</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">></span> type<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nMyAllocList<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>type lw<span class="token punctuation">;</span></code></pre></div>\n<p>Если же после этого мы захотим использовать этот шаблно внутри другого шаблонизированного класса, то придется писать <code class="language-text">typename</code>:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>\nclass <span class="token class-name">Widget</span> <span class="token punctuation">{</span>\nprivate<span class="token punctuation">:</span>\n\ttypename MyAllocList<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>type list<span class="token punctuation">;</span>\n<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>\n<p>Кстати, при использовании type traits так и приходится писать, так как они были реализованы с использованием тайпдефов, а не алиасов, несмотря на то, что были введены в C++11. В С++14 признали эту ошибку и для каждого класса <code class="language-text">std::transformation&lt;T&gt;::type</code> теперь есть соответствующий <code class="language-text">std::transformation_t&lt;T&gt;</code>, реализованный через алиасы.</p>\n<p>Так вот, в С++11 есть алиасы и использовать их мы можем так:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>\nusing MyAllocList <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">></span><span class="token punctuation">;</span>\n\nMyAllocList<span class="token operator">&lt;</span>Widget<span class="token operator">></span> lw<span class="token punctuation">;</span></code></pre></div>\n<h2>Используйте scoped enums вместо unscoped enums</h2>\n<p>Есть такое правило, что имя, объявленное внутри фигурных скобок, видно только внутри области, ограниченной этими скобками. Это правило соблюдается всегда, кроме енумов в C++98.</p>\n<p>Поэтому енумы в C++98 - unscoped enums:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">enum Color <span class="token punctuation">{</span>red<span class="token punctuation">,</span> black<span class="token punctuation">,</span> white<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nauto white <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\t\t<span class="token comment">// ОШИБКА КОМПИЛЯЦИИ! white уже определен</span></code></pre></div>\n<p>В С++11 им на замену пришли scoped enums:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">enum class <span class="token class-name">Color</span> <span class="token punctuation">{</span>red<span class="token punctuation">,</span> black<span class="token punctuation">,</span> white<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nauto white <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\t\t<span class="token comment">// все норм</span>\nColor c <span class="token operator">=</span> white<span class="token punctuation">;</span>\t\t<span class="token comment">// ОШИБКА КОМПИЛЯЦИИ! нет имени white в текущем скоупе</span>\nColor c <span class="token operator">=</span> Color<span class="token punctuation">:</span><span class="token punctuation">:</span>white<span class="token punctuation">;</span>\t<span class="token comment">// ok</span>\nauto c <span class="token operator">=</span> Color<span class="token punctuation">:</span><span class="token punctuation">:</span>white<span class="token punctuation">;</span>\t<span class="token comment">// ok</span></code></pre></div>\n<p>Помимо ограниченной видимости, вторая причина, по которой стоит использовать scoped enums - более строгая типизация. Unscoped enums свободно неявно приводятся к целочисленным типам и типам с плавающей точкой:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">Color c <span class="token operator">=</span> Color<span class="token punctuation">:</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span>\n\n<span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token number">14.5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\t<span class="token comment">// ОШИБКА КОМПИЛЯЦИИ</span>\n\t<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">if</span><span class="token punctuation">(</span>static_vast<span class="token operator">&lt;</span>double<span class="token operator">></span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">14.5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\t\t<span class="token comment">// OK</span>\n\t<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n<span class="token punctuation">}</span></code></pre></div>\n<p>И еще одно преимущество - при использовании scoped enums не нужно перекомпиливать клиентов енума при добавлении в него нового значения. А с unscoped enums - нужно.</p>\n<p>Дефолтный тип для scoped enums - int, для unscoped enums - нет дефолтного.</p>\n<h2>Используйте deleted функции вместо private undefined</h2>\n<p>В С++98 когда нужно запретить вызов какой-либо функции (обычно конструктора присваивания или копирования), то определяют ее как private и просто не пишут ее реализацию:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template <span class="token operator">&lt;</span>class <span class="token class-name">charT</span><span class="token punctuation">,</span> class <span class="token class-name">traits</span> <span class="token operator">=</span> char_traits<span class="token operator">&lt;</span>charT<span class="token operator">></span> <span class="token operator">></span>\n   class <span class="token class-name">basic_ios</span> <span class="token punctuation">:</span> public ios_base <span class="token punctuation">{</span>\n   public<span class="token punctuation">:</span>\n<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\nprivate<span class="token punctuation">:</span>\n     <span class="token function">basic_ios</span><span class="token punctuation">(</span>const basic_ios<span class="token operator">&amp;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// not defined</span>\n     basic_ios<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span>const basic_ios<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// not defined</span>\n   <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>\n<p><strong>private</strong> гарантирует, что внешний код не имеет доступ к этим функциям. Отсутствие реализации для таких функций гарантирует, что даже если какой-то какой-то код, имеющий к ним доступ, попытается их вызвать, он получит ошибку на этапе линковки.</p>\n<p>В C++11 такие функции определяются как удаленные:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template <span class="token operator">&lt;</span>class <span class="token class-name">charT</span><span class="token punctuation">,</span> class <span class="token class-name">traits</span> <span class="token operator">=</span> char_traits<span class="token operator">&lt;</span>charT<span class="token operator">></span> <span class="token operator">></span> \nclass <span class="token class-name">basic_ios</span> <span class="token punctuation">:</span> public ios_base <span class="token punctuation">{</span>\npublic<span class="token punctuation">:</span>\n\t<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n\t<span class="token function">basic_ios</span><span class="token punctuation">(</span>const basic_ios<span class="token operator">&amp;</span> <span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span> \n\tbasic_ios<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span>const basic_ios<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span> \n\t<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n<span class="token punctuation">}</span></code></pre></div>\n<p>Удаленные функции никак не могут быть использованы и такие попытки приведт к ошибкам на этапе компиляции.</p>\n<p>А еще, используя удаленные функции, можно запредить использование шаблонных функций с определенными типами:</p>\n<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>\nvoid <span class="token function">processPointer</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\ntemplate<span class="token operator">&lt;</span><span class="token operator">></span>\nvoid processPointer<span class="token operator">&lt;</span>void<span class="token operator">></span><span class="token punctuation">(</span>void<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span>\ntemplate<span class="token operator">&lt;</span><span class="token operator">></span>\nvoid processPointer<span class="token operator">&lt;</span>char<span class="token operator">></span><span class="token punctuation">(</span>char<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span>\ntemplate<span class="token operator">&lt;</span><span class="token operator">></span>\nvoid processPointer<span class="token operator">&lt;</span>const void<span class="token operator">></span><span class="token punctuation">(</span>const void<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span>\ntemplate<span class="token operator">&lt;</span><span class="token operator">></span>\nvoid processPointer<span class="token operator">&lt;</span>const char<span class="token operator">></span><span class="token punctuation">(</span>const char<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span></code></pre></div>',
frontmatter:{path:"/blog/books/effective-modern-cpp",title:"Effective Modern C++"}}},pathContext:{}}}});
//# sourceMappingURL=path---blog-books-effective-modern-cpp-dfe0a57e8b4287161878.js.map