{"version":3,"sources":["webpack:///path---blog-books-computer-organization-and-design-df9ba92f588b98eb54fb.js","webpack:///./.cache/json/blog-books-computer-organization-and-design.json"],"names":["webpackJsonp","409","module","exports","data","markdownRemark","html","frontmatter","path","title","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA;AAAks6JC,aAAgxQC,KAAA,+CAAAC,MAAA,sCAAmGC","file":"path---blog-books-computer-organization-and-design-df9ba92f588b98eb54fb.js","sourcesContent":["webpackJsonp([55889076892030],{\n\n/***/ 409:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>Источники: </p>\\n<ul>\\n<li><a href=\\\"https://www.amazon.com/Computer-Organization-Design-MIPS-Architecture/dp/0124077269\\\">Computer Organization and Design MIPS Edition</a></li>\\n<li><a href=\\\"https://habr.com/post/179647/\\\">Логическая организация кэш-памяти процессора</a></li>\\n<li><a href=\\\"https://habr.com/post/183834/\\\">Кэш в многопроцессорных системах. Когерентность кэша. Протокол MESI</a></li>\\n</ul>\\n<h1>I/O</h1>\\n<h2>LCD</h2>\\n<p>Состоит из двух фильтров с перпендикулярной поляризацией, а между ними - стержнеобразные молекулы (кристаллы) в жидкости. Эти молекулы формируют закручивающуюся спираль, которая изгибает свет, проходящий через дисплей.</p>\\n<p>Когда напряжения нет, то кристалы, примыкающие к горизонтальному фильтру, повернуты горизонтально, а к вертикальному - вертикально. Когда через эти кристалы проходит свет, то он \\\"изгибается\\\" и меняет свою поскость поляризации с горизонтальной на вертикальную, в результате чего проходит через оба фильтра без потерь (не считая половины неполяризованного света, поглощенного первым фильтром, ну то есть вертикально поляризованный свет не смог пройти через горизонтальный фильтр).</p>\\n<p>Если же к кристаллам приложено напряжение, молекулы стремятся выстроиться в направлении электрического поля, что искажает их винтовую структуру. Свет уже ко второму фильтру приходит не совсем вертикально поляризованный, а отклоненный на сколько-то градусов, поэтому степень прозрачности понижмается. Варьируя напряжение, можно управлять степенью прозрачности.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/aae383dbf961d65ff8a971793d38b6e6/8cd7e/lcd-display.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 640px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 80%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAB7BAAAewQHDaVRTAAAC9UlEQVQ4y21Uy05aURTlA4w/4ES/wYGJA9M6sA79BYcmfoBjY+LAgYlp0pI0oRQTa2x5KMUiYPEB2pAUBeQlLzHFoCjv9+Wu7n24IDbuZOece+8+6+zHWlclyzLYeK1Wq8IrlQoajQZqtVrfB+M6nc6rz+wqufsWEgEEr67g9/kQCYfF/vLyEj56vr6+FofYMpkM/H4/whQTCoXEN46JRqOo1+sEqAT+b016Xy6XRRCvnDFbu91Gs9lEq9WCJEliLRQKYuVLVRwkXVxA0mhQpJuSsRgyHg/uKQMOrDEoldyR2qhSK2KUEWcVCYfgpwqOnU4Ui8V++QKwaTQir1Lhhjy6uIijpSXszs7Cabfjni4o5nK4y9fhj93BcR6CwfILZtsJTCYzNjbeo1QqvQSUUinkh4aQJsDU3BzcKyuwvHsHm2UfAW8Y/mAS7nAWDm8GO3Y/tgxWbP84hf6nGx8+6UQLXgDK1KfS2JgATExP43R5GXtv3kKj/ox9qwdeHwHGnmDx3EJrcmNzxwzd9wNotnaxtf2tP7DulJXxV2ZmkCHA5Pi4yHB3agpfP6pxdPgbZ54QDi7SsFKGevsfOJwuOE/OYDTt4vj4qA/WBaSpsdUWFgRgbHQUZ6urMExMwPpFi9ubFHJ/M4gmbhAIx9FotomnZdxns3C5XIIybD0uqmQaN1tjfR1ZArwfHoZbq4Vxfh6HajVKNaJNsSBiqoLwdQVAJgpJfZr1Ku3zUH54QH5kBDUCvbVYYNjbg0OvB4dJzDFFEUwR5iVTilU1yNHnoShlN3Q6FAkQNhuCNHkzgXaIvEzgQXt8fEQkEkE8HkcwGMQDJfNiKMKVTKuTk5DX1sQ+6PXiKZ8XKmBn1bCue6pg58tYPb1J96csK1m0z8/R2NxEq9socYBBuDRWSIyInkgkhI5Zz4FAQOi4V7ZqsKG9LBsEUqDMuF+sghwpJUtT7TmX3HnlH/DcQ6XsQdDee/6VJZNJpKin6XRa7HltK33vt0w5/w8GdHxC1SCFPwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"LCD Display\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/aae383dbf961d65ff8a971793d38b6e6/8cd7e/lcd-display.png\\\"\\n        srcset=\\\"/hows-that-again/static/aae383dbf961d65ff8a971793d38b6e6/bf5b7/lcd-display.png 163w,\\n/hows-that-again/static/aae383dbf961d65ff8a971793d38b6e6/f1b9d/lcd-display.png 325w,\\n/hows-that-again/static/aae383dbf961d65ff8a971793d38b6e6/8cd7e/lcd-display.png 640w\\\"\\n        sizes=\\\"(max-width: 640px) 100vw, 640px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Раньше использовалась <strong>пассивная матрица</strong>. Это значит, что для управления экраном NxM пикселей использовались N+M линий адресации, то есть N - для выбора строки и M - для выбора столбца. На выбранные строки подавалось напряжение, пиксель на пересечении загорался и должен был хранить свое состояние до следующей активации. Таким образом, при смене кадра последовательно изменялись все пиксели экрана. Из-за большой емкости ячеек напряжение на них меняется медленно, а значит и кадры тоже медленно меняются.</p>\\n<p>В настоящее время большинство ЖК-дисплеев используют <strong>активную матрицу</strong> на тонкопленочных транзисторах (thin film transistors / TFT). Раньше широко применялись матрицы на тонкопленочных диодах (TFD), но сейчас таких почти нет. В схеме активной матрицы с каждой точкой изображения последовательно включена собственная тройка транзисторов, управляющих цветами R, G, B. Все пиксели изменяются параллельно.</p>\\n<p>На уровне железа поддержка графики состоит в основном из <strong>фреймбуфера</strong>, в котором хранится битовая карта. Изображение, которое нужно отобразить на экране, сохраняется в фреймбуфере. Если у нас 24-битный цвет, то для каждого пикселя во фреймбуфере сохраняется 24 бита.</p>\\n<h2>Тачскрин</h2>\\n<p>На данный момент в большинстве тачскринов используются емкостностные экраны.</p>\\n<h3>Поверхностно-емкостной экран</h3>\\n<p>Экран покрывается прозрачным проводящим материалом, а по углам экрана располагаются 4 электрона, подающие на этот слой небольшое напряжение. Когда человек прикасается к экрану, возникает утечка точка. Чем ближе палец к электроду, тем меньше сопротивление экрана, а значит больше сила тока. Ток регистрируется датчиками в углах и передается на контроллер, вычисляющий координаты точки касания.</p>\\n<p>Не умеет в мультитач.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/8a8976025f3c35e3345bc3b0ba9815b6/b7119/touch-screen-capacitive.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 360px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 105.83333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsSAAALEgHS3X78AAAEMElEQVQ4y62VbUxbVRiA773QwspHO9gKjhFgczHRTexM5tQY/eFvk8X4AxNNYP7QIG5LRtzUZWabc4o4MxhmG0FWPtpuZdpv7uSr0malA6W0sCItUOnnSoGW0tJbbl/vLZcELEZNPMnT2557znPe9773nCLIesulKED+p4ZRPEmRR5FOkcZc/w1pm9jSaBmHgk/BpcimyPkHsjeNpzPcsSGjbzzFCMsQFOX/h+zouShD7kbnToqXKfJRDDvIyc56RgKAvnBWjh2p+hLNe+V9au2C5AyE+fyLEGPI2eikR/GY77ztwlBPx7BKySJWIVpEX7qkRZDX6zZuHaDYzTyy/YwYQTNydybDPXriysF3u2wXqvD4m+X1nkNIxUzWdgsAlYGguoGFsjIEjLSU4jAFOynkFZfRDxY5bYfDV8x+S8vUkq7LnVA3W6LippHIpcvacOVbwsCr/POeQgSRbq4oh71ebRYT5XrK3L2lSWG1hRBcdSYGWn73aRTukGo0BvLJVVBZgiQ+uUTeU88S0s+Ho7eq+sNnjilix/Yc7ziCsA+kP8FjYwiKZacIaywxQd0fpE7oB41w0osrnUG5MQwS2yqIfXHoDJAgHgyD5pqTNHw7B/pKtdWAXrUeouem5RdxU4QfjROCrxxrumZfAhfNg0JlsY2MOP1DlihIZqKJO75YotMcTkhb/SD/bsLbe+q3JT1XAeX0XFZByfbCrx2krslD4sLHoO72x37WT0zZ9K5F5XQcJO5VUuyIQYfWE9J1j9scJ8djA7y7q0lhOn8bYQ0tpFJudCfwZi+JSwOg1MwTMs2UWzW6ELnnJEDiIaBN/8g2JHEsPThlJfu54vA2wqJ14YemCBXh2mCDi8SvexJ4+2NSfT8ISn0oIeuZ8f9kj4PIHgjdMTr9UnkQ5KcfEYNZ4sizKUJe8b7kj1onPFfvggdNPui+7lq73+GL94h8CSW+QMqMDkePqrfbaJya/TEAIBxaJmVnrYQ2UxRJiRDh5O2md0jGa+caX/xkyNl70Tz/yw3TnFU9ZnOptOrpscG2+WG91DFg6DP0j1nVdl+ge5aK9vIU0Z8uWlkvymYhHSU7N49+QdlHq+tzSloX9n/Ra/p0dFgeICeEELW0gdE0aPqVANnkckxN1Wl2xuvruekERaZ4ZaPKuX97hISM35+Im1vtSw9vQWRCBOC6CzD+DfQNSH/oC8J5g2u5y2Rz4DfHF/U5naHn6TlsfvHWc0DwdCm9pbKKSvbxVsy358DbDjOaz1yu3otzHrx24GHL2+26jwt30WPrDCvcHieUn7zd915GxQV6L3PSeQWZW4RsVlohfVgqbtRmBrVnRuzS43WN72RwdOd4O7YeDKkZ7W2dTe1E0eR/Cg/Ahinq3ihLOWGIa6i+vQb5wAWI3B5DlOYFrMEcxXYxK7Dy9ySvfwIMLx/HYE6D9wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Touch Screen Capacitive\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/8a8976025f3c35e3345bc3b0ba9815b6/b7119/touch-screen-capacitive.png\\\"\\n        srcset=\\\"/hows-that-again/static/8a8976025f3c35e3345bc3b0ba9815b6/4c099/touch-screen-capacitive.png 163w,\\n/hows-that-again/static/8a8976025f3c35e3345bc3b0ba9815b6/d150d/touch-screen-capacitive.png 325w,\\n/hows-that-again/static/8a8976025f3c35e3345bc3b0ba9815b6/b7119/touch-screen-capacitive.png 360w\\\"\\n        sizes=\\\"(max-width: 360px) 100vw, 360px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<h3>Проекционно-емкостной экран</h3>\\n<p>На внутренней стороне экрана нанесена сетка электродов. Электрод вместе с телом человека образует конденсатор; электроника измеряет ёмкость этого конденсатора (подаёт импульс тока и измеряет напряжение).</p>\\n<p>Такие экраны применяются в айфонах. </p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/cc5558188d9f4b11eb174792794c2e7a/380b9/touch-screen-capacitive2.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 260px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 138.46153846153845%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAAAsSAAALEgHS3X78AAAERElEQVRIx63We1BUVRwH8O9ydxbBAaWgl2HJFEMCUQ0sgoMgL+X9fiwPQV4K8hgRGZRddgVZEUFAAkWH2CXlkULMgA9CMgIpnMwZK4d3OQ2GjTMYpJmlv057t9cfNe3WnTlzZ/fe+czvd87vd84F9LniDuL/u+Ir+XuEfDnqv3wCqqUV6CNTpDY+DcPlq/QBBTxYIkb9rISBQThLm5BcVwCRUd1/AOW/grFQLwXgXfLCthNxMDIN1GP+DmhBmROOTEVAveiOzsfOKOh2g3JMqDsYXsyDATtfQ80NL3T87MBSfhnh0vUsZbHuoG8WD25MsUXFVUcoPrABkRncErzBCfVY/nWRPOgSvQZhe8Sw9QhGRtPr7P80CEUVf3mX4ww09xeft0CYrxip0Z7ITtyMgrQg5CUHojA7EXAM5kGnECsWZSA80yJx/JaYTUUGS1mheXbppFxwpVvJzY02cTR7mqPbfX+MeTbunOceTXZwMx91cF19nZqJFzoFvYEt1eFQf7ce75An9l6QwNLOCuea9+hX4C+4uApkA7Es3VREyotQdjmOLZSJ5lm/qnj1xVZp+IBaKnlPVZx2sVWWM9SuKBzpLC0e6SwrGetWyi+0SEvbjpaWj5xTHfrk/FtS+9CkVKgfhAoSKnchMF+G/DOZMDLJ1oALn6qyWGpEN7uJ5nuJvj1LLF1+zGvHXA/dv9FOd66dIvqqi2SlBcPIGY4wDNutgM/2UlaX+9gcHtaANNMRQ7OdRNPt39N02w80depHmjr5E02qH9F482MabyIabySaaSCaOkKLQ9K54OR4Gco+i+WiZEXwyy1B/MFiBtby4PXqaLp1jGiihuiLKqJrFfRgbD/dG1U8XPyweOl2/66Fm705X092ZQ5cakosaYgyM8dzG9yFb87EQXIgl4EyFPSkwniFRAN+3rHN7mrr1torLUmFQ8fi0/uqIyNb5f6e0q3ODn7rLFf7OD5rZiKC4Z/XROSZtBGFfels7pIgUeawAg9CQuUyVuTd/3phiQgtJ4pEmh+bs12xQ52J49/4YJCckNvmAxPztdoX+9k4w90bLhJebk4Wvn80keupijFoLPI3kKdvEDRLAwSDDXGo2OEBhO3lC1uitEdMWTo8klNZdGLWKfEw4PjWk/jawmrVyt8jWSb6h03DP48H/fLWsgi94RobgvzT1rDzCmNgue4F7Rqrbb1Qa+wftUbdhCVLz4IVdRDrZaXuoFMID9p7v8S6wwbtD63ZBvsqizYAT1ra6A76bOdBt/hXUHXdFa1LzmxPdEfJYARS6o11B39bFL9cB9RO+LMdexOL0J9FmA3jlVv0OAIqtEeAlB0B0xK03A1FLwNT6gthaFyjO5hYxW+aUfucGZiAloUQBvoxcDcDD+sOJhzSggoXBiZBdTcc3RSMrJadrPUy9AGhBU0Z+AxUi+Z4+74Fyj9+Sv+vh4TKv330C/JOwhVjRybuAAAAAElFTkSuQmCC'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Touch Screen Capacitive2\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/cc5558188d9f4b11eb174792794c2e7a/380b9/touch-screen-capacitive2.png\\\"\\n        srcset=\\\"/hows-that-again/static/cc5558188d9f4b11eb174792794c2e7a/4231f/touch-screen-capacitive2.png 163w,\\n/hows-that-again/static/cc5558188d9f4b11eb174792794c2e7a/380b9/touch-screen-capacitive2.png 260w\\\"\\n        sizes=\\\"(max-width: 260px) 100vw, 260px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<h1>Память</h1>\\n<table>\\n<thead>\\n<tr>\\n<th>Тип памяти</th>\\n<th>Время доступа</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>DRAM</td>\\n<td>50-150 наносекуд</td>\\n</tr>\\n<tr>\\n<td>Магнитный диск</td>\\n<td>5-20 милисекунд</td>\\n</tr>\\n<tr>\\n<td>Флэш-память</td>\\n<td>5-50 микросекунд</td>\\n</tr>\\n</tbody>\\n</table>\\n<h2>Производство процессоров и памяти</h2>\\n<ol>\\n<li>Из расплавленного кремния на специальном оборудовании выращивают монокристалл цилиндрической формы</li>\\n<li>Получившийся слиток охлаждают и режут на «блины», поверхность которых тщательно выравнивают и полируют до зеркального блеска</li>\\n<li>Затем в «чистых комнатах» полупроводниковых заводов на кремниевых пластинах методами фотолитографии и травления создаются интегральные схемы</li>\\n<li>После повторной очистки пластин, специалисты лаборатории под микроскопом производят выборочное тестирование процессоров – если все «ОК», то готовые пластины разрезают на отдельные процессоры, которые позже заключают в корпуса</li>\\n</ol>\\n<p>Подробности <a href=\\\"https://habr.com/company/intel/blog/110234/\\\">здесь</a></p>\\n<h1>Инструкции MIPS</h1>\\n<p><strong>Слово</strong> - единица доступа к памяти компьютера. Совпадает с размером регистра. В 32-битной архитектуре слово = 32 бита, регистр = 32 бита и к памяти мы можем обращаться шагами по 32 бита или 4 байта. Чем больше регистров, тем дольше будет такт, потому что расстояние до регистров будет больше и сигналы будут его дольше проходить. Помимо этого, чем больше регистров, тем больше бит занимает инструкция в памяти.</p>\\n<p>Разница между переменными и регистрами в том, что количество регистров ограничено, и некоторые инструкции могут работать только с данными, лежащими в определенных регистрах. Поэтому перед выполнением этих инструкций нжуно выполнить операцию <strong>load</strong>, которая загружает значение из памяти в регистр. Команда <strong>store</strong> - наоборот, сохраняет значение из регистра в переменную в памяти.</p>\\n<p>В архитектуре MIPS 32 32-битных регистра. Регистры в MIPS обозначаются знаком доллара и 2-буквенным обозначением, например: $s0, $s1 - регистры общего назначения. $t0, $t1 - временные регистры.</p>\\n<h2>Команды перемещения данных</h2>\\n<p><strong>Команда загрузки в регистр состоит из</strong>:</p>\\n<ul>\\n<li>название операции</li>\\n<li>регистр, в который загружаем</li>\\n<li>константа, обозначающая <strong>сдвиг</strong>, измеряемый в <em>байтах</em>. Это обязательно должна быть костанта. Если сдвиг определяется динамически, то нужно предварительно записать сдвиг в какой-нибудь регистр, затем этот регистр подать как адрес в памяти, а сдвиг указать равный 0.</li>\\n<li>регистр, обозначающий адрес в памяти, называемый <strong>базовый регистр</strong></li>\\n</ul>\\n<pre><code>g = h + A[8] => \\n\\n    lw $t0, 32($s3) \\n    add $s1, $s2, $t0\\n</code></pre>\\n<ul>\\n<li><code>lw</code> = load word</li>\\n<li><code>$t0</code> = регистр, куда попадет значение</li>\\n<li><code>32</code> = сдвиг. Нас интересует 8-й элемент массива, то есть 8-е слово. Каждое слово состоит из 4 байт, значит нас интересует 32-й байт. </li>\\n<li><code>$s3</code> = адрес начала массива <code>A</code> в памяти</li>\\n<li><code>$s2</code> = ассоциирован с <code>h</code></li>\\n<li><code>$s1</code> = результат сложения, ассоциирован с <code>g</code> </li>\\n</ul>\\n<p>Из-за выравнивания памяти адреса всех слов должны быть кратны 4.</p>\\n<p><strong>Пример обращения с динамическим сдвигом</strong>:</p>\\n<p>$s0 = i\\n$a0 = A</p>\\n<pre><code>g = A[i] =>\\n\\n    sll $t0 $s0 2   # сдвигаем на 2, то есть умножаем на 4, чтобы из кол-ва слов получить кол-во байт\\n    add $t1 $a0 $t0 # t1 = a0 + t0, то есть узнаем адрес в памяти элемента A[i]\\n    lw $t2 0($t1)   # t2 = A[i]\\n</code></pre>\\n<p>Компьютеры делятся на те, которые используют адрес самого левого (старшего) байта в слове в качестве адреса слова (<em>big-endian</em>) и на те, которые используют адрес правого (младшего) байта (<em>little-endian</em>). MIPS относится к <em>big-endian</em> архитектурам.</p>\\n<p><strong>Команда выгрузки из регистра в память</strong> называется <strong>store</strong> и имеет аналогичный с командой <strong>load</strong> синтаксис: название операции <em>sw</em>, сохраняемый регистр, сдвиг и базовый регистр.</p>\\n<pre><code>A[12] = h + A[8] =>\\n\\n    lw $t0, 32($s3)\\n    add $t0, $s2, $t0\\n    sw $t0, 48($s3)\\n</code></pre>\\n<h2>Константы</h2>\\n<p>Команда <code>add</code> принимает в качестве операндов регистры. Если нам нужно что-то сложить с константой, то пришлось бы сначала записать константу в регистр, что неэффективно. Для решения проблемы есть специальная команда <code>addi</code>, что означает <em>add immediate</em>. Так как константы могут быть отрицательными, то нет надобности в команде <code>subi</code>.</p>\\n<pre><code>addi $s3, $s3, 4    # $s3 = $s3 + 4\\n</code></pre>\\n<p>Для константы 0 даже есть специальный регистр <code>$zero</code>.</p>\\n<h2>Знаковые числа</h2>\\n<p>В большинстве систем сейчас используется техника представления знаковых чисел под назваием <strong>two's complement</strong>, или <em>второе дополнение</em>. Второе дополнение числа определяется как величина, полученная вычитанием числа из наибольшей степени двух.</p>\\n<p>В знаковых числах старший бит означает знак. Если он равен 0, то в остальных разрядах записаноположительное число.\\nЕсли 1, значит число отрицательное. Предществующие 1 в этом случае выполняют роль предшествующих 0 в положительных числах, то есть все подряд идущие 1 слева становятся незначимыми, значимая только самая правая в ряду подряд идущих единиц. При этом самый старбишй бит - всегда НЕ значимый. Если после него идет 0, то первым значащим битом становится этот ноль. </p>\\n<p>Разница 2^(количество значимых бит справа) - число, закодированное в этих битах = абсолют нашего искомого отрицательного числа.</p>\\n<p>Пример:</p>\\n<pre><code>1111 1111 1111 1111 1111 1111 1111 1101 = -3\\n\\n 1111 1111 1111 1111 1111 1111 1111 1 101 = -3\\n|                                    |   |\\n------------------------------------- ----\\n              ^                        ^\\n              |- не значимые           |- значимые 101 = 5\\n\\nКоличество значимых бит = 3\\n\\n2^3 - 5 = 3\\n\\nИскомое число = -3\\n</code></pre>\\n<p>Другой пример, когда у нас после знака сразу идет 0:</p>\\n<pre><code>1010 = -6\\n         1           010 = -6\\n|                   |   |\\n-------------------------\\n ^                    ^\\n |- не значимый бит   |- значимый 010 = 2\\n\\nКоличество значимых бит = 3\\n\\n2 ^ 3 - 2 = 6\\n\\nИскомое число = -6\\n</code></pre>\\n<p>Иначе говоря, число со знаком может быть представлено как:</p>\\n<pre><code>(x[31] * -2^31) + (x[30] * 2^30) + (x[29] * 2^29) + ... + (x[1] * 2^1) + (x[0] * 2^0)\\n</code></pre>\\n<p>То есть в случае <code>signed</code> числа знаковый бит умножается на -2^31, а в случае <code>unsigned</code> - на 2^31.</p>\\n<p>Другой способ преобразования - инвертировать число и прибавить 1, получаем абсолют. То есть в нашем случае это будет <code>10 = 2</code>, прибавляем 1 - получаем 3.</p>\\n<p>Неиспользуемая ныне техника <strong>one's complement</strong> получает отрицательное число как <code>2^n - x - 1</code>. Все отрицательные числа получаются из положительных установкой знакового бита в 1 и инвертацией всех остальных позиций. Сейчас техника не используется, так как требует больше шагов для арифметических операций (в two's complement отрицательное число равняется <code>2^n - x</code>).</p>\\n<h2>Представление инструкции в машинном коде</h2>\\n<p>Регистры $t0-$t7 имеют номера 8-15, а $s0-$s7 - 16-23.</p>\\n<p>Для примера возьмем инструкцию сложения:</p>\\n<pre><code>add $t0, $s1, $s2\\n</code></pre>\\n<p>Она представляется в памяти в следующем виде:</p>\\n<pre><code>0 17 18 8 0 32\\n</code></pre>\\n<p>Где:</p>\\n<p>0 - первая часть идентификатора команды <code>add</code>\\n17 - <code>$s1</code>\\n18 - <code>$s2</code>\\n8 - <code>$t0</code>\\n0 - не используется в этой команде\\n32 - вторая часть идентифкатора команды <code>add</code>.</p>\\n<p>В бинарном виде команда имеет вид:</p>\\n<pre><code>000000 10001 10010 01000 00000 100000\\n</code></pre>\\n<p>1 и 6 части имеют по 6 бит, 2-5 по 5. Итого каждая инструкция занимает 32 бита, то есть сколько же, сколько занимает слово в этой архитектуре.</p>\\n<p>Каждое из полей команды имеет свое название:</p>\\n<pre><code>|   op  |   rs  |   rt  |   rd  | shamt | funct |\\n| 6 бит | 5 бит | 5 бит | 5 бит | 5 бит | 6 бит |\\n</code></pre>\\n<ul>\\n<li><em>op</em>: 6 бит, <em>opcode</em>, определяет операцию и формат инструкции</li>\\n<li><em>rs</em>: 5 бит, первый входной регистр</li>\\n<li><em>rt</em>: 5 бит, второй входной регистр</li>\\n<li><em>rd</em>: 5 бит, регистр назначения</li>\\n<li><em>shamt</em>: 5 бит, сдвиг</li>\\n<li><em>funct</em>: 6 бит, <em>function code</em>, определяет конкретный варинт операции, указанной в поле <em>op</em>.</li>\\n</ul>\\n<p>Этот формат называется <em>R-type</em> или <em>R-format</em>, от слова register.</p>\\n<p>Есть еще другой формат - <em>I-type</em> / <em>I-format</em>, который используется для операций с константами и операций сохранения/загрузки данных. Дело в том, что при использовании R-формата размер константы ограничен 5 битами, а значит может принимать значения от 0 до 32. Это очень мало для константы и особенно для адресации внутри массива в случае команд <em>load/store</em>. </p>\\n<p>I-формат:</p>\\n<pre><code>|   op  |   rs  |   rt  | constant or address |\\n| 6 бит | 5 бит | 5 бит | 16 бит              |\\n</code></pre>\\n<p>При этом в этом формате регистр <code>rt</code> означает регистр назначения.</p>\\n<p>Еще есть самый простой формат - <em>J-type</em>, используемый для инструкции <code>j</code>:</p>\\n<pre><code>|   op  | address |\\n| 6 бит | 26 бит  |\\n</code></pre>\\n<h2>Условия</h2>\\n<p><code>beq reg1 reg2 L1</code> - если значение регистра 1 = значению регистра 2, то перейти к метке L1</p>\\n<p><code>bne reg1 reg2 L1</code> - если значение регистра 1 != значению регистра 2, то перейти к метке L1</p>\\n<p><code>slt reg1 reg2 reg3</code> - set on less than, если reg2 &#x3C; reg3, то reg1 = 1, иначе 0</p>\\n<p><code>slti reg1 reg2 10</code> - set on less than immediate, если reg2 &#x3C; 10, то reg1 = 1, иначе 0</p>\\n<p>Есть еще <code>sltu - set on less than unsinged</code> и <code>sltiu - set on less than immediate unsgined</code>. </p>\\n<h3>Быстрая проверка на выход за границы цикла</h3>\\n<pre><code>sltu $t0 $s1 $t2  # $t0=0 if $s1 >= length or $s1&#x3C;0\\nbeg $t0 $zero IndexOutOfBounds  # if bad, goto Error\\n</code></pre>\\n<h2>Цикл</h2>\\n<p>Допустим, мы хотим преобразовать следующий код в ассемблер:</p>\\n<pre><code class=\\\"language-c\\\">while (save[i] == k)\\n    i += 1;\\n</code></pre>\\n<p>Пускай переменные у нас лежат в следующих регистрах:</p>\\n<pre><code>i = $s3\\nk = $s5\\nsave = $s6\\n</code></pre>\\n<p>Тогда код на ассемблере будет таким:</p>\\n<pre><code class=\\\"language-asm\\\">While: \\n    sll $t1 $s3 2  # умножаем i на 4 путем сдвига влево на 2 знака, чтобы из количества слов получить количество байт\\n    add $t1 $t1 $s6 # получаем адрес save[i]\\n    lw $t0 0($t1) # загружаем в регистр значение save[i]\\n    beq $t0 $s5 Exit # if(save[i] != k) break;\\n    addi $s3 $s3 1 # i += 1\\n    j While # возвращаемся в начало \\nExit:\\n</code></pre>\\n<h2>Вызов процедуры</h2>\\n<p>Для вызова процедуры, нужно сделать следующее:</p>\\n<ol>\\n<li>Положить параметры в место, откуда процедура сможет их получить</li>\\n<li>Передать контроль процедуре</li>\\n<li>Получить ресурсы, необходимые процедуре</li>\\n<li>Выполнить процедуру</li>\\n<li>Положить результат в место, откуда вызывающая программа сможет его получить</li>\\n<li>Вернуть контроль точке вызова процедуры</li>\\n</ol>\\n<p>В MIPS для вызова процедур служат следующие регистры:</p>\\n<ul>\\n<li><em>$a0-$a3</em>: 4 регистра, куда можно положить параметры</li>\\n<li><em>$v0-$v1</em>: 2 регистра, куда можно положить результат</li>\\n<li><em>$ra</em>: return address, то есть регистр, куда кладется адресс точки вызова перед вызовом процедуры</li>\\n</ul>\\n<p>Если нужно передать больше 4 параметров, то все дополнительные параметры кладутся на стек сразу над <code>$fp</code>.</p>\\n<p>Для вызова есть специальная инструкция <code>jal (jump-and-link)</code> - она кладет адрес следующей инструкции в регистр <code>$ra</code>, после чего вызывает процедуру. </p>\\n<p>Синтаксис прост:</p>\\n<pre><code>jal ProcedureAddress\\n</code></pre>\\n<p>Процедура возвращается вызовом <code>jr $ra</code>.</p>\\n<p>Адрес текущей выполняемой инструкции почти всегда называется <em>program counter</em> или <em>PC</em>. Команда jal просто сохраняет в регистр $ra значение PC + 4.</p>\\n<h2>Стек</h2>\\n<p>Когда регистров не хватает, на помощь приходит <strong>стек</strong>. Например, после вызова процедуры нужно подчистить все следы и вернуть все используемые процедурой регистры к тем значениям, которые были <em>до</em> вызова процедуры. А для этого их нужно где-то хранить. Вот на стеке они и хранятся. Также в нем хранятся локальные массивы и структуры.</p>\\n<p>Для работы со стеком используется <em>stack pointer</em>, указывающий на адрес последнего сохраненного в стек значения. При сохранении или извлечении каждого значения, стэк пойнтер изменяется на 1 слово. Обратиться к нему можно по регистру <code>$sp</code>.</p>\\n<p>Стек растет от высших адресов к низшим. Это означает, что для пуша на стек нужно вычитать 1 слово из значения стэк пойнтера. А увеличение стэк пойнтера уменьшает стэк, выдавливая из него значения.</p>\\n<p>Пример процедуры:</p>\\n<pre><code class=\\\"language-c\\\">int leaf_example(int g, int h, int i, int j)\\n{\\n    int f;\\n    f = (g + h) - (i + j);\\n    return f;\\n}\\n</code></pre>\\n<p>g,h,i,j = $a0,$a1,$a2,$a3</p>\\n<p>f = $s0</p>\\n<p>Скомпилированная процедура будет выглядеть так:</p>\\n<pre><code class=\\\"language-asm\\\">leaf_example:\\n    addi $sp, $sp, -12  # выделяем в стеке место для 3 локальных переменных\\n    sw $t1, 8($sp)\\n    sw $t0, 4($sp)\\n    sw $s0, 0($sp) # бэкапим на стек значение регистров, которые будем использовать в теле функции\\n\\n    add $t0, $a0, $a1\\n    add $t1, $a2, $a3\\n    sub $s0, $t0, $t1 # делаем наши арифметические операции\\n    add $v0, $s0, $zero # возвращаем результат\\n\\n    lw $s0, 0($sp)\\n    lw $t0, 4($sp)\\n    lw $t1, 8($sp) # ресторим из стека значение регистров\\n    addi $sp, $sp, 12 # уменьшаем стек на 3 элемента\\n\\n    jr $ra   # возвращаемся к точке вызова\\n</code></pre>\\n<p>Теперь посмотрим, как выглядит рекурсия:</p>\\n<pre><code class=\\\"language-c\\\">int fact (int n)\\n{\\n    if (n &#x3C; 1) return 1;\\n    else return ( n * fact(n-1));\\n}\\n</code></pre>\\n<pre><code class=\\\"language-asm\\\">fact:\\n    addi $sp $sp -8\\n    sw $ra 4($sp)\\n    sw $a0 0($sp) # бэкапим аргументы и адрес возврата, чтобы восстановить их после вызова другой процедуры внутри этой\\n\\n    slti $t0 $a0 1\\n    beq $t0 $zero L1 # if n > 1 goto L1\\n\\n    addi $v0 $zero 1 # else return 1\\n    addi $sp $sp 8 # уничтожаем забекапленные значения, так как внутренний вызов не пригодился\\n    jr $ra # возвращаемся к точке вызова\\n\\nL1: \\n    addi $a0 $a0 -1 \\n    jal fact   # fact(n-1)\\n    lw $a0 0($sp) # восстанавливаем из стека значение регистров после внутреннего вызова\\n    lw $ra 4($sp)\\n    addi $sp $sp 8\\n\\n    mul $v0 $a0 $v0 # return n * fact(n-1)\\n    jr $ra\\n</code></pre>\\n<p>Рассмотрим, какие регистры нужно обязательно сохранять перед вызовом процедуры и ресторить после возврата из нее, а какие необязательно</p>\\n<table>\\n<thead>\\n<tr>\\n<th>Сохранять</th>\\n<th>Можно не сохранять</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>$s0-$s7</td>\\n<td>$t0-$t9</td>\\n</tr>\\n<tr>\\n<td>$sp</td>\\n<td>$a0-$a3</td>\\n</tr>\\n<tr>\\n<td>$ra</td>\\n<td>$v0-$v1</td>\\n</tr>\\n<tr>\\n<td>Стэк над $sp</td>\\n<td>Стэк под $sp</td>\\n</tr>\\n</tbody>\\n</table>\\n<h3>Выделение места на стеке</h3>\\n<p>Сегмент стека, содержащий сохраненные процедурой регистры и ее локальные переменные, называется <em>фрейм процедуры</em>.</p>\\n<p>Для обозначения начала фрейма используется регистр <code>$fp</code> - frame pointer, указывающий на адрес первого слова фрейма процедуры. Stack pointer может измениться во время процедуры, а frame pointer - нет.</p>\\n<p>На рисунке изображен стек до, во время и после вызова процедуры:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/a9983574e0824c051ede6965c590ffcf/ad3dc/procedure-frame.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 48.64864864864865%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABt0lEQVQoz3WR7WsTQRDG8/9/LRZRAxX0g4i0CpX6UikVDLXUIkhTm6vExiTNpXdeNnu5fb3Hmal3RKgDD7e3M/Obl+1Mp1PMZjNY7xFrINS1KJLqVlg7ky8E8Yd1xVtfR+slbgqFw+sK71KPD6TXE4OrpQVh4Cx/IWc2hhV5htFihbczj32Kf58GHFB+aR06q1JjTsC9cYXticerqcezK4NBvkJ0FqqyMMQyEfLV1mNOE/3INV6MHV5OnOTt/qqgDQG5oiFyqg0yW4vSKkjXC6Wkcvd0hK0vQ3RPhtgZKhQlJVcGc6qS2XibUzpYR0AZI0b4djSZC56cbHvnY2wcfMWjT33c//gNT04usaQug7PtGmQh9Aa+AQbu0th2U95z1xY1FdofZnhwNCDgGR72vuN5/1rWwLttHo7NEcytA+1ah/zvpMMah2OF7ucEj48TbB1fYifJsDRegPX/gHxpjPkHqLWWuzc/F9joJdjsXeBeb4Cn/RSKRnbku7PDsiwlmSHtPiiI7xXdj8qA898GFwXLIlnQq9NK4t/4Bsj5rE6e55inKYqiaAOaIAGrAncZF2ymauLZ/gDUEfxlzmyBFQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Procedure frame\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/a9983574e0824c051ede6965c590ffcf/10273/procedure-frame.png\\\"\\n        srcset=\\\"/hows-that-again/static/a9983574e0824c051ede6965c590ffcf/9b14a/procedure-frame.png 163w,\\n/hows-that-again/static/a9983574e0824c051ede6965c590ffcf/94962/procedure-frame.png 325w,\\n/hows-that-again/static/a9983574e0824c051ede6965c590ffcf/10273/procedure-frame.png 650w,\\n/hows-that-again/static/a9983574e0824c051ede6965c590ffcf/ad3dc/procedure-frame.png 666w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>На следующей схеме - распределение данных в памяти для архитектуры MIPS</p>\\n<p><a href=\\\"mips-memory-allocation.png\\\">!MIPS Memory allocation</a></p>\\n<p>Указанные адреса не являются частью архитектуры, а просто соглашение на уровне приложений. </p>\\n<p>Вершина стека инициализируется самым старшим адресом доступной памяти, то есть <code>$sp = 7fff fffc</code>. Оттуда стек будет расти вниз.</p>\\n<p>Затем идет сегмент динамической памяти, или <em>куча</em>. Она растет вверх, навстречу стеку. Это память, выделяемая командами <code>malloc</code> и <code>new</code>. Здесь всякие массивы, структуры.</p>\\n<p>Затем сегмент статической памяти, который начинается с адреса <code>1000 0000</code>. Здесь хранятся константы и другие статические переменные.</p>\\n<p>Затем сегмент Text, содержащий машинный код исполняемой программы.</p>\\n<p><code>$gp</code> указывает на середину сегмента статической памяти и с его помощью, указывая положительный или отрицательный сдвиг, можно обратиться к любому адресу статического сегмента.</p>\\n<p>И в конце сегмент зарезервированной памяти.</p>\\n<h3>Tail call optimization</h3>\\n<pre><code class=\\\"language-c\\\">int sum(int n, int acc) {\\n    if (n > 0)\\n        return sum(n-1, acc+n);\\n    else\\n        return acc;\\n}\\n</code></pre>\\n<p> Преобразуется в:</p>\\n<p> $a0 = n\\n$a1 = acc</p>\\n<pre><code>sum:\\n    slti $t0 $a0 1                 # if n &#x3C;= 0\\n    bne $t0 $zero sum_exit         # goto sum_exit if n &#x3C;= 0\\n    add $a1 $a1 $a0                # acc += n\\n    addi $a0 $a0 -1                # n -= 1\\n    j sum\\nsum_exit:\\n    add $v0 $a1 $zero              # return acc\\n    jr $ra\\n</code></pre>\\n<h2>Манипуляции со строками</h2>\\n<p>Для работы со строками есть инструкции <code>lb</code> и <code>sb</code>, которые загружают из памяти 1 байт и сохраняют его в младший байт регистра - и наоборот. В этом случае адрес памяти необязательно должен быть кратным 4.</p>\\n<pre><code>lb $t0 0($sp)   # read byte from source\\nsb $t0 0($gp)   # write byte to destination\\n</code></pre>\\n<p>А для чтения юникодных символов есть инструкции <code>lh</code> и <code>sh</code> (load half/store half), которые читают по 2 байта из памяти и сохраняют в младшие 2 байта регистра - и наоборот. Адрес должен быть кратен 2.</p>\\n<p>В <strong>С</strong> строка ограничена символом с кодом 0 справа.</p>\\n<pre><code class=\\\"language-c\\\">void strcpy(char x[], char y[])\\n{\\n    int i;\\n\\n    i = 0;\\n    while((x[i] = y[i]) != '\\\\0')\\n        i += 1;\\n}\\n</code></pre>\\n<p>$a0 = x\\n$a1 = y\\ni = $t0</p>\\n<pre><code>strcpy:\\n    add $t0 $zero $zero\\nloop:\\n    add $t1 $t0 $a1 \\n    lbu $t2 0($t1)      # $t2 = y[i]\\n\\n    add $t3 $t0 $a0\\n    sb $t2 0($t3)       # x[i] = y[i]\\n\\n    beq $t2 $zero exit\\n    add1 $t0 $t0 1\\n    j loop\\n\\nexit:   \\n    jr $ra\\n</code></pre>\\n<p>Так как вложенных вызовов процедур нет, то нам удалось обойти только временными регистрами <code>$t</code>. Если есть вложенные вызовы, то перед вызовом:</p>\\n<ol>\\n<li>если есть значение, которое полностью используется до вызова и не будет использоваться после вызова, то оно пишется во временный регистр</li>\\n<li>остальные значения пишутся в сохраняемые регистры <code>$s</code>, бэкапятся перед вызовом процедуры и ресторятся после вызова (либо в начал и в конце процедуры, зависит от соглашения вызова).</li>\\n</ol>\\n<h2>Работа с большими константами</h2>\\n<p>Если нужно работать с константой, которая не влезает в 16 бит, на этот случай есть команда <code>lui</code> - <code>load upper intermediate</code>. Она загружает старшие 16 бит в регистр, позволяя затем указать младшие 16 бит, используя инструкцию <code>ori</code>.</p>\\n<p>Пример:</p>\\n<p>допустим, хотим в регистр <code>$s0</code> загрузить значение <code>0000 0000 0011 1101 0000 1001 0000 0000</code></p>\\n<p>Сначала загружаем старшие 16 бит, которые составляют число 61:</p>\\n<p><code>lui $s0 61</code></p>\\n<p>После этого в <code>$s0</code> лежит значение: <code>0000 0000 0011 1101 0000 0000 0000 0000</code></p>\\n<p>Затем через OR соединяем с младшими 16 битами (которые составляют 2304) и результат кладем в тот же регистр:</p>\\n<p><code>ori $s0 $s0 2304</code></p>\\n<p>Готово!</p>\\n<h2>Работа с большими адресами</h2>\\n<p>Если используем команду <code>j</code>, то там используется формат J-type, который выделяет 26 бит на адрес слова. Этого достаточно для адресации в пределах 256 MB.</p>\\n<p>Если же используются бранч-команды, типа <code>beq</code> или <code>bne</code>, то там на адрес остается всего лишь 16 бит. Но этого достаточно, так как такие команды используются обычно, чтобы перейти к какой-то близлежащей инструкции в коде. Используя в качестве базового адреса <code>$pc</code> мы можем перейти на команду, отстоящую на +-2^15 от текущей. К тому же адресация идет по словам, а не по байтам, так что эти числа можно умножить еще на 4. В результате получаем относительную адресацию в пределах +-128 КБ.</p>\\n<p>Ну а если не хватает, то мы всегда можем воспользоваться следующим хаком:</p>\\n<pre><code>    beq $s0 $s1 L1\\n</code></pre>\\n<p>преобразуем в:</p>\\n<pre><code>    bne $s0 $s1 L2\\n    j L1\\nL2:\\n</code></pre>\\n<h2>Синхронизация потоков</h2>\\n<p>Для реализации атомарных операций есть две специальных инструкции:</p>\\n<ul>\\n<li><code>ll</code>: load linked. Аналогична обычной загрузке, но обозначает начало атомарной операции</li>\\n<li><code>sc</code>: store conditional. Сохраняет регистр в указанный адрес в памяти, но только <em>если</em> значение указанного адреса памяти было изменено между этой инструкцией и инструкцией <code>ll</code>, прочитавшей значение из этого же адреса. При этом случае успеха он меняет значение этого регистра в 1, а в случае неудачи - 0.</li>\\n</ul>\\n<p>Таким образом, потокобезопасная замена значения, лежащего в <code>$s1</code> будет выглядеть так:</p>\\n<pre><code>again:\\n    addi $t0 $zero 1\\n    ll $t1 0($s1)\\n    sc $t0 0($s1)\\n    beq $t0 $zero again\\n    add $s4 $zero $t1\\n</code></pre>\\n<p>В этом коде мы прочитали значение по адресу <code>$s1</code> и записали туда новое значение из регистра <code>$t0</code>.\\t</p>\\n<p>На основании конструкции <em>load linked/store conditional</em> могут быть построены другие примитивы синхронизации, такие как <em>atomic compare</em>, <em>swap</em> или <em>atomic fetch-and-increment</em>.</p>\\n<h2>Системные вызовы</h2>\\n<p>Реализация системных вызовов зависит от ОС и архитектуры процессора, рассмотрим, как реализованы сисколлы в x86_64 на линуксе:</p>\\n<ol>\\n<li>Номер системного вызова кладется в регистр RAX</li>\\n<li>Аргументы вызова кладутся в регистры RDI, RSI, RDX...</li>\\n<li>Выполняется инструкция ассемблера SYSCALL. Эта инструкция переводит процессор на кольцо защиты 0 и выполняет код, на который ссылается регистр <code>MSR_LSTAR</code>, а он ссылается на функцию <code>system_call</code>. Эта функция пушит регистры в стек ядра и берет из таблицы <code>sys_call_table</code> адрес функции, в строке с номером, соответствующим номеру системного вызова, лежащему в RAX. </li>\\n</ol>\\n<h2>Компиляция программы</h2>\\n<h3>Компилятор</h3>\\n<h4>Фронтенд</h4>\\n<p>На вход фронтенду компилятора поступает код программы, а на выходе - некая промежуточная форма, не зависящая от архитектуры. Фронтенд - единственный этап процесса компиляции, который зависит от языка.</p>\\n<p>Шаги фронтенда:</p>\\n<ol>\\n<li><strong>Сканирование</strong> - читает символы и создает поток <em>токенов</em>. <strong>Токены</strong> - это атомарные единицы языка, например: зарезервированные слова, имена, операторы, знаки пунктуации. В коде <code>while (save[i] == k) i += 1;</code> токенами будут: while, (, save, [, i, ], ==, k, ), i, +=, 1, ;.</li>\\n<li><strong>Парсинг</strong> - берет поток токенов, проверяет синтаксис и строит <strong>AST - abstract syntax tree</strong>. Это дерево, в котором представлена ситнактическая структура программы.</li>\\n<li><strong>Семантический анализ</strong> - берет AST и проверяет программу на семантическую корректность. Обычно на этом этапе проверяется, что переменные и типы правильно объявлены, типы операторов и объектов совпадают. В процессе составляется таблица символов, в которую заносятся все именованные объекты - классы, функции, переменные.</li>\\n<li><strong>Генерация промежуточного представления</strong> - берет AST со 2 шага, таблицу символов с 3 шага и генерирует текст программы на языке промежуточного представления. Это что-то вроде байткода или MSIL. Обычно этот язык представляет собой подобие MIPS, но с бесконечным количеством виртуальных регистров.</li>\\n</ol>\\n<p>После фронтенда идет шаг высокоуровневых оптимизаций</p>\\n<p>Потом глобальные оптимизации - оптимизации, которые влияют на несколько блоков кода</p>\\n<p>И наконец генерация машинного кода</p>\\n<h3>Ассемблер</h3>\\n<p>На выходе из ассемблера получается object file - комбинация инструкций на машинном языке, данных и информации, необходимой для загрузки инструкций в память. Для создания бинарной версии, ассемблер поддерживает <em>таблицу символов</em>, в которой записаны соответствия меток и их адресов в памяти.</p>\\n<p>В объектном файле на UNIX обычно содержатся 6 блоков:</p>\\n<ul>\\n<li><strong>object file header</strong>: описывает размер и расположение остальных блоков</li>\\n<li><strong>text segment</strong>: содержит код на машинном языке</li>\\n<li><strong>static data segment</strong>: содержит статические данные, которые никогда не меняются</li>\\n<li><strong>relocation information</strong>: содержит адреса инструкций, в которых происходит обращение по абсолютному адресу. Блок нужен, чтобы можно было изменить адреса, когда мы линкуем модуль с другими модулями и стартовый адрес нашей памяти изменяется</li>\\n<li><strong>symbol table</strong>: содержит незарезолвленные метки, то есть внешние ссылки</li>\\n<li><strong>debugging information</strong>: инфа о том, как были скомпилированы модули, чтобы дебаггер мог сассоциировать машинные инструкции со строками исходного кода</li>\\n</ul>\\n<h3>Линкер</h3>\\n<p>Берет независимо собранные программы на ассемблере и \\\"линкует\\\" их вместе.</p>\\n<p>Работает в 3 шага:</p>\\n<ol>\\n<li>Помещает код и данные в память</li>\\n<li>Определяет новые адреса для данных и меток инструкций</li>\\n<li>Патчит внутренние и внешние ссылки</li>\\n</ol>\\n<p>Для 2 и 3 шага линкер использует <em>relocation information</em> и <em>symbol table</em> каждого объектного модуля, чтобы зарезолвить ссылки на внешние процедуры. </p>\\n<p>В 3 шаге линкер просто проходит по всему коду, отыскивает ссылки и заменяет адреса в них новыми адресами. Польза линкера в том, что патчить код ораздо проще и быстрее, чем перекомпилировать его заново.</p>\\n<p>На выходе линкера получается <em>исполняемый файл</em>. Обычно он имеет тот же формат, что и объектный файл, только теперь в нем нет незарезолвленнхы ссылок.</p>\\n<p>Далее мы видим пример того, как линкер линкует 2 модуля в один:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/7b9bf997acd4b668105e42b9a323eb97/dc311/linker-before.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 602px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 116.77740863787376%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsSAAALEgHS3X78AAAC+0lEQVQ4y32V63LiMAyFef8HLD+WW0ICCeROrkCr1Sfbmc5su8wIR4otHUlHzmaeZ6mqSrYfW9nvdrL7s5O2aeTxeMgwDDKOo3vue9ORCVvXyTiMMk2T6ay823CAh7ZtpUN04zROFiQ6RXJJUymLQu73uwXb7/fS1LXcbzepdeVcEPQNCN/vt3z/fX5+SqMotx8fhhrnsyJIzokkSSLLskittl5RB0CsgNmQTlVWtpHoyflskcqilNPxKKkirKvaAhxVPxwOVhKCkDZOg5DhivDr60ter5ehQydaUzdrKmVZyuVylTS72TO2UOcghpBUns+npcGK4Ljz0dnIYVYQteoEENj6b41aUw6GPM8VwcWKzUtQtN3DBJsrfCeVptur05vaKIOlq7rLSJsy9IPVCWdZltkzK5vPcSzZ9WrO6HIcxZJqrXlum9bt0ZpjZw8lMNoQhTQWlcAnDoCS4tNRGoEOhUCDnSYU2rCsqAwlTi1lHJICnCO9wEvK4NC41EAHGwiKQ8jeK6C6H43caw1BGSZi9DoH8nshhVKqUFRGZnVOYA7yTMpd5wYCAOiWMgro8iy3AzgG1aidn+bFdVnRPFWHFSAMXf6H2Ch4jqLIUqIRvMAhOmkHLp5OJ2sC9PmVh/Dvpx9ODvuDBai0GaCJNSi6lURtOB78lLBaU8LIQBWisxKZjm63WznqqFV+bskC3che/YLQFN1sMw0ViKo2nm++y1Al10CxBoyS1MpgjbKmdP6m6lxTfrpt0Algw69rqBcH6rZbx/G/oxemhOjWeS5ZvRd7FSjjuqnUUifLMq/zPfthQMwhf5f0YrRJvZAeBM8ylzJSqBAUG/W1UugKAIQA3E4biBxqZXVTRzYdWhdoc/WzTB25K1O7wUtLH3uieqR2gK2zDHWATE1Y0Y17zLFGDvUKnwL2gM4ma3JlGf24ull+9O760mgg7D2nMpCrk/DR4kYCISAIFmgTmmM1HL0BVEF4abeydrRlbv0H6eEpYtdZ+EhpsOab/AUbJddrfXgOSAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Before link\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/7b9bf997acd4b668105e42b9a323eb97/dc311/linker-before.png\\\"\\n        srcset=\\\"/hows-that-again/static/7b9bf997acd4b668105e42b9a323eb97/38e32/linker-before.png 163w,\\n/hows-that-again/static/7b9bf997acd4b668105e42b9a323eb97/21a34/linker-before.png 325w,\\n/hows-that-again/static/7b9bf997acd4b668105e42b9a323eb97/dc311/linker-before.png 602w\\\"\\n        sizes=\\\"(max-width: 602px) 100vw, 602px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Здесь мы видим 2 модуля. До прохода линкера <code>$gp</code> указывает на начало сегмента данных.</p>\\n<p>Процедура А в строчке 0 ссылается на строчку 0 в сегменте данных, где у нас лежит переменная Х.</p>\\n<p>В строчке по адресу 4 мы ссылаемся на адрес 0, но в <em>relocation information</em> мы видим, что строчка 4 зависит от процедуры B, а значит это адрес 0 не в нашем модуле, а в модуле B.</p>\\n<p>Процедура B в строчке 0 ссылается на строчку 0 в сегменте данных, где у нас лежит переменная Y.</p>\\n<p>В строчке по адресу 4 мы ссылаемся на адрес 0, но в <em>relocation information</em> мы видим, что строчка 4 зависит от процедуры A, а значит это адрес 0 не в нашем модуле, а в модуле A.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/397533e645af420b876ec0a66fede5ed/49b69/linker-after.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 573px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 60.90750436300174%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAABq0lEQVQoz2VT2XLDIAz0/39eOpk0id2ZpEl8gA0Y4yMvqlax3HT6IAMyWu0ukKVhoJQSfRUFfR4OdDwe6cCjaRrJhxBkRIzjSH3fS2AeYyTUj2mkgecYMxQMnGxtK9F1HVlrBch7T945qqqK8vNZ8shhz8SA9/udvq/fW+PIjTJlAFCwQnHbtsLAO089/0fhx27HDX8bTdNE18uF8tNJmKIe4waIhWkMlY+HFI5rV4A/OJfnuTQDGJg2dUW3sqaiNFQzkaauX4D4zPMsHZdloefzKWsEukIyQK2xokCkcU0InlxMZNJCNo6yNw2JMnRUoyXCa0SRW/2EZw2DYRRwzuFfx5YYDsdNkUOdMAQzZaWBHKxAQ0iFFSpLDoYBbD/QrZ+pcb0owf5MJaixEnH4Ixed5TDWtajitYPHrKhjYFUogDhR0L7wqRV8H3GqyAVcGzAsS9rv9yzTbaeM/2gKkImZqU3bPVSWcf0Bg/XOwZ+qrMRHeIe83D3e2/kge/8Bqsz3QOHrhI2w1MNQvwLkAhxMV+syeTJMX5/X+zOLq3fKAHOEPj1VpnPU/QCeCpGBn3BmawAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"After link\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/397533e645af420b876ec0a66fede5ed/49b69/linker-after.png\\\"\\n        srcset=\\\"/hows-that-again/static/397533e645af420b876ec0a66fede5ed/80ceb/linker-after.png 163w,\\n/hows-that-again/static/397533e645af420b876ec0a66fede5ed/654cc/linker-after.png 325w,\\n/hows-that-again/static/397533e645af420b876ec0a66fede5ed/49b69/linker-after.png 573w\\\"\\n        sizes=\\\"(max-width: 573px) 100vw, 573px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Мы видели ранее, что после линка сегмент текста начинается по адресу <code>0х40 0000</code>, а сегмент данных - по <code>0х1000 0000</code>. Текст процедуры А располагается по первому адресу, а ее данные - по второму. Заголовок процедуры А говорит, что ее текст занимает <code>0х100</code> байт, а данные - <code>0х20</code> байт, поэтому текст процедуры B располагается сразу после А по адресу <code>0х40 0100</code>, а ее данные - по <code>0х1000 0020</code>.</p>\\n<p>Шаг 1 закончен. Теперь линкер обновляет адреса в инструкциях. Он проходит по каждой строчке в сегменте <em>relocation information</em> и патчит соответствующие инструкции. Чтобы определить используемый формат, он читает поле <em>instruction type</em>.</p>\\n<p>В нашем случае используется 2 типа команд:</p>\\n<ol>\\n<li><code>jal</code>. C ними все просто, потому что они используют абсолютные адреса. <code>jal</code> по адресу <code>0х40 0004</code> должен обращаться к 0 строчке процедуры B. B у нас лежит по <code>0x40 0100</code>, значит и целевой адрес такой же. Аналогично <code>jal</code> по адресу <code>0x40 0104</code> преобразуется в <code>0х40 0000</code>.</li>\\n<li><code>lw</code> и <code>sw</code> посложнее, потому что они используют относительные смещения от <code>$gp</code>. Как мы видели ранее, <code>$gp</code> инициализируется значением <code>0х1000 8000</code>. В строчке <code>0х40 0000</code> нам нужно обратиться к переменной Х, то есть бывшей 0 строке сегмента данных процедуры А. 0 строка данных А теперь получила адрес <code>0х1000 0000</code>. Значит ее относительный адрес относительно <code>$gp</code> будет <code>0х-8000</code>. Аналогично в строчке <code>0х40 0100</code> относительный адрес меняется на <code>0х8020</code>.</li>\\n</ol>\\n<h3>Загрузчик</h3>\\n<p>Кладет программу в память, чтобы она могла выполниться.</p>\\n<p>Для этого выполняет следующие шаги:</p>\\n<ol>\\n<li>Читает заголовок программы в память, чтобы определить размер сегментов кода и данных</li>\\n<li>Выделяет адресное пространство, достаточное чтобы вместить текст и данные</li>\\n<li>Копирует инструкции и данные из исполняемого файла в память</li>\\n<li>Копирует параметры главной программы на стек</li>\\n<li>Инициализирует регистры и устанавливает stack pointer</li>\\n<li>Переходит к процедуре запуска, которая копирует параметры в регистры аргументов и вызывает главный метод программы</li>\\n</ol>\\n<h3>Динамически загружаемые библиотеки</h3>\\n<p>Поблемы вышеописанного способа линковки:</p>\\n<ol>\\n<li>Все библиотеки становятся часть исполняемого файла, новая версия библиотеки означает перелинковку.</li>\\n<li>При старте в память загружаются все функции всех модулей даже если эти функции не запускаются</li>\\n</ol>\\n<p>Эти проблемы решают динамически связываемые библиотеки (DLL). В таком способе линковки библиотеки не линкуются и не связываются, пока программа не запущена. </p>\\n<p>Для этого:</p>\\n<ol>\\n<li>Объектный файл динамически загружаемой библиотеки содержит дополнительную информацию о расположении процедур внутри нее</li>\\n<li>При старте загрузчика запускается динамический линкер, который использует эту информацию для связывания библиотек и обновления всех внешних ссылок</li>\\n</ol>\\n<p>Недостаток первоначальной версии был в том, что в память все равно загружались все функции программы, а не только те, которые будут использоваться. Поэтому в следующей версии каждая функция линкуется индивидуально только <strong>после</strong> того, как она была вызвана.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/4bf2dd0b6774c85dc85860cdac175646/1828f/lazy-procedure-linkage.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 117.87234042553192%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAABYlAAAWJQFJUiTwAAADnklEQVQ4y41V2W4bRxDU//+LH4IgQBB/QJ6SGLYESRQpcknufc/O3kelupekJcOJPcBghrPN2u7qmto7cCzLgrIsdbZti67rdMpepjyXIfs0TWGt1ef9ZTZNg2EYNOYOKyK22y3c8xnLPOtDDeC+rmtM06RheZ7j6fFRz2aeFbZG2/cYOAX0BtiN0/r2osDCwIcwx2/7BB0DJRMBnBnXcF8xOwEa+g6/bCM8RIWCS5wCTqwm6UZ4RYVzVqAZZ+yTAp+8BLYf0UnJ8wQzLohsy2c5Ytug7AbcE+xY1hjH8T1gwwyrqlIOZbzEBT462S1QMmiZouxLqYIvwDTg932KbVopTe8AS2ZSGoPCVCgIXHCflQZRWcHy97KQSwZGVa1nIWdQrDGn3Gj8O0CvGbBxTtidXaT8U1k3uhqu0lGmAMsMnTjF82aDKEkVoGYjbNPcuv4VsB7wutvBc130bERMrtqu104bU2mJFQH3YYKTc9Cs06ZHUrcaIx2WziugdC+oe2SUxDQwyFj8+pog5JoK+ZfOW9IW5CV114Itxp9ujr+CQmNycq+VXDNM2eW8XjuXNx0ss5NVwCvyI8Ju+GaRi/CWkw7LjCSrgDGGGff9peR+JtndBM/z4AWhlmoplapptZSVQ96kYUbST6pZUUXNaYd1P88zrjfubiBg0I4IfA9xHCuHb4cIXm6MoT6rccb/DQUkHiJ2We6kXKGqyLGLMvwdUpNsRsvzVdgr6PWP35s3Dg11mJHYlPxU5OX+5OOPzQlekqG+lvwN4H8NAi7w2wlPBwcvJ+qQUjCtNGZtzpVD8/OAwJkl7+g2zn6vMkmTBEWeIcuy1UUuHP40oGG3drstnp6f8cz5st3hn89f4LPz4jjvOVx+zGFNwJpa0vLGHg9ujA+Prl6t9uY27PK0/LjLEhNRNl6aw+dNkNtwCCJs/EjPtClY1L5Sir1l05rLi96u4kyaoegwbAd17A3nka4t4pYKxFjlNog9iTm49MstzUEq0TJ5LqvcZ9XrW3OQBjiHA47Ho67DReCrsFeD9U2N0PcRBIEaSRAnGjPP3zi2XKHaVmqyGAd8cjx8ePKUw+v3Qwy2kStpyvUDZY3yfO+vVtZ9zXBBTCvyWU5I00wqq6VtwhQBjVTdRXTIlwbMUHiWT4CY7CHO8MpPQknTEHPQpgj6mel7LOV4OuNMqURRBJdnYRjeOiifzz3Fv3c4SYnEua6HMzkXDxCqJOZfDtk85znLY0YAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Lazy Procedure Linkage\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/4bf2dd0b6774c85dc85860cdac175646/10273/lazy-procedure-linkage.png\\\"\\n        srcset=\\\"/hows-that-again/static/4bf2dd0b6774c85dc85860cdac175646/9b14a/lazy-procedure-linkage.png 163w,\\n/hows-that-again/static/4bf2dd0b6774c85dc85860cdac175646/94962/lazy-procedure-linkage.png 325w,\\n/hows-that-again/static/4bf2dd0b6774c85dc85860cdac175646/10273/lazy-procedure-linkage.png 650w,\\n/hows-that-again/static/4bf2dd0b6774c85dc85860cdac175646/1828f/lazy-procedure-linkage.png 940w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Когда вызывается функция библиотеки, то: происходит переход по адресу, лежащему в некой переменной (первый прямоугольник). Эта переменная лежит в области данных (второй прямоугольник) и при первом вызове указывает на заглушку (третий). Заглушка загружает в регистр идентификатор функции и переходит в динамический загрузчик (четвертый). Загрузчик по идентификатору определяет, где лежит эта функция, динамически ее линкует, загружает и вызывает. А вместе с этим он переписывает переменную из 2-го прямоугольника так, чтобы она указывала сразу на адрес загруженной в память реальной функции. Таким образом при последующих вызовах мы попадаем сразу в функцию, правда через адрес, лежащий в переменной. Но количество инструкций остается тем же, просто вместо <code>j</code> используется <code>jr</code>.</p>\\n<h1>Архитектура ARMv7 (32-bit)</h1>\\n<p>Для ARMv8 мануал <a href=\\\"https://www.element14.com/community/servlet/JiveServlet/previewBody/41836-102-1-229511/ARM.Reference_Manual.pdf\\\">здесь</a></p>\\n<p>Основное отличие от MIPS: меньше регистров, больше схем адресации</p>\\n<table>\\n<thead>\\n<tr>\\n<th></th>\\n<th>ARM</th>\\n<th>MIPS</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>Размер инструкции</td>\\n<td>32</td>\\n<td>32</td>\\n</tr>\\n<tr>\\n<td>Адресное пространство</td>\\n<td>32-битное</td>\\n<td>32-битное</td>\\n</tr>\\n<tr>\\n<td>Выравнивание данных</td>\\n<td>Есть</td>\\n<td>Есть</td>\\n</tr>\\n<tr>\\n<td>Схем адресации</td>\\n<td>9</td>\\n<td>3</td>\\n</tr>\\n<tr>\\n<td>Регистры</td>\\n<td>15 х 32 бит</td>\\n<td>31 х 32 бит</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>Сравнение инструкций:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/9de5d07b55cdf8c16e41d063247d091f/83be2/arm-mips-instructions.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 88.95612708018155%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsSAAALEgHS3X78AAAC7ElEQVQ4y2VUy27TUBDN77FGLFARiC1ijZBgx+8gEGwroaJCARUB6iNpXo5feTmOHb/i2E1ymDOx01Iije6945kzZ87cm8Zbt8C94wgPv8d4cBLjyWmKx6cZXl8s8aqy579SHPxI8Ej8z35neHme4b7EPv2Z4UB8b1q55Cd4cZahYYRLfBom+DrJcDLNcdj38OHcwjcnwLE5wxfLx8koxqExw7s/Bo4GPr65IY7cGB8vLLw/G+CoO8RnN1J/Y1sWALaof2WygNtrI5yOEfse0sAH1iWKOMTENJDOZyjTWHwFpvZAzh42eQYUOa7F31itVijXa6w3W4UNwhAXl5dwHBfebIbRaAx/Pke4WKDXNzCZeojiGPmqgGlaEuMjzTJky1z9jaIocPsXCmBTAD3P030gYFEUwfd9uI6jvoWAJ0kCy7JgGAbG47GewyDYMcykQp7nIPhcAGwJpJ++2h8JCBO5V598t20bk8lEz4wnqAISmSxioTyTNsmORXimMXAmPgJwX8eSMdlqXBTvGN5tmQHdble0G2EsNnRdBSfIdDpVJsvlUlm58o1AdSdJXDFcy1C2292kmdhpt9HpdFQfVicAtRsNh7rP0kxXMqSPBXmOJVcZbjabf4bSarbQ7/UUuNZItZWWmZhK21ztaijUl2eSaSi6mF4fAfdFQ06ZwdxTAsYEog8LUAoadXaEoSNFGMcYxv7fcqWhOTDR6/aUcSF3jivZpGmqyTTqm1RstWW9hwJ4u2VWuWq10BUNW80m2ldX++o9kaEeSD0Utn8zlArw+vp6D8rETrsjDAfaFlmQHduy5GUwiVrRqCm/cRi0oL42pErRuUYVQ7ZMZmVZqrGQdevCc6WWbJn7/cW+2zIrss1+vw9P3u0iXEiRSC+2ZZq7ohUj27J3RKKdb//07gKS4UAGwASd6nAkbzqQiTqYy5uunyOnzDfO/Q1DOVBDTprA9RVZCDBZMZnfOAxq6su/C/fMYRHua1kY+xeMAUfzmC0qQQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"ARM vs MIPS instructions\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/9de5d07b55cdf8c16e41d063247d091f/10273/arm-mips-instructions.png\\\"\\n        srcset=\\\"/hows-that-again/static/9de5d07b55cdf8c16e41d063247d091f/9b14a/arm-mips-instructions.png 163w,\\n/hows-that-again/static/9de5d07b55cdf8c16e41d063247d091f/94962/arm-mips-instructions.png 325w,\\n/hows-that-again/static/9de5d07b55cdf8c16e41d063247d091f/10273/arm-mips-instructions.png 650w,\\n/hows-that-again/static/9de5d07b55cdf8c16e41d063247d091f/83be2/arm-mips-instructions.png 661w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Обратите внимание, в ARM нет инструкции для деления!</p>\\n<p>Сравнение схем адресации:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/84d2c264d56a99cd9c89bb235a399edc/7737d/arm-mips-addressing-modes.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 43.730886850152906%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABuElEQVQoz21QTU/VUBDtP2RlYgLEpb9BNgZ/iUu3xohCgiEav0h0gYj09cFre19LX3ltb+9HP4HjzDU1MbI4OTPnzpyZud7GJ42tY4Od0wa7Py2enlo8OTHY/qrx4LPCFvGjY41N4mdn1uWMbdIeflFOe/xNY+Ojwom8gff8e4gXP5Z4dZ7iw5XF+9TgiLAvDN4Ijb2wxutFhbcUH0Z/mPO9ULr3d6QdCIWXlxKZ6eDl4RxlEiOLLtErCXQWt40GGH3jcGcVcNNj1LXju4by1gC3pBmKh5b6DMauhXf26xxRLOD7MwTBHLMgwFW2QiyWWOU5pFJYFyWUMbher6G0QVFWKCsJbax7q5V2edOSYRiGyKkxjmMIQrJcoiwKdF2Hvu9hrYUiU45VXTtdk4GhAdM7a5wzexfzC2RZhoiMoyhyCGjLaxoyDMM/hvU9hpPRX0Pf9yGEwJxMwsUCwWzmDBcUcxGblGUJS3FBm7NWVRWklE6TFGutXd7yybwZn5smCdI0RULMRTyNCyZTzmtqYuaNDZlMm3EdmzrDfLUCg6eO44iBzuBTuJjRNM1/5/E3sM4a81THX/QbQb2bWuvr9mIAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"ARM vs MIPS addressing modes\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/84d2c264d56a99cd9c89bb235a399edc/10273/arm-mips-addressing-modes.png\\\"\\n        srcset=\\\"/hows-that-again/static/84d2c264d56a99cd9c89bb235a399edc/9b14a/arm-mips-addressing-modes.png 163w,\\n/hows-that-again/static/84d2c264d56a99cd9c89bb235a399edc/94962/arm-mips-addressing-modes.png 325w,\\n/hows-that-again/static/84d2c264d56a99cd9c89bb235a399edc/10273/arm-mips-addressing-modes.png 650w,\\n/hows-that-again/static/84d2c264d56a99cd9c89bb235a399edc/7737d/arm-mips-addressing-modes.png 654w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p><strong>Следующий блок относится только к ARMv7 и более ранним моделям. В ARMv8 от условно-выполняемых инструкций отказались</strong></p>\\n<hr>\\n<p>Еще одно важное отличие: для выполнения условий условных переходов в MIPS используется содержимое регистров. В ARM же используется 4 условных бита (<strong>condition codes</strong>), которые хранятся в <em>program status word</em>: negative, zero, carry, overflow. Эти биты могут быть изменены любой инструкцией, но выставлять их необязательно.</p>\\n<p>Например, CMP (Compare) вычитает один операнд из другого и выставляет условные биты соответственно результату вычитания. CMN (Compare negative) <em>складывает</em> операнды и так же выставляет условные биты соответственно результату. TST делает операндам логическое И и выставляет все условные биты кроме overflow, а TEQ делает им OR и так же выставляет все биты кроме overflow.</p>\\n<p>Необычная особенность ARM заключается в том, что каждая инструкция может быть выполнена или не выполнена в зависимости от состояния условных битов. Каждая инструкция начинается с 4-битового поля, которое определяет, будет ли инструкция превращена в nop. Засчет этого можно сэкономить время и место, когда нужно, например, перепрыгнуть через одну инструкцию - теперь не нужно вставлять дополнительное условие и инструкцию j для этого.</p>\\n<hr>\\n<p>Сравнение форматов инструкций: </p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/48d4b0c986436b5e980dca30f60cc6a2/0f45d/arm-mips-instruction-formats.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 81.47590361445783%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsSAAALEgHS3X78AAACeElEQVQ4y22UaU+iQRCE3///T9wvum7iB3WjJoInyimigNwIyn0qaG0/vU7CHpN0BnqG7qrqGiJtrPV6rcVioVKxqNubG2UyGd3f3+vu7s73l5cX9V5fNRqNVC6XPZ/P5/2s2WhqOp0qokC/39dwONTq/V3L5VJZK3R9daWry0slEgmlkklls1kNBwN1Oh2NreDT05OfJ29vfa9Vq14n+vj48EKge3t703QyVTwW0/edHf08PFS/19N8PtdsNtOgP9BkMrHCQ0cDAxodHR3p29aWEtfXijYpf35+igYUgBY/Jsd6t6awgUEI7pGjGff5/kfB1Wrlh3nT5iwed7o3FtDPpNPqdrumYU8Do96o11W3qBh1otls+rlriNCL+cLRgKRoQ0HsXC6nQqGgUqnkP4Lmq92lYM+kaLfbalmhVqvlnzmLAk0WNMbjsWu4s72tw4MDvxQojYYjNRoNpQ1twSabTqWVtIE9PDz4xGu12u+CIcICNWgoRLO1ScHOnTA8mLBvBrn/agiCk+NjxU5PPaBdq9bcKqAomwTkKpWKR9Uswxm0ozAtFijo0jWvdZ6fXXTCNfsaBuZmx3O4gEAmwo0NKuAGa5BEwx+7u64hBeazuecuLy58YOj1+PjoPoQNGuIMzB397UE0onvbJsdAaEKAIPgwoOF1EaBkaMj1j4bQRw865+wVgAL9KN7tdN1rzyYH0wZ9CPL9nj096NIlTBE0CI6ReaepVMpN27QCHvYZXas2DM9/RWgQhUGwwls+PzvX3t6eDvb3/a3yz4K5Q5BDN/RkR09A1PHhJmX/ozDaUII2SHgRiM2PyBVt90JWgBcSJs49tPwFTGumq8H0V00AAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"ARM vs MIPS instruction formats\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/48d4b0c986436b5e980dca30f60cc6a2/10273/arm-mips-instruction-formats.png\\\"\\n        srcset=\\\"/hows-that-again/static/48d4b0c986436b5e980dca30f60cc6a2/9b14a/arm-mips-instruction-formats.png 163w,\\n/hows-that-again/static/48d4b0c986436b5e980dca30f60cc6a2/94962/arm-mips-instruction-formats.png 325w,\\n/hows-that-again/static/48d4b0c986436b5e980dca30f60cc6a2/10273/arm-mips-instruction-formats.png 650w,\\n/hows-that-again/static/48d4b0c986436b5e980dca30f60cc6a2/0f45d/arm-mips-instruction-formats.png 664w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Еще в ARM есть сохранение и загрузка групп регистров. </p>\\n<h1>Архитектура x86</h1>\\n<p>Архитектура поддерживает следующие комбинации оперендов в инструкциях:</p>\\n<ul>\\n<li>регистр-регистр</li>\\n<li>регистр-константа</li>\\n<li>регистр-память</li>\\n<li>память-регистр</li>\\n<li>память-константа</li>\\n</ul>\\n<p>Не поддерживается только комбинация память-память. В это время, в ARM и MIPS большинством инструкций не поддерживается адрес памяти в качестве одного из операндов.</p>\\n<p>Все регистры, начинающиеся с Е, являются расширениями 16-битных регистров до 32-битных. Большинство инструкций имеют только 2 операнда, это значит что один из операндов часто является и входным и выходным.</p>\\n<p>Среди используемых методов адресации есть:</p>\\n<ul>\\n<li><em>based mode with 8- or 32-bit displacement</em> - адрес равен содержимое регистра плюс сдвиг на 8 или 32 бита</li>\\n<li><em>base plus scaled index</em> - адрес равен содержимому регистра плюс 2^scale * index, где scale = 0, 1, 2 или 3. Этот режим нужен, чтобы избежать умножения на 4 при адресации по байтам. scale = 1 используется для 16-битных слов, 2 для 32-битных, 3 - для 64-битных. 0 означает, что не скейлим.</li>\\n<li><em>base plus scaled index with 8- or 32-bit displacement</em> - комбинация первых двух режимов</li>\\n</ul>\\n<p>Каждая инструкция в 80386 может занимать от 1 до 15 байт. Обычно опкоды включают указание, используется ли 8-битный или 16-битный операнд. Некоторые опкоды включают в себя указание метода адресации и регистра. Другие инструкции включают дополнительный байт опкода, называемый <strong>постбайт</strong> содержащий метод адресации и регистр. Режим адресации <em>base plus scaled index</em> использует еще и второй постбайт.</p>\\n<h1>Архитектура ARMv8 (64-bit)</h1>\\n<p>Первая архитектура ARM, поддерживающая 64-битное адресное пространство.</p>\\n<p>По сравнению с ARMv7 отброшены почти все необычные возможности, которых не было в MIPS:</p>\\n<ul>\\n<li>нет условного выполнения инструкций</li>\\n<li>под константы выделено простое 12-битное поле, а не функция, производящая константу, как было в v7</li>\\n<li>нет загрузки и сохранения групп регистров</li>\\n<li>PC больше не регистр</li>\\n</ul>\\n<p>Добавлены новые возможности, которые наоборот оказались полезными в MIPS:</p>\\n<ul>\\n<li>добавлены регистры общего назначения, теперь их тоже 32. Один из регистров привязан к константе 0</li>\\n<li>режимы адресации работают для всех размеров слов</li>\\n<li>добавлена инструкция деления</li>\\n<li>добавлены эквиваленты команд BEQ и BNE</li>\\n</ul>\\n<p>В целом, главное сходство между ARMv7 и ARMv8 это имя.</p>\\n<h1>Арифметика в компьютерах</h1>\\n<h2>Сложение и вычитание</h2>\\n<p>При вычитании мы можем либо вычитать, либо складывать с отрицательным числом, полученным по методу <em>two's complement</em>. При переполнении в 32-й бит знака попадает перенос из сложения битов на 31-й позиции и знак меняется. Если складывать A и B, а N - количество доступных бит для представления числа (включая знакомый), то результат сложения при переполнении будет равен <code>A + B - 2^N</code>.</p>\\n<p>Пример: </p>\\n<p>допустим, у нас есть только 4 бита и мы складываем 5 и 5:</p>\\n<pre><code>  0101\\n+ 0101\\n  ----\\n  1010 == -6\\n\\n  N = 4\\n  Результат равен 5 + 5 - 2^4 = -6\\n</code></pre>\\n<p>Для <code>unsigned</code> операций MIPS НЕ выбрасывает исключения (прерывания) при переполнении, потому что чаще всего беззнаковые операции выполняются для адресной арифметики и там переполнение может быть не важно. Для <code>signed</code> операций исключения выбрасываются.</p>\\n<p>При исключении/прерывании адрес инструкции записывается в регистр и происходит переход на инструкцию обработчика этого прерывания. Адрес инструкции сохраняется, чтобы после обработки исключения программа могла продолжить выполнение. В MIPS есть регистр EPC (exception program counter), в который записывается адрес этой инструкции. Инструкция <em>mfc0</em> используется для загрузки этого значения из EPC в регистр общего нзаначения, после чего можно сделать джамп на соответствующую инструкцию. Причем по соглашению значение EPC пишется в специальные регистры $k0 или $k1, так как если писать в другой регистр общего назначения, то по возвращению в функцию, из которой было выброшено исключение, никто не будет восстанавливать значение этого регистра, и оно будет потеряно.</p>\\n<h2>Умножение</h2>\\n<p>Рассмотри первую версию множителя.</p>\\n<p>В качестве примера умножим 8 на 9 столбиком:</p>\\n<pre><code>      1 0 0 0\\n    X 1 0 0 1\\n    ---------\\n      1 0 0 1\\n    0 0 0 0\\n  0 0 0 0\\n1 0 0 1\\n-------------\\n1 0 0 1 0 0 0\\n</code></pre>\\n<p>Мы видим, что первый операнд (множимое) на каждом i-м шаге сдвигается на одну позицию влево и в зависимости от значения i-го бита множителя либо идет в сумму, либо нет. То есть на каждом шаге:</p>\\n<ol>\\n<li>если младший бит множителя = 1, то множимое суммируется с текущим результатов</li>\\n<li>множимое сдвигается на 1 позицию влево</li>\\n<li>множитель сдвигается на 1 позицию вправо</li>\\n</ol>\\n<p>Эти 3 шага повторяются 32 раза - по количеству бит в операндах. Если бы каждый шаг занимал один такт, то любое умножение занимало бы 96 тактов. Однако операция может быть ускорена засчет распараллеливания - операции сдвига и сложения выполняются одновременно, засчет этого мы получаем 34 такта.</p>\\n<p>Этот алгоритм может быть реализован в виде следующей схемы:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/48f0f1083ad066c8d468d19034217370/83c1d/multiplication-hardware.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 591px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 53.299492385786806%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABdUlEQVQoz5WT63KCQAxGef/3syozgoiAotxF8Uaak3YZdfqnmUHZ9cvJl+zqjeMoPMQwDFLXtXRdJ7vdTsIgkLIobN21nVyvV9M5/V/hvS6appHb7SbP59OAgQKL4/EX2Nre/X6foK9m3J7HB5V5yrKUpm6k1WSeLMtkG28lDEODR+vIHH+6fAV7OEqTRE6nkyasrW0cImCd5/nkiuj7/g306dgDgBtaSgBre7ROm8DSNJXL5WKJFO+1MO9VVZlr3/dNPzmk1bqqJ9FRZxZFkcEQxnFsroC6UbBu9TcObblY6ndo+lE7MyAgAiiQZLu1vfP5/HaCdMOcH4+HjShNUvmazVSfTF0ZsNBBN3pd2OTaLOZzORwOJmAPdwSQTEfgHDMmdG7muLdDyfe5JTsXFMAdQkZA2+gYBSe+2WzEX/qWBwQ4RShoDkly7gDTQrBa/VwbbX+/31shigBAy7u7boMCgdopM7edJjIbwFxkICS6f8Z/4huw307qz6lMjwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Multiplication hardware\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/48f0f1083ad066c8d468d19034217370/83c1d/multiplication-hardware.png\\\"\\n        srcset=\\\"/hows-that-again/static/48f0f1083ad066c8d468d19034217370/b431c/multiplication-hardware.png 163w,\\n/hows-that-again/static/48f0f1083ad066c8d468d19034217370/d82d3/multiplication-hardware.png 325w,\\n/hows-that-again/static/48f0f1083ad066c8d468d19034217370/83c1d/multiplication-hardware.png 591w\\\"\\n        sizes=\\\"(max-width: 591px) 100vw, 591px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Обычно эту схему усложняют за счет того, что в блоке Product мы можем хранить одновременно множитель (в правой половине) и результат (в левой половине). ЭТо возможно благодаря тому, что на каждом шаге у нас множитель уменьшается на 1 знак, а результат - увеличивается.</p>\\n<p>Если нам нужно умножить знаковые числа, то мы сначала запоминаем их знаки, обрубаем их, перемножаем два 31-битных числа, а затем выставляем отрицательный знак если оригинальные знаки различались.</p>\\n<p>В новых множителях схема гораздо сложнее. К каждому биту множителя подсоединяется свой 32-битный сумматор, которому на вход подается выход предыдущего сумматора и результат AND над множимым и соответствующим битом множителя. Причем все сумматору соединяются не последовательно, а в виде бинарного дерева, чтобы уменьшить количество операций. В результате мы ждем не 32 последовательных сложения, а только 5.</p>\\n<p><img src=\\\"fast-multiplication-hardware.png\\\" alt=\\\"Fast multiplication hardware\\\"></p>\\n<p>(рисунок немного неверный, так как на каждом следующем слое должно быть больше бит для хранения результата сложения. На втором слое - 34, на третьем - 36 и т.д.)</p>\\n<p>В MIPS есть специальные регистры для хранения результата умножения 32-битных регистров, называемые Hi и Lo, и инструкции mfhi/mflo, означающие move from hi, move from lo.</p>\\n<p>Например, при умножении $s2 на $s3:</p>\\n<pre><code>mult $s2, $s3 # верхний бит результата окажется в Hi, нижний бит - в Lo\\nmfhi $s0      # перемещаем верхний бит в s0\\nmflo $s1      # перемещаем нижний бит в s1\\n</code></pre>\\n<h2>Деление</h2>\\n<p>Пример деления столбиком, делим 1001010  (делимое) на 1000 (делитель):</p>\\n<pre><code> 1001010 | 1000 &#x3C;- делитель\\n-1000    |------\\n-----    | 1001 &#x3C;- результат\\n    1\\n    10\\n    101\\n    1010\\n   -1000\\n   -----\\n      10   &#x3C;- остаток\\n</code></pre>\\n<ol>\\n<li>Берем максимум знаков слева делимого, чтобы было больше делителя, в нашем случае это 4 знака и 1001. </li>\\n<li>Делим полученное число на делитель, то есть 1001/1000</li>\\n<li>Результат деления пишем в результат - 1</li>\\n<li>Остаток от деления (1) пишем под вычитанием, приписываем один знак от делимого - 0.</li>\\n<li>Если полученное число (10) меньше делителя, то в результат пишем 0 и приписываем еще один знак делимого. Так до тех пор, пока не сможем разделить полученное число на делитель. В нашем случае мы не смогли разделить 10 и 101 на 1000, поэтому в результат попало два нуля, а вот 1010 уже смогли, поэтому после двух нулей стоит 1.</li>\\n</ol>\\n<p>Итого, алгоритмически деление может быть осуществлено следующим образом:</p>\\n<ol>\\n<li>32-битный делитель представляем как 64-битное число, у которого делитель записан в левой половине, а правая заполнена нулями</li>\\n<li>В остаток вначале операции записывается делимое</li>\\n<li>\\n<p>Затем в цикле повторяем 33 раза:</p>\\n<ol>\\n<li>Вычитаем делитель из остатка, пишем результат в остаток</li>\\n<li>Если остаток >= 0, сдвигаем частное влево на 1 позицию, выставляем правый бит в 1. Иначе - обратно прибавляем делитель к остатку, после чего сдвигаем частное влево на 1 позицию, выставляем правый бит в 0</li>\\n<li>делитель сдвигаем вправо на 1 позицию</li>\\n</ol>\\n</li>\\n</ol>\\n<p>Таким образом, в шагах 3.1-3.2 мы определяем, является ли текущий остаток большим, чем делитель и если да, то пишем в результат 1 и вычитаем делитель из остатка, а если нет, то пишем 0 и оставляем остаток нертронутым.</p>\\n<p>Такое деление называется <em><a href=\\\"https://en.wikipedia.org/wiki/Division_algorithm#Restoring_division\\\">восстанавливающее (restoring)</a></em>. Есть еще <em><a href=\\\"https://en.wikipedia.org/wiki/Division_algorithm#Non-restoring_division\\\">невосстанавливающее (nonrestoring)</a></em> - оно более быстрое. В нем на 2 шаге не происходит восстановления остатка, а вместо этого прибавляет делитель к сдвинутому остатку на следующем шаге, так как <code>(r + d) * 2 - d = 2r + 2d - d = 2r + d</code>.</p>\\n<p>На картинке изображен пример деления 7 (00000111) на 2 (0010) этим алгоритмом:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/d167f9259082337ce37e314e9f9a6794/7737d/division-example.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 57.645259938837924%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAACdklEQVQoz1WSzYvTUBTF+2cKA4K4cSOIuBhEcOlC/D9cCIIzzMKFji5GpI79mLZpkibvJXlNXl6T5rvTVPR481JGXBzeDe9y8jv3vsGLWYOX8wYPrxvc/7HDybDB00mD02mDe99KnHwv8WBY4fnNDq/tFk9GNR6Pd3hltnj0s8Ez6n1j73FK92dhi8EXpnAVbPF+wvB2aOLdyMFXL8WVyPBZlLgUBT7xFJeOxMXY0ncfpgxnIwvnMw8f7QjnkxUuFj5WSYkB8AfAb6RhAOUzZJFAJkMUSuI2S9EWW606z8ACgUNVQHIH7nKOhPpVVsBQBcI0x21dYbBvD9i3LTj3YBhLWJYNx2VIkhRJmiLdZtiSVLqF4XDkeQ4r3GDqx2ByAxFT7fhw1xHKigxbMtvv92TI4axW+uSMYy0EYimhlNKSpIXr0Y8S2NQ3Xxjgrgs3TjFep7CjBEVRYHAgw87U8zyYyyVWNpkyRlRbZFmmmwqiSjQhQ0Xf1jrGjRfBI8L1kZCtJaqq7glbHZmTma3NGCkIAkRRhDiOoUhSbYjQ7wmp745QJphqwk1PqA0pckdomaaO3dXdrPIs788j4cJ2NaEpYkx4CF8qBCrBtbuGE6qe8HA4oFNHZpkWHIc2SPKIWNIMy7JESlRRrGCwQNcWEc7mC53KFRHGpgOb+/8Iu6X4RGVblib0j4Sd2W6302e3dcvl/80wiBMISbRk6PoCdX0k/EViNI+lsdRz7BfD9Qy7hdwRcqHrJSWZ3Mx0KicIMTRo6yvWE3YEt6QuXuD7EPR4JRlV9KZKaujua6qzvICIYqpL+GmB1YYeeF5iu1FglEoEvu79C/HEbDzBQnEMAAAAAElFTkSuQmCC'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Division example\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/d167f9259082337ce37e314e9f9a6794/10273/division-example.png\\\"\\n        srcset=\\\"/hows-that-again/static/d167f9259082337ce37e314e9f9a6794/9b14a/division-example.png 163w,\\n/hows-that-again/static/d167f9259082337ce37e314e9f9a6794/94962/division-example.png 325w,\\n/hows-that-again/static/d167f9259082337ce37e314e9f9a6794/10273/division-example.png 650w,\\n/hows-that-again/static/d167f9259082337ce37e314e9f9a6794/7737d/division-example.png 654w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>На следующей картинке изображена первая версия делителя:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/39ac247a99f16a60eb7972d4f2158160/4946c/division-hardware.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 540px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 59.074074074074076%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAABlklEQVQoz3WSh46DQAxE+f8PhDQplITeUkhCms/Pp0VcdEEyC7v27HjG3vv9Fp7H4yHjOMr9fpfL5SJlWcr5fJ72n8+nkOvy3fr5eLwAqatKTqeTgaRpKosgkLqube94PErbtlPRN7AJEBaHvpfX62Xfl2EwEJgmcSyxxma9lrZpLMeBzsPtebColF2R58bucDgYEAC+70uWZcaOM+J2u/3LzIF6JDQKuksS24ABEsRRJNfr9U8RuQ6wbVrTedBu5vp6sAEMZr22XRal6dbUjbEEdG4WgOTu93s930hRFHJSeaaWeZHcaVskRWEoubbfd52BAnLVsAu73gAb1XI4D7JaLs28QKVxHnhOZMwgEYdhxf/8MeMUlPYgQLuBH0ie5XYh+rLvIThA3BAqu+ViYcm4jGFOx0ELcDyJE5Pkc3TQ0gAxhFsJ3AacAnRDW2QgERlS/V6vVr9TodrBiovdrFrLGAFLZwosozCS3W5nenLBqLrBlHM6QFeKP+fQxqbS9igimLntdmtr13YGQiswcSug3+aQ+AF0CJvvm5RuswAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Division hardware\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/39ac247a99f16a60eb7972d4f2158160/4946c/division-hardware.png\\\"\\n        srcset=\\\"/hows-that-again/static/39ac247a99f16a60eb7972d4f2158160/ae4e1/division-hardware.png 163w,\\n/hows-that-again/static/39ac247a99f16a60eb7972d4f2158160/e0ba1/division-hardware.png 325w,\\n/hows-that-again/static/39ac247a99f16a60eb7972d4f2158160/4946c/division-hardware.png 540w\\\"\\n        sizes=\\\"(max-width: 540px) 100vw, 540px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<ul>\\n<li>Divisor - делитель</li>\\n<li>Quotient - частное</li>\\n<li>Remainder - остаток</li>\\n</ul>\\n<p>В новых делителях используется более сложная схема. Использовать тот же подход, что и в сложном делении мы не можем, так как на каждом шаге нужно знать результат сравнения делителя с остатком. Но есть техники, позволяющие производить более 1 знака частного за шаг. Техника <em>SRT division</em> пытается <strong>предугадать</strong> несколько бит частного, используя поиск по таблице по верхним битам делимого и остатка. В последующих шагах алгоритм может исправить предсказания, если они оказались неверными. Обычно считается по 4 бита частного за раз, используя 4 бита делимого и 6 бит остатка в качестве ключа поиска по таблице.</p>\\n<p>В MIPS для деления используются те же регистры Hi/Lo и операции mfhi/mflo, что и при умножении:</p>\\n<pre><code>div $s2, $s3  # остаток окажется в Hi, частное - в Lo\\nmfhi $s0      # перемещаем остаток в s0\\nmflo $s1      # перемещаем частное в s1\\n</code></pre>\\n<h2>Плавающая точка</h2>\\n<p><strong>Научная нотация записи</strong> чисел имеет один знак слева от запятой, например: <code>1.2 * 10^9</code>. Есть еще <strong>нормализованная научная запись</strong>, в которой слева от запятой должен быть только один знак и он должен быть ненулевым. Например, <code>0.1 * 10^-8</code> и <code>10.0 * 10^-10</code> не являются нормализованными научными записями, а <code>1.0 * 10^-9</code> - является.</p>\\n<p>Двоичные числа так же могут быть представлены в научной нотации: <code>1.0 * 2^-1</code>. Степень двойки означает, на сколько знаков вправо нужно сдвинуть число в двоичной записи. В данном случае 0.5 будет представлено как 0.1 в двоичной записи.</p>\\n<p>Числа с плавающей запятой имеют форму <code>1.xxxxxxxxx * 2^yyyy</code></p>\\n<p>В компьютере числа с плавающей точкой представлены в виде двух частей - мантиссы и экспоненты. Увеличение мантиссы увеличивает точность, увеличение экспоненты увеличивает представимый интервал. </p>\\n<p>Мантисса всегда имеет значение от 0 до 1 - это <code>1.xxxxxxxxx</code>.</p>\\n<p>Экспонента - это <code>yyyy</code>.</p>\\n<p>В MIPS числа с плавающей точкой представлены следующим образом:</p>\\n<pre><code>| знак (1 бит) | экспонента (8 бит) | мантисса (23 бита) |\\n</code></pre>\\n<p>Значение = <code>-1^S * M * 2^E</code>, где S - знак, M - мантисса, E - экспонента.</p>\\n<p>Переполнение возникает, когда не хватает знаков для экспоненты. Однако может быть еще и <em>опустошение / underflow</em>, когда нам нужно представить настолько маленькое число, что знаков в экспоненте не хватает. Тогда используются типы с удвоенной точностью, имеющие больше бит для экспоненты.</p>\\n<p>В MIPS число с удвоенной точностью занимает 64 бита, из них 11 - экспонента, а 52 - мантисса.</p>\\n<pre><code>| знак (1 бит) | экспонента (11 бит) | мантисса (52 бита) |\\n</code></pre>\\n<p>Чтобы использовать больше бит, спецификация IEEE 754 предполагает, что 1 слева от запятой в нормализованном представлении числа всегда есть и поэтому она в мантиссе не указывается.</p>\\n<p>Тогда числа имеют значение: <code>-1^S * (1 + M) * 2^E</code>, где мантисса - число от 0 до 1. При этом в мантиссе биты используются \\\"слева-направо\\\". То есть, если пронумеровать биты мантиссы слева направо как s1, s2, s3, то значение будет равно:</p>\\n<p><code>-1^S * (1 + (s1 * 2^-1) + (s2 * 2^-2) + (s3 * 2^-3) + (s4 * 2^-4) + ...) * 2^E</code></p>\\n<p>Помимо этого, чтобы меньшие числа имели меньшее значение, было решено, что наименьшая экспонента (-127) должна иметь значение 0000..00, а наибольшая (128) - 1111..11. Поэтому для записи экспоненты применяется т.н. <code>biased notation</code>, где к реальному значению экспоненты прибавляется некий сдвиг. В числах с одинарной точностью сдвиг равен -127. Таким образом, экспонента -1 становится равна <code>-1 + 127 = 126 = 0111 1110</code>, а экспонента 1 становится <code>1 + 127 = 128 = 1000 0000</code>.</p>\\n<p>В числах с двойной точностью сдвиг равен 1023.</p>\\n<p>Таким образом, значение, представленное числов с плавающей точкой, равно:</p>\\n<p><code>-1^S * (1 + M) * 2^(E - bias)</code></p>\\n<p>или, если писать полностью:</p>\\n<p><code>-1^S * (1 + (s1 * 2^-1) + (s2 * 2^-2) + (s3 * 2^-3) + (s4 * 2^-4) + ...) * 2^(E - bias)</code>, где s1,s2,s3 - биты мантиссы, перечисленные слева направо.</p>\\n<p>Пример:</p>\\n<p>преобразуем число в десятичную запись:</p>\\n<pre><code>110000001010000000...\\n\\nзнак = 1\\nмантисса = 10000001\\nэкспонента = 010000000...\\n\\nДля начала определим знак, значение 1 - значит отрицательный\\n\\nМантисса представлена как 129, нужно отнять 127, получаем 2.\\n\\nВ экспоненте мы видим 01000..., что значит 0*2^-1 + 1*2^-2 + 0*2^-3 + ... = 0.25\\n\\nИтого получаем: -1 * (1 + 0.25) * 2^2 = -5.0\\n</code></pre>\\n<p>Обратный пример:</p>\\n<p>преобразуем -0.75 в число с плавающей точкой:</p>\\n<pre><code>-0.75 = -3 * 2^-2 = -1,5 * 2^-1\\n\\nЗнак = 1\\nМантисса = 1.5, для представления отбрасываем 1, остается 0.5 = 1 * 2^-1 = 100000...0 в двоичном представлении\\nЭкспонента = -1, для представления нужно прибавить 127, получаем 126 = 0111 1110 в двоичном представлении\\n\\nИтого, получаем:\\n\\n1 0111 1110 1000000000...0\\n</code></pre>\\n<p>Хороший источник по чтению и записи чисел с плавающей точкой: <a href=\\\"http://cstl-csm.semo.edu/xzhang/Class%20Folder/CS280/Workbook_HTML/FLOATING_tut.htm\\\">http://cstl-csm.semo.edu/xzhang/Class%20Folder/CS280/Workbook<em>HTML/FLOATING</em>tut.htm</a></p>\\n<p>Еще одна инструкция по переводу из бинарного вида в десятичную дробь: <a href=\\\"http://sandbox.mc.edu/~bennet/cs110/flt/ftod.html\\\">http://sandbox.mc.edu/~bennet/cs110/flt/ftod.html</a></p>\\n<h3>Инструкции MIPS по работе с плавающей точкой</h3>\\n<ul>\\n<li>add.s, add.d - сложение single- и double-precision чисел</li>\\n<li>sub.s, sub.d</li>\\n<li>mul.s, mul.d</li>\\n<li>div.s, div.d</li>\\n<li>c.x.s, c.x.d - сравнение чисел, где x может быть eq, neq, lt, le, gt, ge</li>\\n<li>bclt, bclf - команды перехода</li>\\n<li>lwcl, swcl - загрузить/сохранить регистр с плавающей точкой</li>\\n</ul>\\n<p>Для операция с плавающей точкой выделены специальные регистры - $f0, $f1, $f2, ...</p>\\n<h2>Subword parallelism</h2>\\n<p>Если мы оперируем типами, размер которых меньше машинного слова, то в одном регистре может быть несколько значений такого типа. Инструкции, поддерживающие <em>subword parallelism</em>, таким образом, параллельно обрабатывают несколько таких значений, лежащих в одном регистре.</p>\\n<p>В процессоры ARM такие операции были добавлены расширением ARM NEON.</p>\\n<h2>Streaming SIMD Extension (SSE)</h2>\\n<p>SSE и MMX (MultiMedia eXtension) - это расширения к x86, реализующие <strong>subword parallelism</strong>.</p>\\n<h1>Процессор</h1>\\n<p>Далее будет представлен вариант реализации процессора, который поддерживает следующие команды MIPS:</p>\\n<ul>\\n<li>инструкции работы с памятью: lw, sw</li>\\n<li>арифметико-логические инструкции: add, sub, and, or, slt</li>\\n<li>инструкции ветвления: beq, j</li>\\n</ul>\\n<p>Не поддерживаются: сдвиг, умножение, деление, операции с плавающей точкой и т.д.</p>\\n<p>В общем виде каждая из инструкций может быть декомпозирована на следующие шаги:</p>\\n<ol>\\n<li>Читаем из памяти инструкцию по адресу, содержащемуся в регистре PC</li>\\n<li>Парсим инструкцию</li>\\n<li>Читаем 1 или 2 регистра в зависимости от инструкции</li>\\n</ol>\\n<p>Дальнейшие действия зависят от инструкции, но сильно похожи. Для всех инструкций, кроме <code>j</code>, нужно обратиться к ALU, подав на вход либо значение 2 регистров, либо значение 1 регистра и константу. </p>\\n<p>Затем, если у нас инструкция работы с памятью, то нужно обратиться к памяти (для записи или чтения) по полученному из ALU адресу. Если арифметико-логическая инструкция, то нужно результат работы ALU записать в какой-то регистр. А если инструкция ветвления, то нужно изменить значение регистра PC в зависимости от результата сравнения. Если же это не инструкция ветвления, то значение PC должно быть увеличено на 4.</p>\\n<p>Таким образом, получаем следующую высоко-уровневую схему реализации MIPS:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/e7122415dbdd4ccd91e1a77ca6b1d16a/b0dec/mips-implementation1.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 55.227882037533504%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABbElEQVQoz4WT627CMAyF8/4vN/4xMYlVQK/0Ru+lgOfPI9OY2GbJxEkcn+Nj6k6nk/R9L33X2ToMg3T3uCgKi3HylmUR7Ha7yW/mBn3ojcRpmqRrW4ursrRCnOHn8/n/gv2PgnjTNFJVlbGkSF3Vtr9cLg95z9wKXq/Xr3bHcZQoiqRUdrCq61qSOP6T1QPDUYvwcJ5nWZQNjNhTuNF2YduqBDixB/XajsP4eXbX3vFDIgwRnYK0ho5JkkgUhjLcWwcIECukRRkkb4yMrsji0CdLU0P5LjiIpU65LMqHCdu/AnYKiByAcAeJLMvE8Wi73UqsuuV5bkwBQMe3zUbSJJUgCOR1vbYzmAIeKnM6ILfVDjH2DrokkLx6WUnwHtgliOHhYJ5qIkyww35vEnHvWa8VLNXCDNIxYS7QBcq04fXKj7n60VaYc7bb7UyrWWPa98NC00ndPRs9IGhJEuz91+O/GD8EYliRD2Mm/gG/aFOaQzDUIgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"MIPS implementation 1\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/e7122415dbdd4ccd91e1a77ca6b1d16a/10273/mips-implementation1.png\\\"\\n        srcset=\\\"/hows-that-again/static/e7122415dbdd4ccd91e1a77ca6b1d16a/9b14a/mips-implementation1.png 163w,\\n/hows-that-again/static/e7122415dbdd4ccd91e1a77ca6b1d16a/94962/mips-implementation1.png 325w,\\n/hows-that-again/static/e7122415dbdd4ccd91e1a77ca6b1d16a/10273/mips-implementation1.png 650w,\\n/hows-that-again/static/e7122415dbdd4ccd91e1a77ca6b1d16a/b0dec/mips-implementation1.png 746w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>На этой схеме для понятности опущены мультиплексоры и контроллеры, занимающиеся выбором линий в зависимости от инструкций. Полная схема выглядит так:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/771daf35826589796876b9cc3302c490/fb6b3/mips-implementation2.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 74.18630751964085%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACPklEQVQ4y4VUiZKiMBT0//9wpxTHAQTlhlwQQk+/oFOus1WbqjYhR79+l4dt2/COOQCWcI9ZYNbtB5rITUDJA/uyL+sD3sayLKiaBto6wkIbC8P1SkNPyON+2eDD/u2JQChPQmsMHB9aYp5nKKVQ3e9xb9sCthDiWeC8jy3+urB78zqiQq11vLyuayQchiGSDn0POZM9Q6OB5zIkHAJRKErdIzRiYIwKaf11OOfQd10kE+KG7steJJsX1P1IVwOGeYVZKMI/sAY0MwnFNe99VCHx69o2koihnirHcdwdpXvOGjQMx2w0em32MDmBg6WA1q27QiETNaJEEBNTVehEqdKRVHAbDdJeI+smFFzbbXff02CjHUrjcRAiueys+3FbYiqJKYsiqn/uDSTvJqpTBvXEZC4evfM4Dw7nZsRZkVBUpGkaFYm6ieQt3T6eEpRliSzLkGcppBqsFU8mxrjFR1rgXtWoOyZv9jG2yURCIRGFxfWK0/EY11JfSXrFNc9Q1w0mqjd8lJP8RiOWbyrlYjJuxRXpOaFqjdPEGD67Q5ReLpeYXclidq9R5DmausZNz0joUpKcUbd9jLkkSKrB0m3tFox2xqcOvzsFUvkknHjJUpkSdSSYxBCT5Vh7rHbWLStjGtEZh6/RoSPhRQjf+1iGvJE2YrtCsZ6vTOdtBirWWc20Si8rYuIdtfCb9ai5TtRD4V+Ej1ku1GyBO/GpV/wZV3wwRsdfCJHoSMtf/3L5tT8lOUvY/wSeBsN/8A0udI2qn1RYKgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"MIPS implementation 2\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/771daf35826589796876b9cc3302c490/10273/mips-implementation2.png\\\"\\n        srcset=\\\"/hows-that-again/static/771daf35826589796876b9cc3302c490/9b14a/mips-implementation2.png 163w,\\n/hows-that-again/static/771daf35826589796876b9cc3302c490/94962/mips-implementation2.png 325w,\\n/hows-that-again/static/771daf35826589796876b9cc3302c490/10273/mips-implementation2.png 650w,\\n/hows-that-again/static/771daf35826589796876b9cc3302c490/fb6b3/mips-implementation2.png 891w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Здесь верхний мультиплексор определяет, нужно ли брать PC = PC + 4 или PC = адрес джампа. Ему на вход поступает AND результата сравнения от ALU и бита, определяющего, является ли инструкция инструкцией ветвления. Второй сверху мультиплексор выбирает, в зависимости от инструкции, писать в регистр результат работы ALU или значение, полученное из памяти. Ну и третий - в зависимости от инструкции определяет, подавать вторым операндом в ALU значение регистра, или константу сдвига, полученную из инструкции.</p>\\n<p>Теперь разберем итеративный процесс построения потока данных (<strong>datapath</strong>).</p>\\n<p>Для начала нам понадобится блок, который читает инструкции и инкрементирует PC:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/0d959ba9046c42f9819d8351546ace90/0e537/datapath-pc.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 373px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 78.28418230563003%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsSAAALEgHS3X78AAABu0lEQVQ4y5WUa2+CUAyG+f8/bDPz23RxUadDIt4VwQuo2PWpHgeiydakObf27dsLePv9XlarlayjtURR9C/FJ15f/Na6LpdL8QDb7XZyPB7lcDjI6XSSPM9tfaa8Z1km8/lcNpuNnNQ313vAPaIA5gQDY6yPD1XZJEki4XBodmmaShzH5ku2HnRh5mS5WNgDUY8P1GVBYIAR7jkDXgHkjMNfBJBwGEq/35fZbCbT6fQCWEw5Wv2ez+dzRZ2wBxDb9NpYiHjUhQfqQHPcwzNJ1M6YheGtdqw0CfEwgCURt9utOMaAo9SpqKQFAPu5pmldvhIAw4uU0Xg0MgPYDrV74/FYRno3U2fAMbRxuToCyF2WZqUSGEM643/70mm3DSwIAvF9Xz5bLanVahIMglI9b4D5uXJvDNmQmq2asjuTSnE0St29uys2y3OFBoSU+QoAKRrx1u/1bEQGyp6G0DzqWWR3A6Q+NIT0LcAdIPskTixVFDD3eVYAi45OYNrtdOWj2ZTGe0OajUZp+B8FLKV8P7iwZfJfX16l/laXr263PIsFwIcp30eyGdM/yUKVlVot9Bs31fNkMql02MkPLPnatoQAcBIAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Datapath PC portion\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/0d959ba9046c42f9819d8351546ace90/0e537/datapath-pc.png\\\"\\n        srcset=\\\"/hows-that-again/static/0d959ba9046c42f9819d8351546ace90/0fc99/datapath-pc.png 163w,\\n/hows-that-again/static/0d959ba9046c42f9819d8351546ace90/9c6bb/datapath-pc.png 325w,\\n/hows-that-again/static/0d959ba9046c42f9819d8351546ace90/0e537/datapath-pc.png 373w\\\"\\n        sizes=\\\"(max-width: 373px) 100vw, 373px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Дальше - блок бранчинга:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/463d74a56e02fc1b5a38593837f88ff9/778fa/datapath-branching.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 632px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 71.99367088607596%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAABnklEQVQ4y31Ui26DMAzk/3+vk1omQaEtHZUolEcICQ/P542IImikCEjs8905waPFmKbJPY0xMruuo05rebZtS9ZaUkrJ3jiOtM73tgAR2DQNla8XFUVBzyyjPM8p4yfW67oWwLqqpJDmgn3fS663ZDXPvYHEYRgE8PF4SBG8+74v7w5wC2RZAIzLsqSvw4GiKBKQwbIlukXkvuSKJVziWBKWUuAZJuTDR90ZyhRLZpW5GckME9D+ABtOBkhyu1GapvTN9OHNPJIkEVZgCHAUKnk/bQwV2lJuWcGClAc5QFaNEtAwCKn6T4ZfYPni5syA6DIK2k5TzWuQjXh4iHgnGcDYiKNYAMIgEOPnZuhWOxYAz7IngxRixc/9TtH5LFa5LgMdgQACwDyul6usoQjkAgBxYGr4e93QN0CYHoYhGUjrB1nDeQMAGgYVkI017G2dCAcohjOzUrV0LjtKlaWKJYAR2IDd3tFaXgoHaLkqbgG+re2FLVjJcWHDsbd1Adbn+E0ykqUBPAFyPB7JP52cZ0sme8P7FDT/HNZ3/dP4BV2PRCQX4kUvAAAAAElFTkSuQmCC'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Datapath branching portion\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/463d74a56e02fc1b5a38593837f88ff9/778fa/datapath-branching.png\\\"\\n        srcset=\\\"/hows-that-again/static/463d74a56e02fc1b5a38593837f88ff9/7fe72/datapath-branching.png 163w,\\n/hows-that-again/static/463d74a56e02fc1b5a38593837f88ff9/6307c/datapath-branching.png 325w,\\n/hows-that-again/static/463d74a56e02fc1b5a38593837f88ff9/778fa/datapath-branching.png 632w\\\"\\n        sizes=\\\"(max-width: 632px) 100vw, 632px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Здесь синим обозначены управляющие сигналы</p>\\n<ul>\\n<li><strong>RegWrite</strong> - сигнал блока регистров, который подается, когда данные, поданные на вход <em>Write data</em> нужно записать в регистр <em>Write register</em>. Для чтения такого управляющего сигнала нет, поэтому значения регистров <em>Read register 1</em> и <em>Read register 2</em> <strong>всегда</strong> подаются на исходящие пины <em>Read data 1</em> и <em>Read data 2</em>.</li>\\n<li><strong>ALU operation</strong> - 4-битовый сигнал, определяющий операцию, которую должен выполнить АЛУ. В данном случае это будет операция сравнения. Управляющий сигнал здесь нужен потому что этот АЛУ будет использован для разных операций в разных инструкциях. А вот для сумматора на этой схеме используется другой АЛУ, у которого всегда будет проводиться операция сложения, поэтому ему управляющий сигнал не нужен. Дублирование АЛУ обусловлено тем, что в конце концов наш процессор должен выполнять инструкцию за один такт, а значит ни один элемент не может быть использован больше 1 раза.</li>\\n</ul>\\n<p>Блок <em>Sign-extend</em> нужен, чтобы преобразовать знаковый 16-битный сдвиг в знаковый 32-битный, который можно подать на сумматор.</p>\\n<p>Далее - блок выполнения инструкций работы с памятью и инструкций R-типа:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/d8f4f198e08050058d98942bf5bd393a/8f4fa/datapath-memory-r-type.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 48.86685552407932%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABlklEQVQoz5VSa2+DMAzs//9924dpGh2FAuX9SEISAjdfUKt9mrRIBidOzuezL8dxYF1XZLcb2raFtRbGGCzLgufa9wO9DRg24GEP+OM8D/Lfon8eCBQu+77Hx9fkirquY6DvupjAOwcryaZpwrg6jEpDuw3Oe1jn0WiHTHnMksjtJ+glTVOURYmiKEC/aZrIeJIk+WTQrx5aKUnSoioLdG0T9wSdJVHTD8gFtLX7CbhKeWSU5zmyLMM4jvKwRPKVoBtGfKc3jMMAJexyiRf3e0yqtcYg5634ZZ7BqFOiCzVkIJcS3WpeulHHScBLYc4k27aBdwnEP5f3W9yzsk5IRUBqOAlgcq+QtDMmY+MlWv2oMc9zlIDGhlFnyuPE//z4ECJp9Bl/AZJBkI2Wls3aSHkqXiIo49FCiMz6vsf39YpGJqLqBtyqBk7YE/B4lky6Rh4rYXMXLd/f3lBV1Wt0niX+9kPYZZQ2VGuAlflhLyJDfogeQogHTkaFzLx08T/L/AZUwoRaEYis2CSesfS/bFmedr7n+gHjAAPrxGQeUQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Datapath for memory instructions and R-type instructions\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/d8f4f198e08050058d98942bf5bd393a/10273/datapath-memory-r-type.png\\\"\\n        srcset=\\\"/hows-that-again/static/d8f4f198e08050058d98942bf5bd393a/9b14a/datapath-memory-r-type.png 163w,\\n/hows-that-again/static/d8f4f198e08050058d98942bf5bd393a/94962/datapath-memory-r-type.png 325w,\\n/hows-that-again/static/d8f4f198e08050058d98942bf5bd393a/10273/datapath-memory-r-type.png 650w,\\n/hows-that-again/static/d8f4f198e08050058d98942bf5bd393a/8f4fa/datapath-memory-r-type.png 706w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Управляющие сигналы:</p>\\n<ul>\\n<li><strong>ALUSrc</strong> - определяем, подавать ли вторым операндом в АЛУ значение регистра (для арифметико-логических операций) или константу сдвига (для операций памяти)</li>\\n<li><strong>MemWrite, MemRead</strong> - если сигналы активированы, то происходит запись либо чтение в память. В отличие от блока регистров, здесь чтение должно происходить по сигналу, так как попытка чтения из невалидного адреса может привести к проблемам</li>\\n<li><strong>MemToReg</strong> - определяет, что нужно писать в регистр - результат работы АЛУ, или значение, прочитанное из памяти</li>\\n</ul>\\n<p>На схедующей схеме эти 3 блока объединены в общую схему процессора. Этот процессор может выполнять основные инструкции (чтение/запись слова, сложение/вычитание/сравнение и условные переходы) за один такт. Джампы пока не поддерживаются.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/7b9bb95bf075dbe5a9c60d19c35ba267/83be2/datapath-combined.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 67.32223903177005%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAAB6UlEQVQ4y21T23ajMAzk//9u+9a0SUMukJiLbTD3hKlGCVm6W50zx2Ds0Wgkoq7rME0TuHrv0bYt5vmO+/0vmqZRhBBQ1zWGvkfoBqS5RSV3GPM8KyISkIwXedhcjb6vYa3VlaS2LPVcK8+n41He7U9CHhyGAb1kdc5hHEf8FjxHolIIj0JkjNEEt9vtRciIGimD+DeomFbwAhF/fWHz/q5neyGf5fsj5p8KizzH5XLB+XTS7FSbSXaWw2eqKPIMphnguhFlO6CQIvJhxnSfMQr6+/wijlhmkiSKxfzD4YDt51aVOedxFnIXWpS+krWBq2qxSGyShCb0SOsepSSpJ1FImbzIblFpHMeK/T7GbrdDKomoNhfzvRDlmdHSk/NZPa280+dT7uClgmjxLE1SvP15Q5qmSnA+xLrPJsX7PT42G1yvV20Oq9KmyIRQDIl3n5+oK/9QSLAJXGn4QQg/EoOqn7QxRVGo+lAHLHN7EeWBVYkAfiuKUmc4Wtr9Gg/ZtKLADTdkrtKuctbapxoqZrO2pwQ7U8IIUZ5lOvTcj9YtX+aNisa+QyrebKRUqqCqdRRVwNUHeGkSh5wJ+Qe9PFwIeZGZFv8yyb4e3nXydfAe7fqPkF4663Qm7RPlE/aXvce+RS7zzOq+AYfV6oQkKfh1AAAAAElFTkSuQmCC'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Datapath combined\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/7b9bb95bf075dbe5a9c60d19c35ba267/10273/datapath-combined.png\\\"\\n        srcset=\\\"/hows-that-again/static/7b9bb95bf075dbe5a9c60d19c35ba267/9b14a/datapath-combined.png 163w,\\n/hows-that-again/static/7b9bb95bf075dbe5a9c60d19c35ba267/94962/datapath-combined.png 325w,\\n/hows-that-again/static/7b9bb95bf075dbe5a9c60d19c35ba267/10273/datapath-combined.png 650w,\\n/hows-that-again/static/7b9bb95bf075dbe5a9c60d19c35ba267/83be2/datapath-combined.png 661w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Здесь добавлен один мультиплексор, управляемый сигналом:</p>\\n<ul>\\n<li><strong>PCSrc</strong> - определяет, использовать ли для PC следующую инструкцию или перепрыгивать на адрес, указанный в инструкции условного перехода</li>\\n</ul>\\n<p>Итак, у нас готов <strong>datapath</strong>, теперь попробуем реализовать его внутренние элементы.</p>\\n<p>Наша реализация будет поддерживать следующие команды: lw, sw, beq, add, sub, and, or, slt.</p>\\n<p>Вспомним, какие у нас используются форматы инструкций:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/211a92ffee7974633687bc226729170a/d8e13/instruction-formats.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 617px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 37.27714748784441%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABC0lEQVQozz1Ri46EIAzk/79wL2a9rHt7gi9UUPCBvU5zSDJS2+kwFDVPE02M8zzJOUdaa+r7XlDXNQ3DQI0xZBiWY9TbtqW+66h8PsloQx3H1etF4ziSyiIdk7Ztk6J3Xg4A4bouijHKoVjg4x9rnmdKKQm895JTaEQT1rquLOakiKbjOCiGcMeo7/suCJxflkV2GEEOPAX7P++3nAahoij4GlocVVUlTeD8fj4iCEAE3K/Hg0ZrRSjXFOzmRN4hggbEuAEAh3nPMW6WznTnoKXgJM8CAnaw8u8YeBgIW3YBYH7icA3C+S5LycOxjIu5Cp+maW7rLccgxxBFEPOBEF77+J9fBup5vjn3B2a9GyFSZ46sAAAAAElFTkSuQmCC'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Instruction formats\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/211a92ffee7974633687bc226729170a/d8e13/instruction-formats.png\\\"\\n        srcset=\\\"/hows-that-again/static/211a92ffee7974633687bc226729170a/c05a3/instruction-formats.png 163w,\\n/hows-that-again/static/211a92ffee7974633687bc226729170a/c0194/instruction-formats.png 325w,\\n/hows-that-again/static/211a92ffee7974633687bc226729170a/d8e13/instruction-formats.png 617w\\\"\\n        sizes=\\\"(max-width: 617px) 100vw, 617px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p><strong>а</strong>. арифметические инструкции, <code>rs</code> и <code>rt</code> - источники, <code>rd</code> - регистр, куда кладем результат. <code>shamt</code> не используем, а операция АЛУ задается совокупностью полей <code>op</code> (31:26) и <code>funct</code>.</p>\\n<p><strong>b</strong>. Операции с памятью. <code>rs</code> - регистр, в котором записан сдвиг, который будет добавлен к адресу памяти. <code>rt</code> - регистр, из которого читаем или в который пишем данные.</p>\\n<p><strong>c</strong>. Операции бранчинга. <code>rs</code> и <code>rt</code> - сравниваемые регистры. <code>address</code> - адрес перехода при равенстве этих регистров.</p>\\n<p>В операциях a и b различается поле, в котором записан регистр, куда нужно писать данные, поэтому перед записью в регистр нам понадобится еще один мультиплексор.</p>\\n<p>Добавим вышеописанную информацию о полях и новый мультиплексор на нашу схему:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/5ea329797dccb6d6df273b2e3ebee85b/65d77/mips-implementation3.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 61.474269819193324%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAAB5UlEQVQoz2VT53KjMBjk/d/u8sczcYnpGEwvonpvVw6OL6cZIRBi2/fhdF0HYwx6rn3fYxxH+/x7av+fyb26N4irFo9tg8bj8YCjw+u6YhgGlEWBiYc3HtDe+6r3Im/b1q7LsqDtevhR/D/g+K0gTVNUVYVpmn6UcS7TiLZpeD9a4Px+R8azeZ4j8P0X2AtwnucXwO8h7m593tdVDdd1UZYlkjhGR7XrMr8BAk5D5qqsLLNsSJ0sdbQj+2lZI24NBpLlWUagyArYycz2BOPV7jnKzSPr+XRCwXsxe54Hn1Zk6XI+o8zviMKQRRjQmskSKTezbMjMCrNuaOli3mhZocuqwo7CCNfrFXVdIwxCHD8/7XNRlIijCG58Q1xUSG8JThRwp+L8TtW3FFHNDlkJuGd1uVzw8ecDvufbwJMkweFwwPXraqsvgtPxaJWqcHIiEYaFkrMzyVVA5+kfNhdZUS9qdMwmKhokVBZxxgQQaNfUaOhAYFIdk8C1rhrr1NkrtA/lJnVpSjt5YdUFQUCwgNUtkLYDMkYgNV+uZ2NQu+0FfSncV71QT65cBabWCPyAWeW2F+OahRlGe3biJxkv6irVQt857z33rtTaJlhISzcqVk5qpxtbyMwLNgII5KE/iVPqBPgXFW+a+BmiSLQAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"MIPS implementation 3\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/5ea329797dccb6d6df273b2e3ebee85b/10273/mips-implementation3.png\\\"\\n        srcset=\\\"/hows-that-again/static/5ea329797dccb6d6df273b2e3ebee85b/9b14a/mips-implementation3.png 163w,\\n/hows-that-again/static/5ea329797dccb6d6df273b2e3ebee85b/94962/mips-implementation3.png 325w,\\n/hows-that-again/static/5ea329797dccb6d6df273b2e3ebee85b/10273/mips-implementation3.png 650w,\\n/hows-that-again/static/5ea329797dccb6d6df273b2e3ebee85b/65d77/mips-implementation3.png 719w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Новые управляющие сигналы:</p>\\n<ul>\\n<li><strong>ALUOp</strong> - 2-битовый управляющий сигнал, который переводит АЛУ в один из трех режимов - сложение, вычитание, или использование инструкции, указанной в поле <code>funct</code>.</li>\\n<li><strong>RegDst</strong> - определяет, брать регистр назначения из <code>rt</code> или <code>rd</code>.</li>\\n</ul>\\n<p>Итак, у нас есть 9 управляющих сигналов (для <code>ALUOp</code> используются два). Все, кроме <code>PCSrc</code> могут быть установлены в заисимости от <code>opcode</code>. Для определения <code>PCSrc</code> нужно еще знать результат сравнения регистров.</p>\\n<p>В результате наш контроллер принимает на вход 6 бит <code>opcode</code> и имеет 9 выходов. На рисунке изображена наша схема с добавлением контроллера:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/b80f11d0941cd35ba57f3e7c7b4e4f67/942d5/datapath-with-controller.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 77.42857142857143%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACi0lEQVQ4y2VT2ZKbQAz0/39L3vIXyUuyteuyd2ExBgPmGIZruOm0hjjl2lClmgGJltRqHfq+xzRN6LoOZVnaO7YN27paW+Xk+zAMaJrGxjV1bePk3yRJYIyBPBJ3kI8SPI4j7nSWukLXD2hNb038I/1t29ofB8ZprZFnGeqqQhgEmOf5f8BWsvPeLcCw7ib3mrHLZuPRs7qrf4HKc0RRhLRQqM2wO7EH/QOUNudtB3pkm9cNPlF/FDPKacP1nuPkh0iqFsW44dZvUGRo/Ru7PFe4LDMEK8oKRGGIMIpxqwyO9Yrv0Yjf5Yy47lExSBE8H1dcmUzxfJjm98ODP6lQAMvW2PLlLq16ZsO3cMKxmnHKW7Rsw9AamoB0PO3QGFwLoBAs1gvh84IkVzuf5KvuenxmGmdlUJkRH3ljeYVNRuBlN0ksgJUAZmmKi3eB8/4OXTc4uR78C833oZTCp+NAF5lVgHMvUNTtnnzZKzXzioX8kVIOkIDSrvCoqcFrGMH1A3Rtg5hT9DwPLgEzSiSOE5yjDGXT2UROGCNO+c7uYvKt+V2PCw5Svoj3+PaGXy+vcAgo1QiI637ifDpbSoIgxM+TC891UVYNbkwoWpSCsiyH+/GBgAM9CKFiUmU/jEgZ3DBTM61IdW3Bb5x6QHvxQnS6RNpy2v2IhKDiF3oEPKWcLODzo4rCOmUN5V5QxHHM9oTDhL5+gVONaLhNSXSjvBImu5GmFoqDOzxE/ACWSmVn5SwIWHEVL+QyzwuEuoWjB/hm34ttWzmclVJaUQ8TFFVxeK7ua7UiHVGBtKVYcaD5biZuk4XDc/SyLNz5J8AH2Ndq0/sdKUHzLMXxluEtIg2qtKoon0y66TqDP9rzf7i2saMEAAAAAElFTkSuQmCC'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Datapath with controller\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/b80f11d0941cd35ba57f3e7c7b4e4f67/10273/datapath-with-controller.png\\\"\\n        srcset=\\\"/hows-that-again/static/b80f11d0941cd35ba57f3e7c7b4e4f67/9b14a/datapath-with-controller.png 163w,\\n/hows-that-again/static/b80f11d0941cd35ba57f3e7c7b4e4f67/94962/datapath-with-controller.png 325w,\\n/hows-that-again/static/b80f11d0941cd35ba57f3e7c7b4e4f67/10273/datapath-with-controller.png 650w,\\n/hows-that-again/static/b80f11d0941cd35ba57f3e7c7b4e4f67/942d5/datapath-with-controller.png 700w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>На этой таблице видим таблицу истинности для контроллера:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/e72a78bf2d710d890e40834473eeed94/7c90c/controller-truth-table.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 19.006211180124225%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsSAAALEgHS3X78AAAA0UlEQVQY00WMu27CQBBF/Y9pSKBzHQlFaRBBFEhRgBT5rMQIkG34BQrbOzt+rZs4l9nBCsXR2bkzd4OHH4fxzmGya9Wep8gh3Du8JB3Cg8NU7HmOO7ym3f/dWDqjqNXuY3S7D96+L1jsc6xixja1WBwJ68RidiB8DPNGvE5kFj5TwlKy95hkZ7E5Mebekn+dGUFvM6AmoDL4Kwt5G32rGwtI9mtzIdO9t88U31MMes7RSxZwVaNqWhjLSkF2gEFcIjd0R3Jvv9fboUNc6R9l3eAKiMEZDIOX1IwAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Controller truth table\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/e72a78bf2d710d890e40834473eeed94/10273/controller-truth-table.png\\\"\\n        srcset=\\\"/hows-that-again/static/e72a78bf2d710d890e40834473eeed94/9b14a/controller-truth-table.png 163w,\\n/hows-that-again/static/e72a78bf2d710d890e40834473eeed94/94962/controller-truth-table.png 325w,\\n/hows-that-again/static/e72a78bf2d710d890e40834473eeed94/10273/controller-truth-table.png 650w,\\n/hows-that-again/static/e72a78bf2d710d890e40834473eeed94/7c90c/controller-truth-table.png 805w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Пример работы процессора для операции <code>add $t1, $t2, $t3</code>. Жирным выделены активные соединения и элементы. Вся операция выполняется за 1 такт.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/aed65898b2520049af5d224a83f396eb/04c80/datapath-add-example.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 75.87168758716875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACfElEQVQ4y2VTy5KbMBD0//9NbvmDXHJLtmyvN2SxwbxsQCAQCIlOj7C3ditUtSXr0TM9Pdr1fY9xHNF1XRinaYIx5j/I+hMfa8QwDPDeQ751XbGTDWttIBTIXA4454ht9H7FyItyWYIaQs41TYPb7fY/oUSVw1VZQjPjeZ5D9JnrT4gSIZE9mcu9W1WiLIoPsi+EnVKY7ALtAOM3dMuGLT4w6h6aKiYpUa+hxgl2cY/dNfx+EJIelmvGSSQPS7kT5y/K4VfrMFiPvOlQdgPU7FBMKy7jioFnLEsyE/5zhp61ko0kL5GlCc7XHMVg8eO+4NvVYq8sinFBZYFy8sjMBsUs6nlFy1ESCIRSlyBppuTZhrkIoVr8VCu+Fw7x4HDu55DJzIvKbmSShMjVyxrU7eq6ZnFvdJE1GUYU9waD1gEt/5/yO/J+Qq0NLto+yrURTeK+26T2DBAIq6pCFEU4xzFuTYvDW4TkckGSJCiKHH9Or6jLAnGa4aIMHdaYqEIvJHhACLXf6r+TPhuYSdvUOJzeECdXZteHdjgeDojPZ7Rtg3cSHq8VFHsvyQq8ndPQk5pKpI3qftgIRYGYctzv8Xt/RETCglmneYHD6wnx+ztLUuEv11+iGGVOs2oVAkpDS2+qtsWRZ0X+7tmQAkNzOjNDKkUjcW8VpCR5dkVS3pCSyNuZbjsoeVns3YYetETNcg3WbRkKmXwSsWLkPMvCq5HMRJJcFElJZxCx8y90XJ6i4nrVdmi6ngYa6M+En0m39+shHSD17VQbMk9bkho6+nwc/GYqEUVqNOHVfMnwOT6/Vgyg21ma4sKGj2uaNcxYWDf7gMzdsoS2897hH9kZhYbQYOEeAAAAAElFTkSuQmCC'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Datapath add example\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/aed65898b2520049af5d224a83f396eb/10273/datapath-add-example.png\\\"\\n        srcset=\\\"/hows-that-again/static/aed65898b2520049af5d224a83f396eb/9b14a/datapath-add-example.png 163w,\\n/hows-that-again/static/aed65898b2520049af5d224a83f396eb/94962/datapath-add-example.png 325w,\\n/hows-that-again/static/aed65898b2520049af5d224a83f396eb/10273/datapath-add-example.png 650w,\\n/hows-that-again/static/aed65898b2520049af5d224a83f396eb/04c80/datapath-add-example.png 717w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>А здесь - пример для инструкции <code>lw $t1, offset($t2)</code>:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/5df023df91dbd0267df49a1df77f6a3a/99256/datapath-lw-example.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 76.33802816901408%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACfUlEQVQ4y2VUi27bMAzM/3/NsO8YsALb+liaLnFsJ35bliVLft2OctJ2mAFGNE0eeSSVndYa1lp0XRdO5xyGYfhPxP4uw4ePMQbTNEGedV2xE+M4jgFQRHT5sCxLkHlewvvAZBIsSUXET6kOeZ7/DyhZxUk+aoJ670N2T3sQ7yBMXNA9dN+HBG3TIE3Td7B/ADul4MYJ/QwMyyaaesfk8xpiAogWPzl1j86S+rhVR8jw+w5IeIy0DRItOqk66k/djO8NE00LLq3GldK4CblbcbYr9LRiWlZ4yvK5wmWeMbKq+JrjmiaI0iuuvce3ZsbXdMSTmlDYCfUIVH5BRgqJXaAYVPO9YTV2vgFKXwIllq/dppMtiI8HteBLMuJVT4i0D1ULCwFSBHGhHyvMdANs6hpVVcEa9sRYZFUDw6aLtL3Fy6VErAZUZgiA6zYBstnABEioSkuMAMpkD4cDTscjykbh5fAHyfmMOI5RM5HoXV3hlFwQtRa9TJgsBEj65pZtJGS/VSg7JPvVqRZ7gh3jFJZBsg5vTJTnRViptKzxljdhG6607aMEDdemLMsgNaduWOVO0GUoz4+PePjxE0lB+uxrw8Dnl9/Y7/fodUd7jV+HYxhYQSZZloXeSzGyj6/0a7lGu/tCypQtr1RDo4xF9lBaULAllyTBkVM/JBkWPyDntA19hX4cRfTJwuK31n8Ahl7zqpVFjjy7oioK6kW4PRIUXXi2BGCmyMxbH1ldpTSU0GUCNYwb5c+gI1dHqGx3VYXM59MJVWdQGI+TYVJ/uzp8uILgjkORmfU3wPtzB70/Ahb+hUit7HrkvUPteAGmObRonrdTmDn2fWIRfwHdG4Wt4TfBGQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Datapath load example\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/5df023df91dbd0267df49a1df77f6a3a/10273/datapath-lw-example.png\\\"\\n        srcset=\\\"/hows-that-again/static/5df023df91dbd0267df49a1df77f6a3a/9b14a/datapath-lw-example.png 163w,\\n/hows-that-again/static/5df023df91dbd0267df49a1df77f6a3a/94962/datapath-lw-example.png 325w,\\n/hows-that-again/static/5df023df91dbd0267df49a1df77f6a3a/10273/datapath-lw-example.png 650w,\\n/hows-that-again/static/5df023df91dbd0267df49a1df77f6a3a/99256/datapath-lw-example.png 710w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>И напоследок - пример для инструкции бранчинга <code>beq $t1, $t2, offset</code>:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/910d3d795400851d1203009c545579e9/165d7/datapath-beq-example.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 78.22349570200574%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsSAAALEgHS3X78AAACoUlEQVQ4y11U2W7bMBDU//9KH/sTBfrSFEXSJnFsWT50UhdJidQxnaWjIA6BBUlxOTu7O1TU9z3GYYC1Ntjwvh7e95+/j+MYfGWW/WZyvq4rZETyYZomtG0LAfdcy+GyLLTbLPt5nqF5bo2F1jqAeu9R1zXaprkHFBOnLMvQ0sEFBvbGZrAf53LZOQelVDBhdjwcwlqGgAZAcWroPBBITyuGGcEszcz4GHJBggrw5XxGlqZQbc8M53tAoS+pTUzRLO+XaY7r67DgTzuBcdB3HR4fnwKgcR7VOKPyuBsfgPM8BZCCEVVZoCgrVNoitiu+Xxx+qhmHxiId1xDkQnvTC1LONSMrWseokYBJyguLLgxT1cCyXm3Xo7IOO7Pi24mA9YynykCNbKBf0fgFGcEaLyVaWZ41fI+ks8aYQHf0ExRZyZASeAa4mgk/SoeSqb0qw0u3mvA+DBm55WZSP9lH6fWKt90OxzhGpw1e4gSnJMGZRZfuvfIso0+R53hJK3SDw8SM1nUJzCSonSgxBpCGRiKHsiyRs3vXNMO/fYyyKAJgyi7u9/vQzSwv8PdSoOw0NJuTdRZlb+GoRTs6ZuepCAKGVFlHYfjr4Td2x1NgoHV/A2Ig0dvlmuLhNcYxOaGqKlzSnLMK4hZS8jByNjIAyiuQ1M+XK5KyQS+FH33oeE62wngDTI4xWpamMmymvDLelYDyitIsR7Q9mW1oNsjx+XmKdaTWRFaBKUEPRR0a17oZuWGKTF2pOjA2zMjzLNoUvpmIVtgKK0XHivV9eX5GfEwQk32iJzx2S5DISu1K/URePTNqB38D3EC/DqmtSErSEQUUxqET/Y33vuv2sj4z/MpURvgLNS0a/k06pndQGvt2hCKjefJ8EB6eDfTeheYIgf+pOdJOvQ1roQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Datapath branching example\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/910d3d795400851d1203009c545579e9/10273/datapath-beq-example.png\\\"\\n        srcset=\\\"/hows-that-again/static/910d3d795400851d1203009c545579e9/9b14a/datapath-beq-example.png 163w,\\n/hows-that-again/static/910d3d795400851d1203009c545579e9/94962/datapath-beq-example.png 325w,\\n/hows-that-again/static/910d3d795400851d1203009c545579e9/10273/datapath-beq-example.png 650w,\\n/hows-that-again/static/910d3d795400851d1203009c545579e9/165d7/datapath-beq-example.png 698w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<h2>Почему однотактовые реализации больше не используются</h2>\\n<p>Наша реализация выполняет всю инструкцию за 1 такт. Тем не менее, такие реализации на данный момент не используются потому что тогда длина такта будет одинакова для всех возможных инструкций, а значит - будет равна длине самой медленной инструкции. Это наверняка будет инструкция загрузки из памяти, так как она последовательно задействует целых 5 элементов: блок инструкций, блок регистров, АЛУ, блок памяти и опять блок регистров, но уже для записи.</p>\\n<p>Такая реализация может быть приемлема для архитектур с небольшим количеством простых инструкций, так как тогда расхождение между самой быстрой и самой медленной поерацией не очень велико, однако если бы мы добавили операции с плавающей точкой, то такой вариант работал бы совсем плохо.</p>\\n<h2>Проектирование набора инструкций для пайплайнинга</h2>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/eaee3245f1b2deee1886e48e24f4d489/4b367/mips-pipeline.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 37.79385171790235%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABE0lEQVQoz32RiY6CQAxA+f9f4w8UVgHlPkUuOeq8ZtmoMTtJ02mnx2vHchxH6rqWbdtkWRZ5PB5yu91Ut20r0zT9afzjOH7V5K7rKpZt25LnuSRJIsMwqKTm3nWdpGkq9/v9TVM8iiItEsexamzygLBiYxCIs+97FTrN86wBu0CCj0n+O1ZVVYJcr1e5XC5yOBykaRopikIJIIPe8zxtCiGHwt/EIjgzhBRD2Knv+3I8HnUVURiqnynwn89ntT8L73cLEhIhhIblQwIpvtPpJGVZSm2moDnCe2ga8ZnE78V0ZMajG4XZEYcPybJMC0LMWxAESriT/riuuEaw3wg/l/q6dAii309jnzSBjIlebT5xz30C3AxjPnDAMQAAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"MIPS pipeline\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/eaee3245f1b2deee1886e48e24f4d489/10273/mips-pipeline.png\\\"\\n        srcset=\\\"/hows-that-again/static/eaee3245f1b2deee1886e48e24f4d489/9b14a/mips-pipeline.png 163w,\\n/hows-that-again/static/eaee3245f1b2deee1886e48e24f4d489/94962/mips-pipeline.png 325w,\\n/hows-that-again/static/eaee3245f1b2deee1886e48e24f4d489/10273/mips-pipeline.png 650w,\\n/hows-that-again/static/eaee3245f1b2deee1886e48e24f4d489/2fc6f/mips-pipeline.png 975w,\\n/hows-that-again/static/eaee3245f1b2deee1886e48e24f4d489/4b367/mips-pipeline.png 1106w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>В MIPS инструкции были спроектированы для пайплайна, этому способствуют следующие свойства:</p>\\n<ol>\\n<li>Все инструкции имеют одинаковую длину. </li>\\n<li>Поле регистра-источника всегда находится в одном и том же месте. Благодаря этому, пока первый шаг определяет тип инструкции, второй шаг может уже начать читать значение регистра. Если бы это свойство не соблюдалось, пришлось бы разбить шаг 2 на 2 шага.</li>\\n<li>Адреса памяти используются только для операций чтения и записи. Благодаря этому мы можем на 4 шаге вычислять адрес памяти и обращаться по этому адресу на шаге 5. Если бы мы могли бы совершать арифметические действия над данными из памяти, то после 4 шага пришлось бы вставить еще один АЛУ.</li>\\n<li>Все операнды выровнены в памяти.</li>\\n</ol>\\n<h2>Риски пайплайна</h2>\\n<p>Риски - это ситуации, в которых следующая инструкция не может быть выполнена в следующем такте. Есть 3 разных типа:</p>\\n<h3>Структурные риски</h3>\\n<p>Возникают когда аппаратная часть не поддерживает запрашиваемую комбинацию инструкций, которую мы хотим выполнить в одном такте. В MIPS таких рисков нет, так как набор инструкций был тщательно спроектирован для пайплайнинга. Например, если инструкции и данные хранятся в одной памяти, то 1 и 4 шаг нашего пайплайна не может быть выполнен одновременно, так как и там и там происходит чтение из одной памяти.</p>\\n<h3>Риски данных</h3>\\n<p>Возникает когда данные, необходимые для выполнения шага, еще не доступны</p>\\n<p>Пример:</p>\\n<pre><code>add $s0 $t0 $t1\\nsub $t2 $s0 $t3\\n</code></pre>\\n<p>Здесь вторая инструкция ожидает результата выполнения первой. Если не вмешаться, то пайплайн не сработает. Первая инструкция пишет результат только на 5-м шаге, значит второй инструкции придется 3 такта ждать впустую. </p>\\n<p>Компилятор может переупорядочивать местами команды чтобы избежать этого, но это помогает не всегда.</p>\\n<p>Типичное решение - не ждать полного выполнения 1-й инструкции, а сразу подать во 2-ю результат сложения, минуя память.</p>\\n<p>Однако такое решение помогает не всегда. Если бы первой инструкцией была <code>lw</code>, результат был бы доступен только после 4 шага, что уже слишком поздно. Тогда все равно пришлось бы ждать 1 такт впустую и только после него подать выход с 4 шага 1-й инструкции на 3-й шаг 2-й.</p>\\n<h3>Риски управления</h3>\\n<p>Возникает, когда прочитана не та инструкция, которая нужна. Например, в инструкциях ветвления адрес следующей инструкции выясняется только на последнем шаге, а следующая инструкция к этому момент уже прочитала неверный адрес.</p>\\n<p>Одно из решений - остановить пайплайн сразу, как только прочитали инструкция бранчинга до тех пор, пока не станет известен следующий адрес.</p>\\n<p>Но обычно используется <em>branch prediction</em>: попытаться предсказать, какой бранч будет выбран и начать загружать его. Если окажется, что выбран не он, то загрузку этого отбрасываем и считаем заново правильный.</p>\\n<p>Очень популярный подход для предсказания бранчей - для каждого бранча помнить, был ли он в прошлый раз выбран или нет, и предсказывать что в следующий раз будет так же. Это хорошо работает для циклов.</p>\\n<p>Еще один вариант решения - <em>отложенное выполнение</em>: переупорядочить инструкции так, чтобы пока не станет известен адрес бранча для перехода, выполнялись другие инструкции, не зависящие от этого.</p>\\n<h2>Pipelined datapath</h2>\\n<p>На схеме изображена наша однотактовая схема процессора, на которой выделены шаги пайплайна:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/41f47af6c90e30f3960019492f4073df/eb88f/pipelined-datapath.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 70.27379400260756%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAAB6klEQVQ4y3VTiXKrMAzk/z+ynUnK0RAwhy/AoLcrcJPO9HnQYIO8Wq3XxXEcwrFtm0zTpMF5CEGqspKmaSTGKM45Kb++ZBxH8d7LYIzmLsuiueMwaF4hf4yUkrDQvu/65prBNYMF88jf8ih82qW3QQYXxCC6yWr4bZeIPMYcVwnp0HlATFg7/PfpLJYLsHhhlySz87qYZysj2mjbp7aiyYiI+UoZ0FKWBxsuwF3zfgDdmsSHM5E6zPMMwFZ1oiYMa63+67pOzDgpQ3Zgt5ccfwJSXAK8a8KxrqseDotZHM4Chgmbj0vDXy07VHmaUYwZEEZBGc46ZUWm7eMhA+YTTnhF+xsKJICw0DsBBVxQxlgvZd1IjYi0ADZ+g9H9fle7sNVsF8pB+3TPTsHImgRy22qb480efd/L58eHgtd1rayqqpLb7SZPHBb1JFuyG9AVc2YcZPNoBc1KcVxaqP8AbFGxA2g7zgrOIjRxWZYKtIAVpenBmuwWAOueYVJbFbn3d+CwrNLPTjezXQKzrZybbxSDUpAh2UXY6Afw/U3A0UcJ3kmDlowyfd2OdPlQbwpvEP79AswjA9LENG3EkjfE0lrpNDLXvDnnXIS2s8smDut1/w8gfaV3VKU4C+xIxvNaXxLxpmxbOuXCt387kUPuh4dhEQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Pipelined datapath\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/41f47af6c90e30f3960019492f4073df/10273/pipelined-datapath.png\\\"\\n        srcset=\\\"/hows-that-again/static/41f47af6c90e30f3960019492f4073df/9b14a/pipelined-datapath.png 163w,\\n/hows-that-again/static/41f47af6c90e30f3960019492f4073df/94962/pipelined-datapath.png 325w,\\n/hows-that-again/static/41f47af6c90e30f3960019492f4073df/10273/pipelined-datapath.png 650w,\\n/hows-that-again/static/41f47af6c90e30f3960019492f4073df/eb88f/pipelined-datapath.png 767w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Данные всегда идут слева направо, кроме 2 исключений:</p>\\n<ul>\\n<li>write-back, где данные из памяти идут в регистр</li>\\n<li>выбор следующего значения PC</li>\\n</ul>\\n<p>Но эти исключения не мешают выполнению текущей инструкции - они влияют только на последующие инструкции в пайплайне.</p>\\n<p>При этом первое исключение может привести к рискам данных, а второе - к рискам управления.</p>\\n<p>Чтобы каждый из шагов выполнялся в отдельном такте, между ними нужно поместить специальные пайплайн-регистры, которые будут хранить результат выполнения предыдущего шага для передачи его в следующий. При этом, если из шага выходит несколько значений, то и регистр должен быть достаточно большим, чтобы все их вместить.</p>\\n<p>Например, на следующей схеме регистр <code>IF/ID</code> должен быть 64-битным, чтобы вместить 2 выхода из шага <code>IF</code>. Остальные регистры содержат 128, 97 и 64 бита соответственно.</p>\\n<p>Чтение из таких регистров производится в начале такта, а запись - в конце, поэтому конфликта не происходит. </p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/32f40166d3a680afb61cb90a2be93144/3e276/pipelined-datapath2.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 47.19800747198008%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABqElEQVQozz1Si27bMAz0///WhmZJt3XAugHdmraZE8eWZEuW/JBsyTdKdkKAEEHQd8ejMykljDEpu+3t+z6lcw7OWlhKTX271eM4QimVZmJ47zFQL0bWqjYVcbDrOoydwVl1eJPr8LIscLPHM9PwVMcIlL8YEY82TkA7j5+lWgGjohtg27YYjMZRaPzm1J+npDJ++Pm9wrWqwCiV1ni8KJh+SIDKBTxVJtVZXddJWQT2PiTws7b4I4e7Qk/CDnkNUTewtNpEKz5VGnNYFetpwY9qFZY1TYNrUYAxBk3MbujxITvsjxfwa5GIKi6w/yegiTgCSrJpTwRR4UJbMD3ge7lal4WwqprnmQbJaN0mwN3rGfn7WyJhpOzTscD5UkBwDi4EHsgC0cgkIOcSX04cSnBk2GKaJso5MV6Mw9dTCaPk3cOoMAKOw4CRersTQ1FWCZDpHrsPhrapkUWPlu1624OcPPyWc/ofZnBSVDKOw1nCumklp6sf6ChR4TT2KKRJR/LOroA382816yxeOXkS/F3hC49HCIl1puO9CIOwbddNAX/rjsBH/AeN/rKBuZCMTQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Pipelined datapath 2\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/32f40166d3a680afb61cb90a2be93144/10273/pipelined-datapath2.png\\\"\\n        srcset=\\\"/hows-that-again/static/32f40166d3a680afb61cb90a2be93144/9b14a/pipelined-datapath2.png 163w,\\n/hows-that-again/static/32f40166d3a680afb61cb90a2be93144/94962/pipelined-datapath2.png 325w,\\n/hows-that-again/static/32f40166d3a680afb61cb90a2be93144/10273/pipelined-datapath2.png 650w,\\n/hows-that-again/static/32f40166d3a680afb61cb90a2be93144/3e276/pipelined-datapath2.png 803w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<h2>Forwarding unit</h2>\\n<p>Форвардинг - направление результата работы АЛУ на текущей инструкции сразу на вход АЛУ следующей, чтобы следующая не дожидалась пока текущая завершится и запишет свой результат в регистр.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/88573e5fa0145476d231895dfb49207d/afeef/pipeline-forwarding.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 630px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 128.41269841269843%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAAsSAAALEgHS3X78AAADG0lEQVRIx22Vi27iQAxF+f/P27YrdVVUnnlDHpCQAMHrY+I0UEaykpl47lzb15OZTMb1epXdbieXy8Xmt9vNjMFaEidSleWDfxLHtsf9ZyyeTiezrutkl2Uj4PNhaZrKoarGzYw0SaTIix/AMAjNmVEUhRyPR6l0Ewcwr+t6BOXAKXsGfufz+Qew1BCiMJRYqR8Oh5EpA8f9fm+gvHMY1jTNCMS8bdsfQGdSFqUAzmY2wIRnQkj6nXc2x1Fkfn4gJLq2G6OYkVBCxggVB0Br3Qy7kwJNQ+Z7vs/l78eHZJpvjyDUKPeKNWMCG88PTPq+t3cPh29Egm+mhcnSOxAF8v1hEMhms7kDTitpDhoK+QDIzQGRCaDMkVA5GGmB/QgIAIDNUIBXw+XFd5if9SDAiIRBdA8MAWXRZfQK8Pkw/H0NrBmFqAc5QNkr2g5splYOOvVvsIQh+3gfQw40ocE2MC16QTgV83eefIO9zV+s8Zw9h+Wifh5WJGUxbUvWXAWjDq266uSnbLX0hAMDnj4AWi6X1us+YMcaGhw7hZxxgrcRKeC5Wq3ke/4ll6613Dmb81MEVpRu0ssRrTQkO8/zoW87iaJYtqmK99xLqYVjI5LicJidB63eizTpZRwJk8LQzy7YOEklbW8SKKGDAuFDRRF2rl3CoNoA/uplv0hdAqTh3+enbNcrabqLReAyKTQKbP71Zb3PHidhwgZgVP7w5ORPBUyiUNK8tBuHUEkHRWHOlcc7lyv+i+9vK9CvXjYmakG2l/DUS971VnFOr4/3Xvbryw/hG5cFqfjVy8yhn2k+E81h1PYPGi0nFwK3zf0uLUxWkHkAxPhvvL+/y1JDyOJICq3yrb+aVpuhOJv1xjpru91a+LQue62Xp4DIgZySv7c/b3a/baqTRGVtlunF6sL3a+2o/hSH3J+aFwwZ5GI+n0uuCgh3uaybXtYqtbg8SKTyWq/XynBrDB3sPOR55neZA/oV5j+tQ1XKvjrK7lDfJaVVRXd+aThTogPL/nqLxcLyQrtVw4/K/y930MqMNTbxn2kGOw3GHlLxH1Va3ctF5fktAAAAAElFTkSuQmCC'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Pipeline forwarding\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/88573e5fa0145476d231895dfb49207d/afeef/pipeline-forwarding.png\\\"\\n        srcset=\\\"/hows-that-again/static/88573e5fa0145476d231895dfb49207d/4715b/pipeline-forwarding.png 163w,\\n/hows-that-again/static/88573e5fa0145476d231895dfb49207d/503c4/pipeline-forwarding.png 325w,\\n/hows-that-again/static/88573e5fa0145476d231895dfb49207d/afeef/pipeline-forwarding.png 630w\\\"\\n        sizes=\\\"(max-width: 630px) 100vw, 630px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Здесь наверху - обычная схема, снизу - схема с добавленной функциональностью форвардинга. </p>\\n<p><code>Forwarding unit</code> - смотрит, совпадает ли регистр, куда пишется результат АЛУ на текущей инструкции (<code>EX/MEM.RegisterRd</code>) с регистром, откуда берется операнд для АЛУ на следующей (<code>ID/EX.RegisterRs</code>) и если да, то активирует контрольную линию <code>ForwardA</code>, которая верхнему мультиплексору говорит брать то значение, которое приходит из регистра <code>EX/MEM</code>. </p>\\n<p>Аналогично обрабатываются 3 других случая:</p>\\n<pre><code>if (EX/MEM.RegWrite\\nand (EX/MEM.RegisterRd ≠ 0)\\nand (EX/MEM.RegisterRd = ID/EX.RegisterRs)) ForwardA = 10\\n\\nif (EX/MEM.RegWrite\\nand (EX/MEM.RegisterRd ≠ 0)\\nand (EX/MEM.RegisterRd = ID/EX.RegisterRt)) ForwardB = 10\\n\\nif (MEM/WB.RegWrite\\nand (MEM/WB.RegisterRd ≠ 0)\\nand ( MEM/WB.RegisterRd = ID/EX.RegisterRs)) ForwardA = 01\\n\\nif (MEM/WB.RegWrite\\nand (MEM/WB.RegisterRd ≠ 0)\\nand (MEM/WB.RegisterRd = ID/EX.RegisterRt)) ForwardB = 01\\n</code></pre>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/83946b40ecb23879a33ce4a1db031e52/3cece/forwarding-controls.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 611px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 31.914893617021278%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABaUlEQVQY0y2PzW7aUBCF/WJdVUlVddldWnVdqZH6InmmJiRIVWkIcE3xz7WxsWOD/42NwVl9vThZfDozZ+6MztVurCPfJgeunw58+dNypfj+1PH5d8vl/Z6L+4bLh3bQT+OGH7OOn/OOr2rn/ajhg5p9HLe8u2sGXxNuwFiYzJ0NE7lhrNuYUcrUi7nVJaN/LndKfwmb0VLy13CYWi4Pwhq8yTpmFmYs4hIrqdCiYIM0ViRxRJnusJY60canqyvkaolnmYRrB19aRP4aR/WelPiO5NlzByLfo9xtObUNWlGUlFVFvd+TFwWFou978rzA933CMKRS86qqqepX6jeKshy071/ojkeatkVzXZfp4yNnDYOA+WxGoDTPMizTxDSMASEExspgqevoQlf1CrFYYKo3vucRxzHd4YCWpRlb1ZRv6Z5VokwdO9fnQ1J9z7ZtoihSqXOSJGG33XLeS5OUNFUor1RpT6cT/wGuw6m1IBDRnAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Forwarding controls\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/83946b40ecb23879a33ce4a1db031e52/3cece/forwarding-controls.png\\\"\\n        srcset=\\\"/hows-that-again/static/83946b40ecb23879a33ce4a1db031e52/9adac/forwarding-controls.png 163w,\\n/hows-that-again/static/83946b40ecb23879a33ce4a1db031e52/90375/forwarding-controls.png 325w,\\n/hows-that-again/static/83946b40ecb23879a33ce4a1db031e52/3cece/forwarding-controls.png 611w\\\"\\n        sizes=\\\"(max-width: 611px) 100vw, 611px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<h2>Static Multiple Issue</h2>\\n<p>Компилятор упаковывает несколько разных инструкций в одну длинную инструкцию. За счет дублирования блоков процессор выполняет несколько инструкций за один такт.</p>\\n<h2>Dynamic Multiple Issue</h2>\\n<p>Тоже самое, что и Static, но инструкции объединяются не компилятором, а самим процессором во время выполнения. Так же такой подход называется <strong>суперскалярным</strong>.</p>\\n<p>Дублируются обычно блоки АЛУ и блоки регистров. Такой подход используется во всех современных архитектурах.</p>\\n<h2>Реальные архитектуры процессоров</h2>\\n<h3>ARM Cortex-A8</h3>\\n<p>Использует пайплайн из 14 шагов. Суперскаляр с 2 иструкциями за такт. Инструкции не перемешиваются, а выполняются ровно в том порядке, в котором приходят. Пайплайн состоит из 3 секций: получение инструкции, декодирование и выполнение. </p>\\n<p>На схеме ибозражен пайплайн процессора ARM A8:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/edf06e328c5ffc6600fd7e0c8f4d9475/72793/a8-pipeline.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 577px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 43.327556325823224%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABfElEQVQoz3VRaW+CQBDl//8sm9gPFsohh1wKRlFRDqUCXtN5U7FJk5JMZnbZfdcqx+OR2nNLdV3T5XKhqiyprioqikKq5Kp43XUdNU0j/Xw+yzwU1sC53++k0J/ver1S4Ps0n88pjiIKgkCIHo+HABeHg3QhYvKS6/DcO51OpAAdIH3XU9u2wpbnuajDIczYh4IkSSiOY+lz7ovFQnoUhrTZbKSU9XpNWZYJC+xADQjQh8Ia7Ljos/qIlQNYQNkJ3KxWK7KnU1KQlz+bEYABCgvIAnW73V4zSPVPnRzbkfMzzyOPCwSmYYhq13FIcV2XDF0nTdOEAUoQ9H6/l8eBZQDvdjuyLEvAkGvIlbBlqJ3yPvLGfwWy30Yj8hgYh6AQOeLVGwZHjrAMBzoTm4ZJ6odKqqpKBFD8Ph7LfYOVKrjwMZkIwBcrQ/hDdn3fv2YoxSXbtsWRZZpiN2RQTdV+Fd6fOQ15/fcBHK+43W5pk/28aM4xoC/TpfQ0TekbFOKfzXPITU0AAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"ARM A8 Pipeline\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/edf06e328c5ffc6600fd7e0c8f4d9475/72793/a8-pipeline.png\\\"\\n        srcset=\\\"/hows-that-again/static/edf06e328c5ffc6600fd7e0c8f4d9475/0e63c/a8-pipeline.png 163w,\\n/hows-that-again/static/edf06e328c5ffc6600fd7e0c8f4d9475/d1ac8/a8-pipeline.png 325w,\\n/hows-that-again/static/edf06e328c5ffc6600fd7e0c8f4d9475/72793/a8-pipeline.png 577w\\\"\\n        sizes=\\\"(max-width: 577px) 100vw, 577px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Первые 3 шага получают 2 инструкции за такт и поддерживают очередь из 12 заранее прочитанных инструкций. Для этого используется 2-уровневый бранч-предиктор, состощий из:</p>\\n<ul>\\n<li><strong>BTB: Branch target buffer</strong> на 512 записей, содержащий адреса используемых бранчей</li>\\n<li><strong>GHB: Global history buffer</strong> на 4096 записей, содержащий историю переходов по бранчам</li>\\n<li><strong>RS: Return stack</strong> на 8 записей, предскаывающий будущие возвраты из бранчей</li>\\n</ul>\\n<p>Если предсказание бранча ошиблось, то пайплайн очищается и мы получаем штраф на 13 тактов.</p>\\n<p>Затем блок из 5 шагов определяет, есть ли зависимости между инструкциями и в какой пайплайн последней секции нужно подать инструкцию.</p>\\n<p>Последние 6 шагов предоставляют один пайплайн для инструкций сохранения/загрузки и 2 пайплайна для арифметических операций.</p>\\n<h3>Intel Core i7 920</h3>\\n<p>Архитектура x86. Предоставляет сложный подход к пайплайнингу, использует 14-шаговый пайплайн,  мультискалярность, спекуляции, перемешивание инструкций. </p>\\n<p>Из-за очень сложного набора инструкций x86, Intel сначала преобразует их в так называемые <em>микрооперации</em>, похожие на операции, используемые в MIPS. Затем эти микрооперации используются сложным, спекуляционным пайплайном с динамическим расписанием, который может выполнять до 6 микроопераций за такт.</p>\\n<p><img src=\\\"core-i8-pipeline.png\\\" alt=\\\"Core i8 Pipeline\\\"></p>\\n<p>Внутренняя организация процессора называется его <strong>микроархитектурой</strong>.</p>\\n<p>Каждая инструкция x86 проходит через 7 этапов:</p>\\n<ol>\\n<li><strong>Instruction fetch</strong> - используется многоуровненый <em>branch target buffer</em> для достижения баланса между скоростью и точностью предсказаний. Ошибочное предсказание влечет штраф на 15 тактов. В результате получаем пакет инструкций длиной 16 байт.</li>\\n<li><strong>Predecode</strong> - полученные 16 байт кладутся в <em>predecode instruction buffer</em> и на этом этапе преобразуются в индивидуальные инструкции x86. Это нетривиальный шаг, так как инструкции x86 имеют длину от 1 до 15 байт. Полученные инструкции кладутся в 18-элементную очередь инструкций.</li>\\n<li><strong>Micro-op decode</strong> - инструкции x86 транслируются в <em>микрооперации</em>. 3 из 4 декодеров работают с инструкциями, которые напрямую транслируются в 1 микрооперацию. Декодер для сложных инструкций транслирует инструкцию в последовательность микроопераций. Он производит до 4 микроопераций за такт и продолжает работать в следующих тактах, пока не сгенерирует всю нужную последовательность. Микрооперации помещаются в 28-элементный буфер микроопераций.</li>\\n<li><strong>Loop stream detection</strong> - если есть последовательность инструкций (меньше чем 28 штук или 256 байт в длину), которые образуют петлю, то на этом этапе они обнаруживаются и дальше микрооперации будут подаваться напрямую из буфера микроопераций, чтобы не выполнять впустую шаги 1-3</li>\\n<li><strong>Perform the basic instruction issue</strong> - регистр ищется в таблице регистров, переименовывается, выделяется место в <em>reorder buffer entry</em>, из <em>reorder buffer</em> и регистров получаются нужные значения прежде чем микрооперации отправятся в <em>reservation stations</em></li>\\n<li><strong>Reservation</strong> - 6 функциональных блоков поддерживают 36-элементную станцию резервации. На этом этапе микрооперации распределяются между ними. В каждый из блоков можно назначить до 6 микроопераций за такт.</li>\\n<li>Функциональные блоки выполняют микрооперации, результаты посылаются обратно на станцию резервации и в <em>register retirement unit</em>, откуда они запишутся в регистры, как только станет известно, что инструкция больше не спекулятивна. После этого инструкция в <em>reorder buffer</em> помечается как выполненная</li>\\n<li>Когда одна или несколько инструкций сверху <em>reorder buffer</em> помечаются как выполненные, ожидающие записи в <em>register retirement unit</em> выполняются, а инструкции удаляются из буфера.</li>\\n</ol>\\n<h2>Кэши процессора</h2>\\n<p>Кэши создаются основе статической памяти RAM или SRAM.</p>\\n<p>Кэш L1 - свой у каждого ядра. Самый быстрый и самый мелкий. Обычно процессоры имеют два кэша L1 - для инструкций и для данных.</p>\\n<p>Кэш L2 - разделятся между всеми ядрами и через него ядра могут обмениваться информацией. Некоторые процессоры дублируют данные из L1 в L2. Этот кеш медленнее, но больше, чем L1.</p>\\n<p>Кэш L3 - тоже разделяется между всеми ядрами, но использует более медленный и дешевый SRAM, чем L2, засчет чего размер L3 может быть сильно больше L2.</p>\\n<p>Процессор спроектирован так, что самые важные значения кладутся в более быстрый L2, а менее важные - в медленный L3.</p>\\n<p>При попытке чтения из кэша процессор сначала ищет его в L1, потом в L2, потом в L3, L4 и, когда кеши кончаются - в память.</p>\\n<p>Логически кэш-память представляет собой набор кэш-линий. Каждая кэш-линия хранит блок данных и дополнительную информацию. Под размером кэш-линии понимают размер блока данных. В архитектуре x86 размер кэш-линии составляет 64 байта. </p>\\n<p>Суть кэширования состоит в разбиении RAM на кэш-линии и отображении их на кэш-линии кэш-памяти. Возможно несколько вариантов такого отображения.</p>\\n<h3>Inclusive vs Exclusive</h3>\\n<p><strong>(В этом разделе под верхними уровнями подразумеваются более быстрые уровни, то есть L1 - выше, чем L2)</strong></p>\\n<p>Если все блоки верхнего уровня кэша присутствуют в блоке нижнего уровня, тогда нижний называется <strong>инклюзивным</strong>. Такие кэши используются в процессорах Intel.</p>\\n<p>Если же в нижнем уровне только те блоки, которых нет в верхнем - то он <strong>эксклюзивный</strong>. Такие кэши используются в процессорах AMD.</p>\\n<p>При чтении из инклюзивного кэша:</p>\\n<ul>\\n<li>если блок Х найден в L1, то читаем оттуда</li>\\n<li>если не найден в L1, но найден в L2, тогда копируем его в L1. </li>\\n<li>если же не найден ни L1 ни на L2, но найден в L3, то копируем его в L2 и L1. </li>\\n</ul>\\n<p>При переполнении одного из уровней <strong>удаляем</strong> один из старых блоков и шлет уровню <strong>выше</strong> команду удаления этого блока, чтобы не нарушить свойство инклюзивности.</p>\\n<p>При чтении из эксклюзивного кэша:</p>\\n<ul>\\n<li>если блок Х найден в L1, то читаем оттуда</li>\\n<li>если не найден в L1, то найден в L2, тогда <strong>перемещаем</strong> его из L2 в L1. </li>\\n<li>если не найден ни на одном из уровней, то берем из памяти и кладем в L1. </li>\\n</ul>\\n<p>При переполнении одного из уровней <strong>перемещаем</strong> один из старых блоков на уровень <strong>ниже</strong>, чтобы не нарушить свойство эксклюзивности.</p>\\n<p>Таким образом, низжие уровни кэша получают блоки только когда они вытесняются высшими уровнями, что делает низжие уровни эксклюзивных кэшей <strong>виктимными кэшами</strong>.</p>\\n<h3>Виды отображения</h3>\\n<h4>Direct Mapping</h4>\\n<p>RAM делится на сегменты, причем размер каждого сегмента равен размеру кэша, а каждый сегмент делится на блоки, причем размер каждого блока равен размеру кэш-линии.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/6dee6c84c45b72969524a7339f66296c/739ee/cpu-cache-direct-mapping.jpg\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 82.72604588394063%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMBBf/EABUBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAHsVlo2CSwirC5//8QAGhAAAQUBAAAAAAAAAAAAAAAAAQIQETFCMv/aAAgBAQABBQIdy2yqCK0qxX//xAAVEQEBAAAAAAAAAAAAAAAAAAAQQf/aAAgBAwEBPwEp/8QAFREBAQAAAAAAAAAAAAAAAAAAEEH/2gAIAQIBAT8BIf/EABUQAQEAAAAAAAAAAAAAAAAAACBB/9oACAEBAAY/AoIf/8QAHRAAAwACAgMAAAAAAAAAAAAAAAERITFRYXGhsf/aAAgBAQABPyFFUy85Gq5E6K1ZOtjoe7GqMR+JoP/aAAwDAQACAAMAAAAQ2ADA/8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQMBAT8QSEf/xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAgEBPxAjH//EAB0QAQACAgIDAAAAAAAAAAAAAAEAESExYXGBkaH/2gAIAQEAAT8QyYLOrekRpy4IZsvyRo07OIOSaXoYiFWl4m/tm/pPgJ//2Q=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Direct Mapping\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/6dee6c84c45b72969524a7339f66296c/b80fa/cpu-cache-direct-mapping.jpg\\\"\\n        srcset=\\\"/hows-that-again/static/6dee6c84c45b72969524a7339f66296c/cf410/cpu-cache-direct-mapping.jpg 163w,\\n/hows-that-again/static/6dee6c84c45b72969524a7339f66296c/62f2a/cpu-cache-direct-mapping.jpg 325w,\\n/hows-that-again/static/6dee6c84c45b72969524a7339f66296c/b80fa/cpu-cache-direct-mapping.jpg 650w,\\n/hows-that-again/static/6dee6c84c45b72969524a7339f66296c/739ee/cpu-cache-direct-mapping.jpg 741w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Адрес каждого байта представляет собой сумму порядкового номера сегмента, порядкового номера кэш-линии внутри сегмента и порядкового номера байта внутри кэш-линии. </p>\\n<p>Тэг кэш-линии хранит порядковый номер сегмента, то есть старшую часть адреса первого байта в данной кэш-линии.</p>\\n<p>Этапы поиска:</p>\\n<ol>\\n<li>извлекается средняя часть адреса, определяющая номер линии в кэше</li>\\n<li>тэг кэш-линии сравнивается со старшей частью адреса, то есть с номером сегмента</li>\\n<li>если совпадает, то внутри этой кэш-линии ищем байт с адресом, совпадающим с младшей частью искомого адреса.</li>\\n</ol>\\n<p>Этот вариант очень подвержен конфликтам, когда две строки соревнуются за одну ячейку, поочередно вытесняя друг друга из кэша.</p>\\n<h4>Fully associative mapping</h4>\\n<p>RAM делится на блоки, размер которых равен размеру кэш-линий. Каждый блок RAM может сохраняться в любой кэш-линии кэша.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/420ac154242ce109ed755b623b915d0e/db3c4/cpu-cache-fully-associative-mapping.jpg\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 88.62019914651495%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAASABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7WuQ2VFYIuD/xAAcEAABAwUAAAAAAAAAAAAAAAABAAJCEBEhMUH/2gAIAQEAAQUClSZdZDI64Ia//8QAFREBAQAAAAAAAAAAAAAAAAAAEAH/2gAIAQMBAT8BIf/EABURAQEAAAAAAAAAAAAAAAAAABAB/9oACAECAQE/ASn/xAAVEAEBAAAAAAAAAAAAAAAAAAAgMf/aAAgBAQAGPwIQ/wD/xAAbEAEAAgIDAAAAAAAAAAAAAAABABEhQRCBwf/aAAgBAQABPyFKt7y3oRFRbuPIlRDWApgmIn//2gAMAwEAAgADAAAAENAPw//EABcRAQADAAAAAAAAAAAAAAAAAAABEDH/2gAIAQMBAT8QrSX/xAAXEQEAAwAAAAAAAAAAAAAAAAAAARAx/9oACAECAQE/EKwh/8QAHRABAAICAgMAAAAAAAAAAAAAAQARITFBURBhkf/aAAgBAQABPxDUihPb55xEQszi9QcUdpKihYPF3FFQuM1EpZrkgBAB0T//2Q=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Fully Associative Mapping\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/420ac154242ce109ed755b623b915d0e/b80fa/cpu-cache-fully-associative-mapping.jpg\\\"\\n        srcset=\\\"/hows-that-again/static/420ac154242ce109ed755b623b915d0e/cf410/cpu-cache-fully-associative-mapping.jpg 163w,\\n/hows-that-again/static/420ac154242ce109ed755b623b915d0e/62f2a/cpu-cache-fully-associative-mapping.jpg 325w,\\n/hows-that-again/static/420ac154242ce109ed755b623b915d0e/b80fa/cpu-cache-fully-associative-mapping.jpg 650w,\\n/hows-that-again/static/420ac154242ce109ed755b623b915d0e/db3c4/cpu-cache-fully-associative-mapping.jpg 703w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Адрес каждого байта представляет собой сумму порядкового номера кэш-линии и порядкового номера байта внутри кэш-линии. Адреса байт различаются только старшими частями, поэтому в тэге каждой кэш-линии хранится старшая часть, то есть порядковый номер кэш-линии(блока) в RAM.</p>\\n<p>Этапы поиска:</p>\\n<ol>\\n<li>тэги всех кэш-линий сравниваются со старшей частью адреса одновременно</li>\\n<li>если было совпадение по одному из тэгов, то внутри этой кэш-линии ищем байт с адресом, совпадающим с младшей частью искомого адреса</li>\\n</ol>\\n<p>Этот вариант имеет гораздо меньше конфликтов, но сложен и дорог в реализации.</p>\\n<h4>Set associative mapping</h4>\\n<p>Когда говорят об N-ассоциативном кэше, то имеется в виду этот тип отображения с N каналами.</p>\\n<p>RAM делится так же, как и в прямом отображеии, а сам кэш состоит из k каналов, использующих прямое отображение. Кэш-линии, имеющие одинаковые номера во всех каналах, образуют <strong>сет</strong>.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/5b0d916a6d1b2d80f8a658a58676d1c4/c88de/cpu-cache-set-associative-mapping-set.jpg\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 31%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAMF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB2QUB/8QAGBAAAgMAAAAAAAAAAAAAAAAAAAECMUH/2gAIAQEAAQUCaZka/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGBAAAgMAAAAAAAAAAAAAAAAAAAEQESH/2gAIAQEABj8CelR//8QAGhABAAIDAQAAAAAAAAAAAAAAAQARMUFhcf/aAAgBAQABPyECtuwHM37AlGf/2gAMAwEAAgADAAAAEAPP/8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQMBAT8Qp//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAECAQE/EIf/xAAZEAEBAAMBAAAAAAAAAAAAAAABEQAhsTH/2gAIAQEAAT8QXClyPWJRtdNd9yrK13V7n//Z'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Set Associative Mapping (Set)\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/5b0d916a6d1b2d80f8a658a58676d1c4/b80fa/cpu-cache-set-associative-mapping-set.jpg\\\"\\n        srcset=\\\"/hows-that-again/static/5b0d916a6d1b2d80f8a658a58676d1c4/cf410/cpu-cache-set-associative-mapping-set.jpg 163w,\\n/hows-that-again/static/5b0d916a6d1b2d80f8a658a58676d1c4/62f2a/cpu-cache-set-associative-mapping-set.jpg 325w,\\n/hows-that-again/static/5b0d916a6d1b2d80f8a658a58676d1c4/b80fa/cpu-cache-set-associative-mapping-set.jpg 650w,\\n/hows-that-again/static/5b0d916a6d1b2d80f8a658a58676d1c4/c88de/cpu-cache-set-associative-mapping-set.jpg 800w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/4f85224c39f0c2674ca2b73e58b550a6/c88de/cpu-cache-set-associative-mapping.jpg\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 51.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIBBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe1VA0f/xAAXEAEBAQEAAAAAAAAAAAAAAAABABEg/9oACAEBAAEFAoSHeP/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABUQAQEAAAAAAAAAAAAAAAAAAAEg/9oACAEBAAY/Amv/xAAZEAEBAAMBAAAAAAAAAAAAAAABABExUSH/2gAIAQEAAT8hEPes2kQDJIcsHLV//9oADAMBAAIAAwAAABBkz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAQADAQADAAAAAAAAAAAAAAEAESExYXGR/9oACAEBAAE/EL8ExZYbML5NUV6liqU9yAaD5ABQAeJ//9k='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Set Associative Mapping\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/4f85224c39f0c2674ca2b73e58b550a6/b80fa/cpu-cache-set-associative-mapping.jpg\\\"\\n        srcset=\\\"/hows-that-again/static/4f85224c39f0c2674ca2b73e58b550a6/cf410/cpu-cache-set-associative-mapping.jpg 163w,\\n/hows-that-again/static/4f85224c39f0c2674ca2b73e58b550a6/62f2a/cpu-cache-set-associative-mapping.jpg 325w,\\n/hows-that-again/static/4f85224c39f0c2674ca2b73e58b550a6/b80fa/cpu-cache-set-associative-mapping.jpg 650w,\\n/hows-that-again/static/4f85224c39f0c2674ca2b73e58b550a6/c88de/cpu-cache-set-associative-mapping.jpg 800w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Структура адреса и тэга такая же, как и в прямом отображении, но алгоритм поиска отличается:</p>\\n<ol>\\n<li>извлекается средняя часть адреса, определяющая номер сэта в кеше</li>\\n<li>тэги всех кэш-линий данного сета сравниваются со старшей частью одновременно</li>\\n<li>если было совпадение по одному из тэгов, то внутри этой кэш-линии ищем байт с адресом, совпадающим с младшей частью искомого адреса</li>\\n</ol>\\n<p>Таким образом, количество каналов кэша определяет количество одновременно сравниваемых тэгов.</p>\\n<p>Этот вариант является общепринятым компромиссом между сложностью реализации и эффективностью.</p>\\n<h3>Категории промахов</h3>\\n<ul>\\n<li><strong>Промах по чтению из кэша инструкций</strong>. Обычно дает очень большую задержку, поскольку процессор не может продолжать исполнение программы (по крайней мере, текущего потока исполнения) и вынужден простаивать в ожидании загрузки инструкции из памяти.</li>\\n<li><strong>Промах по чтению из кэша данных.</strong> Обычно дает меньшую задержку, поскольку инструкции, не зависящие от запрошенных данных, могут продолжать исполняться, пока запрос обрабатывается в основной памяти. После получения данных из памяти можно продолжать исполнение зависимых инструкций.</li>\\n<li><strong>Промах по записи в кэш данных</strong>. Обычно дает наименьшую задержку, поскольку запись может быть поставлена в очередь и последующие инструкции практически не ограничены в своих возможностях. Процессор может продолжать свою работу, кроме случаев промаха по записи с полностью заполненной очередью.</li>\\n</ul>\\n<h3>Согласованность кэшей</h3>\\n<p>Кэш L1 - свой у каждого ядра. То есть у нас в несколько разных кэшей копируются одни и те же данные из памяти. Так как они используются на чтение и запись разными потоками, то теоретически могут рассинхронизироваться и значение какого-то адреса в одном кэше может не совпадать со значением этого же адреса в другом.</p>\\n<p>На практике аппаратные кэши в современных процессорах всегда синхронизируются. Это значит, что если два разных потока в любом месте системы читают данные с одного и того же адреса памяти, то они никогда не должны <em>одновременно</em> считывать разные значения.</p>\\n<p>Наиболее распространенный протокол для обеспечения согласованности между кэшами известен как протокол MESI. </p>\\n<h4>MESI</h4>\\n<p>Каждая строка данных в кэше помечена одним из следующих состояний:</p>\\n<ol>\\n<li><strong>М</strong>odified - данные модифицированы и отличаются от основной памяти. Являются источником истины, а все остальные источники устарели.</li>\\n<li><strong>E</strong>xclusive - данные не модифицированы и синхронизированы с основной памятью. Ни в одном другом кэше того же уровня нет этих данных.</li>\\n<li><strong>S</strong>hared - данные не модифицированы и синхронизированы с общей памятью. В других кэшах того же уровня (возможно) есть те же данные</li>\\n<li><strong>I</strong>nvalid - данные устарели и не должны использоваться</li>\\n</ol>\\n<p>Применяя и обновляя эти состояния, можно добиться согласованности кэша.</p>\\n<p>Рассмотрим несколько примеров для процессора с четырьмя ядрами, у каждого из которых собственный кэш L1, а также глобальный кэш L2 на кристалле.</p>\\n<h5>Запись в память</h5>\\n<p>Предположим, что поток на core-1 хочет записать в память по адресу 0xabcd. Ниже приведены некоторые возможные последовательности событий.</p>\\n<h6>Попадание в кэш</h6>\\n<p>В L1-1 есть данные в состоянии E или M.\\nL1-1 производит запись. Всё готово.\\nНи в одном другом кэше нет данных, так что немедленная запись будет безопасной.\\nСостояние строки кэша изменяется на M, поскольку она теперь изменена.</p>\\n<h6>Промах локального кэша, попадание одноуровневого кэша</h6>\\n<p>В L1-1 есть данные в состоянии S.\\nЭто значит, что в другом одноуровневом кэше могут быть эти данные.\\nТа же последовательность применяется, если в L1-1 вообще нет этих данных.\\nL1-1 отправляет Request-For-Ownership в кэш L2.\\nL2 смотрит по своему каталогу и видит, что в L1-2 сейчас есть эти данные в состоянии S.\\nL2 отправляет snoop-invalidate в L1-2.\\nL1-2 помечает данные как недействительные (I).\\nL1-2 отправляет запрос Ack в L2.\\nL2 отправляет Ack вместе с последними данными в L1-1.\\nL2 проверяет, что в L1-1 эти данные хранятся в состоянии E.\\nВ L1-1 теперь последние данные, а также разрешение войти в состояние E.\\nL1-1 осуществляет запись и изменяет состояние этих данных на M.</p>\\n<h5>Чтение памяти</h5>\\n<p>Теперь предположим, что поток на core-2 хочет считать с адреса 0xabcd. Ниже приведены некоторые возможные последовательности событий.</p>\\n<h6>Попадание кэша</h6>\\n<p>L1-2 имеет данные в состоянии S, E или M.\\nL1-2 считывает данные и возвращает в поток. Готово.</p>\\n<h6>Промах локального кэша, промах кэша верхнего уровня</h6>\\n<p>L1-2 имеет данные в состоянии I (недействительное), то есть не может их использовать.\\nL1-2 отправляет запрос Request-for-Share в кэш L2.\\nВ L2 тоже нет данных. Он считывает данные из памяти.\\nL2 возвращает данные из памяти.\\nL2 отправляет данные в L1-2 с разрешением войти в состояние S.\\nL2 проверяет, что в L1-2 эти данные хранятся в состоянии S.\\nL1-2 получает данные, сохраняет их в кэше и отправляет в поток.</p>\\n<h6>Промах локального кэша, попадание кэша верхнего уровня</h6>\\n<p>В L1-2 есть данные в состоянии I.\\nL1-2 отправляет запрос Request-for-S в кэш L2.\\nL2 видит, что в L1-1 данные в состоянии S.\\nL2 отправляет Ack в L1-2, вместе с данными и разрешением войти в состояние S.\\nL1-2 получает данные, сохраняет их в кэше и отправляет в поток.</p>\\n<h6>Промах локального кэша, попадание одноуровневого кэша</h6>\\n<p>В L1-2 есть данные в состоянии I.\\nL1-2 отправляет запрос Request-for-S в кэш L2.\\nL2 видит, что в L1-1 данные в состоянии E (или M).\\nL2 отправляет snoop-share в L1-1\\nL1-1 понижает состояние до S.\\nL1-1 отправляет Ack в L2 вместе с модифицированными данными, если это применимо.\\nL2 отправляет Ack в L1-2 вместе с данными и разрешением войти в состояние S.\\nL1-2 получает данные, сохраняет их в кэше и отправляет в поток.</p>\\n<h1>Дисковая память</h1>\\n<p>Магнитный жесткий диск состоит из набора металлических пластин, которые вертятся на шпинделе со скоростью 5400-15000 оборотов в минуту. Пластины покрыты с обоих сторон магнитным записываемым материалом, похожим на материал, которым покрываются аудио- или видеокассеты. Чтобы читать и писать информацию на диск, над каждой поверхностью размещается перемещаемая ручка, содержащая на конце маленькую электромагнитную спираль, называемую <em>головкой чтения/записи</em>.</p>\\n<p>Каждая поверхность пластин радлелена на концентрические окружности, называемые \\\"треками\\\". На каждой десятки тысяч таких треков. Каждый трек делится ена сектора, содержащие информацию: на каждом треке тысячи секторов. В секторе обычно от 512 до 4096 байт. На пластине записаны последовательно: номер сектора, пустой промежуток, кусок данных, включающий код коррекции, пустой промежуток, следующий кусок данных с кодом коррекции, и так далее.</p>\\n<p>Головки дисков соединены и двигаются вместе, так что каждая головка находится над одним и тем же треком. Словом <strong>цилиндр</strong> обозначаются все треки под всеми головками.</p>\\n<p>Чтобы обратиться к данным, нужно пройти 3 шага:</p>\\n<ol>\\n<li>Позиционируем головку над нужным треком. Эта операция называется <strong>seek</strong>.</li>\\n<li>Дождаться, пока нужный сектор попадет под головку. Это время называется <strong>rotational latency</strong> или <strong>rotational delay</strong>. </li>\\n<li>Передать блок данных. Время передачи зависит от размера сектора, скорости вращения и плотности записи.</li>\\n</ol>\\n<p>Большинство контроллеров дисков имеют встроенный кэш, который сохраняет все сектора, которые через него проходят.</p>\",\"frontmatter\":{\"path\":\"/blog/books/computer-organization-and-design\",\"title\":\"computer-organization-and-design\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---blog-books-computer-organization-and-design-df9ba92f588b98eb54fb.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>Источники: </p>\\n<ul>\\n<li><a href=\\\"https://www.amazon.com/Computer-Organization-Design-MIPS-Architecture/dp/0124077269\\\">Computer Organization and Design MIPS Edition</a></li>\\n<li><a href=\\\"https://habr.com/post/179647/\\\">Логическая организация кэш-памяти процессора</a></li>\\n<li><a href=\\\"https://habr.com/post/183834/\\\">Кэш в многопроцессорных системах. Когерентность кэша. Протокол MESI</a></li>\\n</ul>\\n<h1>I/O</h1>\\n<h2>LCD</h2>\\n<p>Состоит из двух фильтров с перпендикулярной поляризацией, а между ними - стержнеобразные молекулы (кристаллы) в жидкости. Эти молекулы формируют закручивающуюся спираль, которая изгибает свет, проходящий через дисплей.</p>\\n<p>Когда напряжения нет, то кристалы, примыкающие к горизонтальному фильтру, повернуты горизонтально, а к вертикальному - вертикально. Когда через эти кристалы проходит свет, то он \\\"изгибается\\\" и меняет свою поскость поляризации с горизонтальной на вертикальную, в результате чего проходит через оба фильтра без потерь (не считая половины неполяризованного света, поглощенного первым фильтром, ну то есть вертикально поляризованный свет не смог пройти через горизонтальный фильтр).</p>\\n<p>Если же к кристаллам приложено напряжение, молекулы стремятся выстроиться в направлении электрического поля, что искажает их винтовую структуру. Свет уже ко второму фильтру приходит не совсем вертикально поляризованный, а отклоненный на сколько-то градусов, поэтому степень прозрачности понижмается. Варьируя напряжение, можно управлять степенью прозрачности.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/aae383dbf961d65ff8a971793d38b6e6/8cd7e/lcd-display.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 640px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 80%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAB7BAAAewQHDaVRTAAAC9UlEQVQ4y21Uy05aURTlA4w/4ES/wYGJA9M6sA79BYcmfoBjY+LAgYlp0pI0oRQTa2x5KMUiYPEB2pAUBeQlLzHFoCjv9+Wu7n24IDbuZOece+8+6+zHWlclyzLYeK1Wq8IrlQoajQZqtVrfB+M6nc6rz+wqufsWEgEEr67g9/kQCYfF/vLyEj56vr6+FofYMpkM/H4/whQTCoXEN46JRqOo1+sEqAT+b016Xy6XRRCvnDFbu91Gs9lEq9WCJEliLRQKYuVLVRwkXVxA0mhQpJuSsRgyHg/uKQMOrDEoldyR2qhSK2KUEWcVCYfgpwqOnU4Ui8V++QKwaTQir1Lhhjy6uIijpSXszs7Cabfjni4o5nK4y9fhj93BcR6CwfILZtsJTCYzNjbeo1QqvQSUUinkh4aQJsDU3BzcKyuwvHsHm2UfAW8Y/mAS7nAWDm8GO3Y/tgxWbP84hf6nGx8+6UQLXgDK1KfS2JgATExP43R5GXtv3kKj/ox9qwdeHwHGnmDx3EJrcmNzxwzd9wNotnaxtf2tP7DulJXxV2ZmkCHA5Pi4yHB3agpfP6pxdPgbZ54QDi7SsFKGevsfOJwuOE/OYDTt4vj4qA/WBaSpsdUWFgRgbHQUZ6urMExMwPpFi9ubFHJ/M4gmbhAIx9FotomnZdxns3C5XIIybD0uqmQaN1tjfR1ZArwfHoZbq4Vxfh6HajVKNaJNsSBiqoLwdQVAJgpJfZr1Ku3zUH54QH5kBDUCvbVYYNjbg0OvB4dJzDFFEUwR5iVTilU1yNHnoShlN3Q6FAkQNhuCNHkzgXaIvEzgQXt8fEQkEkE8HkcwGMQDJfNiKMKVTKuTk5DX1sQ+6PXiKZ8XKmBn1bCue6pg58tYPb1J96csK1m0z8/R2NxEq9socYBBuDRWSIyInkgkhI5Zz4FAQOi4V7ZqsKG9LBsEUqDMuF+sghwpJUtT7TmX3HnlH/DcQ6XsQdDee/6VJZNJpKin6XRa7HltK33vt0w5/w8GdHxC1SCFPwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"LCD Display\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/aae383dbf961d65ff8a971793d38b6e6/8cd7e/lcd-display.png\\\"\\n        srcset=\\\"/hows-that-again/static/aae383dbf961d65ff8a971793d38b6e6/bf5b7/lcd-display.png 163w,\\n/hows-that-again/static/aae383dbf961d65ff8a971793d38b6e6/f1b9d/lcd-display.png 325w,\\n/hows-that-again/static/aae383dbf961d65ff8a971793d38b6e6/8cd7e/lcd-display.png 640w\\\"\\n        sizes=\\\"(max-width: 640px) 100vw, 640px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Раньше использовалась <strong>пассивная матрица</strong>. Это значит, что для управления экраном NxM пикселей использовались N+M линий адресации, то есть N - для выбора строки и M - для выбора столбца. На выбранные строки подавалось напряжение, пиксель на пересечении загорался и должен был хранить свое состояние до следующей активации. Таким образом, при смене кадра последовательно изменялись все пиксели экрана. Из-за большой емкости ячеек напряжение на них меняется медленно, а значит и кадры тоже медленно меняются.</p>\\n<p>В настоящее время большинство ЖК-дисплеев используют <strong>активную матрицу</strong> на тонкопленочных транзисторах (thin film transistors / TFT). Раньше широко применялись матрицы на тонкопленочных диодах (TFD), но сейчас таких почти нет. В схеме активной матрицы с каждой точкой изображения последовательно включена собственная тройка транзисторов, управляющих цветами R, G, B. Все пиксели изменяются параллельно.</p>\\n<p>На уровне железа поддержка графики состоит в основном из <strong>фреймбуфера</strong>, в котором хранится битовая карта. Изображение, которое нужно отобразить на экране, сохраняется в фреймбуфере. Если у нас 24-битный цвет, то для каждого пикселя во фреймбуфере сохраняется 24 бита.</p>\\n<h2>Тачскрин</h2>\\n<p>На данный момент в большинстве тачскринов используются емкостностные экраны.</p>\\n<h3>Поверхностно-емкостной экран</h3>\\n<p>Экран покрывается прозрачным проводящим материалом, а по углам экрана располагаются 4 электрона, подающие на этот слой небольшое напряжение. Когда человек прикасается к экрану, возникает утечка точка. Чем ближе палец к электроду, тем меньше сопротивление экрана, а значит больше сила тока. Ток регистрируется датчиками в углах и передается на контроллер, вычисляющий координаты точки касания.</p>\\n<p>Не умеет в мультитач.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/8a8976025f3c35e3345bc3b0ba9815b6/b7119/touch-screen-capacitive.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 360px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 105.83333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsSAAALEgHS3X78AAAEMElEQVQ4y62VbUxbVRiA773QwspHO9gKjhFgczHRTexM5tQY/eFvk8X4AxNNYP7QIG5LRtzUZWabc4o4MxhmG0FWPtpuZdpv7uSr0malA6W0sCItUOnnSoGW0tJbbl/vLZcELEZNPMnT2557znPe9773nCLIesulKED+p4ZRPEmRR5FOkcZc/w1pm9jSaBmHgk/BpcimyPkHsjeNpzPcsSGjbzzFCMsQFOX/h+zouShD7kbnToqXKfJRDDvIyc56RgKAvnBWjh2p+hLNe+V9au2C5AyE+fyLEGPI2eikR/GY77ztwlBPx7BKySJWIVpEX7qkRZDX6zZuHaDYzTyy/YwYQTNydybDPXriysF3u2wXqvD4m+X1nkNIxUzWdgsAlYGguoGFsjIEjLSU4jAFOynkFZfRDxY5bYfDV8x+S8vUkq7LnVA3W6LippHIpcvacOVbwsCr/POeQgSRbq4oh71ebRYT5XrK3L2lSWG1hRBcdSYGWn73aRTukGo0BvLJVVBZgiQ+uUTeU88S0s+Ho7eq+sNnjilix/Yc7ziCsA+kP8FjYwiKZacIaywxQd0fpE7oB41w0osrnUG5MQwS2yqIfXHoDJAgHgyD5pqTNHw7B/pKtdWAXrUeouem5RdxU4QfjROCrxxrumZfAhfNg0JlsY2MOP1DlihIZqKJO75YotMcTkhb/SD/bsLbe+q3JT1XAeX0XFZByfbCrx2krslD4sLHoO72x37WT0zZ9K5F5XQcJO5VUuyIQYfWE9J1j9scJ8djA7y7q0lhOn8bYQ0tpFJudCfwZi+JSwOg1MwTMs2UWzW6ELnnJEDiIaBN/8g2JHEsPThlJfu54vA2wqJ14YemCBXh2mCDi8SvexJ4+2NSfT8ISn0oIeuZ8f9kj4PIHgjdMTr9UnkQ5KcfEYNZ4sizKUJe8b7kj1onPFfvggdNPui+7lq73+GL94h8CSW+QMqMDkePqrfbaJya/TEAIBxaJmVnrYQ2UxRJiRDh5O2md0jGa+caX/xkyNl70Tz/yw3TnFU9ZnOptOrpscG2+WG91DFg6DP0j1nVdl+ge5aK9vIU0Z8uWlkvymYhHSU7N49+QdlHq+tzSloX9n/Ra/p0dFgeICeEELW0gdE0aPqVANnkckxN1Wl2xuvruekERaZ4ZaPKuX97hISM35+Im1vtSw9vQWRCBOC6CzD+DfQNSH/oC8J5g2u5y2Rz4DfHF/U5naHn6TlsfvHWc0DwdCm9pbKKSvbxVsy358DbDjOaz1yu3otzHrx24GHL2+26jwt30WPrDCvcHieUn7zd915GxQV6L3PSeQWZW4RsVlohfVgqbtRmBrVnRuzS43WN72RwdOd4O7YeDKkZ7W2dTe1E0eR/Cg/Ahinq3ihLOWGIa6i+vQb5wAWI3B5DlOYFrMEcxXYxK7Dy9ySvfwIMLx/HYE6D9wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Touch Screen Capacitive\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/8a8976025f3c35e3345bc3b0ba9815b6/b7119/touch-screen-capacitive.png\\\"\\n        srcset=\\\"/hows-that-again/static/8a8976025f3c35e3345bc3b0ba9815b6/4c099/touch-screen-capacitive.png 163w,\\n/hows-that-again/static/8a8976025f3c35e3345bc3b0ba9815b6/d150d/touch-screen-capacitive.png 325w,\\n/hows-that-again/static/8a8976025f3c35e3345bc3b0ba9815b6/b7119/touch-screen-capacitive.png 360w\\\"\\n        sizes=\\\"(max-width: 360px) 100vw, 360px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<h3>Проекционно-емкостной экран</h3>\\n<p>На внутренней стороне экрана нанесена сетка электродов. Электрод вместе с телом человека образует конденсатор; электроника измеряет ёмкость этого конденсатора (подаёт импульс тока и измеряет напряжение).</p>\\n<p>Такие экраны применяются в айфонах. </p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/cc5558188d9f4b11eb174792794c2e7a/380b9/touch-screen-capacitive2.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 260px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 138.46153846153845%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAAAsSAAALEgHS3X78AAAERElEQVRIx63We1BUVRwH8O9ydxbBAaWgl2HJFEMCUQ0sgoMgL+X9fiwPQV4K8hgRGZRddgVZEUFAAkWH2CXlkULMgA9CMgIpnMwZK4d3OQ2GjTMYpJmlv057t9cfNe3WnTlzZ/fe+czvd87vd84F9LniDuL/u+Ir+XuEfDnqv3wCqqUV6CNTpDY+DcPlq/QBBTxYIkb9rISBQThLm5BcVwCRUd1/AOW/grFQLwXgXfLCthNxMDIN1GP+DmhBmROOTEVAveiOzsfOKOh2g3JMqDsYXsyDATtfQ80NL3T87MBSfhnh0vUsZbHuoG8WD25MsUXFVUcoPrABkRncErzBCfVY/nWRPOgSvQZhe8Sw9QhGRtPr7P80CEUVf3mX4ww09xeft0CYrxip0Z7ITtyMgrQg5CUHojA7EXAM5kGnECsWZSA80yJx/JaYTUUGS1mheXbppFxwpVvJzY02cTR7mqPbfX+MeTbunOceTXZwMx91cF19nZqJFzoFvYEt1eFQf7ce75An9l6QwNLOCuea9+hX4C+4uApkA7Es3VREyotQdjmOLZSJ5lm/qnj1xVZp+IBaKnlPVZx2sVWWM9SuKBzpLC0e6SwrGetWyi+0SEvbjpaWj5xTHfrk/FtS+9CkVKgfhAoSKnchMF+G/DOZMDLJ1oALn6qyWGpEN7uJ5nuJvj1LLF1+zGvHXA/dv9FOd66dIvqqi2SlBcPIGY4wDNutgM/2UlaX+9gcHtaANNMRQ7OdRNPt39N02w80depHmjr5E02qH9F482MabyIabySaaSCaOkKLQ9K54OR4Gco+i+WiZEXwyy1B/MFiBtby4PXqaLp1jGiihuiLKqJrFfRgbD/dG1U8XPyweOl2/66Fm705X092ZQ5cakosaYgyM8dzG9yFb87EQXIgl4EyFPSkwniFRAN+3rHN7mrr1torLUmFQ8fi0/uqIyNb5f6e0q3ODn7rLFf7OD5rZiKC4Z/XROSZtBGFfels7pIgUeawAg9CQuUyVuTd/3phiQgtJ4pEmh+bs12xQ52J49/4YJCckNvmAxPztdoX+9k4w90bLhJebk4Wvn80keupijFoLPI3kKdvEDRLAwSDDXGo2OEBhO3lC1uitEdMWTo8klNZdGLWKfEw4PjWk/jawmrVyt8jWSb6h03DP48H/fLWsgi94RobgvzT1rDzCmNgue4F7Rqrbb1Qa+wftUbdhCVLz4IVdRDrZaXuoFMID9p7v8S6wwbtD63ZBvsqizYAT1ra6A76bOdBt/hXUHXdFa1LzmxPdEfJYARS6o11B39bFL9cB9RO+LMdexOL0J9FmA3jlVv0OAIqtEeAlB0B0xK03A1FLwNT6gthaFyjO5hYxW+aUfucGZiAloUQBvoxcDcDD+sOJhzSggoXBiZBdTcc3RSMrJadrPUy9AGhBU0Z+AxUi+Z4+74Fyj9+Sv+vh4TKv330C/JOwhVjRybuAAAAAElFTkSuQmCC'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Touch Screen Capacitive2\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/cc5558188d9f4b11eb174792794c2e7a/380b9/touch-screen-capacitive2.png\\\"\\n        srcset=\\\"/hows-that-again/static/cc5558188d9f4b11eb174792794c2e7a/4231f/touch-screen-capacitive2.png 163w,\\n/hows-that-again/static/cc5558188d9f4b11eb174792794c2e7a/380b9/touch-screen-capacitive2.png 260w\\\"\\n        sizes=\\\"(max-width: 260px) 100vw, 260px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<h1>Память</h1>\\n<table>\\n<thead>\\n<tr>\\n<th>Тип памяти</th>\\n<th>Время доступа</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>DRAM</td>\\n<td>50-150 наносекуд</td>\\n</tr>\\n<tr>\\n<td>Магнитный диск</td>\\n<td>5-20 милисекунд</td>\\n</tr>\\n<tr>\\n<td>Флэш-память</td>\\n<td>5-50 микросекунд</td>\\n</tr>\\n</tbody>\\n</table>\\n<h2>Производство процессоров и памяти</h2>\\n<ol>\\n<li>Из расплавленного кремния на специальном оборудовании выращивают монокристалл цилиндрической формы</li>\\n<li>Получившийся слиток охлаждают и режут на «блины», поверхность которых тщательно выравнивают и полируют до зеркального блеска</li>\\n<li>Затем в «чистых комнатах» полупроводниковых заводов на кремниевых пластинах методами фотолитографии и травления создаются интегральные схемы</li>\\n<li>После повторной очистки пластин, специалисты лаборатории под микроскопом производят выборочное тестирование процессоров – если все «ОК», то готовые пластины разрезают на отдельные процессоры, которые позже заключают в корпуса</li>\\n</ol>\\n<p>Подробности <a href=\\\"https://habr.com/company/intel/blog/110234/\\\">здесь</a></p>\\n<h1>Инструкции MIPS</h1>\\n<p><strong>Слово</strong> - единица доступа к памяти компьютера. Совпадает с размером регистра. В 32-битной архитектуре слово = 32 бита, регистр = 32 бита и к памяти мы можем обращаться шагами по 32 бита или 4 байта. Чем больше регистров, тем дольше будет такт, потому что расстояние до регистров будет больше и сигналы будут его дольше проходить. Помимо этого, чем больше регистров, тем больше бит занимает инструкция в памяти.</p>\\n<p>Разница между переменными и регистрами в том, что количество регистров ограничено, и некоторые инструкции могут работать только с данными, лежащими в определенных регистрах. Поэтому перед выполнением этих инструкций нжуно выполнить операцию <strong>load</strong>, которая загружает значение из памяти в регистр. Команда <strong>store</strong> - наоборот, сохраняет значение из регистра в переменную в памяти.</p>\\n<p>В архитектуре MIPS 32 32-битных регистра. Регистры в MIPS обозначаются знаком доллара и 2-буквенным обозначением, например: $s0, $s1 - регистры общего назначения. $t0, $t1 - временные регистры.</p>\\n<h2>Команды перемещения данных</h2>\\n<p><strong>Команда загрузки в регистр состоит из</strong>:</p>\\n<ul>\\n<li>название операции</li>\\n<li>регистр, в который загружаем</li>\\n<li>константа, обозначающая <strong>сдвиг</strong>, измеряемый в <em>байтах</em>. Это обязательно должна быть костанта. Если сдвиг определяется динамически, то нужно предварительно записать сдвиг в какой-нибудь регистр, затем этот регистр подать как адрес в памяти, а сдвиг указать равный 0.</li>\\n<li>регистр, обозначающий адрес в памяти, называемый <strong>базовый регистр</strong></li>\\n</ul>\\n<pre><code>g = h + A[8] => \\n\\n    lw $t0, 32($s3) \\n    add $s1, $s2, $t0\\n</code></pre>\\n<ul>\\n<li><code>lw</code> = load word</li>\\n<li><code>$t0</code> = регистр, куда попадет значение</li>\\n<li><code>32</code> = сдвиг. Нас интересует 8-й элемент массива, то есть 8-е слово. Каждое слово состоит из 4 байт, значит нас интересует 32-й байт. </li>\\n<li><code>$s3</code> = адрес начала массива <code>A</code> в памяти</li>\\n<li><code>$s2</code> = ассоциирован с <code>h</code></li>\\n<li><code>$s1</code> = результат сложения, ассоциирован с <code>g</code> </li>\\n</ul>\\n<p>Из-за выравнивания памяти адреса всех слов должны быть кратны 4.</p>\\n<p><strong>Пример обращения с динамическим сдвигом</strong>:</p>\\n<p>$s0 = i\\n$a0 = A</p>\\n<pre><code>g = A[i] =>\\n\\n    sll $t0 $s0 2   # сдвигаем на 2, то есть умножаем на 4, чтобы из кол-ва слов получить кол-во байт\\n    add $t1 $a0 $t0 # t1 = a0 + t0, то есть узнаем адрес в памяти элемента A[i]\\n    lw $t2 0($t1)   # t2 = A[i]\\n</code></pre>\\n<p>Компьютеры делятся на те, которые используют адрес самого левого (старшего) байта в слове в качестве адреса слова (<em>big-endian</em>) и на те, которые используют адрес правого (младшего) байта (<em>little-endian</em>). MIPS относится к <em>big-endian</em> архитектурам.</p>\\n<p><strong>Команда выгрузки из регистра в память</strong> называется <strong>store</strong> и имеет аналогичный с командой <strong>load</strong> синтаксис: название операции <em>sw</em>, сохраняемый регистр, сдвиг и базовый регистр.</p>\\n<pre><code>A[12] = h + A[8] =>\\n\\n    lw $t0, 32($s3)\\n    add $t0, $s2, $t0\\n    sw $t0, 48($s3)\\n</code></pre>\\n<h2>Константы</h2>\\n<p>Команда <code>add</code> принимает в качестве операндов регистры. Если нам нужно что-то сложить с константой, то пришлось бы сначала записать константу в регистр, что неэффективно. Для решения проблемы есть специальная команда <code>addi</code>, что означает <em>add immediate</em>. Так как константы могут быть отрицательными, то нет надобности в команде <code>subi</code>.</p>\\n<pre><code>addi $s3, $s3, 4    # $s3 = $s3 + 4\\n</code></pre>\\n<p>Для константы 0 даже есть специальный регистр <code>$zero</code>.</p>\\n<h2>Знаковые числа</h2>\\n<p>В большинстве систем сейчас используется техника представления знаковых чисел под назваием <strong>two's complement</strong>, или <em>второе дополнение</em>. Второе дополнение числа определяется как величина, полученная вычитанием числа из наибольшей степени двух.</p>\\n<p>В знаковых числах старший бит означает знак. Если он равен 0, то в остальных разрядах записаноположительное число.\\nЕсли 1, значит число отрицательное. Предществующие 1 в этом случае выполняют роль предшествующих 0 в положительных числах, то есть все подряд идущие 1 слева становятся незначимыми, значимая только самая правая в ряду подряд идущих единиц. При этом самый старбишй бит - всегда НЕ значимый. Если после него идет 0, то первым значащим битом становится этот ноль. </p>\\n<p>Разница 2^(количество значимых бит справа) - число, закодированное в этих битах = абсолют нашего искомого отрицательного числа.</p>\\n<p>Пример:</p>\\n<pre><code>1111 1111 1111 1111 1111 1111 1111 1101 = -3\\n\\n 1111 1111 1111 1111 1111 1111 1111 1 101 = -3\\n|                                    |   |\\n------------------------------------- ----\\n              ^                        ^\\n              |- не значимые           |- значимые 101 = 5\\n\\nКоличество значимых бит = 3\\n\\n2^3 - 5 = 3\\n\\nИскомое число = -3\\n</code></pre>\\n<p>Другой пример, когда у нас после знака сразу идет 0:</p>\\n<pre><code>1010 = -6\\n         1           010 = -6\\n|                   |   |\\n-------------------------\\n ^                    ^\\n |- не значимый бит   |- значимый 010 = 2\\n\\nКоличество значимых бит = 3\\n\\n2 ^ 3 - 2 = 6\\n\\nИскомое число = -6\\n</code></pre>\\n<p>Иначе говоря, число со знаком может быть представлено как:</p>\\n<pre><code>(x[31] * -2^31) + (x[30] * 2^30) + (x[29] * 2^29) + ... + (x[1] * 2^1) + (x[0] * 2^0)\\n</code></pre>\\n<p>То есть в случае <code>signed</code> числа знаковый бит умножается на -2^31, а в случае <code>unsigned</code> - на 2^31.</p>\\n<p>Другой способ преобразования - инвертировать число и прибавить 1, получаем абсолют. То есть в нашем случае это будет <code>10 = 2</code>, прибавляем 1 - получаем 3.</p>\\n<p>Неиспользуемая ныне техника <strong>one's complement</strong> получает отрицательное число как <code>2^n - x - 1</code>. Все отрицательные числа получаются из положительных установкой знакового бита в 1 и инвертацией всех остальных позиций. Сейчас техника не используется, так как требует больше шагов для арифметических операций (в two's complement отрицательное число равняется <code>2^n - x</code>).</p>\\n<h2>Представление инструкции в машинном коде</h2>\\n<p>Регистры $t0-$t7 имеют номера 8-15, а $s0-$s7 - 16-23.</p>\\n<p>Для примера возьмем инструкцию сложения:</p>\\n<pre><code>add $t0, $s1, $s2\\n</code></pre>\\n<p>Она представляется в памяти в следующем виде:</p>\\n<pre><code>0 17 18 8 0 32\\n</code></pre>\\n<p>Где:</p>\\n<p>0 - первая часть идентификатора команды <code>add</code>\\n17 - <code>$s1</code>\\n18 - <code>$s2</code>\\n8 - <code>$t0</code>\\n0 - не используется в этой команде\\n32 - вторая часть идентифкатора команды <code>add</code>.</p>\\n<p>В бинарном виде команда имеет вид:</p>\\n<pre><code>000000 10001 10010 01000 00000 100000\\n</code></pre>\\n<p>1 и 6 части имеют по 6 бит, 2-5 по 5. Итого каждая инструкция занимает 32 бита, то есть сколько же, сколько занимает слово в этой архитектуре.</p>\\n<p>Каждое из полей команды имеет свое название:</p>\\n<pre><code>|   op  |   rs  |   rt  |   rd  | shamt | funct |\\n| 6 бит | 5 бит | 5 бит | 5 бит | 5 бит | 6 бит |\\n</code></pre>\\n<ul>\\n<li><em>op</em>: 6 бит, <em>opcode</em>, определяет операцию и формат инструкции</li>\\n<li><em>rs</em>: 5 бит, первый входной регистр</li>\\n<li><em>rt</em>: 5 бит, второй входной регистр</li>\\n<li><em>rd</em>: 5 бит, регистр назначения</li>\\n<li><em>shamt</em>: 5 бит, сдвиг</li>\\n<li><em>funct</em>: 6 бит, <em>function code</em>, определяет конкретный варинт операции, указанной в поле <em>op</em>.</li>\\n</ul>\\n<p>Этот формат называется <em>R-type</em> или <em>R-format</em>, от слова register.</p>\\n<p>Есть еще другой формат - <em>I-type</em> / <em>I-format</em>, который используется для операций с константами и операций сохранения/загрузки данных. Дело в том, что при использовании R-формата размер константы ограничен 5 битами, а значит может принимать значения от 0 до 32. Это очень мало для константы и особенно для адресации внутри массива в случае команд <em>load/store</em>. </p>\\n<p>I-формат:</p>\\n<pre><code>|   op  |   rs  |   rt  | constant or address |\\n| 6 бит | 5 бит | 5 бит | 16 бит              |\\n</code></pre>\\n<p>При этом в этом формате регистр <code>rt</code> означает регистр назначения.</p>\\n<p>Еще есть самый простой формат - <em>J-type</em>, используемый для инструкции <code>j</code>:</p>\\n<pre><code>|   op  | address |\\n| 6 бит | 26 бит  |\\n</code></pre>\\n<h2>Условия</h2>\\n<p><code>beq reg1 reg2 L1</code> - если значение регистра 1 = значению регистра 2, то перейти к метке L1</p>\\n<p><code>bne reg1 reg2 L1</code> - если значение регистра 1 != значению регистра 2, то перейти к метке L1</p>\\n<p><code>slt reg1 reg2 reg3</code> - set on less than, если reg2 &#x3C; reg3, то reg1 = 1, иначе 0</p>\\n<p><code>slti reg1 reg2 10</code> - set on less than immediate, если reg2 &#x3C; 10, то reg1 = 1, иначе 0</p>\\n<p>Есть еще <code>sltu - set on less than unsinged</code> и <code>sltiu - set on less than immediate unsgined</code>. </p>\\n<h3>Быстрая проверка на выход за границы цикла</h3>\\n<pre><code>sltu $t0 $s1 $t2  # $t0=0 if $s1 >= length or $s1&#x3C;0\\nbeg $t0 $zero IndexOutOfBounds  # if bad, goto Error\\n</code></pre>\\n<h2>Цикл</h2>\\n<p>Допустим, мы хотим преобразовать следующий код в ассемблер:</p>\\n<pre><code class=\\\"language-c\\\">while (save[i] == k)\\n    i += 1;\\n</code></pre>\\n<p>Пускай переменные у нас лежат в следующих регистрах:</p>\\n<pre><code>i = $s3\\nk = $s5\\nsave = $s6\\n</code></pre>\\n<p>Тогда код на ассемблере будет таким:</p>\\n<pre><code class=\\\"language-asm\\\">While: \\n    sll $t1 $s3 2  # умножаем i на 4 путем сдвига влево на 2 знака, чтобы из количества слов получить количество байт\\n    add $t1 $t1 $s6 # получаем адрес save[i]\\n    lw $t0 0($t1) # загружаем в регистр значение save[i]\\n    beq $t0 $s5 Exit # if(save[i] != k) break;\\n    addi $s3 $s3 1 # i += 1\\n    j While # возвращаемся в начало \\nExit:\\n</code></pre>\\n<h2>Вызов процедуры</h2>\\n<p>Для вызова процедуры, нужно сделать следующее:</p>\\n<ol>\\n<li>Положить параметры в место, откуда процедура сможет их получить</li>\\n<li>Передать контроль процедуре</li>\\n<li>Получить ресурсы, необходимые процедуре</li>\\n<li>Выполнить процедуру</li>\\n<li>Положить результат в место, откуда вызывающая программа сможет его получить</li>\\n<li>Вернуть контроль точке вызова процедуры</li>\\n</ol>\\n<p>В MIPS для вызова процедур служат следующие регистры:</p>\\n<ul>\\n<li><em>$a0-$a3</em>: 4 регистра, куда можно положить параметры</li>\\n<li><em>$v0-$v1</em>: 2 регистра, куда можно положить результат</li>\\n<li><em>$ra</em>: return address, то есть регистр, куда кладется адресс точки вызова перед вызовом процедуры</li>\\n</ul>\\n<p>Если нужно передать больше 4 параметров, то все дополнительные параметры кладутся на стек сразу над <code>$fp</code>.</p>\\n<p>Для вызова есть специальная инструкция <code>jal (jump-and-link)</code> - она кладет адрес следующей инструкции в регистр <code>$ra</code>, после чего вызывает процедуру. </p>\\n<p>Синтаксис прост:</p>\\n<pre><code>jal ProcedureAddress\\n</code></pre>\\n<p>Процедура возвращается вызовом <code>jr $ra</code>.</p>\\n<p>Адрес текущей выполняемой инструкции почти всегда называется <em>program counter</em> или <em>PC</em>. Команда jal просто сохраняет в регистр $ra значение PC + 4.</p>\\n<h2>Стек</h2>\\n<p>Когда регистров не хватает, на помощь приходит <strong>стек</strong>. Например, после вызова процедуры нужно подчистить все следы и вернуть все используемые процедурой регистры к тем значениям, которые были <em>до</em> вызова процедуры. А для этого их нужно где-то хранить. Вот на стеке они и хранятся. Также в нем хранятся локальные массивы и структуры.</p>\\n<p>Для работы со стеком используется <em>stack pointer</em>, указывающий на адрес последнего сохраненного в стек значения. При сохранении или извлечении каждого значения, стэк пойнтер изменяется на 1 слово. Обратиться к нему можно по регистру <code>$sp</code>.</p>\\n<p>Стек растет от высших адресов к низшим. Это означает, что для пуша на стек нужно вычитать 1 слово из значения стэк пойнтера. А увеличение стэк пойнтера уменьшает стэк, выдавливая из него значения.</p>\\n<p>Пример процедуры:</p>\\n<pre><code class=\\\"language-c\\\">int leaf_example(int g, int h, int i, int j)\\n{\\n    int f;\\n    f = (g + h) - (i + j);\\n    return f;\\n}\\n</code></pre>\\n<p>g,h,i,j = $a0,$a1,$a2,$a3</p>\\n<p>f = $s0</p>\\n<p>Скомпилированная процедура будет выглядеть так:</p>\\n<pre><code class=\\\"language-asm\\\">leaf_example:\\n    addi $sp, $sp, -12  # выделяем в стеке место для 3 локальных переменных\\n    sw $t1, 8($sp)\\n    sw $t0, 4($sp)\\n    sw $s0, 0($sp) # бэкапим на стек значение регистров, которые будем использовать в теле функции\\n\\n    add $t0, $a0, $a1\\n    add $t1, $a2, $a3\\n    sub $s0, $t0, $t1 # делаем наши арифметические операции\\n    add $v0, $s0, $zero # возвращаем результат\\n\\n    lw $s0, 0($sp)\\n    lw $t0, 4($sp)\\n    lw $t1, 8($sp) # ресторим из стека значение регистров\\n    addi $sp, $sp, 12 # уменьшаем стек на 3 элемента\\n\\n    jr $ra   # возвращаемся к точке вызова\\n</code></pre>\\n<p>Теперь посмотрим, как выглядит рекурсия:</p>\\n<pre><code class=\\\"language-c\\\">int fact (int n)\\n{\\n    if (n &#x3C; 1) return 1;\\n    else return ( n * fact(n-1));\\n}\\n</code></pre>\\n<pre><code class=\\\"language-asm\\\">fact:\\n    addi $sp $sp -8\\n    sw $ra 4($sp)\\n    sw $a0 0($sp) # бэкапим аргументы и адрес возврата, чтобы восстановить их после вызова другой процедуры внутри этой\\n\\n    slti $t0 $a0 1\\n    beq $t0 $zero L1 # if n > 1 goto L1\\n\\n    addi $v0 $zero 1 # else return 1\\n    addi $sp $sp 8 # уничтожаем забекапленные значения, так как внутренний вызов не пригодился\\n    jr $ra # возвращаемся к точке вызова\\n\\nL1: \\n    addi $a0 $a0 -1 \\n    jal fact   # fact(n-1)\\n    lw $a0 0($sp) # восстанавливаем из стека значение регистров после внутреннего вызова\\n    lw $ra 4($sp)\\n    addi $sp $sp 8\\n\\n    mul $v0 $a0 $v0 # return n * fact(n-1)\\n    jr $ra\\n</code></pre>\\n<p>Рассмотрим, какие регистры нужно обязательно сохранять перед вызовом процедуры и ресторить после возврата из нее, а какие необязательно</p>\\n<table>\\n<thead>\\n<tr>\\n<th>Сохранять</th>\\n<th>Можно не сохранять</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>$s0-$s7</td>\\n<td>$t0-$t9</td>\\n</tr>\\n<tr>\\n<td>$sp</td>\\n<td>$a0-$a3</td>\\n</tr>\\n<tr>\\n<td>$ra</td>\\n<td>$v0-$v1</td>\\n</tr>\\n<tr>\\n<td>Стэк над $sp</td>\\n<td>Стэк под $sp</td>\\n</tr>\\n</tbody>\\n</table>\\n<h3>Выделение места на стеке</h3>\\n<p>Сегмент стека, содержащий сохраненные процедурой регистры и ее локальные переменные, называется <em>фрейм процедуры</em>.</p>\\n<p>Для обозначения начала фрейма используется регистр <code>$fp</code> - frame pointer, указывающий на адрес первого слова фрейма процедуры. Stack pointer может измениться во время процедуры, а frame pointer - нет.</p>\\n<p>На рисунке изображен стек до, во время и после вызова процедуры:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/a9983574e0824c051ede6965c590ffcf/ad3dc/procedure-frame.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 48.64864864864865%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABt0lEQVQoz3WR7WsTQRDG8/9/LRZRAxX0g4i0CpX6UikVDLXUIkhTm6vExiTNpXdeNnu5fb3Hmal3RKgDD7e3M/Obl+1Mp1PMZjNY7xFrINS1KJLqVlg7ky8E8Yd1xVtfR+slbgqFw+sK71KPD6TXE4OrpQVh4Cx/IWc2hhV5htFihbczj32Kf58GHFB+aR06q1JjTsC9cYXticerqcezK4NBvkJ0FqqyMMQyEfLV1mNOE/3INV6MHV5OnOTt/qqgDQG5oiFyqg0yW4vSKkjXC6Wkcvd0hK0vQ3RPhtgZKhQlJVcGc6qS2XibUzpYR0AZI0b4djSZC56cbHvnY2wcfMWjT33c//gNT04usaQug7PtGmQh9Aa+AQbu0th2U95z1xY1FdofZnhwNCDgGR72vuN5/1rWwLttHo7NEcytA+1ah/zvpMMah2OF7ucEj48TbB1fYifJsDRegPX/gHxpjPkHqLWWuzc/F9joJdjsXeBeb4Cn/RSKRnbku7PDsiwlmSHtPiiI7xXdj8qA898GFwXLIlnQq9NK4t/4Bsj5rE6e55inKYqiaAOaIAGrAncZF2ymauLZ/gDUEfxlzmyBFQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Procedure frame\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/a9983574e0824c051ede6965c590ffcf/10273/procedure-frame.png\\\"\\n        srcset=\\\"/hows-that-again/static/a9983574e0824c051ede6965c590ffcf/9b14a/procedure-frame.png 163w,\\n/hows-that-again/static/a9983574e0824c051ede6965c590ffcf/94962/procedure-frame.png 325w,\\n/hows-that-again/static/a9983574e0824c051ede6965c590ffcf/10273/procedure-frame.png 650w,\\n/hows-that-again/static/a9983574e0824c051ede6965c590ffcf/ad3dc/procedure-frame.png 666w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>На следующей схеме - распределение данных в памяти для архитектуры MIPS</p>\\n<p><a href=\\\"mips-memory-allocation.png\\\">!MIPS Memory allocation</a></p>\\n<p>Указанные адреса не являются частью архитектуры, а просто соглашение на уровне приложений. </p>\\n<p>Вершина стека инициализируется самым старшим адресом доступной памяти, то есть <code>$sp = 7fff fffc</code>. Оттуда стек будет расти вниз.</p>\\n<p>Затем идет сегмент динамической памяти, или <em>куча</em>. Она растет вверх, навстречу стеку. Это память, выделяемая командами <code>malloc</code> и <code>new</code>. Здесь всякие массивы, структуры.</p>\\n<p>Затем сегмент статической памяти, который начинается с адреса <code>1000 0000</code>. Здесь хранятся константы и другие статические переменные.</p>\\n<p>Затем сегмент Text, содержащий машинный код исполняемой программы.</p>\\n<p><code>$gp</code> указывает на середину сегмента статической памяти и с его помощью, указывая положительный или отрицательный сдвиг, можно обратиться к любому адресу статического сегмента.</p>\\n<p>И в конце сегмент зарезервированной памяти.</p>\\n<h3>Tail call optimization</h3>\\n<pre><code class=\\\"language-c\\\">int sum(int n, int acc) {\\n    if (n > 0)\\n        return sum(n-1, acc+n);\\n    else\\n        return acc;\\n}\\n</code></pre>\\n<p> Преобразуется в:</p>\\n<p> $a0 = n\\n$a1 = acc</p>\\n<pre><code>sum:\\n    slti $t0 $a0 1                 # if n &#x3C;= 0\\n    bne $t0 $zero sum_exit         # goto sum_exit if n &#x3C;= 0\\n    add $a1 $a1 $a0                # acc += n\\n    addi $a0 $a0 -1                # n -= 1\\n    j sum\\nsum_exit:\\n    add $v0 $a1 $zero              # return acc\\n    jr $ra\\n</code></pre>\\n<h2>Манипуляции со строками</h2>\\n<p>Для работы со строками есть инструкции <code>lb</code> и <code>sb</code>, которые загружают из памяти 1 байт и сохраняют его в младший байт регистра - и наоборот. В этом случае адрес памяти необязательно должен быть кратным 4.</p>\\n<pre><code>lb $t0 0($sp)   # read byte from source\\nsb $t0 0($gp)   # write byte to destination\\n</code></pre>\\n<p>А для чтения юникодных символов есть инструкции <code>lh</code> и <code>sh</code> (load half/store half), которые читают по 2 байта из памяти и сохраняют в младшие 2 байта регистра - и наоборот. Адрес должен быть кратен 2.</p>\\n<p>В <strong>С</strong> строка ограничена символом с кодом 0 справа.</p>\\n<pre><code class=\\\"language-c\\\">void strcpy(char x[], char y[])\\n{\\n    int i;\\n\\n    i = 0;\\n    while((x[i] = y[i]) != '\\\\0')\\n        i += 1;\\n}\\n</code></pre>\\n<p>$a0 = x\\n$a1 = y\\ni = $t0</p>\\n<pre><code>strcpy:\\n    add $t0 $zero $zero\\nloop:\\n    add $t1 $t0 $a1 \\n    lbu $t2 0($t1)      # $t2 = y[i]\\n\\n    add $t3 $t0 $a0\\n    sb $t2 0($t3)       # x[i] = y[i]\\n\\n    beq $t2 $zero exit\\n    add1 $t0 $t0 1\\n    j loop\\n\\nexit:   \\n    jr $ra\\n</code></pre>\\n<p>Так как вложенных вызовов процедур нет, то нам удалось обойти только временными регистрами <code>$t</code>. Если есть вложенные вызовы, то перед вызовом:</p>\\n<ol>\\n<li>если есть значение, которое полностью используется до вызова и не будет использоваться после вызова, то оно пишется во временный регистр</li>\\n<li>остальные значения пишутся в сохраняемые регистры <code>$s</code>, бэкапятся перед вызовом процедуры и ресторятся после вызова (либо в начал и в конце процедуры, зависит от соглашения вызова).</li>\\n</ol>\\n<h2>Работа с большими константами</h2>\\n<p>Если нужно работать с константой, которая не влезает в 16 бит, на этот случай есть команда <code>lui</code> - <code>load upper intermediate</code>. Она загружает старшие 16 бит в регистр, позволяя затем указать младшие 16 бит, используя инструкцию <code>ori</code>.</p>\\n<p>Пример:</p>\\n<p>допустим, хотим в регистр <code>$s0</code> загрузить значение <code>0000 0000 0011 1101 0000 1001 0000 0000</code></p>\\n<p>Сначала загружаем старшие 16 бит, которые составляют число 61:</p>\\n<p><code>lui $s0 61</code></p>\\n<p>После этого в <code>$s0</code> лежит значение: <code>0000 0000 0011 1101 0000 0000 0000 0000</code></p>\\n<p>Затем через OR соединяем с младшими 16 битами (которые составляют 2304) и результат кладем в тот же регистр:</p>\\n<p><code>ori $s0 $s0 2304</code></p>\\n<p>Готово!</p>\\n<h2>Работа с большими адресами</h2>\\n<p>Если используем команду <code>j</code>, то там используется формат J-type, который выделяет 26 бит на адрес слова. Этого достаточно для адресации в пределах 256 MB.</p>\\n<p>Если же используются бранч-команды, типа <code>beq</code> или <code>bne</code>, то там на адрес остается всего лишь 16 бит. Но этого достаточно, так как такие команды используются обычно, чтобы перейти к какой-то близлежащей инструкции в коде. Используя в качестве базового адреса <code>$pc</code> мы можем перейти на команду, отстоящую на +-2^15 от текущей. К тому же адресация идет по словам, а не по байтам, так что эти числа можно умножить еще на 4. В результате получаем относительную адресацию в пределах +-128 КБ.</p>\\n<p>Ну а если не хватает, то мы всегда можем воспользоваться следующим хаком:</p>\\n<pre><code>    beq $s0 $s1 L1\\n</code></pre>\\n<p>преобразуем в:</p>\\n<pre><code>    bne $s0 $s1 L2\\n    j L1\\nL2:\\n</code></pre>\\n<h2>Синхронизация потоков</h2>\\n<p>Для реализации атомарных операций есть две специальных инструкции:</p>\\n<ul>\\n<li><code>ll</code>: load linked. Аналогична обычной загрузке, но обозначает начало атомарной операции</li>\\n<li><code>sc</code>: store conditional. Сохраняет регистр в указанный адрес в памяти, но только <em>если</em> значение указанного адреса памяти было изменено между этой инструкцией и инструкцией <code>ll</code>, прочитавшей значение из этого же адреса. При этом случае успеха он меняет значение этого регистра в 1, а в случае неудачи - 0.</li>\\n</ul>\\n<p>Таким образом, потокобезопасная замена значения, лежащего в <code>$s1</code> будет выглядеть так:</p>\\n<pre><code>again:\\n    addi $t0 $zero 1\\n    ll $t1 0($s1)\\n    sc $t0 0($s1)\\n    beq $t0 $zero again\\n    add $s4 $zero $t1\\n</code></pre>\\n<p>В этом коде мы прочитали значение по адресу <code>$s1</code> и записали туда новое значение из регистра <code>$t0</code>.\\t</p>\\n<p>На основании конструкции <em>load linked/store conditional</em> могут быть построены другие примитивы синхронизации, такие как <em>atomic compare</em>, <em>swap</em> или <em>atomic fetch-and-increment</em>.</p>\\n<h2>Системные вызовы</h2>\\n<p>Реализация системных вызовов зависит от ОС и архитектуры процессора, рассмотрим, как реализованы сисколлы в x86_64 на линуксе:</p>\\n<ol>\\n<li>Номер системного вызова кладется в регистр RAX</li>\\n<li>Аргументы вызова кладутся в регистры RDI, RSI, RDX...</li>\\n<li>Выполняется инструкция ассемблера SYSCALL. Эта инструкция переводит процессор на кольцо защиты 0 и выполняет код, на который ссылается регистр <code>MSR_LSTAR</code>, а он ссылается на функцию <code>system_call</code>. Эта функция пушит регистры в стек ядра и берет из таблицы <code>sys_call_table</code> адрес функции, в строке с номером, соответствующим номеру системного вызова, лежащему в RAX. </li>\\n</ol>\\n<h2>Компиляция программы</h2>\\n<h3>Компилятор</h3>\\n<h4>Фронтенд</h4>\\n<p>На вход фронтенду компилятора поступает код программы, а на выходе - некая промежуточная форма, не зависящая от архитектуры. Фронтенд - единственный этап процесса компиляции, который зависит от языка.</p>\\n<p>Шаги фронтенда:</p>\\n<ol>\\n<li><strong>Сканирование</strong> - читает символы и создает поток <em>токенов</em>. <strong>Токены</strong> - это атомарные единицы языка, например: зарезервированные слова, имена, операторы, знаки пунктуации. В коде <code>while (save[i] == k) i += 1;</code> токенами будут: while, (, save, [, i, ], ==, k, ), i, +=, 1, ;.</li>\\n<li><strong>Парсинг</strong> - берет поток токенов, проверяет синтаксис и строит <strong>AST - abstract syntax tree</strong>. Это дерево, в котором представлена ситнактическая структура программы.</li>\\n<li><strong>Семантический анализ</strong> - берет AST и проверяет программу на семантическую корректность. Обычно на этом этапе проверяется, что переменные и типы правильно объявлены, типы операторов и объектов совпадают. В процессе составляется таблица символов, в которую заносятся все именованные объекты - классы, функции, переменные.</li>\\n<li><strong>Генерация промежуточного представления</strong> - берет AST со 2 шага, таблицу символов с 3 шага и генерирует текст программы на языке промежуточного представления. Это что-то вроде байткода или MSIL. Обычно этот язык представляет собой подобие MIPS, но с бесконечным количеством виртуальных регистров.</li>\\n</ol>\\n<p>После фронтенда идет шаг высокоуровневых оптимизаций</p>\\n<p>Потом глобальные оптимизации - оптимизации, которые влияют на несколько блоков кода</p>\\n<p>И наконец генерация машинного кода</p>\\n<h3>Ассемблер</h3>\\n<p>На выходе из ассемблера получается object file - комбинация инструкций на машинном языке, данных и информации, необходимой для загрузки инструкций в память. Для создания бинарной версии, ассемблер поддерживает <em>таблицу символов</em>, в которой записаны соответствия меток и их адресов в памяти.</p>\\n<p>В объектном файле на UNIX обычно содержатся 6 блоков:</p>\\n<ul>\\n<li><strong>object file header</strong>: описывает размер и расположение остальных блоков</li>\\n<li><strong>text segment</strong>: содержит код на машинном языке</li>\\n<li><strong>static data segment</strong>: содержит статические данные, которые никогда не меняются</li>\\n<li><strong>relocation information</strong>: содержит адреса инструкций, в которых происходит обращение по абсолютному адресу. Блок нужен, чтобы можно было изменить адреса, когда мы линкуем модуль с другими модулями и стартовый адрес нашей памяти изменяется</li>\\n<li><strong>symbol table</strong>: содержит незарезолвленные метки, то есть внешние ссылки</li>\\n<li><strong>debugging information</strong>: инфа о том, как были скомпилированы модули, чтобы дебаггер мог сассоциировать машинные инструкции со строками исходного кода</li>\\n</ul>\\n<h3>Линкер</h3>\\n<p>Берет независимо собранные программы на ассемблере и \\\"линкует\\\" их вместе.</p>\\n<p>Работает в 3 шага:</p>\\n<ol>\\n<li>Помещает код и данные в память</li>\\n<li>Определяет новые адреса для данных и меток инструкций</li>\\n<li>Патчит внутренние и внешние ссылки</li>\\n</ol>\\n<p>Для 2 и 3 шага линкер использует <em>relocation information</em> и <em>symbol table</em> каждого объектного модуля, чтобы зарезолвить ссылки на внешние процедуры. </p>\\n<p>В 3 шаге линкер просто проходит по всему коду, отыскивает ссылки и заменяет адреса в них новыми адресами. Польза линкера в том, что патчить код ораздо проще и быстрее, чем перекомпилировать его заново.</p>\\n<p>На выходе линкера получается <em>исполняемый файл</em>. Обычно он имеет тот же формат, что и объектный файл, только теперь в нем нет незарезолвленнхы ссылок.</p>\\n<p>Далее мы видим пример того, как линкер линкует 2 модуля в один:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/7b9bf997acd4b668105e42b9a323eb97/dc311/linker-before.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 602px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 116.77740863787376%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsSAAALEgHS3X78AAAC+0lEQVQ4y32V63LiMAyFef8HLD+WW0ICCeROrkCr1Sfbmc5su8wIR4otHUlHzmaeZ6mqSrYfW9nvdrL7s5O2aeTxeMgwDDKOo3vue9ORCVvXyTiMMk2T6ay823CAh7ZtpUN04zROFiQ6RXJJUymLQu73uwXb7/fS1LXcbzepdeVcEPQNCN/vt3z/fX5+SqMotx8fhhrnsyJIzokkSSLLskittl5RB0CsgNmQTlVWtpHoyflskcqilNPxKKkirKvaAhxVPxwOVhKCkDZOg5DhivDr60ter5ehQydaUzdrKmVZyuVylTS72TO2UOcghpBUns+npcGK4Ljz0dnIYVYQteoEENj6b41aUw6GPM8VwcWKzUtQtN3DBJsrfCeVptur05vaKIOlq7rLSJsy9IPVCWdZltkzK5vPcSzZ9WrO6HIcxZJqrXlum9bt0ZpjZw8lMNoQhTQWlcAnDoCS4tNRGoEOhUCDnSYU2rCsqAwlTi1lHJICnCO9wEvK4NC41EAHGwiKQ8jeK6C6H43caw1BGSZi9DoH8nshhVKqUFRGZnVOYA7yTMpd5wYCAOiWMgro8iy3AzgG1aidn+bFdVnRPFWHFSAMXf6H2Ch4jqLIUqIRvMAhOmkHLp5OJ2sC9PmVh/Dvpx9ODvuDBai0GaCJNSi6lURtOB78lLBaU8LIQBWisxKZjm63WznqqFV+bskC3che/YLQFN1sMw0ViKo2nm++y1Al10CxBoyS1MpgjbKmdP6m6lxTfrpt0Algw69rqBcH6rZbx/G/oxemhOjWeS5ZvRd7FSjjuqnUUifLMq/zPfthQMwhf5f0YrRJvZAeBM8ylzJSqBAUG/W1UugKAIQA3E4biBxqZXVTRzYdWhdoc/WzTB25K1O7wUtLH3uieqR2gK2zDHWATE1Y0Y17zLFGDvUKnwL2gM4ma3JlGf24ull+9O760mgg7D2nMpCrk/DR4kYCISAIFmgTmmM1HL0BVEF4abeydrRlbv0H6eEpYtdZ+EhpsOab/AUbJddrfXgOSAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Before link\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/7b9bf997acd4b668105e42b9a323eb97/dc311/linker-before.png\\\"\\n        srcset=\\\"/hows-that-again/static/7b9bf997acd4b668105e42b9a323eb97/38e32/linker-before.png 163w,\\n/hows-that-again/static/7b9bf997acd4b668105e42b9a323eb97/21a34/linker-before.png 325w,\\n/hows-that-again/static/7b9bf997acd4b668105e42b9a323eb97/dc311/linker-before.png 602w\\\"\\n        sizes=\\\"(max-width: 602px) 100vw, 602px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Здесь мы видим 2 модуля. До прохода линкера <code>$gp</code> указывает на начало сегмента данных.</p>\\n<p>Процедура А в строчке 0 ссылается на строчку 0 в сегменте данных, где у нас лежит переменная Х.</p>\\n<p>В строчке по адресу 4 мы ссылаемся на адрес 0, но в <em>relocation information</em> мы видим, что строчка 4 зависит от процедуры B, а значит это адрес 0 не в нашем модуле, а в модуле B.</p>\\n<p>Процедура B в строчке 0 ссылается на строчку 0 в сегменте данных, где у нас лежит переменная Y.</p>\\n<p>В строчке по адресу 4 мы ссылаемся на адрес 0, но в <em>relocation information</em> мы видим, что строчка 4 зависит от процедуры A, а значит это адрес 0 не в нашем модуле, а в модуле A.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/397533e645af420b876ec0a66fede5ed/49b69/linker-after.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 573px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 60.90750436300174%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAABq0lEQVQoz2VT2XLDIAz0/39eOpk0id2ZpEl8gA0Y4yMvqlax3HT6IAMyWu0ukKVhoJQSfRUFfR4OdDwe6cCjaRrJhxBkRIzjSH3fS2AeYyTUj2mkgecYMxQMnGxtK9F1HVlrBch7T945qqqK8vNZ8shhz8SA9/udvq/fW+PIjTJlAFCwQnHbtsLAO089/0fhx27HDX8bTdNE18uF8tNJmKIe4waIhWkMlY+HFI5rV4A/OJfnuTQDGJg2dUW3sqaiNFQzkaauX4D4zPMsHZdloefzKWsEukIyQK2xokCkcU0InlxMZNJCNo6yNw2JMnRUoyXCa0SRW/2EZw2DYRRwzuFfx5YYDsdNkUOdMAQzZaWBHKxAQ0iFFSpLDoYBbD/QrZ+pcb0owf5MJaixEnH4Ixed5TDWtajitYPHrKhjYFUogDhR0L7wqRV8H3GqyAVcGzAsS9rv9yzTbaeM/2gKkImZqU3bPVSWcf0Bg/XOwZ+qrMRHeIe83D3e2/kge/8Bqsz3QOHrhI2w1MNQvwLkAhxMV+syeTJMX5/X+zOLq3fKAHOEPj1VpnPU/QCeCpGBn3BmawAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"After link\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/397533e645af420b876ec0a66fede5ed/49b69/linker-after.png\\\"\\n        srcset=\\\"/hows-that-again/static/397533e645af420b876ec0a66fede5ed/80ceb/linker-after.png 163w,\\n/hows-that-again/static/397533e645af420b876ec0a66fede5ed/654cc/linker-after.png 325w,\\n/hows-that-again/static/397533e645af420b876ec0a66fede5ed/49b69/linker-after.png 573w\\\"\\n        sizes=\\\"(max-width: 573px) 100vw, 573px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Мы видели ранее, что после линка сегмент текста начинается по адресу <code>0х40 0000</code>, а сегмент данных - по <code>0х1000 0000</code>. Текст процедуры А располагается по первому адресу, а ее данные - по второму. Заголовок процедуры А говорит, что ее текст занимает <code>0х100</code> байт, а данные - <code>0х20</code> байт, поэтому текст процедуры B располагается сразу после А по адресу <code>0х40 0100</code>, а ее данные - по <code>0х1000 0020</code>.</p>\\n<p>Шаг 1 закончен. Теперь линкер обновляет адреса в инструкциях. Он проходит по каждой строчке в сегменте <em>relocation information</em> и патчит соответствующие инструкции. Чтобы определить используемый формат, он читает поле <em>instruction type</em>.</p>\\n<p>В нашем случае используется 2 типа команд:</p>\\n<ol>\\n<li><code>jal</code>. C ними все просто, потому что они используют абсолютные адреса. <code>jal</code> по адресу <code>0х40 0004</code> должен обращаться к 0 строчке процедуры B. B у нас лежит по <code>0x40 0100</code>, значит и целевой адрес такой же. Аналогично <code>jal</code> по адресу <code>0x40 0104</code> преобразуется в <code>0х40 0000</code>.</li>\\n<li><code>lw</code> и <code>sw</code> посложнее, потому что они используют относительные смещения от <code>$gp</code>. Как мы видели ранее, <code>$gp</code> инициализируется значением <code>0х1000 8000</code>. В строчке <code>0х40 0000</code> нам нужно обратиться к переменной Х, то есть бывшей 0 строке сегмента данных процедуры А. 0 строка данных А теперь получила адрес <code>0х1000 0000</code>. Значит ее относительный адрес относительно <code>$gp</code> будет <code>0х-8000</code>. Аналогично в строчке <code>0х40 0100</code> относительный адрес меняется на <code>0х8020</code>.</li>\\n</ol>\\n<h3>Загрузчик</h3>\\n<p>Кладет программу в память, чтобы она могла выполниться.</p>\\n<p>Для этого выполняет следующие шаги:</p>\\n<ol>\\n<li>Читает заголовок программы в память, чтобы определить размер сегментов кода и данных</li>\\n<li>Выделяет адресное пространство, достаточное чтобы вместить текст и данные</li>\\n<li>Копирует инструкции и данные из исполняемого файла в память</li>\\n<li>Копирует параметры главной программы на стек</li>\\n<li>Инициализирует регистры и устанавливает stack pointer</li>\\n<li>Переходит к процедуре запуска, которая копирует параметры в регистры аргументов и вызывает главный метод программы</li>\\n</ol>\\n<h3>Динамически загружаемые библиотеки</h3>\\n<p>Поблемы вышеописанного способа линковки:</p>\\n<ol>\\n<li>Все библиотеки становятся часть исполняемого файла, новая версия библиотеки означает перелинковку.</li>\\n<li>При старте в память загружаются все функции всех модулей даже если эти функции не запускаются</li>\\n</ol>\\n<p>Эти проблемы решают динамически связываемые библиотеки (DLL). В таком способе линковки библиотеки не линкуются и не связываются, пока программа не запущена. </p>\\n<p>Для этого:</p>\\n<ol>\\n<li>Объектный файл динамически загружаемой библиотеки содержит дополнительную информацию о расположении процедур внутри нее</li>\\n<li>При старте загрузчика запускается динамический линкер, который использует эту информацию для связывания библиотек и обновления всех внешних ссылок</li>\\n</ol>\\n<p>Недостаток первоначальной версии был в том, что в память все равно загружались все функции программы, а не только те, которые будут использоваться. Поэтому в следующей версии каждая функция линкуется индивидуально только <strong>после</strong> того, как она была вызвана.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/4bf2dd0b6774c85dc85860cdac175646/1828f/lazy-procedure-linkage.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 117.87234042553192%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAABYlAAAWJQFJUiTwAAADnklEQVQ4y41V2W4bRxDU//+LH4IgQBB/QJ6SGLYESRQpcknufc/O3kelupekJcOJPcBghrPN2u7qmto7cCzLgrIsdbZti67rdMpepjyXIfs0TWGt1ef9ZTZNg2EYNOYOKyK22y3c8xnLPOtDDeC+rmtM06RheZ7j6fFRz2aeFbZG2/cYOAX0BtiN0/r2osDCwIcwx2/7BB0DJRMBnBnXcF8xOwEa+g6/bCM8RIWCS5wCTqwm6UZ4RYVzVqAZZ+yTAp+8BLYf0UnJ8wQzLohsy2c5Ytug7AbcE+xY1hjH8T1gwwyrqlIOZbzEBT462S1QMmiZouxLqYIvwDTg932KbVopTe8AS2ZSGoPCVCgIXHCflQZRWcHy97KQSwZGVa1nIWdQrDGn3Gj8O0CvGbBxTtidXaT8U1k3uhqu0lGmAMsMnTjF82aDKEkVoGYjbNPcuv4VsB7wutvBc130bERMrtqu104bU2mJFQH3YYKTc9Cs06ZHUrcaIx2WziugdC+oe2SUxDQwyFj8+pog5JoK+ZfOW9IW5CV114Itxp9ujr+CQmNycq+VXDNM2eW8XjuXNx0ss5NVwCvyI8Ju+GaRi/CWkw7LjCSrgDGGGff9peR+JtndBM/z4AWhlmoplapptZSVQ96kYUbST6pZUUXNaYd1P88zrjfubiBg0I4IfA9xHCuHb4cIXm6MoT6rccb/DQUkHiJ2We6kXKGqyLGLMvwdUpNsRsvzVdgr6PWP35s3Dg11mJHYlPxU5OX+5OOPzQlekqG+lvwN4H8NAi7w2wlPBwcvJ+qQUjCtNGZtzpVD8/OAwJkl7+g2zn6vMkmTBEWeIcuy1UUuHP40oGG3drstnp6f8cz5st3hn89f4LPz4jjvOVx+zGFNwJpa0vLGHg9ujA+Prl6t9uY27PK0/LjLEhNRNl6aw+dNkNtwCCJs/EjPtClY1L5Sir1l05rLi96u4kyaoegwbAd17A3nka4t4pYKxFjlNog9iTm49MstzUEq0TJ5LqvcZ9XrW3OQBjiHA47Ho67DReCrsFeD9U2N0PcRBIEaSRAnGjPP3zi2XKHaVmqyGAd8cjx8ePKUw+v3Qwy2kStpyvUDZY3yfO+vVtZ9zXBBTCvyWU5I00wqq6VtwhQBjVTdRXTIlwbMUHiWT4CY7CHO8MpPQknTEHPQpgj6mel7LOV4OuNMqURRBJdnYRjeOiifzz3Fv3c4SYnEua6HMzkXDxCqJOZfDtk85znLY0YAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Lazy Procedure Linkage\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/4bf2dd0b6774c85dc85860cdac175646/10273/lazy-procedure-linkage.png\\\"\\n        srcset=\\\"/hows-that-again/static/4bf2dd0b6774c85dc85860cdac175646/9b14a/lazy-procedure-linkage.png 163w,\\n/hows-that-again/static/4bf2dd0b6774c85dc85860cdac175646/94962/lazy-procedure-linkage.png 325w,\\n/hows-that-again/static/4bf2dd0b6774c85dc85860cdac175646/10273/lazy-procedure-linkage.png 650w,\\n/hows-that-again/static/4bf2dd0b6774c85dc85860cdac175646/1828f/lazy-procedure-linkage.png 940w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Когда вызывается функция библиотеки, то: происходит переход по адресу, лежащему в некой переменной (первый прямоугольник). Эта переменная лежит в области данных (второй прямоугольник) и при первом вызове указывает на заглушку (третий). Заглушка загружает в регистр идентификатор функции и переходит в динамический загрузчик (четвертый). Загрузчик по идентификатору определяет, где лежит эта функция, динамически ее линкует, загружает и вызывает. А вместе с этим он переписывает переменную из 2-го прямоугольника так, чтобы она указывала сразу на адрес загруженной в память реальной функции. Таким образом при последующих вызовах мы попадаем сразу в функцию, правда через адрес, лежащий в переменной. Но количество инструкций остается тем же, просто вместо <code>j</code> используется <code>jr</code>.</p>\\n<h1>Архитектура ARMv7 (32-bit)</h1>\\n<p>Для ARMv8 мануал <a href=\\\"https://www.element14.com/community/servlet/JiveServlet/previewBody/41836-102-1-229511/ARM.Reference_Manual.pdf\\\">здесь</a></p>\\n<p>Основное отличие от MIPS: меньше регистров, больше схем адресации</p>\\n<table>\\n<thead>\\n<tr>\\n<th></th>\\n<th>ARM</th>\\n<th>MIPS</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>Размер инструкции</td>\\n<td>32</td>\\n<td>32</td>\\n</tr>\\n<tr>\\n<td>Адресное пространство</td>\\n<td>32-битное</td>\\n<td>32-битное</td>\\n</tr>\\n<tr>\\n<td>Выравнивание данных</td>\\n<td>Есть</td>\\n<td>Есть</td>\\n</tr>\\n<tr>\\n<td>Схем адресации</td>\\n<td>9</td>\\n<td>3</td>\\n</tr>\\n<tr>\\n<td>Регистры</td>\\n<td>15 х 32 бит</td>\\n<td>31 х 32 бит</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>Сравнение инструкций:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/9de5d07b55cdf8c16e41d063247d091f/83be2/arm-mips-instructions.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 88.95612708018155%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsSAAALEgHS3X78AAAC7ElEQVQ4y2VUy27TUBDN77FGLFARiC1ijZBgx+8gEGwroaJCARUB6iNpXo5feTmOHb/i2E1ymDOx01Iije6945kzZ87cm8Zbt8C94wgPv8d4cBLjyWmKx6cZXl8s8aqy579SHPxI8Ej8z35neHme4b7EPv2Z4UB8b1q55Cd4cZahYYRLfBom+DrJcDLNcdj38OHcwjcnwLE5wxfLx8koxqExw7s/Bo4GPr65IY7cGB8vLLw/G+CoO8RnN1J/Y1sWALaof2WygNtrI5yOEfse0sAH1iWKOMTENJDOZyjTWHwFpvZAzh42eQYUOa7F31itVijXa6w3W4UNwhAXl5dwHBfebIbRaAx/Pke4WKDXNzCZeojiGPmqgGlaEuMjzTJky1z9jaIocPsXCmBTAD3P030gYFEUwfd9uI6jvoWAJ0kCy7JgGAbG47GewyDYMcykQp7nIPhcAGwJpJ++2h8JCBO5V598t20bk8lEz4wnqAISmSxioTyTNsmORXimMXAmPgJwX8eSMdlqXBTvGN5tmQHdble0G2EsNnRdBSfIdDpVJsvlUlm58o1AdSdJXDFcy1C2292kmdhpt9HpdFQfVicAtRsNh7rP0kxXMqSPBXmOJVcZbjabf4bSarbQ7/UUuNZItZWWmZhK21ztaijUl2eSaSi6mF4fAfdFQ06ZwdxTAsYEog8LUAoadXaEoSNFGMcYxv7fcqWhOTDR6/aUcSF3jivZpGmqyTTqm1RstWW9hwJ4u2VWuWq10BUNW80m2ldX++o9kaEeSD0Utn8zlArw+vp6D8rETrsjDAfaFlmQHduy5GUwiVrRqCm/cRi0oL42pErRuUYVQ7ZMZmVZqrGQdevCc6WWbJn7/cW+2zIrss1+vw9P3u0iXEiRSC+2ZZq7ohUj27J3RKKdb//07gKS4UAGwASd6nAkbzqQiTqYy5uunyOnzDfO/Q1DOVBDTprA9RVZCDBZMZnfOAxq6su/C/fMYRHua1kY+xeMAUfzmC0qQQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"ARM vs MIPS instructions\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/9de5d07b55cdf8c16e41d063247d091f/10273/arm-mips-instructions.png\\\"\\n        srcset=\\\"/hows-that-again/static/9de5d07b55cdf8c16e41d063247d091f/9b14a/arm-mips-instructions.png 163w,\\n/hows-that-again/static/9de5d07b55cdf8c16e41d063247d091f/94962/arm-mips-instructions.png 325w,\\n/hows-that-again/static/9de5d07b55cdf8c16e41d063247d091f/10273/arm-mips-instructions.png 650w,\\n/hows-that-again/static/9de5d07b55cdf8c16e41d063247d091f/83be2/arm-mips-instructions.png 661w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Обратите внимание, в ARM нет инструкции для деления!</p>\\n<p>Сравнение схем адресации:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/84d2c264d56a99cd9c89bb235a399edc/7737d/arm-mips-addressing-modes.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 43.730886850152906%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABuElEQVQoz21QTU/VUBDtP2RlYgLEpb9BNgZ/iUu3xohCgiEav0h0gYj09cFre19LX3ltb+9HP4HjzDU1MbI4OTPnzpyZud7GJ42tY4Od0wa7Py2enlo8OTHY/qrx4LPCFvGjY41N4mdn1uWMbdIeflFOe/xNY+Ojwom8gff8e4gXP5Z4dZ7iw5XF+9TgiLAvDN4Ijb2wxutFhbcUH0Z/mPO9ULr3d6QdCIWXlxKZ6eDl4RxlEiOLLtErCXQWt40GGH3jcGcVcNNj1LXju4by1gC3pBmKh5b6DMauhXf26xxRLOD7MwTBHLMgwFW2QiyWWOU5pFJYFyWUMbher6G0QVFWKCsJbax7q5V2edOSYRiGyKkxjmMIQrJcoiwKdF2Hvu9hrYUiU45VXTtdk4GhAdM7a5wzexfzC2RZhoiMoyhyCGjLaxoyDMM/hvU9hpPRX0Pf9yGEwJxMwsUCwWzmDBcUcxGblGUJS3FBm7NWVRWklE6TFGutXd7yybwZn5smCdI0RULMRTyNCyZTzmtqYuaNDZlMm3EdmzrDfLUCg6eO44iBzuBTuJjRNM1/5/E3sM4a81THX/QbQb2bWuvr9mIAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"ARM vs MIPS addressing modes\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/84d2c264d56a99cd9c89bb235a399edc/10273/arm-mips-addressing-modes.png\\\"\\n        srcset=\\\"/hows-that-again/static/84d2c264d56a99cd9c89bb235a399edc/9b14a/arm-mips-addressing-modes.png 163w,\\n/hows-that-again/static/84d2c264d56a99cd9c89bb235a399edc/94962/arm-mips-addressing-modes.png 325w,\\n/hows-that-again/static/84d2c264d56a99cd9c89bb235a399edc/10273/arm-mips-addressing-modes.png 650w,\\n/hows-that-again/static/84d2c264d56a99cd9c89bb235a399edc/7737d/arm-mips-addressing-modes.png 654w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p><strong>Следующий блок относится только к ARMv7 и более ранним моделям. В ARMv8 от условно-выполняемых инструкций отказались</strong></p>\\n<hr>\\n<p>Еще одно важное отличие: для выполнения условий условных переходов в MIPS используется содержимое регистров. В ARM же используется 4 условных бита (<strong>condition codes</strong>), которые хранятся в <em>program status word</em>: negative, zero, carry, overflow. Эти биты могут быть изменены любой инструкцией, но выставлять их необязательно.</p>\\n<p>Например, CMP (Compare) вычитает один операнд из другого и выставляет условные биты соответственно результату вычитания. CMN (Compare negative) <em>складывает</em> операнды и так же выставляет условные биты соответственно результату. TST делает операндам логическое И и выставляет все условные биты кроме overflow, а TEQ делает им OR и так же выставляет все биты кроме overflow.</p>\\n<p>Необычная особенность ARM заключается в том, что каждая инструкция может быть выполнена или не выполнена в зависимости от состояния условных битов. Каждая инструкция начинается с 4-битового поля, которое определяет, будет ли инструкция превращена в nop. Засчет этого можно сэкономить время и место, когда нужно, например, перепрыгнуть через одну инструкцию - теперь не нужно вставлять дополнительное условие и инструкцию j для этого.</p>\\n<hr>\\n<p>Сравнение форматов инструкций: </p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/48d4b0c986436b5e980dca30f60cc6a2/0f45d/arm-mips-instruction-formats.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 81.47590361445783%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsSAAALEgHS3X78AAACeElEQVQ4y22UaU+iQRCE3///T9wvum7iB3WjJoInyimigNwIyn0qaG0/vU7CHpN0BnqG7qrqGiJtrPV6rcVioVKxqNubG2UyGd3f3+vu7s73l5cX9V5fNRqNVC6XPZ/P5/2s2WhqOp0qokC/39dwONTq/V3L5VJZK3R9daWry0slEgmlkklls1kNBwN1Oh2NreDT05OfJ29vfa9Vq14n+vj48EKge3t703QyVTwW0/edHf08PFS/19N8PtdsNtOgP9BkMrHCQ0cDAxodHR3p29aWEtfXijYpf35+igYUgBY/Jsd6t6awgUEI7pGjGff5/kfB1Wrlh3nT5iwed7o3FtDPpNPqdrumYU8Do96o11W3qBh1otls+rlriNCL+cLRgKRoQ0HsXC6nQqGgUqnkP4Lmq92lYM+kaLfbalmhVqvlnzmLAk0WNMbjsWu4s72tw4MDvxQojYYjNRoNpQ1twSabTqWVtIE9PDz4xGu12u+CIcICNWgoRLO1ScHOnTA8mLBvBrn/agiCk+NjxU5PPaBdq9bcKqAomwTkKpWKR9Uswxm0ozAtFijo0jWvdZ6fXXTCNfsaBuZmx3O4gEAmwo0NKuAGa5BEwx+7u64hBeazuecuLy58YOj1+PjoPoQNGuIMzB397UE0onvbJsdAaEKAIPgwoOF1EaBkaMj1j4bQRw865+wVgAL9KN7tdN1rzyYH0wZ9CPL9nj096NIlTBE0CI6ReaepVMpN27QCHvYZXas2DM9/RWgQhUGwwls+PzvX3t6eDvb3/a3yz4K5Q5BDN/RkR09A1PHhJmX/ozDaUII2SHgRiM2PyBVt90JWgBcSJs49tPwFTGumq8H0V00AAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"ARM vs MIPS instruction formats\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/48d4b0c986436b5e980dca30f60cc6a2/10273/arm-mips-instruction-formats.png\\\"\\n        srcset=\\\"/hows-that-again/static/48d4b0c986436b5e980dca30f60cc6a2/9b14a/arm-mips-instruction-formats.png 163w,\\n/hows-that-again/static/48d4b0c986436b5e980dca30f60cc6a2/94962/arm-mips-instruction-formats.png 325w,\\n/hows-that-again/static/48d4b0c986436b5e980dca30f60cc6a2/10273/arm-mips-instruction-formats.png 650w,\\n/hows-that-again/static/48d4b0c986436b5e980dca30f60cc6a2/0f45d/arm-mips-instruction-formats.png 664w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Еще в ARM есть сохранение и загрузка групп регистров. </p>\\n<h1>Архитектура x86</h1>\\n<p>Архитектура поддерживает следующие комбинации оперендов в инструкциях:</p>\\n<ul>\\n<li>регистр-регистр</li>\\n<li>регистр-константа</li>\\n<li>регистр-память</li>\\n<li>память-регистр</li>\\n<li>память-константа</li>\\n</ul>\\n<p>Не поддерживается только комбинация память-память. В это время, в ARM и MIPS большинством инструкций не поддерживается адрес памяти в качестве одного из операндов.</p>\\n<p>Все регистры, начинающиеся с Е, являются расширениями 16-битных регистров до 32-битных. Большинство инструкций имеют только 2 операнда, это значит что один из операндов часто является и входным и выходным.</p>\\n<p>Среди используемых методов адресации есть:</p>\\n<ul>\\n<li><em>based mode with 8- or 32-bit displacement</em> - адрес равен содержимое регистра плюс сдвиг на 8 или 32 бита</li>\\n<li><em>base plus scaled index</em> - адрес равен содержимому регистра плюс 2^scale * index, где scale = 0, 1, 2 или 3. Этот режим нужен, чтобы избежать умножения на 4 при адресации по байтам. scale = 1 используется для 16-битных слов, 2 для 32-битных, 3 - для 64-битных. 0 означает, что не скейлим.</li>\\n<li><em>base plus scaled index with 8- or 32-bit displacement</em> - комбинация первых двух режимов</li>\\n</ul>\\n<p>Каждая инструкция в 80386 может занимать от 1 до 15 байт. Обычно опкоды включают указание, используется ли 8-битный или 16-битный операнд. Некоторые опкоды включают в себя указание метода адресации и регистра. Другие инструкции включают дополнительный байт опкода, называемый <strong>постбайт</strong> содержащий метод адресации и регистр. Режим адресации <em>base plus scaled index</em> использует еще и второй постбайт.</p>\\n<h1>Архитектура ARMv8 (64-bit)</h1>\\n<p>Первая архитектура ARM, поддерживающая 64-битное адресное пространство.</p>\\n<p>По сравнению с ARMv7 отброшены почти все необычные возможности, которых не было в MIPS:</p>\\n<ul>\\n<li>нет условного выполнения инструкций</li>\\n<li>под константы выделено простое 12-битное поле, а не функция, производящая константу, как было в v7</li>\\n<li>нет загрузки и сохранения групп регистров</li>\\n<li>PC больше не регистр</li>\\n</ul>\\n<p>Добавлены новые возможности, которые наоборот оказались полезными в MIPS:</p>\\n<ul>\\n<li>добавлены регистры общего назначения, теперь их тоже 32. Один из регистров привязан к константе 0</li>\\n<li>режимы адресации работают для всех размеров слов</li>\\n<li>добавлена инструкция деления</li>\\n<li>добавлены эквиваленты команд BEQ и BNE</li>\\n</ul>\\n<p>В целом, главное сходство между ARMv7 и ARMv8 это имя.</p>\\n<h1>Арифметика в компьютерах</h1>\\n<h2>Сложение и вычитание</h2>\\n<p>При вычитании мы можем либо вычитать, либо складывать с отрицательным числом, полученным по методу <em>two's complement</em>. При переполнении в 32-й бит знака попадает перенос из сложения битов на 31-й позиции и знак меняется. Если складывать A и B, а N - количество доступных бит для представления числа (включая знакомый), то результат сложения при переполнении будет равен <code>A + B - 2^N</code>.</p>\\n<p>Пример: </p>\\n<p>допустим, у нас есть только 4 бита и мы складываем 5 и 5:</p>\\n<pre><code>  0101\\n+ 0101\\n  ----\\n  1010 == -6\\n\\n  N = 4\\n  Результат равен 5 + 5 - 2^4 = -6\\n</code></pre>\\n<p>Для <code>unsigned</code> операций MIPS НЕ выбрасывает исключения (прерывания) при переполнении, потому что чаще всего беззнаковые операции выполняются для адресной арифметики и там переполнение может быть не важно. Для <code>signed</code> операций исключения выбрасываются.</p>\\n<p>При исключении/прерывании адрес инструкции записывается в регистр и происходит переход на инструкцию обработчика этого прерывания. Адрес инструкции сохраняется, чтобы после обработки исключения программа могла продолжить выполнение. В MIPS есть регистр EPC (exception program counter), в который записывается адрес этой инструкции. Инструкция <em>mfc0</em> используется для загрузки этого значения из EPC в регистр общего нзаначения, после чего можно сделать джамп на соответствующую инструкцию. Причем по соглашению значение EPC пишется в специальные регистры $k0 или $k1, так как если писать в другой регистр общего назначения, то по возвращению в функцию, из которой было выброшено исключение, никто не будет восстанавливать значение этого регистра, и оно будет потеряно.</p>\\n<h2>Умножение</h2>\\n<p>Рассмотри первую версию множителя.</p>\\n<p>В качестве примера умножим 8 на 9 столбиком:</p>\\n<pre><code>      1 0 0 0\\n    X 1 0 0 1\\n    ---------\\n      1 0 0 1\\n    0 0 0 0\\n  0 0 0 0\\n1 0 0 1\\n-------------\\n1 0 0 1 0 0 0\\n</code></pre>\\n<p>Мы видим, что первый операнд (множимое) на каждом i-м шаге сдвигается на одну позицию влево и в зависимости от значения i-го бита множителя либо идет в сумму, либо нет. То есть на каждом шаге:</p>\\n<ol>\\n<li>если младший бит множителя = 1, то множимое суммируется с текущим результатов</li>\\n<li>множимое сдвигается на 1 позицию влево</li>\\n<li>множитель сдвигается на 1 позицию вправо</li>\\n</ol>\\n<p>Эти 3 шага повторяются 32 раза - по количеству бит в операндах. Если бы каждый шаг занимал один такт, то любое умножение занимало бы 96 тактов. Однако операция может быть ускорена засчет распараллеливания - операции сдвига и сложения выполняются одновременно, засчет этого мы получаем 34 такта.</p>\\n<p>Этот алгоритм может быть реализован в виде следующей схемы:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/48f0f1083ad066c8d468d19034217370/83c1d/multiplication-hardware.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 591px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 53.299492385786806%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABdUlEQVQoz5WT63KCQAxGef/3syozgoiAotxF8Uaak3YZdfqnmUHZ9cvJl+zqjeMoPMQwDFLXtXRdJ7vdTsIgkLIobN21nVyvV9M5/V/hvS6appHb7SbP59OAgQKL4/EX2Nre/X6foK9m3J7HB5V5yrKUpm6k1WSeLMtkG28lDEODR+vIHH+6fAV7OEqTRE6nkyasrW0cImCd5/nkiuj7/g306dgDgBtaSgBre7ROm8DSNJXL5WKJFO+1MO9VVZlr3/dNPzmk1bqqJ9FRZxZFkcEQxnFsroC6UbBu9TcObblY6ndo+lE7MyAgAiiQZLu1vfP5/HaCdMOcH4+HjShNUvmazVSfTF0ZsNBBN3pd2OTaLOZzORwOJmAPdwSQTEfgHDMmdG7muLdDyfe5JTsXFMAdQkZA2+gYBSe+2WzEX/qWBwQ4RShoDkly7gDTQrBa/VwbbX+/31shigBAy7u7boMCgdopM7edJjIbwFxkICS6f8Z/4huw307qz6lMjwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Multiplication hardware\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/48f0f1083ad066c8d468d19034217370/83c1d/multiplication-hardware.png\\\"\\n        srcset=\\\"/hows-that-again/static/48f0f1083ad066c8d468d19034217370/b431c/multiplication-hardware.png 163w,\\n/hows-that-again/static/48f0f1083ad066c8d468d19034217370/d82d3/multiplication-hardware.png 325w,\\n/hows-that-again/static/48f0f1083ad066c8d468d19034217370/83c1d/multiplication-hardware.png 591w\\\"\\n        sizes=\\\"(max-width: 591px) 100vw, 591px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Обычно эту схему усложняют за счет того, что в блоке Product мы можем хранить одновременно множитель (в правой половине) и результат (в левой половине). ЭТо возможно благодаря тому, что на каждом шаге у нас множитель уменьшается на 1 знак, а результат - увеличивается.</p>\\n<p>Если нам нужно умножить знаковые числа, то мы сначала запоминаем их знаки, обрубаем их, перемножаем два 31-битных числа, а затем выставляем отрицательный знак если оригинальные знаки различались.</p>\\n<p>В новых множителях схема гораздо сложнее. К каждому биту множителя подсоединяется свой 32-битный сумматор, которому на вход подается выход предыдущего сумматора и результат AND над множимым и соответствующим битом множителя. Причем все сумматору соединяются не последовательно, а в виде бинарного дерева, чтобы уменьшить количество операций. В результате мы ждем не 32 последовательных сложения, а только 5.</p>\\n<p><img src=\\\"fast-multiplication-hardware.png\\\" alt=\\\"Fast multiplication hardware\\\"></p>\\n<p>(рисунок немного неверный, так как на каждом следующем слое должно быть больше бит для хранения результата сложения. На втором слое - 34, на третьем - 36 и т.д.)</p>\\n<p>В MIPS есть специальные регистры для хранения результата умножения 32-битных регистров, называемые Hi и Lo, и инструкции mfhi/mflo, означающие move from hi, move from lo.</p>\\n<p>Например, при умножении $s2 на $s3:</p>\\n<pre><code>mult $s2, $s3 # верхний бит результата окажется в Hi, нижний бит - в Lo\\nmfhi $s0      # перемещаем верхний бит в s0\\nmflo $s1      # перемещаем нижний бит в s1\\n</code></pre>\\n<h2>Деление</h2>\\n<p>Пример деления столбиком, делим 1001010  (делимое) на 1000 (делитель):</p>\\n<pre><code> 1001010 | 1000 &#x3C;- делитель\\n-1000    |------\\n-----    | 1001 &#x3C;- результат\\n    1\\n    10\\n    101\\n    1010\\n   -1000\\n   -----\\n      10   &#x3C;- остаток\\n</code></pre>\\n<ol>\\n<li>Берем максимум знаков слева делимого, чтобы было больше делителя, в нашем случае это 4 знака и 1001. </li>\\n<li>Делим полученное число на делитель, то есть 1001/1000</li>\\n<li>Результат деления пишем в результат - 1</li>\\n<li>Остаток от деления (1) пишем под вычитанием, приписываем один знак от делимого - 0.</li>\\n<li>Если полученное число (10) меньше делителя, то в результат пишем 0 и приписываем еще один знак делимого. Так до тех пор, пока не сможем разделить полученное число на делитель. В нашем случае мы не смогли разделить 10 и 101 на 1000, поэтому в результат попало два нуля, а вот 1010 уже смогли, поэтому после двух нулей стоит 1.</li>\\n</ol>\\n<p>Итого, алгоритмически деление может быть осуществлено следующим образом:</p>\\n<ol>\\n<li>32-битный делитель представляем как 64-битное число, у которого делитель записан в левой половине, а правая заполнена нулями</li>\\n<li>В остаток вначале операции записывается делимое</li>\\n<li>\\n<p>Затем в цикле повторяем 33 раза:</p>\\n<ol>\\n<li>Вычитаем делитель из остатка, пишем результат в остаток</li>\\n<li>Если остаток >= 0, сдвигаем частное влево на 1 позицию, выставляем правый бит в 1. Иначе - обратно прибавляем делитель к остатку, после чего сдвигаем частное влево на 1 позицию, выставляем правый бит в 0</li>\\n<li>делитель сдвигаем вправо на 1 позицию</li>\\n</ol>\\n</li>\\n</ol>\\n<p>Таким образом, в шагах 3.1-3.2 мы определяем, является ли текущий остаток большим, чем делитель и если да, то пишем в результат 1 и вычитаем делитель из остатка, а если нет, то пишем 0 и оставляем остаток нертронутым.</p>\\n<p>Такое деление называется <em><a href=\\\"https://en.wikipedia.org/wiki/Division_algorithm#Restoring_division\\\">восстанавливающее (restoring)</a></em>. Есть еще <em><a href=\\\"https://en.wikipedia.org/wiki/Division_algorithm#Non-restoring_division\\\">невосстанавливающее (nonrestoring)</a></em> - оно более быстрое. В нем на 2 шаге не происходит восстановления остатка, а вместо этого прибавляет делитель к сдвинутому остатку на следующем шаге, так как <code>(r + d) * 2 - d = 2r + 2d - d = 2r + d</code>.</p>\\n<p>На картинке изображен пример деления 7 (00000111) на 2 (0010) этим алгоритмом:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/d167f9259082337ce37e314e9f9a6794/7737d/division-example.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 57.645259938837924%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAACdklEQVQoz1WSzYvTUBTF+2cKA4K4cSOIuBhEcOlC/D9cCIIzzMKFji5GpI79mLZpkibvJXlNXl6T5rvTVPR481JGXBzeDe9y8jv3vsGLWYOX8wYPrxvc/7HDybDB00mD02mDe99KnHwv8WBY4fnNDq/tFk9GNR6Pd3hltnj0s8Ez6n1j73FK92dhi8EXpnAVbPF+wvB2aOLdyMFXL8WVyPBZlLgUBT7xFJeOxMXY0ncfpgxnIwvnMw8f7QjnkxUuFj5WSYkB8AfAb6RhAOUzZJFAJkMUSuI2S9EWW606z8ACgUNVQHIH7nKOhPpVVsBQBcI0x21dYbBvD9i3LTj3YBhLWJYNx2VIkhRJmiLdZtiSVLqF4XDkeQ4r3GDqx2ByAxFT7fhw1xHKigxbMtvv92TI4axW+uSMYy0EYimhlNKSpIXr0Y8S2NQ3Xxjgrgs3TjFep7CjBEVRYHAgw87U8zyYyyVWNpkyRlRbZFmmmwqiSjQhQ0Xf1jrGjRfBI8L1kZCtJaqq7glbHZmTma3NGCkIAkRRhDiOoUhSbYjQ7wmp745QJphqwk1PqA0pckdomaaO3dXdrPIs788j4cJ2NaEpYkx4CF8qBCrBtbuGE6qe8HA4oFNHZpkWHIc2SPKIWNIMy7JESlRRrGCwQNcWEc7mC53KFRHGpgOb+/8Iu6X4RGVblib0j4Sd2W6302e3dcvl/80wiBMISbRk6PoCdX0k/EViNI+lsdRz7BfD9Qy7hdwRcqHrJSWZ3Mx0KicIMTRo6yvWE3YEt6QuXuD7EPR4JRlV9KZKaujua6qzvICIYqpL+GmB1YYeeF5iu1FglEoEvu79C/HEbDzBQnEMAAAAAElFTkSuQmCC'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Division example\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/d167f9259082337ce37e314e9f9a6794/10273/division-example.png\\\"\\n        srcset=\\\"/hows-that-again/static/d167f9259082337ce37e314e9f9a6794/9b14a/division-example.png 163w,\\n/hows-that-again/static/d167f9259082337ce37e314e9f9a6794/94962/division-example.png 325w,\\n/hows-that-again/static/d167f9259082337ce37e314e9f9a6794/10273/division-example.png 650w,\\n/hows-that-again/static/d167f9259082337ce37e314e9f9a6794/7737d/division-example.png 654w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>На следующей картинке изображена первая версия делителя:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/39ac247a99f16a60eb7972d4f2158160/4946c/division-hardware.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 540px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 59.074074074074076%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAABlklEQVQoz3WSh46DQAxE+f8PhDQplITeUkhCms/Pp0VcdEEyC7v27HjG3vv9Fp7H4yHjOMr9fpfL5SJlWcr5fJ72n8+nkOvy3fr5eLwAqatKTqeTgaRpKosgkLqube94PErbtlPRN7AJEBaHvpfX62Xfl2EwEJgmcSyxxma9lrZpLMeBzsPtebColF2R58bucDgYEAC+70uWZcaOM+J2u/3LzIF6JDQKuksS24ABEsRRJNfr9U8RuQ6wbVrTedBu5vp6sAEMZr22XRal6dbUjbEEdG4WgOTu93s930hRFHJSeaaWeZHcaVskRWEoubbfd52BAnLVsAu73gAb1XI4D7JaLs28QKVxHnhOZMwgEYdhxf/8MeMUlPYgQLuBH0ie5XYh+rLvIThA3BAqu+ViYcm4jGFOx0ELcDyJE5Pkc3TQ0gAxhFsJ3AacAnRDW2QgERlS/V6vVr9TodrBiovdrFrLGAFLZwosozCS3W5nenLBqLrBlHM6QFeKP+fQxqbS9igimLntdmtr13YGQiswcSug3+aQ+AF0CJvvm5RuswAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Division hardware\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/39ac247a99f16a60eb7972d4f2158160/4946c/division-hardware.png\\\"\\n        srcset=\\\"/hows-that-again/static/39ac247a99f16a60eb7972d4f2158160/ae4e1/division-hardware.png 163w,\\n/hows-that-again/static/39ac247a99f16a60eb7972d4f2158160/e0ba1/division-hardware.png 325w,\\n/hows-that-again/static/39ac247a99f16a60eb7972d4f2158160/4946c/division-hardware.png 540w\\\"\\n        sizes=\\\"(max-width: 540px) 100vw, 540px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<ul>\\n<li>Divisor - делитель</li>\\n<li>Quotient - частное</li>\\n<li>Remainder - остаток</li>\\n</ul>\\n<p>В новых делителях используется более сложная схема. Использовать тот же подход, что и в сложном делении мы не можем, так как на каждом шаге нужно знать результат сравнения делителя с остатком. Но есть техники, позволяющие производить более 1 знака частного за шаг. Техника <em>SRT division</em> пытается <strong>предугадать</strong> несколько бит частного, используя поиск по таблице по верхним битам делимого и остатка. В последующих шагах алгоритм может исправить предсказания, если они оказались неверными. Обычно считается по 4 бита частного за раз, используя 4 бита делимого и 6 бит остатка в качестве ключа поиска по таблице.</p>\\n<p>В MIPS для деления используются те же регистры Hi/Lo и операции mfhi/mflo, что и при умножении:</p>\\n<pre><code>div $s2, $s3  # остаток окажется в Hi, частное - в Lo\\nmfhi $s0      # перемещаем остаток в s0\\nmflo $s1      # перемещаем частное в s1\\n</code></pre>\\n<h2>Плавающая точка</h2>\\n<p><strong>Научная нотация записи</strong> чисел имеет один знак слева от запятой, например: <code>1.2 * 10^9</code>. Есть еще <strong>нормализованная научная запись</strong>, в которой слева от запятой должен быть только один знак и он должен быть ненулевым. Например, <code>0.1 * 10^-8</code> и <code>10.0 * 10^-10</code> не являются нормализованными научными записями, а <code>1.0 * 10^-9</code> - является.</p>\\n<p>Двоичные числа так же могут быть представлены в научной нотации: <code>1.0 * 2^-1</code>. Степень двойки означает, на сколько знаков вправо нужно сдвинуть число в двоичной записи. В данном случае 0.5 будет представлено как 0.1 в двоичной записи.</p>\\n<p>Числа с плавающей запятой имеют форму <code>1.xxxxxxxxx * 2^yyyy</code></p>\\n<p>В компьютере числа с плавающей точкой представлены в виде двух частей - мантиссы и экспоненты. Увеличение мантиссы увеличивает точность, увеличение экспоненты увеличивает представимый интервал. </p>\\n<p>Мантисса всегда имеет значение от 0 до 1 - это <code>1.xxxxxxxxx</code>.</p>\\n<p>Экспонента - это <code>yyyy</code>.</p>\\n<p>В MIPS числа с плавающей точкой представлены следующим образом:</p>\\n<pre><code>| знак (1 бит) | экспонента (8 бит) | мантисса (23 бита) |\\n</code></pre>\\n<p>Значение = <code>-1^S * M * 2^E</code>, где S - знак, M - мантисса, E - экспонента.</p>\\n<p>Переполнение возникает, когда не хватает знаков для экспоненты. Однако может быть еще и <em>опустошение / underflow</em>, когда нам нужно представить настолько маленькое число, что знаков в экспоненте не хватает. Тогда используются типы с удвоенной точностью, имеющие больше бит для экспоненты.</p>\\n<p>В MIPS число с удвоенной точностью занимает 64 бита, из них 11 - экспонента, а 52 - мантисса.</p>\\n<pre><code>| знак (1 бит) | экспонента (11 бит) | мантисса (52 бита) |\\n</code></pre>\\n<p>Чтобы использовать больше бит, спецификация IEEE 754 предполагает, что 1 слева от запятой в нормализованном представлении числа всегда есть и поэтому она в мантиссе не указывается.</p>\\n<p>Тогда числа имеют значение: <code>-1^S * (1 + M) * 2^E</code>, где мантисса - число от 0 до 1. При этом в мантиссе биты используются \\\"слева-направо\\\". То есть, если пронумеровать биты мантиссы слева направо как s1, s2, s3, то значение будет равно:</p>\\n<p><code>-1^S * (1 + (s1 * 2^-1) + (s2 * 2^-2) + (s3 * 2^-3) + (s4 * 2^-4) + ...) * 2^E</code></p>\\n<p>Помимо этого, чтобы меньшие числа имели меньшее значение, было решено, что наименьшая экспонента (-127) должна иметь значение 0000..00, а наибольшая (128) - 1111..11. Поэтому для записи экспоненты применяется т.н. <code>biased notation</code>, где к реальному значению экспоненты прибавляется некий сдвиг. В числах с одинарной точностью сдвиг равен -127. Таким образом, экспонента -1 становится равна <code>-1 + 127 = 126 = 0111 1110</code>, а экспонента 1 становится <code>1 + 127 = 128 = 1000 0000</code>.</p>\\n<p>В числах с двойной точностью сдвиг равен 1023.</p>\\n<p>Таким образом, значение, представленное числов с плавающей точкой, равно:</p>\\n<p><code>-1^S * (1 + M) * 2^(E - bias)</code></p>\\n<p>или, если писать полностью:</p>\\n<p><code>-1^S * (1 + (s1 * 2^-1) + (s2 * 2^-2) + (s3 * 2^-3) + (s4 * 2^-4) + ...) * 2^(E - bias)</code>, где s1,s2,s3 - биты мантиссы, перечисленные слева направо.</p>\\n<p>Пример:</p>\\n<p>преобразуем число в десятичную запись:</p>\\n<pre><code>110000001010000000...\\n\\nзнак = 1\\nмантисса = 10000001\\nэкспонента = 010000000...\\n\\nДля начала определим знак, значение 1 - значит отрицательный\\n\\nМантисса представлена как 129, нужно отнять 127, получаем 2.\\n\\nВ экспоненте мы видим 01000..., что значит 0*2^-1 + 1*2^-2 + 0*2^-3 + ... = 0.25\\n\\nИтого получаем: -1 * (1 + 0.25) * 2^2 = -5.0\\n</code></pre>\\n<p>Обратный пример:</p>\\n<p>преобразуем -0.75 в число с плавающей точкой:</p>\\n<pre><code>-0.75 = -3 * 2^-2 = -1,5 * 2^-1\\n\\nЗнак = 1\\nМантисса = 1.5, для представления отбрасываем 1, остается 0.5 = 1 * 2^-1 = 100000...0 в двоичном представлении\\nЭкспонента = -1, для представления нужно прибавить 127, получаем 126 = 0111 1110 в двоичном представлении\\n\\nИтого, получаем:\\n\\n1 0111 1110 1000000000...0\\n</code></pre>\\n<p>Хороший источник по чтению и записи чисел с плавающей точкой: <a href=\\\"http://cstl-csm.semo.edu/xzhang/Class%20Folder/CS280/Workbook_HTML/FLOATING_tut.htm\\\">http://cstl-csm.semo.edu/xzhang/Class%20Folder/CS280/Workbook<em>HTML/FLOATING</em>tut.htm</a></p>\\n<p>Еще одна инструкция по переводу из бинарного вида в десятичную дробь: <a href=\\\"http://sandbox.mc.edu/~bennet/cs110/flt/ftod.html\\\">http://sandbox.mc.edu/~bennet/cs110/flt/ftod.html</a></p>\\n<h3>Инструкции MIPS по работе с плавающей точкой</h3>\\n<ul>\\n<li>add.s, add.d - сложение single- и double-precision чисел</li>\\n<li>sub.s, sub.d</li>\\n<li>mul.s, mul.d</li>\\n<li>div.s, div.d</li>\\n<li>c.x.s, c.x.d - сравнение чисел, где x может быть eq, neq, lt, le, gt, ge</li>\\n<li>bclt, bclf - команды перехода</li>\\n<li>lwcl, swcl - загрузить/сохранить регистр с плавающей точкой</li>\\n</ul>\\n<p>Для операция с плавающей точкой выделены специальные регистры - $f0, $f1, $f2, ...</p>\\n<h2>Subword parallelism</h2>\\n<p>Если мы оперируем типами, размер которых меньше машинного слова, то в одном регистре может быть несколько значений такого типа. Инструкции, поддерживающие <em>subword parallelism</em>, таким образом, параллельно обрабатывают несколько таких значений, лежащих в одном регистре.</p>\\n<p>В процессоры ARM такие операции были добавлены расширением ARM NEON.</p>\\n<h2>Streaming SIMD Extension (SSE)</h2>\\n<p>SSE и MMX (MultiMedia eXtension) - это расширения к x86, реализующие <strong>subword parallelism</strong>.</p>\\n<h1>Процессор</h1>\\n<p>Далее будет представлен вариант реализации процессора, который поддерживает следующие команды MIPS:</p>\\n<ul>\\n<li>инструкции работы с памятью: lw, sw</li>\\n<li>арифметико-логические инструкции: add, sub, and, or, slt</li>\\n<li>инструкции ветвления: beq, j</li>\\n</ul>\\n<p>Не поддерживаются: сдвиг, умножение, деление, операции с плавающей точкой и т.д.</p>\\n<p>В общем виде каждая из инструкций может быть декомпозирована на следующие шаги:</p>\\n<ol>\\n<li>Читаем из памяти инструкцию по адресу, содержащемуся в регистре PC</li>\\n<li>Парсим инструкцию</li>\\n<li>Читаем 1 или 2 регистра в зависимости от инструкции</li>\\n</ol>\\n<p>Дальнейшие действия зависят от инструкции, но сильно похожи. Для всех инструкций, кроме <code>j</code>, нужно обратиться к ALU, подав на вход либо значение 2 регистров, либо значение 1 регистра и константу. </p>\\n<p>Затем, если у нас инструкция работы с памятью, то нужно обратиться к памяти (для записи или чтения) по полученному из ALU адресу. Если арифметико-логическая инструкция, то нужно результат работы ALU записать в какой-то регистр. А если инструкция ветвления, то нужно изменить значение регистра PC в зависимости от результата сравнения. Если же это не инструкция ветвления, то значение PC должно быть увеличено на 4.</p>\\n<p>Таким образом, получаем следующую высоко-уровневую схему реализации MIPS:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/e7122415dbdd4ccd91e1a77ca6b1d16a/b0dec/mips-implementation1.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 55.227882037533504%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABbElEQVQoz4WT627CMAyF8/4vN/4xMYlVQK/0Ru+lgOfPI9OY2GbJxEkcn+Nj6k6nk/R9L33X2ToMg3T3uCgKi3HylmUR7Ha7yW/mBn3ojcRpmqRrW4ursrRCnOHn8/n/gv2PgnjTNFJVlbGkSF3Vtr9cLg95z9wKXq/Xr3bHcZQoiqRUdrCq61qSOP6T1QPDUYvwcJ5nWZQNjNhTuNF2YduqBDixB/XajsP4eXbX3vFDIgwRnYK0ho5JkkgUhjLcWwcIECukRRkkb4yMrsji0CdLU0P5LjiIpU65LMqHCdu/AnYKiByAcAeJLMvE8Wi73UqsuuV5bkwBQMe3zUbSJJUgCOR1vbYzmAIeKnM6ILfVDjH2DrokkLx6WUnwHtgliOHhYJ5qIkyww35vEnHvWa8VLNXCDNIxYS7QBcq04fXKj7n60VaYc7bb7UyrWWPa98NC00ndPRs9IGhJEuz91+O/GD8EYliRD2Mm/gG/aFOaQzDUIgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"MIPS implementation 1\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/e7122415dbdd4ccd91e1a77ca6b1d16a/10273/mips-implementation1.png\\\"\\n        srcset=\\\"/hows-that-again/static/e7122415dbdd4ccd91e1a77ca6b1d16a/9b14a/mips-implementation1.png 163w,\\n/hows-that-again/static/e7122415dbdd4ccd91e1a77ca6b1d16a/94962/mips-implementation1.png 325w,\\n/hows-that-again/static/e7122415dbdd4ccd91e1a77ca6b1d16a/10273/mips-implementation1.png 650w,\\n/hows-that-again/static/e7122415dbdd4ccd91e1a77ca6b1d16a/b0dec/mips-implementation1.png 746w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>На этой схеме для понятности опущены мультиплексоры и контроллеры, занимающиеся выбором линий в зависимости от инструкций. Полная схема выглядит так:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/771daf35826589796876b9cc3302c490/fb6b3/mips-implementation2.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 74.18630751964085%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACPklEQVQ4y4VUiZKiMBT0//9wpxTHAQTlhlwQQk+/oFOus1WbqjYhR79+l4dt2/COOQCWcI9ZYNbtB5rITUDJA/uyL+sD3sayLKiaBto6wkIbC8P1SkNPyON+2eDD/u2JQChPQmsMHB9aYp5nKKVQ3e9xb9sCthDiWeC8jy3+urB78zqiQq11vLyuayQchiGSDn0POZM9Q6OB5zIkHAJRKErdIzRiYIwKaf11OOfQd10kE+KG7steJJsX1P1IVwOGeYVZKMI/sAY0MwnFNe99VCHx69o2koihnirHcdwdpXvOGjQMx2w0em32MDmBg6WA1q27QiETNaJEEBNTVehEqdKRVHAbDdJeI+smFFzbbXff02CjHUrjcRAiueys+3FbYiqJKYsiqn/uDSTvJqpTBvXEZC4evfM4Dw7nZsRZkVBUpGkaFYm6ieQt3T6eEpRliSzLkGcppBqsFU8mxrjFR1rgXtWoOyZv9jG2yURCIRGFxfWK0/EY11JfSXrFNc9Q1w0mqjd8lJP8RiOWbyrlYjJuxRXpOaFqjdPEGD67Q5ReLpeYXclidq9R5DmausZNz0joUpKcUbd9jLkkSKrB0m3tFox2xqcOvzsFUvkknHjJUpkSdSSYxBCT5Vh7rHbWLStjGtEZh6/RoSPhRQjf+1iGvJE2YrtCsZ6vTOdtBirWWc20Si8rYuIdtfCb9ai5TtRD4V+Ej1ku1GyBO/GpV/wZV3wwRsdfCJHoSMtf/3L5tT8lOUvY/wSeBsN/8A0udI2qn1RYKgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"MIPS implementation 2\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/771daf35826589796876b9cc3302c490/10273/mips-implementation2.png\\\"\\n        srcset=\\\"/hows-that-again/static/771daf35826589796876b9cc3302c490/9b14a/mips-implementation2.png 163w,\\n/hows-that-again/static/771daf35826589796876b9cc3302c490/94962/mips-implementation2.png 325w,\\n/hows-that-again/static/771daf35826589796876b9cc3302c490/10273/mips-implementation2.png 650w,\\n/hows-that-again/static/771daf35826589796876b9cc3302c490/fb6b3/mips-implementation2.png 891w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Здесь верхний мультиплексор определяет, нужно ли брать PC = PC + 4 или PC = адрес джампа. Ему на вход поступает AND результата сравнения от ALU и бита, определяющего, является ли инструкция инструкцией ветвления. Второй сверху мультиплексор выбирает, в зависимости от инструкции, писать в регистр результат работы ALU или значение, полученное из памяти. Ну и третий - в зависимости от инструкции определяет, подавать вторым операндом в ALU значение регистра, или константу сдвига, полученную из инструкции.</p>\\n<p>Теперь разберем итеративный процесс построения потока данных (<strong>datapath</strong>).</p>\\n<p>Для начала нам понадобится блок, который читает инструкции и инкрементирует PC:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/0d959ba9046c42f9819d8351546ace90/0e537/datapath-pc.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 373px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 78.28418230563003%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsSAAALEgHS3X78AAABu0lEQVQ4y5WUa2+CUAyG+f8/bDPz23RxUadDIt4VwQuo2PWpHgeiydakObf27dsLePv9XlarlayjtURR9C/FJ15f/Na6LpdL8QDb7XZyPB7lcDjI6XSSPM9tfaa8Z1km8/lcNpuNnNQ313vAPaIA5gQDY6yPD1XZJEki4XBodmmaShzH5ku2HnRh5mS5WNgDUY8P1GVBYIAR7jkDXgHkjMNfBJBwGEq/35fZbCbT6fQCWEw5Wv2ez+dzRZ2wBxDb9NpYiHjUhQfqQHPcwzNJ1M6YheGtdqw0CfEwgCURt9utOMaAo9SpqKQFAPu5pmldvhIAw4uU0Xg0MgPYDrV74/FYRno3U2fAMbRxuToCyF2WZqUSGEM643/70mm3DSwIAvF9Xz5bLanVahIMglI9b4D5uXJvDNmQmq2asjuTSnE0St29uys2y3OFBoSU+QoAKRrx1u/1bEQGyp6G0DzqWWR3A6Q+NIT0LcAdIPskTixVFDD3eVYAi45OYNrtdOWj2ZTGe0OajUZp+B8FLKV8P7iwZfJfX16l/laXr263PIsFwIcp30eyGdM/yUKVlVot9Bs31fNkMql02MkPLPnatoQAcBIAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Datapath PC portion\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/0d959ba9046c42f9819d8351546ace90/0e537/datapath-pc.png\\\"\\n        srcset=\\\"/hows-that-again/static/0d959ba9046c42f9819d8351546ace90/0fc99/datapath-pc.png 163w,\\n/hows-that-again/static/0d959ba9046c42f9819d8351546ace90/9c6bb/datapath-pc.png 325w,\\n/hows-that-again/static/0d959ba9046c42f9819d8351546ace90/0e537/datapath-pc.png 373w\\\"\\n        sizes=\\\"(max-width: 373px) 100vw, 373px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Дальше - блок бранчинга:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/463d74a56e02fc1b5a38593837f88ff9/778fa/datapath-branching.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 632px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 71.99367088607596%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAABnklEQVQ4y31Ui26DMAzk/3+vk1omQaEtHZUolEcICQ/P542IImikCEjs8905waPFmKbJPY0xMruuo05rebZtS9ZaUkrJ3jiOtM73tgAR2DQNla8XFUVBzyyjPM8p4yfW67oWwLqqpJDmgn3fS663ZDXPvYHEYRgE8PF4SBG8+74v7w5wC2RZAIzLsqSvw4GiKBKQwbIlukXkvuSKJVziWBKWUuAZJuTDR90ZyhRLZpW5GckME9D+ABtOBkhyu1GapvTN9OHNPJIkEVZgCHAUKnk/bQwV2lJuWcGClAc5QFaNEtAwCKn6T4ZfYPni5syA6DIK2k5TzWuQjXh4iHgnGcDYiKNYAMIgEOPnZuhWOxYAz7IngxRixc/9TtH5LFa5LgMdgQACwDyul6usoQjkAgBxYGr4e93QN0CYHoYhGUjrB1nDeQMAGgYVkI017G2dCAcohjOzUrV0LjtKlaWKJYAR2IDd3tFaXgoHaLkqbgG+re2FLVjJcWHDsbd1Adbn+E0ykqUBPAFyPB7JP52cZ0sme8P7FDT/HNZ3/dP4BV2PRCQX4kUvAAAAAElFTkSuQmCC'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Datapath branching portion\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/463d74a56e02fc1b5a38593837f88ff9/778fa/datapath-branching.png\\\"\\n        srcset=\\\"/hows-that-again/static/463d74a56e02fc1b5a38593837f88ff9/7fe72/datapath-branching.png 163w,\\n/hows-that-again/static/463d74a56e02fc1b5a38593837f88ff9/6307c/datapath-branching.png 325w,\\n/hows-that-again/static/463d74a56e02fc1b5a38593837f88ff9/778fa/datapath-branching.png 632w\\\"\\n        sizes=\\\"(max-width: 632px) 100vw, 632px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Здесь синим обозначены управляющие сигналы</p>\\n<ul>\\n<li><strong>RegWrite</strong> - сигнал блока регистров, который подается, когда данные, поданные на вход <em>Write data</em> нужно записать в регистр <em>Write register</em>. Для чтения такого управляющего сигнала нет, поэтому значения регистров <em>Read register 1</em> и <em>Read register 2</em> <strong>всегда</strong> подаются на исходящие пины <em>Read data 1</em> и <em>Read data 2</em>.</li>\\n<li><strong>ALU operation</strong> - 4-битовый сигнал, определяющий операцию, которую должен выполнить АЛУ. В данном случае это будет операция сравнения. Управляющий сигнал здесь нужен потому что этот АЛУ будет использован для разных операций в разных инструкциях. А вот для сумматора на этой схеме используется другой АЛУ, у которого всегда будет проводиться операция сложения, поэтому ему управляющий сигнал не нужен. Дублирование АЛУ обусловлено тем, что в конце концов наш процессор должен выполнять инструкцию за один такт, а значит ни один элемент не может быть использован больше 1 раза.</li>\\n</ul>\\n<p>Блок <em>Sign-extend</em> нужен, чтобы преобразовать знаковый 16-битный сдвиг в знаковый 32-битный, который можно подать на сумматор.</p>\\n<p>Далее - блок выполнения инструкций работы с памятью и инструкций R-типа:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/d8f4f198e08050058d98942bf5bd393a/8f4fa/datapath-memory-r-type.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 48.86685552407932%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABlklEQVQoz5VSa2+DMAzs//9924dpGh2FAuX9SEISAjdfUKt9mrRIBidOzuezL8dxYF1XZLcb2raFtRbGGCzLgufa9wO9DRg24GEP+OM8D/Lfon8eCBQu+77Hx9fkirquY6DvupjAOwcryaZpwrg6jEpDuw3Oe1jn0WiHTHnMksjtJ+glTVOURYmiKEC/aZrIeJIk+WTQrx5aKUnSoioLdG0T9wSdJVHTD8gFtLX7CbhKeWSU5zmyLMM4jvKwRPKVoBtGfKc3jMMAJexyiRf3e0yqtcYg5634ZZ7BqFOiCzVkIJcS3WpeulHHScBLYc4k27aBdwnEP5f3W9yzsk5IRUBqOAlgcq+QtDMmY+MlWv2oMc9zlIDGhlFnyuPE//z4ECJp9Bl/AZJBkI2Wls3aSHkqXiIo49FCiMz6vsf39YpGJqLqBtyqBk7YE/B4lky6Rh4rYXMXLd/f3lBV1Wt0niX+9kPYZZQ2VGuAlflhLyJDfogeQogHTkaFzLx08T/L/AZUwoRaEYis2CSesfS/bFmedr7n+gHjAAPrxGQeUQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Datapath for memory instructions and R-type instructions\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/d8f4f198e08050058d98942bf5bd393a/10273/datapath-memory-r-type.png\\\"\\n        srcset=\\\"/hows-that-again/static/d8f4f198e08050058d98942bf5bd393a/9b14a/datapath-memory-r-type.png 163w,\\n/hows-that-again/static/d8f4f198e08050058d98942bf5bd393a/94962/datapath-memory-r-type.png 325w,\\n/hows-that-again/static/d8f4f198e08050058d98942bf5bd393a/10273/datapath-memory-r-type.png 650w,\\n/hows-that-again/static/d8f4f198e08050058d98942bf5bd393a/8f4fa/datapath-memory-r-type.png 706w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Управляющие сигналы:</p>\\n<ul>\\n<li><strong>ALUSrc</strong> - определяем, подавать ли вторым операндом в АЛУ значение регистра (для арифметико-логических операций) или константу сдвига (для операций памяти)</li>\\n<li><strong>MemWrite, MemRead</strong> - если сигналы активированы, то происходит запись либо чтение в память. В отличие от блока регистров, здесь чтение должно происходить по сигналу, так как попытка чтения из невалидного адреса может привести к проблемам</li>\\n<li><strong>MemToReg</strong> - определяет, что нужно писать в регистр - результат работы АЛУ, или значение, прочитанное из памяти</li>\\n</ul>\\n<p>На схедующей схеме эти 3 блока объединены в общую схему процессора. Этот процессор может выполнять основные инструкции (чтение/запись слова, сложение/вычитание/сравнение и условные переходы) за один такт. Джампы пока не поддерживаются.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/7b9bb95bf075dbe5a9c60d19c35ba267/83be2/datapath-combined.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 67.32223903177005%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAAB6UlEQVQ4y21T23ajMAzk//9u+9a0SUMukJiLbTD3hKlGCVm6W50zx2Ds0Wgkoq7rME0TuHrv0bYt5vmO+/0vmqZRhBBQ1zWGvkfoBqS5RSV3GPM8KyISkIwXedhcjb6vYa3VlaS2LPVcK8+n41He7U9CHhyGAb1kdc5hHEf8FjxHolIIj0JkjNEEt9vtRciIGimD+DeomFbwAhF/fWHz/q5neyGf5fsj5p8KizzH5XLB+XTS7FSbSXaWw2eqKPIMphnguhFlO6CQIvJhxnSfMQr6+/wijlhmkiSKxfzD4YDt51aVOedxFnIXWpS+krWBq2qxSGyShCb0SOsepSSpJ1FImbzIblFpHMeK/T7GbrdDKomoNhfzvRDlmdHSk/NZPa280+dT7uClgmjxLE1SvP15Q5qmSnA+xLrPJsX7PT42G1yvV20Oq9KmyIRQDIl3n5+oK/9QSLAJXGn4QQg/EoOqn7QxRVGo+lAHLHN7EeWBVYkAfiuKUmc4Wtr9Gg/ZtKLADTdkrtKuctbapxoqZrO2pwQ7U8IIUZ5lOvTcj9YtX+aNisa+QyrebKRUqqCqdRRVwNUHeGkSh5wJ+Qe9PFwIeZGZFv8yyb4e3nXydfAe7fqPkF4663Qm7RPlE/aXvce+RS7zzOq+AYfV6oQkKfh1AAAAAElFTkSuQmCC'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Datapath combined\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/7b9bb95bf075dbe5a9c60d19c35ba267/10273/datapath-combined.png\\\"\\n        srcset=\\\"/hows-that-again/static/7b9bb95bf075dbe5a9c60d19c35ba267/9b14a/datapath-combined.png 163w,\\n/hows-that-again/static/7b9bb95bf075dbe5a9c60d19c35ba267/94962/datapath-combined.png 325w,\\n/hows-that-again/static/7b9bb95bf075dbe5a9c60d19c35ba267/10273/datapath-combined.png 650w,\\n/hows-that-again/static/7b9bb95bf075dbe5a9c60d19c35ba267/83be2/datapath-combined.png 661w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Здесь добавлен один мультиплексор, управляемый сигналом:</p>\\n<ul>\\n<li><strong>PCSrc</strong> - определяет, использовать ли для PC следующую инструкцию или перепрыгивать на адрес, указанный в инструкции условного перехода</li>\\n</ul>\\n<p>Итак, у нас готов <strong>datapath</strong>, теперь попробуем реализовать его внутренние элементы.</p>\\n<p>Наша реализация будет поддерживать следующие команды: lw, sw, beq, add, sub, and, or, slt.</p>\\n<p>Вспомним, какие у нас используются форматы инструкций:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/211a92ffee7974633687bc226729170a/d8e13/instruction-formats.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 617px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 37.27714748784441%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABC0lEQVQozz1Ri46EIAzk/79wL2a9rHt7gi9UUPCBvU5zSDJS2+kwFDVPE02M8zzJOUdaa+r7XlDXNQ3DQI0xZBiWY9TbtqW+66h8PsloQx3H1etF4ziSyiIdk7Ztk6J3Xg4A4bouijHKoVjg4x9rnmdKKQm895JTaEQT1rquLOakiKbjOCiGcMeo7/suCJxflkV2GEEOPAX7P++3nAahoij4GlocVVUlTeD8fj4iCEAE3K/Hg0ZrRSjXFOzmRN4hggbEuAEAh3nPMW6WznTnoKXgJM8CAnaw8u8YeBgIW3YBYH7icA3C+S5LycOxjIu5Cp+maW7rLccgxxBFEPOBEF77+J9fBup5vjn3B2a9GyFSZ46sAAAAAElFTkSuQmCC'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Instruction formats\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/211a92ffee7974633687bc226729170a/d8e13/instruction-formats.png\\\"\\n        srcset=\\\"/hows-that-again/static/211a92ffee7974633687bc226729170a/c05a3/instruction-formats.png 163w,\\n/hows-that-again/static/211a92ffee7974633687bc226729170a/c0194/instruction-formats.png 325w,\\n/hows-that-again/static/211a92ffee7974633687bc226729170a/d8e13/instruction-formats.png 617w\\\"\\n        sizes=\\\"(max-width: 617px) 100vw, 617px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p><strong>а</strong>. арифметические инструкции, <code>rs</code> и <code>rt</code> - источники, <code>rd</code> - регистр, куда кладем результат. <code>shamt</code> не используем, а операция АЛУ задается совокупностью полей <code>op</code> (31:26) и <code>funct</code>.</p>\\n<p><strong>b</strong>. Операции с памятью. <code>rs</code> - регистр, в котором записан сдвиг, который будет добавлен к адресу памяти. <code>rt</code> - регистр, из которого читаем или в который пишем данные.</p>\\n<p><strong>c</strong>. Операции бранчинга. <code>rs</code> и <code>rt</code> - сравниваемые регистры. <code>address</code> - адрес перехода при равенстве этих регистров.</p>\\n<p>В операциях a и b различается поле, в котором записан регистр, куда нужно писать данные, поэтому перед записью в регистр нам понадобится еще один мультиплексор.</p>\\n<p>Добавим вышеописанную информацию о полях и новый мультиплексор на нашу схему:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/5ea329797dccb6d6df273b2e3ebee85b/65d77/mips-implementation3.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 61.474269819193324%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAAB5UlEQVQoz2VT53KjMBjk/d/u8sczcYnpGEwvonpvVw6OL6cZIRBi2/fhdF0HYwx6rn3fYxxH+/x7av+fyb26N4irFo9tg8bj8YCjw+u6YhgGlEWBiYc3HtDe+6r3Im/b1q7LsqDtevhR/D/g+K0gTVNUVYVpmn6UcS7TiLZpeD9a4Px+R8azeZ4j8P0X2AtwnucXwO8h7m593tdVDdd1UZYlkjhGR7XrMr8BAk5D5qqsLLNsSJ0sdbQj+2lZI24NBpLlWUagyArYycz2BOPV7jnKzSPr+XRCwXsxe54Hn1Zk6XI+o8zviMKQRRjQmskSKTezbMjMCrNuaOli3mhZocuqwo7CCNfrFXVdIwxCHD8/7XNRlIijCG58Q1xUSG8JThRwp+L8TtW3FFHNDlkJuGd1uVzw8ecDvufbwJMkweFwwPXraqsvgtPxaJWqcHIiEYaFkrMzyVVA5+kfNhdZUS9qdMwmKhokVBZxxgQQaNfUaOhAYFIdk8C1rhrr1NkrtA/lJnVpSjt5YdUFQUCwgNUtkLYDMkYgNV+uZ2NQu+0FfSncV71QT65cBabWCPyAWeW2F+OahRlGe3biJxkv6irVQt857z33rtTaJlhISzcqVk5qpxtbyMwLNgII5KE/iVPqBPgXFW+a+BmiSLQAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"MIPS implementation 3\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/5ea329797dccb6d6df273b2e3ebee85b/10273/mips-implementation3.png\\\"\\n        srcset=\\\"/hows-that-again/static/5ea329797dccb6d6df273b2e3ebee85b/9b14a/mips-implementation3.png 163w,\\n/hows-that-again/static/5ea329797dccb6d6df273b2e3ebee85b/94962/mips-implementation3.png 325w,\\n/hows-that-again/static/5ea329797dccb6d6df273b2e3ebee85b/10273/mips-implementation3.png 650w,\\n/hows-that-again/static/5ea329797dccb6d6df273b2e3ebee85b/65d77/mips-implementation3.png 719w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Новые управляющие сигналы:</p>\\n<ul>\\n<li><strong>ALUOp</strong> - 2-битовый управляющий сигнал, который переводит АЛУ в один из трех режимов - сложение, вычитание, или использование инструкции, указанной в поле <code>funct</code>.</li>\\n<li><strong>RegDst</strong> - определяет, брать регистр назначения из <code>rt</code> или <code>rd</code>.</li>\\n</ul>\\n<p>Итак, у нас есть 9 управляющих сигналов (для <code>ALUOp</code> используются два). Все, кроме <code>PCSrc</code> могут быть установлены в заисимости от <code>opcode</code>. Для определения <code>PCSrc</code> нужно еще знать результат сравнения регистров.</p>\\n<p>В результате наш контроллер принимает на вход 6 бит <code>opcode</code> и имеет 9 выходов. На рисунке изображена наша схема с добавлением контроллера:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/b80f11d0941cd35ba57f3e7c7b4e4f67/942d5/datapath-with-controller.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 77.42857142857143%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACi0lEQVQ4y2VT2ZKbQAz0/39L3vIXyUuyteuyd2ExBgPmGIZruOm0hjjl2lClmgGJltRqHfq+xzRN6LoOZVnaO7YN27paW+Xk+zAMaJrGxjV1bePk3yRJYIyBPBJ3kI8SPI4j7nSWukLXD2hNb038I/1t29ofB8ZprZFnGeqqQhgEmOf5f8BWsvPeLcCw7ib3mrHLZuPRs7qrf4HKc0RRhLRQqM2wO7EH/QOUNudtB3pkm9cNPlF/FDPKacP1nuPkh0iqFsW44dZvUGRo/Ru7PFe4LDMEK8oKRGGIMIpxqwyO9Yrv0Yjf5Yy47lExSBE8H1dcmUzxfJjm98ODP6lQAMvW2PLlLq16ZsO3cMKxmnHKW7Rsw9AamoB0PO3QGFwLoBAs1gvh84IkVzuf5KvuenxmGmdlUJkRH3ljeYVNRuBlN0ksgJUAZmmKi3eB8/4OXTc4uR78C833oZTCp+NAF5lVgHMvUNTtnnzZKzXzioX8kVIOkIDSrvCoqcFrGMH1A3Rtg5hT9DwPLgEzSiSOE5yjDGXT2UROGCNO+c7uYvKt+V2PCw5Svoj3+PaGXy+vcAgo1QiI637ifDpbSoIgxM+TC891UVYNbkwoWpSCsiyH+/GBgAM9CKFiUmU/jEgZ3DBTM61IdW3Bb5x6QHvxQnS6RNpy2v2IhKDiF3oEPKWcLODzo4rCOmUN5V5QxHHM9oTDhL5+gVONaLhNSXSjvBImu5GmFoqDOzxE/ACWSmVn5SwIWHEVL+QyzwuEuoWjB/hm34ttWzmclVJaUQ8TFFVxeK7ua7UiHVGBtKVYcaD5biZuk4XDc/SyLNz5J8AH2Ndq0/sdKUHzLMXxluEtIg2qtKoon0y66TqDP9rzf7i2saMEAAAAAElFTkSuQmCC'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Datapath with controller\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/b80f11d0941cd35ba57f3e7c7b4e4f67/10273/datapath-with-controller.png\\\"\\n        srcset=\\\"/hows-that-again/static/b80f11d0941cd35ba57f3e7c7b4e4f67/9b14a/datapath-with-controller.png 163w,\\n/hows-that-again/static/b80f11d0941cd35ba57f3e7c7b4e4f67/94962/datapath-with-controller.png 325w,\\n/hows-that-again/static/b80f11d0941cd35ba57f3e7c7b4e4f67/10273/datapath-with-controller.png 650w,\\n/hows-that-again/static/b80f11d0941cd35ba57f3e7c7b4e4f67/942d5/datapath-with-controller.png 700w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>На этой таблице видим таблицу истинности для контроллера:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/e72a78bf2d710d890e40834473eeed94/7c90c/controller-truth-table.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 19.006211180124225%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsSAAALEgHS3X78AAAA0UlEQVQY00WMu27CQBBF/Y9pSKBzHQlFaRBBFEhRgBT5rMQIkG34BQrbOzt+rZs4l9nBCsXR2bkzd4OHH4fxzmGya9Wep8gh3Du8JB3Cg8NU7HmOO7ym3f/dWDqjqNXuY3S7D96+L1jsc6xixja1WBwJ68RidiB8DPNGvE5kFj5TwlKy95hkZ7E5Mebekn+dGUFvM6AmoDL4Kwt5G32rGwtI9mtzIdO9t88U31MMes7RSxZwVaNqWhjLSkF2gEFcIjd0R3Jvv9fboUNc6R9l3eAKiMEZDIOX1IwAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Controller truth table\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/e72a78bf2d710d890e40834473eeed94/10273/controller-truth-table.png\\\"\\n        srcset=\\\"/hows-that-again/static/e72a78bf2d710d890e40834473eeed94/9b14a/controller-truth-table.png 163w,\\n/hows-that-again/static/e72a78bf2d710d890e40834473eeed94/94962/controller-truth-table.png 325w,\\n/hows-that-again/static/e72a78bf2d710d890e40834473eeed94/10273/controller-truth-table.png 650w,\\n/hows-that-again/static/e72a78bf2d710d890e40834473eeed94/7c90c/controller-truth-table.png 805w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Пример работы процессора для операции <code>add $t1, $t2, $t3</code>. Жирным выделены активные соединения и элементы. Вся операция выполняется за 1 такт.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/aed65898b2520049af5d224a83f396eb/04c80/datapath-add-example.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 75.87168758716875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACfElEQVQ4y2VTy5KbMBD0//9NbvmDXHJLtmyvN2SxwbxsQCAQCIlOj7C3ditUtSXr0TM9Pdr1fY9xHNF1XRinaYIx5j/I+hMfa8QwDPDeQ751XbGTDWttIBTIXA4454ht9H7FyItyWYIaQs41TYPb7fY/oUSVw1VZQjPjeZ5D9JnrT4gSIZE9mcu9W1WiLIoPsi+EnVKY7ALtAOM3dMuGLT4w6h6aKiYpUa+hxgl2cY/dNfx+EJIelmvGSSQPS7kT5y/K4VfrMFiPvOlQdgPU7FBMKy7jioFnLEsyE/5zhp61ko0kL5GlCc7XHMVg8eO+4NvVYq8sinFBZYFy8sjMBsUs6nlFy1ESCIRSlyBppuTZhrkIoVr8VCu+Fw7x4HDu55DJzIvKbmSShMjVyxrU7eq6ZnFvdJE1GUYU9waD1gEt/5/yO/J+Qq0NLto+yrURTeK+26T2DBAIq6pCFEU4xzFuTYvDW4TkckGSJCiKHH9Or6jLAnGa4aIMHdaYqEIvJHhACLXf6r+TPhuYSdvUOJzeECdXZteHdjgeDojPZ7Rtg3cSHq8VFHsvyQq8ndPQk5pKpI3qftgIRYGYctzv8Xt/RETCglmneYHD6wnx+ztLUuEv11+iGGVOs2oVAkpDS2+qtsWRZ0X+7tmQAkNzOjNDKkUjcW8VpCR5dkVS3pCSyNuZbjsoeVns3YYetETNcg3WbRkKmXwSsWLkPMvCq5HMRJJcFElJZxCx8y90XJ6i4nrVdmi6ngYa6M+En0m39+shHSD17VQbMk9bkho6+nwc/GYqEUVqNOHVfMnwOT6/Vgyg21ma4sKGj2uaNcxYWDf7gMzdsoS2897hH9kZhYbQYOEeAAAAAElFTkSuQmCC'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Datapath add example\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/aed65898b2520049af5d224a83f396eb/10273/datapath-add-example.png\\\"\\n        srcset=\\\"/hows-that-again/static/aed65898b2520049af5d224a83f396eb/9b14a/datapath-add-example.png 163w,\\n/hows-that-again/static/aed65898b2520049af5d224a83f396eb/94962/datapath-add-example.png 325w,\\n/hows-that-again/static/aed65898b2520049af5d224a83f396eb/10273/datapath-add-example.png 650w,\\n/hows-that-again/static/aed65898b2520049af5d224a83f396eb/04c80/datapath-add-example.png 717w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>А здесь - пример для инструкции <code>lw $t1, offset($t2)</code>:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/5df023df91dbd0267df49a1df77f6a3a/99256/datapath-lw-example.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 76.33802816901408%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACfUlEQVQ4y2VUi27bMAzM/3/NsO8YsALb+liaLnFsJ35bliVLft2OctJ2mAFGNE0eeSSVndYa1lp0XRdO5xyGYfhPxP4uw4ePMQbTNEGedV2xE+M4jgFQRHT5sCxLkHlewvvAZBIsSUXET6kOeZ7/DyhZxUk+aoJ670N2T3sQ7yBMXNA9dN+HBG3TIE3Td7B/ADul4MYJ/QwMyyaaesfk8xpiAogWPzl1j86S+rhVR8jw+w5IeIy0DRItOqk66k/djO8NE00LLq3GldK4CblbcbYr9LRiWlZ4yvK5wmWeMbKq+JrjmiaI0iuuvce3ZsbXdMSTmlDYCfUIVH5BRgqJXaAYVPO9YTV2vgFKXwIllq/dppMtiI8HteBLMuJVT4i0D1ULCwFSBHGhHyvMdANs6hpVVcEa9sRYZFUDw6aLtL3Fy6VErAZUZgiA6zYBstnABEioSkuMAMpkD4cDTscjykbh5fAHyfmMOI5RM5HoXV3hlFwQtRa9TJgsBEj65pZtJGS/VSg7JPvVqRZ7gh3jFJZBsg5vTJTnRViptKzxljdhG6607aMEDdemLMsgNaduWOVO0GUoz4+PePjxE0lB+uxrw8Dnl9/Y7/fodUd7jV+HYxhYQSZZloXeSzGyj6/0a7lGu/tCypQtr1RDo4xF9lBaULAllyTBkVM/JBkWPyDntA19hX4cRfTJwuK31n8Ahl7zqpVFjjy7oioK6kW4PRIUXXi2BGCmyMxbH1ldpTSU0GUCNYwb5c+gI1dHqGx3VYXM59MJVWdQGI+TYVJ/uzp8uILgjkORmfU3wPtzB70/Ahb+hUit7HrkvUPteAGmObRonrdTmDn2fWIRfwHdG4Wt4TfBGQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Datapath load example\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/5df023df91dbd0267df49a1df77f6a3a/10273/datapath-lw-example.png\\\"\\n        srcset=\\\"/hows-that-again/static/5df023df91dbd0267df49a1df77f6a3a/9b14a/datapath-lw-example.png 163w,\\n/hows-that-again/static/5df023df91dbd0267df49a1df77f6a3a/94962/datapath-lw-example.png 325w,\\n/hows-that-again/static/5df023df91dbd0267df49a1df77f6a3a/10273/datapath-lw-example.png 650w,\\n/hows-that-again/static/5df023df91dbd0267df49a1df77f6a3a/99256/datapath-lw-example.png 710w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>И напоследок - пример для инструкции бранчинга <code>beq $t1, $t2, offset</code>:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/910d3d795400851d1203009c545579e9/165d7/datapath-beq-example.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 78.22349570200574%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsSAAALEgHS3X78AAACoUlEQVQ4y11U2W7bMBDU//9KH/sTBfrSFEXSJnFsWT50UhdJidQxnaWjIA6BBUlxOTu7O1TU9z3GYYC1Ntjwvh7e95+/j+MYfGWW/WZyvq4rZETyYZomtG0LAfdcy+GyLLTbLPt5nqF5bo2F1jqAeu9R1zXaprkHFBOnLMvQ0sEFBvbGZrAf53LZOQelVDBhdjwcwlqGgAZAcWroPBBITyuGGcEszcz4GHJBggrw5XxGlqZQbc8M53tAoS+pTUzRLO+XaY7r67DgTzuBcdB3HR4fnwKgcR7VOKPyuBsfgPM8BZCCEVVZoCgrVNoitiu+Xxx+qhmHxiId1xDkQnvTC1LONSMrWseokYBJyguLLgxT1cCyXm3Xo7IOO7Pi24mA9YynykCNbKBf0fgFGcEaLyVaWZ41fI+ks8aYQHf0ExRZyZASeAa4mgk/SoeSqb0qw0u3mvA+DBm55WZSP9lH6fWKt90OxzhGpw1e4gSnJMGZRZfuvfIso0+R53hJK3SDw8SM1nUJzCSonSgxBpCGRiKHsiyRs3vXNMO/fYyyKAJgyi7u9/vQzSwv8PdSoOw0NJuTdRZlb+GoRTs6ZuepCAKGVFlHYfjr4Td2x1NgoHV/A2Ig0dvlmuLhNcYxOaGqKlzSnLMK4hZS8jByNjIAyiuQ1M+XK5KyQS+FH33oeE62wngDTI4xWpamMmymvDLelYDyitIsR7Q9mW1oNsjx+XmKdaTWRFaBKUEPRR0a17oZuWGKTF2pOjA2zMjzLNoUvpmIVtgKK0XHivV9eX5GfEwQk32iJzx2S5DISu1K/URePTNqB38D3EC/DqmtSErSEQUUxqET/Y33vuv2sj4z/MpURvgLNS0a/k06pndQGvt2hCKjefJ8EB6eDfTeheYIgf+pOdJOvQ1roQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Datapath branching example\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/910d3d795400851d1203009c545579e9/10273/datapath-beq-example.png\\\"\\n        srcset=\\\"/hows-that-again/static/910d3d795400851d1203009c545579e9/9b14a/datapath-beq-example.png 163w,\\n/hows-that-again/static/910d3d795400851d1203009c545579e9/94962/datapath-beq-example.png 325w,\\n/hows-that-again/static/910d3d795400851d1203009c545579e9/10273/datapath-beq-example.png 650w,\\n/hows-that-again/static/910d3d795400851d1203009c545579e9/165d7/datapath-beq-example.png 698w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<h2>Почему однотактовые реализации больше не используются</h2>\\n<p>Наша реализация выполняет всю инструкцию за 1 такт. Тем не менее, такие реализации на данный момент не используются потому что тогда длина такта будет одинакова для всех возможных инструкций, а значит - будет равна длине самой медленной инструкции. Это наверняка будет инструкция загрузки из памяти, так как она последовательно задействует целых 5 элементов: блок инструкций, блок регистров, АЛУ, блок памяти и опять блок регистров, но уже для записи.</p>\\n<p>Такая реализация может быть приемлема для архитектур с небольшим количеством простых инструкций, так как тогда расхождение между самой быстрой и самой медленной поерацией не очень велико, однако если бы мы добавили операции с плавающей точкой, то такой вариант работал бы совсем плохо.</p>\\n<h2>Проектирование набора инструкций для пайплайнинга</h2>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/eaee3245f1b2deee1886e48e24f4d489/4b367/mips-pipeline.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 37.79385171790235%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABE0lEQVQoz32RiY6CQAxA+f9f4w8UVgHlPkUuOeq8ZtmoMTtJ02mnx2vHchxH6rqWbdtkWRZ5PB5yu91Ut20r0zT9afzjOH7V5K7rKpZt25LnuSRJIsMwqKTm3nWdpGkq9/v9TVM8iiItEsexamzygLBiYxCIs+97FTrN86wBu0CCj0n+O1ZVVYJcr1e5XC5yOBykaRopikIJIIPe8zxtCiGHwt/EIjgzhBRD2Knv+3I8HnUVURiqnynwn89ntT8L73cLEhIhhIblQwIpvtPpJGVZSm2moDnCe2ga8ZnE78V0ZMajG4XZEYcPybJMC0LMWxAESriT/riuuEaw3wg/l/q6dAii309jnzSBjIlebT5xz30C3AxjPnDAMQAAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"MIPS pipeline\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/eaee3245f1b2deee1886e48e24f4d489/10273/mips-pipeline.png\\\"\\n        srcset=\\\"/hows-that-again/static/eaee3245f1b2deee1886e48e24f4d489/9b14a/mips-pipeline.png 163w,\\n/hows-that-again/static/eaee3245f1b2deee1886e48e24f4d489/94962/mips-pipeline.png 325w,\\n/hows-that-again/static/eaee3245f1b2deee1886e48e24f4d489/10273/mips-pipeline.png 650w,\\n/hows-that-again/static/eaee3245f1b2deee1886e48e24f4d489/2fc6f/mips-pipeline.png 975w,\\n/hows-that-again/static/eaee3245f1b2deee1886e48e24f4d489/4b367/mips-pipeline.png 1106w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>В MIPS инструкции были спроектированы для пайплайна, этому способствуют следующие свойства:</p>\\n<ol>\\n<li>Все инструкции имеют одинаковую длину. </li>\\n<li>Поле регистра-источника всегда находится в одном и том же месте. Благодаря этому, пока первый шаг определяет тип инструкции, второй шаг может уже начать читать значение регистра. Если бы это свойство не соблюдалось, пришлось бы разбить шаг 2 на 2 шага.</li>\\n<li>Адреса памяти используются только для операций чтения и записи. Благодаря этому мы можем на 4 шаге вычислять адрес памяти и обращаться по этому адресу на шаге 5. Если бы мы могли бы совершать арифметические действия над данными из памяти, то после 4 шага пришлось бы вставить еще один АЛУ.</li>\\n<li>Все операнды выровнены в памяти.</li>\\n</ol>\\n<h2>Риски пайплайна</h2>\\n<p>Риски - это ситуации, в которых следующая инструкция не может быть выполнена в следующем такте. Есть 3 разных типа:</p>\\n<h3>Структурные риски</h3>\\n<p>Возникают когда аппаратная часть не поддерживает запрашиваемую комбинацию инструкций, которую мы хотим выполнить в одном такте. В MIPS таких рисков нет, так как набор инструкций был тщательно спроектирован для пайплайнинга. Например, если инструкции и данные хранятся в одной памяти, то 1 и 4 шаг нашего пайплайна не может быть выполнен одновременно, так как и там и там происходит чтение из одной памяти.</p>\\n<h3>Риски данных</h3>\\n<p>Возникает когда данные, необходимые для выполнения шага, еще не доступны</p>\\n<p>Пример:</p>\\n<pre><code>add $s0 $t0 $t1\\nsub $t2 $s0 $t3\\n</code></pre>\\n<p>Здесь вторая инструкция ожидает результата выполнения первой. Если не вмешаться, то пайплайн не сработает. Первая инструкция пишет результат только на 5-м шаге, значит второй инструкции придется 3 такта ждать впустую. </p>\\n<p>Компилятор может переупорядочивать местами команды чтобы избежать этого, но это помогает не всегда.</p>\\n<p>Типичное решение - не ждать полного выполнения 1-й инструкции, а сразу подать во 2-ю результат сложения, минуя память.</p>\\n<p>Однако такое решение помогает не всегда. Если бы первой инструкцией была <code>lw</code>, результат был бы доступен только после 4 шага, что уже слишком поздно. Тогда все равно пришлось бы ждать 1 такт впустую и только после него подать выход с 4 шага 1-й инструкции на 3-й шаг 2-й.</p>\\n<h3>Риски управления</h3>\\n<p>Возникает, когда прочитана не та инструкция, которая нужна. Например, в инструкциях ветвления адрес следующей инструкции выясняется только на последнем шаге, а следующая инструкция к этому момент уже прочитала неверный адрес.</p>\\n<p>Одно из решений - остановить пайплайн сразу, как только прочитали инструкция бранчинга до тех пор, пока не станет известен следующий адрес.</p>\\n<p>Но обычно используется <em>branch prediction</em>: попытаться предсказать, какой бранч будет выбран и начать загружать его. Если окажется, что выбран не он, то загрузку этого отбрасываем и считаем заново правильный.</p>\\n<p>Очень популярный подход для предсказания бранчей - для каждого бранча помнить, был ли он в прошлый раз выбран или нет, и предсказывать что в следующий раз будет так же. Это хорошо работает для циклов.</p>\\n<p>Еще один вариант решения - <em>отложенное выполнение</em>: переупорядочить инструкции так, чтобы пока не станет известен адрес бранча для перехода, выполнялись другие инструкции, не зависящие от этого.</p>\\n<h2>Pipelined datapath</h2>\\n<p>На схеме изображена наша однотактовая схема процессора, на которой выделены шаги пайплайна:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/41f47af6c90e30f3960019492f4073df/eb88f/pipelined-datapath.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 70.27379400260756%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAAB6klEQVQ4y3VTiXKrMAzk/z+ynUnK0RAwhy/AoLcrcJPO9HnQYIO8Wq3XxXEcwrFtm0zTpMF5CEGqspKmaSTGKM45Kb++ZBxH8d7LYIzmLsuiueMwaF4hf4yUkrDQvu/65prBNYMF88jf8ih82qW3QQYXxCC6yWr4bZeIPMYcVwnp0HlATFg7/PfpLJYLsHhhlySz87qYZysj2mjbp7aiyYiI+UoZ0FKWBxsuwF3zfgDdmsSHM5E6zPMMwFZ1oiYMa63+67pOzDgpQ3Zgt5ccfwJSXAK8a8KxrqseDotZHM4Chgmbj0vDXy07VHmaUYwZEEZBGc46ZUWm7eMhA+YTTnhF+xsKJICw0DsBBVxQxlgvZd1IjYi0ADZ+g9H9fle7sNVsF8pB+3TPTsHImgRy22qb480efd/L58eHgtd1rayqqpLb7SZPHBb1JFuyG9AVc2YcZPNoBc1KcVxaqP8AbFGxA2g7zgrOIjRxWZYKtIAVpenBmuwWAOueYVJbFbn3d+CwrNLPTjezXQKzrZybbxSDUpAh2UXY6Afw/U3A0UcJ3kmDlowyfd2OdPlQbwpvEP79AswjA9LENG3EkjfE0lrpNDLXvDnnXIS2s8smDut1/w8gfaV3VKU4C+xIxvNaXxLxpmxbOuXCt387kUPuh4dhEQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Pipelined datapath\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/41f47af6c90e30f3960019492f4073df/10273/pipelined-datapath.png\\\"\\n        srcset=\\\"/hows-that-again/static/41f47af6c90e30f3960019492f4073df/9b14a/pipelined-datapath.png 163w,\\n/hows-that-again/static/41f47af6c90e30f3960019492f4073df/94962/pipelined-datapath.png 325w,\\n/hows-that-again/static/41f47af6c90e30f3960019492f4073df/10273/pipelined-datapath.png 650w,\\n/hows-that-again/static/41f47af6c90e30f3960019492f4073df/eb88f/pipelined-datapath.png 767w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Данные всегда идут слева направо, кроме 2 исключений:</p>\\n<ul>\\n<li>write-back, где данные из памяти идут в регистр</li>\\n<li>выбор следующего значения PC</li>\\n</ul>\\n<p>Но эти исключения не мешают выполнению текущей инструкции - они влияют только на последующие инструкции в пайплайне.</p>\\n<p>При этом первое исключение может привести к рискам данных, а второе - к рискам управления.</p>\\n<p>Чтобы каждый из шагов выполнялся в отдельном такте, между ними нужно поместить специальные пайплайн-регистры, которые будут хранить результат выполнения предыдущего шага для передачи его в следующий. При этом, если из шага выходит несколько значений, то и регистр должен быть достаточно большим, чтобы все их вместить.</p>\\n<p>Например, на следующей схеме регистр <code>IF/ID</code> должен быть 64-битным, чтобы вместить 2 выхода из шага <code>IF</code>. Остальные регистры содержат 128, 97 и 64 бита соответственно.</p>\\n<p>Чтение из таких регистров производится в начале такта, а запись - в конце, поэтому конфликта не происходит. </p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/32f40166d3a680afb61cb90a2be93144/3e276/pipelined-datapath2.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 47.19800747198008%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABqElEQVQozz1Si27bMAz0///WhmZJt3XAugHdmraZE8eWZEuW/JBsyTdKdkKAEEHQd8ejMykljDEpu+3t+z6lcw7OWlhKTX271eM4QimVZmJ47zFQL0bWqjYVcbDrOoydwVl1eJPr8LIscLPHM9PwVMcIlL8YEY82TkA7j5+lWgGjohtg27YYjMZRaPzm1J+npDJ++Pm9wrWqwCiV1ni8KJh+SIDKBTxVJtVZXddJWQT2PiTws7b4I4e7Qk/CDnkNUTewtNpEKz5VGnNYFetpwY9qFZY1TYNrUYAxBk3MbujxITvsjxfwa5GIKi6w/yegiTgCSrJpTwRR4UJbMD3ge7lal4WwqprnmQbJaN0mwN3rGfn7WyJhpOzTscD5UkBwDi4EHsgC0cgkIOcSX04cSnBk2GKaJso5MV6Mw9dTCaPk3cOoMAKOw4CRersTQ1FWCZDpHrsPhrapkUWPlu1624OcPPyWc/ofZnBSVDKOw1nCumklp6sf6ChR4TT2KKRJR/LOroA382816yxeOXkS/F3hC49HCIl1puO9CIOwbddNAX/rjsBH/AeN/rKBuZCMTQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Pipelined datapath 2\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/32f40166d3a680afb61cb90a2be93144/10273/pipelined-datapath2.png\\\"\\n        srcset=\\\"/hows-that-again/static/32f40166d3a680afb61cb90a2be93144/9b14a/pipelined-datapath2.png 163w,\\n/hows-that-again/static/32f40166d3a680afb61cb90a2be93144/94962/pipelined-datapath2.png 325w,\\n/hows-that-again/static/32f40166d3a680afb61cb90a2be93144/10273/pipelined-datapath2.png 650w,\\n/hows-that-again/static/32f40166d3a680afb61cb90a2be93144/3e276/pipelined-datapath2.png 803w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<h2>Forwarding unit</h2>\\n<p>Форвардинг - направление результата работы АЛУ на текущей инструкции сразу на вход АЛУ следующей, чтобы следующая не дожидалась пока текущая завершится и запишет свой результат в регистр.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/88573e5fa0145476d231895dfb49207d/afeef/pipeline-forwarding.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 630px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 128.41269841269843%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAAsSAAALEgHS3X78AAADG0lEQVRIx22Vi27iQAxF+f/P27YrdVVUnnlDHpCQAMHrY+I0UEaykpl47lzb15OZTMb1epXdbieXy8Xmt9vNjMFaEidSleWDfxLHtsf9ZyyeTiezrutkl2Uj4PNhaZrKoarGzYw0SaTIix/AMAjNmVEUhRyPR6l0Ewcwr+t6BOXAKXsGfufz+Qew1BCiMJRYqR8Oh5EpA8f9fm+gvHMY1jTNCMS8bdsfQGdSFqUAzmY2wIRnQkj6nXc2x1Fkfn4gJLq2G6OYkVBCxggVB0Br3Qy7kwJNQ+Z7vs/l78eHZJpvjyDUKPeKNWMCG88PTPq+t3cPh29Egm+mhcnSOxAF8v1hEMhms7kDTitpDhoK+QDIzQGRCaDMkVA5GGmB/QgIAIDNUIBXw+XFd5if9SDAiIRBdA8MAWXRZfQK8Pkw/H0NrBmFqAc5QNkr2g5splYOOvVvsIQh+3gfQw40ocE2MC16QTgV83eefIO9zV+s8Zw9h+Wifh5WJGUxbUvWXAWjDq266uSnbLX0hAMDnj4AWi6X1us+YMcaGhw7hZxxgrcRKeC5Wq3ke/4ll6613Dmb81MEVpRu0ssRrTQkO8/zoW87iaJYtqmK99xLqYVjI5LicJidB63eizTpZRwJk8LQzy7YOEklbW8SKKGDAuFDRRF2rl3CoNoA/uplv0hdAqTh3+enbNcrabqLReAyKTQKbP71Zb3PHidhwgZgVP7w5ORPBUyiUNK8tBuHUEkHRWHOlcc7lyv+i+9vK9CvXjYmakG2l/DUS971VnFOr4/3Xvbryw/hG5cFqfjVy8yhn2k+E81h1PYPGi0nFwK3zf0uLUxWkHkAxPhvvL+/y1JDyOJICq3yrb+aVpuhOJv1xjpru91a+LQue62Xp4DIgZySv7c/b3a/baqTRGVtlunF6sL3a+2o/hSH3J+aFwwZ5GI+n0uuCgh3uaybXtYqtbg8SKTyWq/XynBrDB3sPOR55neZA/oV5j+tQ1XKvjrK7lDfJaVVRXd+aThTogPL/nqLxcLyQrtVw4/K/y930MqMNTbxn2kGOw3GHlLxH1Va3ctF5fktAAAAAElFTkSuQmCC'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Pipeline forwarding\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/88573e5fa0145476d231895dfb49207d/afeef/pipeline-forwarding.png\\\"\\n        srcset=\\\"/hows-that-again/static/88573e5fa0145476d231895dfb49207d/4715b/pipeline-forwarding.png 163w,\\n/hows-that-again/static/88573e5fa0145476d231895dfb49207d/503c4/pipeline-forwarding.png 325w,\\n/hows-that-again/static/88573e5fa0145476d231895dfb49207d/afeef/pipeline-forwarding.png 630w\\\"\\n        sizes=\\\"(max-width: 630px) 100vw, 630px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Здесь наверху - обычная схема, снизу - схема с добавленной функциональностью форвардинга. </p>\\n<p><code>Forwarding unit</code> - смотрит, совпадает ли регистр, куда пишется результат АЛУ на текущей инструкции (<code>EX/MEM.RegisterRd</code>) с регистром, откуда берется операнд для АЛУ на следующей (<code>ID/EX.RegisterRs</code>) и если да, то активирует контрольную линию <code>ForwardA</code>, которая верхнему мультиплексору говорит брать то значение, которое приходит из регистра <code>EX/MEM</code>. </p>\\n<p>Аналогично обрабатываются 3 других случая:</p>\\n<pre><code>if (EX/MEM.RegWrite\\nand (EX/MEM.RegisterRd ≠ 0)\\nand (EX/MEM.RegisterRd = ID/EX.RegisterRs)) ForwardA = 10\\n\\nif (EX/MEM.RegWrite\\nand (EX/MEM.RegisterRd ≠ 0)\\nand (EX/MEM.RegisterRd = ID/EX.RegisterRt)) ForwardB = 10\\n\\nif (MEM/WB.RegWrite\\nand (MEM/WB.RegisterRd ≠ 0)\\nand ( MEM/WB.RegisterRd = ID/EX.RegisterRs)) ForwardA = 01\\n\\nif (MEM/WB.RegWrite\\nand (MEM/WB.RegisterRd ≠ 0)\\nand (MEM/WB.RegisterRd = ID/EX.RegisterRt)) ForwardB = 01\\n</code></pre>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/83946b40ecb23879a33ce4a1db031e52/3cece/forwarding-controls.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 611px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 31.914893617021278%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABaUlEQVQY0y2PzW7aUBCF/WJdVUlVddldWnVdqZH6InmmJiRIVWkIcE3xz7WxsWOD/42NwVl9vThZfDozZ+6MztVurCPfJgeunw58+dNypfj+1PH5d8vl/Z6L+4bLh3bQT+OGH7OOn/OOr2rn/ajhg5p9HLe8u2sGXxNuwFiYzJ0NE7lhrNuYUcrUi7nVJaN/LndKfwmb0VLy13CYWi4Pwhq8yTpmFmYs4hIrqdCiYIM0ViRxRJnusJY60canqyvkaolnmYRrB19aRP4aR/WelPiO5NlzByLfo9xtObUNWlGUlFVFvd+TFwWFou978rzA933CMKRS86qqqepX6jeKshy071/ojkeatkVzXZfp4yNnDYOA+WxGoDTPMizTxDSMASEExspgqevoQlf1CrFYYKo3vucRxzHd4YCWpRlb1ZRv6Z5VokwdO9fnQ1J9z7ZtoihSqXOSJGG33XLeS5OUNFUor1RpT6cT/wGuw6m1IBDRnAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Forwarding controls\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/83946b40ecb23879a33ce4a1db031e52/3cece/forwarding-controls.png\\\"\\n        srcset=\\\"/hows-that-again/static/83946b40ecb23879a33ce4a1db031e52/9adac/forwarding-controls.png 163w,\\n/hows-that-again/static/83946b40ecb23879a33ce4a1db031e52/90375/forwarding-controls.png 325w,\\n/hows-that-again/static/83946b40ecb23879a33ce4a1db031e52/3cece/forwarding-controls.png 611w\\\"\\n        sizes=\\\"(max-width: 611px) 100vw, 611px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<h2>Static Multiple Issue</h2>\\n<p>Компилятор упаковывает несколько разных инструкций в одну длинную инструкцию. За счет дублирования блоков процессор выполняет несколько инструкций за один такт.</p>\\n<h2>Dynamic Multiple Issue</h2>\\n<p>Тоже самое, что и Static, но инструкции объединяются не компилятором, а самим процессором во время выполнения. Так же такой подход называется <strong>суперскалярным</strong>.</p>\\n<p>Дублируются обычно блоки АЛУ и блоки регистров. Такой подход используется во всех современных архитектурах.</p>\\n<h2>Реальные архитектуры процессоров</h2>\\n<h3>ARM Cortex-A8</h3>\\n<p>Использует пайплайн из 14 шагов. Суперскаляр с 2 иструкциями за такт. Инструкции не перемешиваются, а выполняются ровно в том порядке, в котором приходят. Пайплайн состоит из 3 секций: получение инструкции, декодирование и выполнение. </p>\\n<p>На схеме ибозражен пайплайн процессора ARM A8:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/edf06e328c5ffc6600fd7e0c8f4d9475/72793/a8-pipeline.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 577px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 43.327556325823224%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABfElEQVQoz3VRaW+CQBDl//8sm9gPFsohh1wKRlFRDqUCXtN5U7FJk5JMZnbZfdcqx+OR2nNLdV3T5XKhqiyprioqikKq5Kp43XUdNU0j/Xw+yzwU1sC53++k0J/ver1S4Ps0n88pjiIKgkCIHo+HABeHg3QhYvKS6/DcO51OpAAdIH3XU9u2wpbnuajDIczYh4IkSSiOY+lz7ovFQnoUhrTZbKSU9XpNWZYJC+xADQjQh8Ia7Ljos/qIlQNYQNkJ3KxWK7KnU1KQlz+bEYABCgvIAnW73V4zSPVPnRzbkfMzzyOPCwSmYYhq13FIcV2XDF0nTdOEAUoQ9H6/l8eBZQDvdjuyLEvAkGvIlbBlqJ3yPvLGfwWy30Yj8hgYh6AQOeLVGwZHjrAMBzoTm4ZJ6odKqqpKBFD8Ph7LfYOVKrjwMZkIwBcrQ/hDdn3fv2YoxSXbtsWRZZpiN2RQTdV+Fd6fOQ15/fcBHK+43W5pk/28aM4xoC/TpfQ0TekbFOKfzXPITU0AAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"ARM A8 Pipeline\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/edf06e328c5ffc6600fd7e0c8f4d9475/72793/a8-pipeline.png\\\"\\n        srcset=\\\"/hows-that-again/static/edf06e328c5ffc6600fd7e0c8f4d9475/0e63c/a8-pipeline.png 163w,\\n/hows-that-again/static/edf06e328c5ffc6600fd7e0c8f4d9475/d1ac8/a8-pipeline.png 325w,\\n/hows-that-again/static/edf06e328c5ffc6600fd7e0c8f4d9475/72793/a8-pipeline.png 577w\\\"\\n        sizes=\\\"(max-width: 577px) 100vw, 577px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Первые 3 шага получают 2 инструкции за такт и поддерживают очередь из 12 заранее прочитанных инструкций. Для этого используется 2-уровневый бранч-предиктор, состощий из:</p>\\n<ul>\\n<li><strong>BTB: Branch target buffer</strong> на 512 записей, содержащий адреса используемых бранчей</li>\\n<li><strong>GHB: Global history buffer</strong> на 4096 записей, содержащий историю переходов по бранчам</li>\\n<li><strong>RS: Return stack</strong> на 8 записей, предскаывающий будущие возвраты из бранчей</li>\\n</ul>\\n<p>Если предсказание бранча ошиблось, то пайплайн очищается и мы получаем штраф на 13 тактов.</p>\\n<p>Затем блок из 5 шагов определяет, есть ли зависимости между инструкциями и в какой пайплайн последней секции нужно подать инструкцию.</p>\\n<p>Последние 6 шагов предоставляют один пайплайн для инструкций сохранения/загрузки и 2 пайплайна для арифметических операций.</p>\\n<h3>Intel Core i7 920</h3>\\n<p>Архитектура x86. Предоставляет сложный подход к пайплайнингу, использует 14-шаговый пайплайн,  мультискалярность, спекуляции, перемешивание инструкций. </p>\\n<p>Из-за очень сложного набора инструкций x86, Intel сначала преобразует их в так называемые <em>микрооперации</em>, похожие на операции, используемые в MIPS. Затем эти микрооперации используются сложным, спекуляционным пайплайном с динамическим расписанием, который может выполнять до 6 микроопераций за такт.</p>\\n<p><img src=\\\"core-i8-pipeline.png\\\" alt=\\\"Core i8 Pipeline\\\"></p>\\n<p>Внутренняя организация процессора называется его <strong>микроархитектурой</strong>.</p>\\n<p>Каждая инструкция x86 проходит через 7 этапов:</p>\\n<ol>\\n<li><strong>Instruction fetch</strong> - используется многоуровненый <em>branch target buffer</em> для достижения баланса между скоростью и точностью предсказаний. Ошибочное предсказание влечет штраф на 15 тактов. В результате получаем пакет инструкций длиной 16 байт.</li>\\n<li><strong>Predecode</strong> - полученные 16 байт кладутся в <em>predecode instruction buffer</em> и на этом этапе преобразуются в индивидуальные инструкции x86. Это нетривиальный шаг, так как инструкции x86 имеют длину от 1 до 15 байт. Полученные инструкции кладутся в 18-элементную очередь инструкций.</li>\\n<li><strong>Micro-op decode</strong> - инструкции x86 транслируются в <em>микрооперации</em>. 3 из 4 декодеров работают с инструкциями, которые напрямую транслируются в 1 микрооперацию. Декодер для сложных инструкций транслирует инструкцию в последовательность микроопераций. Он производит до 4 микроопераций за такт и продолжает работать в следующих тактах, пока не сгенерирует всю нужную последовательность. Микрооперации помещаются в 28-элементный буфер микроопераций.</li>\\n<li><strong>Loop stream detection</strong> - если есть последовательность инструкций (меньше чем 28 штук или 256 байт в длину), которые образуют петлю, то на этом этапе они обнаруживаются и дальше микрооперации будут подаваться напрямую из буфера микроопераций, чтобы не выполнять впустую шаги 1-3</li>\\n<li><strong>Perform the basic instruction issue</strong> - регистр ищется в таблице регистров, переименовывается, выделяется место в <em>reorder buffer entry</em>, из <em>reorder buffer</em> и регистров получаются нужные значения прежде чем микрооперации отправятся в <em>reservation stations</em></li>\\n<li><strong>Reservation</strong> - 6 функциональных блоков поддерживают 36-элементную станцию резервации. На этом этапе микрооперации распределяются между ними. В каждый из блоков можно назначить до 6 микроопераций за такт.</li>\\n<li>Функциональные блоки выполняют микрооперации, результаты посылаются обратно на станцию резервации и в <em>register retirement unit</em>, откуда они запишутся в регистры, как только станет известно, что инструкция больше не спекулятивна. После этого инструкция в <em>reorder buffer</em> помечается как выполненная</li>\\n<li>Когда одна или несколько инструкций сверху <em>reorder buffer</em> помечаются как выполненные, ожидающие записи в <em>register retirement unit</em> выполняются, а инструкции удаляются из буфера.</li>\\n</ol>\\n<h2>Кэши процессора</h2>\\n<p>Кэши создаются основе статической памяти RAM или SRAM.</p>\\n<p>Кэш L1 - свой у каждого ядра. Самый быстрый и самый мелкий. Обычно процессоры имеют два кэша L1 - для инструкций и для данных.</p>\\n<p>Кэш L2 - разделятся между всеми ядрами и через него ядра могут обмениваться информацией. Некоторые процессоры дублируют данные из L1 в L2. Этот кеш медленнее, но больше, чем L1.</p>\\n<p>Кэш L3 - тоже разделяется между всеми ядрами, но использует более медленный и дешевый SRAM, чем L2, засчет чего размер L3 может быть сильно больше L2.</p>\\n<p>Процессор спроектирован так, что самые важные значения кладутся в более быстрый L2, а менее важные - в медленный L3.</p>\\n<p>При попытке чтения из кэша процессор сначала ищет его в L1, потом в L2, потом в L3, L4 и, когда кеши кончаются - в память.</p>\\n<p>Логически кэш-память представляет собой набор кэш-линий. Каждая кэш-линия хранит блок данных и дополнительную информацию. Под размером кэш-линии понимают размер блока данных. В архитектуре x86 размер кэш-линии составляет 64 байта. </p>\\n<p>Суть кэширования состоит в разбиении RAM на кэш-линии и отображении их на кэш-линии кэш-памяти. Возможно несколько вариантов такого отображения.</p>\\n<h3>Inclusive vs Exclusive</h3>\\n<p><strong>(В этом разделе под верхними уровнями подразумеваются более быстрые уровни, то есть L1 - выше, чем L2)</strong></p>\\n<p>Если все блоки верхнего уровня кэша присутствуют в блоке нижнего уровня, тогда нижний называется <strong>инклюзивным</strong>. Такие кэши используются в процессорах Intel.</p>\\n<p>Если же в нижнем уровне только те блоки, которых нет в верхнем - то он <strong>эксклюзивный</strong>. Такие кэши используются в процессорах AMD.</p>\\n<p>При чтении из инклюзивного кэша:</p>\\n<ul>\\n<li>если блок Х найден в L1, то читаем оттуда</li>\\n<li>если не найден в L1, но найден в L2, тогда копируем его в L1. </li>\\n<li>если же не найден ни L1 ни на L2, но найден в L3, то копируем его в L2 и L1. </li>\\n</ul>\\n<p>При переполнении одного из уровней <strong>удаляем</strong> один из старых блоков и шлет уровню <strong>выше</strong> команду удаления этого блока, чтобы не нарушить свойство инклюзивности.</p>\\n<p>При чтении из эксклюзивного кэша:</p>\\n<ul>\\n<li>если блок Х найден в L1, то читаем оттуда</li>\\n<li>если не найден в L1, то найден в L2, тогда <strong>перемещаем</strong> его из L2 в L1. </li>\\n<li>если не найден ни на одном из уровней, то берем из памяти и кладем в L1. </li>\\n</ul>\\n<p>При переполнении одного из уровней <strong>перемещаем</strong> один из старых блоков на уровень <strong>ниже</strong>, чтобы не нарушить свойство эксклюзивности.</p>\\n<p>Таким образом, низжие уровни кэша получают блоки только когда они вытесняются высшими уровнями, что делает низжие уровни эксклюзивных кэшей <strong>виктимными кэшами</strong>.</p>\\n<h3>Виды отображения</h3>\\n<h4>Direct Mapping</h4>\\n<p>RAM делится на сегменты, причем размер каждого сегмента равен размеру кэша, а каждый сегмент делится на блоки, причем размер каждого блока равен размеру кэш-линии.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/6dee6c84c45b72969524a7339f66296c/739ee/cpu-cache-direct-mapping.jpg\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 82.72604588394063%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMBBf/EABUBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAHsVlo2CSwirC5//8QAGhAAAQUBAAAAAAAAAAAAAAAAAQIQETFCMv/aAAgBAQABBQIdy2yqCK0qxX//xAAVEQEBAAAAAAAAAAAAAAAAAAAQQf/aAAgBAwEBPwEp/8QAFREBAQAAAAAAAAAAAAAAAAAAEEH/2gAIAQIBAT8BIf/EABUQAQEAAAAAAAAAAAAAAAAAACBB/9oACAEBAAY/AoIf/8QAHRAAAwACAgMAAAAAAAAAAAAAAAERITFRYXGhsf/aAAgBAQABPyFFUy85Gq5E6K1ZOtjoe7GqMR+JoP/aAAwDAQACAAMAAAAQ2ADA/8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQMBAT8QSEf/xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAgEBPxAjH//EAB0QAQACAgIDAAAAAAAAAAAAAAEAESExYXGBkaH/2gAIAQEAAT8QyYLOrekRpy4IZsvyRo07OIOSaXoYiFWl4m/tm/pPgJ//2Q=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Direct Mapping\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/6dee6c84c45b72969524a7339f66296c/b80fa/cpu-cache-direct-mapping.jpg\\\"\\n        srcset=\\\"/hows-that-again/static/6dee6c84c45b72969524a7339f66296c/cf410/cpu-cache-direct-mapping.jpg 163w,\\n/hows-that-again/static/6dee6c84c45b72969524a7339f66296c/62f2a/cpu-cache-direct-mapping.jpg 325w,\\n/hows-that-again/static/6dee6c84c45b72969524a7339f66296c/b80fa/cpu-cache-direct-mapping.jpg 650w,\\n/hows-that-again/static/6dee6c84c45b72969524a7339f66296c/739ee/cpu-cache-direct-mapping.jpg 741w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Адрес каждого байта представляет собой сумму порядкового номера сегмента, порядкового номера кэш-линии внутри сегмента и порядкового номера байта внутри кэш-линии. </p>\\n<p>Тэг кэш-линии хранит порядковый номер сегмента, то есть старшую часть адреса первого байта в данной кэш-линии.</p>\\n<p>Этапы поиска:</p>\\n<ol>\\n<li>извлекается средняя часть адреса, определяющая номер линии в кэше</li>\\n<li>тэг кэш-линии сравнивается со старшей частью адреса, то есть с номером сегмента</li>\\n<li>если совпадает, то внутри этой кэш-линии ищем байт с адресом, совпадающим с младшей частью искомого адреса.</li>\\n</ol>\\n<p>Этот вариант очень подвержен конфликтам, когда две строки соревнуются за одну ячейку, поочередно вытесняя друг друга из кэша.</p>\\n<h4>Fully associative mapping</h4>\\n<p>RAM делится на блоки, размер которых равен размеру кэш-линий. Каждый блок RAM может сохраняться в любой кэш-линии кэша.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/420ac154242ce109ed755b623b915d0e/db3c4/cpu-cache-fully-associative-mapping.jpg\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 88.62019914651495%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAASABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7WuQ2VFYIuD/xAAcEAABAwUAAAAAAAAAAAAAAAABAAJCEBEhMUH/2gAIAQEAAQUClSZdZDI64Ia//8QAFREBAQAAAAAAAAAAAAAAAAAAEAH/2gAIAQMBAT8BIf/EABURAQEAAAAAAAAAAAAAAAAAABAB/9oACAECAQE/ASn/xAAVEAEBAAAAAAAAAAAAAAAAAAAgMf/aAAgBAQAGPwIQ/wD/xAAbEAEAAgIDAAAAAAAAAAAAAAABABEhQRCBwf/aAAgBAQABPyFKt7y3oRFRbuPIlRDWApgmIn//2gAMAwEAAgADAAAAENAPw//EABcRAQADAAAAAAAAAAAAAAAAAAABEDH/2gAIAQMBAT8QrSX/xAAXEQEAAwAAAAAAAAAAAAAAAAAAARAx/9oACAECAQE/EKwh/8QAHRABAAICAgMAAAAAAAAAAAAAAQARITFBURBhkf/aAAgBAQABPxDUihPb55xEQszi9QcUdpKihYPF3FFQuM1EpZrkgBAB0T//2Q=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Fully Associative Mapping\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/420ac154242ce109ed755b623b915d0e/b80fa/cpu-cache-fully-associative-mapping.jpg\\\"\\n        srcset=\\\"/hows-that-again/static/420ac154242ce109ed755b623b915d0e/cf410/cpu-cache-fully-associative-mapping.jpg 163w,\\n/hows-that-again/static/420ac154242ce109ed755b623b915d0e/62f2a/cpu-cache-fully-associative-mapping.jpg 325w,\\n/hows-that-again/static/420ac154242ce109ed755b623b915d0e/b80fa/cpu-cache-fully-associative-mapping.jpg 650w,\\n/hows-that-again/static/420ac154242ce109ed755b623b915d0e/db3c4/cpu-cache-fully-associative-mapping.jpg 703w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Адрес каждого байта представляет собой сумму порядкового номера кэш-линии и порядкового номера байта внутри кэш-линии. Адреса байт различаются только старшими частями, поэтому в тэге каждой кэш-линии хранится старшая часть, то есть порядковый номер кэш-линии(блока) в RAM.</p>\\n<p>Этапы поиска:</p>\\n<ol>\\n<li>тэги всех кэш-линий сравниваются со старшей частью адреса одновременно</li>\\n<li>если было совпадение по одному из тэгов, то внутри этой кэш-линии ищем байт с адресом, совпадающим с младшей частью искомого адреса</li>\\n</ol>\\n<p>Этот вариант имеет гораздо меньше конфликтов, но сложен и дорог в реализации.</p>\\n<h4>Set associative mapping</h4>\\n<p>Когда говорят об N-ассоциативном кэше, то имеется в виду этот тип отображения с N каналами.</p>\\n<p>RAM делится так же, как и в прямом отображеии, а сам кэш состоит из k каналов, использующих прямое отображение. Кэш-линии, имеющие одинаковые номера во всех каналах, образуют <strong>сет</strong>.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/5b0d916a6d1b2d80f8a658a58676d1c4/c88de/cpu-cache-set-associative-mapping-set.jpg\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 31%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAMF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB2QUB/8QAGBAAAgMAAAAAAAAAAAAAAAAAAAECMUH/2gAIAQEAAQUCaZka/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGBAAAgMAAAAAAAAAAAAAAAAAAAEQESH/2gAIAQEABj8CelR//8QAGhABAAIDAQAAAAAAAAAAAAAAAQARMUFhcf/aAAgBAQABPyECtuwHM37AlGf/2gAMAwEAAgADAAAAEAPP/8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQMBAT8Qp//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAECAQE/EIf/xAAZEAEBAAMBAAAAAAAAAAAAAAABEQAhsTH/2gAIAQEAAT8QXClyPWJRtdNd9yrK13V7n//Z'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Set Associative Mapping (Set)\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/5b0d916a6d1b2d80f8a658a58676d1c4/b80fa/cpu-cache-set-associative-mapping-set.jpg\\\"\\n        srcset=\\\"/hows-that-again/static/5b0d916a6d1b2d80f8a658a58676d1c4/cf410/cpu-cache-set-associative-mapping-set.jpg 163w,\\n/hows-that-again/static/5b0d916a6d1b2d80f8a658a58676d1c4/62f2a/cpu-cache-set-associative-mapping-set.jpg 325w,\\n/hows-that-again/static/5b0d916a6d1b2d80f8a658a58676d1c4/b80fa/cpu-cache-set-associative-mapping-set.jpg 650w,\\n/hows-that-again/static/5b0d916a6d1b2d80f8a658a58676d1c4/c88de/cpu-cache-set-associative-mapping-set.jpg 800w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/4f85224c39f0c2674ca2b73e58b550a6/c88de/cpu-cache-set-associative-mapping.jpg\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 51.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIBBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe1VA0f/xAAXEAEBAQEAAAAAAAAAAAAAAAABABEg/9oACAEBAAEFAoSHeP/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABUQAQEAAAAAAAAAAAAAAAAAAAEg/9oACAEBAAY/Amv/xAAZEAEBAAMBAAAAAAAAAAAAAAABABExUSH/2gAIAQEAAT8hEPes2kQDJIcsHLV//9oADAMBAAIAAwAAABBkz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAQADAQADAAAAAAAAAAAAAAEAESExYXGR/9oACAEBAAE/EL8ExZYbML5NUV6liqU9yAaD5ABQAeJ//9k='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Set Associative Mapping\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/4f85224c39f0c2674ca2b73e58b550a6/b80fa/cpu-cache-set-associative-mapping.jpg\\\"\\n        srcset=\\\"/hows-that-again/static/4f85224c39f0c2674ca2b73e58b550a6/cf410/cpu-cache-set-associative-mapping.jpg 163w,\\n/hows-that-again/static/4f85224c39f0c2674ca2b73e58b550a6/62f2a/cpu-cache-set-associative-mapping.jpg 325w,\\n/hows-that-again/static/4f85224c39f0c2674ca2b73e58b550a6/b80fa/cpu-cache-set-associative-mapping.jpg 650w,\\n/hows-that-again/static/4f85224c39f0c2674ca2b73e58b550a6/c88de/cpu-cache-set-associative-mapping.jpg 800w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Структура адреса и тэга такая же, как и в прямом отображении, но алгоритм поиска отличается:</p>\\n<ol>\\n<li>извлекается средняя часть адреса, определяющая номер сэта в кеше</li>\\n<li>тэги всех кэш-линий данного сета сравниваются со старшей частью одновременно</li>\\n<li>если было совпадение по одному из тэгов, то внутри этой кэш-линии ищем байт с адресом, совпадающим с младшей частью искомого адреса</li>\\n</ol>\\n<p>Таким образом, количество каналов кэша определяет количество одновременно сравниваемых тэгов.</p>\\n<p>Этот вариант является общепринятым компромиссом между сложностью реализации и эффективностью.</p>\\n<h3>Категории промахов</h3>\\n<ul>\\n<li><strong>Промах по чтению из кэша инструкций</strong>. Обычно дает очень большую задержку, поскольку процессор не может продолжать исполнение программы (по крайней мере, текущего потока исполнения) и вынужден простаивать в ожидании загрузки инструкции из памяти.</li>\\n<li><strong>Промах по чтению из кэша данных.</strong> Обычно дает меньшую задержку, поскольку инструкции, не зависящие от запрошенных данных, могут продолжать исполняться, пока запрос обрабатывается в основной памяти. После получения данных из памяти можно продолжать исполнение зависимых инструкций.</li>\\n<li><strong>Промах по записи в кэш данных</strong>. Обычно дает наименьшую задержку, поскольку запись может быть поставлена в очередь и последующие инструкции практически не ограничены в своих возможностях. Процессор может продолжать свою работу, кроме случаев промаха по записи с полностью заполненной очередью.</li>\\n</ul>\\n<h3>Согласованность кэшей</h3>\\n<p>Кэш L1 - свой у каждого ядра. То есть у нас в несколько разных кэшей копируются одни и те же данные из памяти. Так как они используются на чтение и запись разными потоками, то теоретически могут рассинхронизироваться и значение какого-то адреса в одном кэше может не совпадать со значением этого же адреса в другом.</p>\\n<p>На практике аппаратные кэши в современных процессорах всегда синхронизируются. Это значит, что если два разных потока в любом месте системы читают данные с одного и того же адреса памяти, то они никогда не должны <em>одновременно</em> считывать разные значения.</p>\\n<p>Наиболее распространенный протокол для обеспечения согласованности между кэшами известен как протокол MESI. </p>\\n<h4>MESI</h4>\\n<p>Каждая строка данных в кэше помечена одним из следующих состояний:</p>\\n<ol>\\n<li><strong>М</strong>odified - данные модифицированы и отличаются от основной памяти. Являются источником истины, а все остальные источники устарели.</li>\\n<li><strong>E</strong>xclusive - данные не модифицированы и синхронизированы с основной памятью. Ни в одном другом кэше того же уровня нет этих данных.</li>\\n<li><strong>S</strong>hared - данные не модифицированы и синхронизированы с общей памятью. В других кэшах того же уровня (возможно) есть те же данные</li>\\n<li><strong>I</strong>nvalid - данные устарели и не должны использоваться</li>\\n</ol>\\n<p>Применяя и обновляя эти состояния, можно добиться согласованности кэша.</p>\\n<p>Рассмотрим несколько примеров для процессора с четырьмя ядрами, у каждого из которых собственный кэш L1, а также глобальный кэш L2 на кристалле.</p>\\n<h5>Запись в память</h5>\\n<p>Предположим, что поток на core-1 хочет записать в память по адресу 0xabcd. Ниже приведены некоторые возможные последовательности событий.</p>\\n<h6>Попадание в кэш</h6>\\n<p>В L1-1 есть данные в состоянии E или M.\\nL1-1 производит запись. Всё готово.\\nНи в одном другом кэше нет данных, так что немедленная запись будет безопасной.\\nСостояние строки кэша изменяется на M, поскольку она теперь изменена.</p>\\n<h6>Промах локального кэша, попадание одноуровневого кэша</h6>\\n<p>В L1-1 есть данные в состоянии S.\\nЭто значит, что в другом одноуровневом кэше могут быть эти данные.\\nТа же последовательность применяется, если в L1-1 вообще нет этих данных.\\nL1-1 отправляет Request-For-Ownership в кэш L2.\\nL2 смотрит по своему каталогу и видит, что в L1-2 сейчас есть эти данные в состоянии S.\\nL2 отправляет snoop-invalidate в L1-2.\\nL1-2 помечает данные как недействительные (I).\\nL1-2 отправляет запрос Ack в L2.\\nL2 отправляет Ack вместе с последними данными в L1-1.\\nL2 проверяет, что в L1-1 эти данные хранятся в состоянии E.\\nВ L1-1 теперь последние данные, а также разрешение войти в состояние E.\\nL1-1 осуществляет запись и изменяет состояние этих данных на M.</p>\\n<h5>Чтение памяти</h5>\\n<p>Теперь предположим, что поток на core-2 хочет считать с адреса 0xabcd. Ниже приведены некоторые возможные последовательности событий.</p>\\n<h6>Попадание кэша</h6>\\n<p>L1-2 имеет данные в состоянии S, E или M.\\nL1-2 считывает данные и возвращает в поток. Готово.</p>\\n<h6>Промах локального кэша, промах кэша верхнего уровня</h6>\\n<p>L1-2 имеет данные в состоянии I (недействительное), то есть не может их использовать.\\nL1-2 отправляет запрос Request-for-Share в кэш L2.\\nВ L2 тоже нет данных. Он считывает данные из памяти.\\nL2 возвращает данные из памяти.\\nL2 отправляет данные в L1-2 с разрешением войти в состояние S.\\nL2 проверяет, что в L1-2 эти данные хранятся в состоянии S.\\nL1-2 получает данные, сохраняет их в кэше и отправляет в поток.</p>\\n<h6>Промах локального кэша, попадание кэша верхнего уровня</h6>\\n<p>В L1-2 есть данные в состоянии I.\\nL1-2 отправляет запрос Request-for-S в кэш L2.\\nL2 видит, что в L1-1 данные в состоянии S.\\nL2 отправляет Ack в L1-2, вместе с данными и разрешением войти в состояние S.\\nL1-2 получает данные, сохраняет их в кэше и отправляет в поток.</p>\\n<h6>Промах локального кэша, попадание одноуровневого кэша</h6>\\n<p>В L1-2 есть данные в состоянии I.\\nL1-2 отправляет запрос Request-for-S в кэш L2.\\nL2 видит, что в L1-1 данные в состоянии E (или M).\\nL2 отправляет snoop-share в L1-1\\nL1-1 понижает состояние до S.\\nL1-1 отправляет Ack в L2 вместе с модифицированными данными, если это применимо.\\nL2 отправляет Ack в L1-2 вместе с данными и разрешением войти в состояние S.\\nL1-2 получает данные, сохраняет их в кэше и отправляет в поток.</p>\\n<h1>Дисковая память</h1>\\n<p>Магнитный жесткий диск состоит из набора металлических пластин, которые вертятся на шпинделе со скоростью 5400-15000 оборотов в минуту. Пластины покрыты с обоих сторон магнитным записываемым материалом, похожим на материал, которым покрываются аудио- или видеокассеты. Чтобы читать и писать информацию на диск, над каждой поверхностью размещается перемещаемая ручка, содержащая на конце маленькую электромагнитную спираль, называемую <em>головкой чтения/записи</em>.</p>\\n<p>Каждая поверхность пластин радлелена на концентрические окружности, называемые \\\"треками\\\". На каждой десятки тысяч таких треков. Каждый трек делится ена сектора, содержащие информацию: на каждом треке тысячи секторов. В секторе обычно от 512 до 4096 байт. На пластине записаны последовательно: номер сектора, пустой промежуток, кусок данных, включающий код коррекции, пустой промежуток, следующий кусок данных с кодом коррекции, и так далее.</p>\\n<p>Головки дисков соединены и двигаются вместе, так что каждая головка находится над одним и тем же треком. Словом <strong>цилиндр</strong> обозначаются все треки под всеми головками.</p>\\n<p>Чтобы обратиться к данным, нужно пройти 3 шага:</p>\\n<ol>\\n<li>Позиционируем головку над нужным треком. Эта операция называется <strong>seek</strong>.</li>\\n<li>Дождаться, пока нужный сектор попадет под головку. Это время называется <strong>rotational latency</strong> или <strong>rotational delay</strong>. </li>\\n<li>Передать блок данных. Время передачи зависит от размера сектора, скорости вращения и плотности записи.</li>\\n</ol>\\n<p>Большинство контроллеров дисков имеют встроенный кэш, который сохраняет все сектора, которые через него проходят.</p>\",\"frontmatter\":{\"path\":\"/blog/books/computer-organization-and-design\",\"title\":\"computer-organization-and-design\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/blog-books-computer-organization-and-design.json\n// module id = 409\n// module chunks = 55889076892030"],"sourceRoot":""}