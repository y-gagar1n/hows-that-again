webpackJsonp([53396112491056],{438:function(e,n){e.exports={data:{markdownRemark:{html:'<h1>Запрос сетевого ресурса</h1>\n<pre><code class="language-java">URL url = new URL("https://adventofcode.com/2018/day/1/input");\nHttpURLConnection conn = (HttpURLConnection)url.openConnection();\nInputStream stream;\ntry {\n    stream = conn.getInputStream();\n}\ncatch(IOException e)\n{\n    stream = conn.getErrorStream(); // без этого, в случае HTTP-статуса, отличного от 200, мы получим просто исключение и не сможем получить тело ответа\n}\nInputStreamReader reader = new InputStreamReader(stream);\nBufferedReader in = new BufferedReader(reader);\n\nString inputLine;\nwhile ((inputLine = in.readLine()) != null)\n    System.out.println(inputLine);\nin.close();\n</code></pre>\n<p>Если нужно обратиться к HTTPS, то нужно <code>HttpURLConnection</code> просто заменить на <code>HttpsURLConnection</code>.</p>\n<p>Если нужно использовать прокси, то делаем так:</p>\n<pre><code class="language-java">HttpsURLConnection conn = (HttpsURLConnection)url.openConnection(new Proxy(Proxy.Type.HTTP, new InetSocketAddress("192.168.2.102", 3128)));\n</code></pre>\n<p>Добавить заголовок можно так:</p>\n<pre><code class="language-java">conn.setRequestProperty("cookie", "COOKIE_CONTENTS");\n</code></pre>\n<h1>Работа с I/O</h1>\n<p>В Java NIO основные концепции - каналы и буферы. При чтении данных каналы читают их из источника в буффер. При записи - буфер пишет в канал.</p>\n<h2>Каналы</h2>\n<p>Самые важные реализации каналов:</p>\n<ul>\n<li><code>FileChannel</code> - работает с файлами</li>\n<li><code>DatagramChannel</code> - работает с UDP</li>\n<li><code>SocketChannel</code> - работает с TCP</li>\n<li><code>ServerSocketChannel</code> - работает с входящими TCP-соединениями, для каждого входящего соединения создается <code>SocketChannel</code>.</li>\n</ul>\n<p>Пример использования <code>FileChannel</code>:</p>\n<pre><code class="language-java">RandomAccessFile aFile = new RandomAccessFile("data/nio-data.txt", "rw");\nFileChannel inChannel = aFile.getChannel();\n\nByteBuffer buf = ByteBuffer.allocate(48);\n\nint bytesRead = inChannel.read(buf);\nwhile (bytesRead != -1) {\n\n  System.out.println("Read " + bytesRead);\n  buf.flip();\n\n  while(buf.hasRemaining()){\n      System.out.print((char) buf.get());\n  }\n\n  buf.clear();\n  bytesRead = inChannel.read(buf);\n}\naFile.close();\n</code></pre>\n<p>Строка <code>buf.flip()</code> очень важна - она переводит буфер из режима записи <strong>в</strong> буфер в режим чтения <strong>из</strong> буфера.</p>\n<h2>Буферы</h2>\n<p>Работа с буфером состоит из 4 шагов:</p>\n<ol>\n<li>Пишем данные в буфер</li>\n<li>Вызываем <code>buffer.flip()</code></li>\n<li>Читаем данные из буфера</li>\n<li>Вызываем <code>buffer.clear()</code> или <code>buffer.compact()</code>.</li>\n</ol>\n<p>Основные реализации буферов:</p>\n<ul>\n<li>ByteBuffer</li>\n<li>MappedByteBuffer</li>\n<li>CharBuffer</li>\n<li>DoubleBuffer</li>\n<li>FloatBuffer</li>\n<li>IntBuffer</li>\n<li>LongBuffer</li>\n<li>ShortBuffer</li>\n</ul>\n<h3>Создание буфера</h3>\n<p>Каждый класс-наследник <code>Buffer</code> имеет метод <code>allocate()</code>, который аллоцирует новый буфер:</p>\n<pre><code class="language-java">ByteBuffer buf = ByteBuffer.allocate(48);\nCharBuffer buf2 = CharBuffer.allocate(48);\n</code></pre>\n<h3>Запись данных в буфер</h3>\n<p>В буфер можно записать данные 2 способами:</p>\n<ol>\n<li>Через канал</li>\n<li>Вручную</li>\n</ol>\n<p>Вот пример записи через канал:</p>\n<pre><code class="language-java">int bytesRead = inChannel.read(buf);\n</code></pre>\n<p>А вот - вручную:</p>\n<pre><code class="language-java">buf.put(127);\n</code></pre>\n<p>У <code>put()</code> есть много перегрузок, можно писать одно значение, массив значений, и даже значения из другого буфера.</p>\n<h3>Чтение данных из буфера</h3>\n<p>Так же как и с записью, есть 2 способа.</p>\n<p>Читать из буфера в канал:</p>\n<pre><code class="language-java">int bytesWritten = inChannel.write(buf);\n</code></pre>\n<p>Читать из буфера в переменную:</p>\n<pre><code class="language-java">byte aByte = buf.get();\n</code></pre>\n<h3>Очистка буфера</h3>\n<p>При вызове <code>clear()</code> внутренний <code>position</code> выставляется в 0, а <code>limit</code> - в <code>capacity</code>. Это означает, что данные не очищаются, но следующая запись будет поверх старых данных.</p>',frontmatter:{path:"/blog/java",title:"Java"}}},pathContext:{}}}});
//# sourceMappingURL=path---blog-java-1bdcc1887eeecc89a78d.js.map