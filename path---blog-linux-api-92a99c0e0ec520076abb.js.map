{"version":3,"sources":["webpack:///path---blog-linux-api-92a99c0e0ec520076abb.js","webpack:///./.cache/json/blog-linux-api.json"],"names":["webpackJsonp","456","module","exports","data","markdownRemark","html","frontmatter","path","title","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA;AAAg+/CC,aAAgCC,KAAA,kBAAAC,MAAA,eAA+CC","file":"path---blog-linux-api-92a99c0e0ec520076abb.js","sourcesContent":["webpackJsonp([79569183618093],{\n\n/***/ 456:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>Работа с аргументами запуска</h1>\\n<pre><code class=\\\"language-cpp\\\">while ((opt = getopt(argc, argv, \\\"nt:\\\")) != -1) {\\n   switch (opt) {\\n   case 'n':\\n       flags = 1;\\n       break;\\n   case 't':\\n       nsecs = atoi(optarg);\\n       tfnd = 1;\\n       break;\\n   default: /* '?' */\\n       fprintf(stderr, \\\"Usage: %s [-t nsecs] [-n] name\\\\n\\\",\\n               argv[0]);\\n       exit(EXIT_FAILURE);\\n   }\\n}\\n</code></pre>\\n<p>Третьим аргументом <code>getopt</code> принимает список допустимых опций. Если после символа стоит двоеточие, значит эта опция принимает аргумент, тогда <code>getopt</code> помещает указатель на текст, последующий за буквой опции, либо весь следующий аргумент, в переменную <code>optarg</code>. Если же там 2 двоеточия, то это означает опциональный аргумент, если он отсутствует, то<code>optarg</code> будет равен нулю.</p>\\n<p><code>optind</code> - индекс следующего аргумента, который будет обработан.</p>\\n<h1>Работа с файлами</h1>\\n<p>3 стандартных дескриптора:</p>\\n<ul>\\n<li>0: стандартный ввод</li>\\n<li>1: стандартный вывод</li>\\n<li>2: стандартный поток ошибок</li>\\n</ul>\\n<h2>Системные вызовы для работы с файлами</h2>\\n<ul>\\n<li><code>fd = open(pathname, flags, mode)</code>: открывает указанный файл, возвращает его дескриптор. Если окрыть не удалось, вернется отрицательный дескриптор (ошибку можно будет получить через <code>errno</code>). Во флагах через <code>|</code> можно указать, что файл открывается на чтение/запись, что его нужно создать, если он не существует. <code>mode</code> - разрешения файла, если будет создан новый.</li>\\n<li><code>numread = read(fd, buffer, count)</code>: читать <code>count</code> байт в буфер. Возвращает количество прочтенных байт, или 0, если достигнут EOF.</li>\\n<li><code>numwritten = write(fd, buffer, count)</code>: писать <code>count</code> байт из буфера.</li>\\n<li><code>status = close(fd)</code>: закрывает дескриптор и все связанные с ним ресурсы ядра</li>\\n</ul>\\n<h2>Пример копирования файла</h2>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;iostream>\\n#include &#x3C;fcntl.h>\\n#include &#x3C;unistd.h>\\n\\n#ifndef BUF_SIZE\\n#define BUF_SIZE 1024\\n#endif\\n\\nint main(int argc, char *argv[]) {\\n    int inputFd, outputFd, openFlags;\\n\\n    mode_t filePerms;\\n    ssize_t numRead;\\n\\n    char buf[BUF_SIZE];\\n\\n    if (argc != 3 || argv[1] == \\\"--help\\\") {\\n        std::cout &#x3C;&#x3C; \\\"usage: copy old-file new-file\\\" &#x3C;&#x3C; std::endl;\\n        exit(EXIT_FAILURE);\\n    }\\n\\n    inputFd = open(argv[1], O_RDONLY);\\n    if (inputFd == -1) exit(EXIT_FAILURE);\\n\\n    openFlags = O_CREAT | O_WRONLY | O_TRUNC;\\n    filePerms = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;\\n    outputFd = open(argv[2], openFlags, filePerms);\\n    if(outputFd == -1) return 1;\\n\\n    while(numRead = read(inputFd, buf, BUF_SIZE))\\n    {\\n        if(write(outputFd, buf, numRead) != numRead) exit(EXIT_FAILURE);\\n    }\\n    if(numRead == -1) exit(EXIT_FAILURE);\\n\\n    if(close(inputFd) == -1) exit(EXIT_FAILURE);\\n    if(close(outputFd) == -1) exit(EXIT_FAILURE);\\n\\n    exit(EXIT_SUCCESS);\\n}\\n</code></pre>\\n<p>ПРИМЕЧАНИЕ: в C++ стандартный способ работы с файлами - через <code>ofstream</code>, <code>ifstream</code>, <code>fstream</code>:</p>\\n<pre><code class=\\\"language-cpp\\\">#include &#x3C;iostream>\\n#include &#x3C;fstream>\\n\\nconst static int BUF_SIZE = 4096;\\n\\nusing std::ios_base;\\n\\nint main(int argc, char** argv) {\\n\\n   std::ifstream in(argv[1],\\n      ios_base::in | ios_base::binary);  // Use binary mode so we can\\n   std::ofstream out(argv[2],            // handle all kinds of file\\n      ios_base::out | ios_base::binary); // content.\\n   \\n   // Make sure the streams opened okay...\\n\\n   char buf[BUF_SIZE];\\n\\n   do {\\n      in.read(&#x26;buf[0], BUF_SIZE);      // Read at most n bytes into\\n      out.write(&#x26;buf[0], in.gcount()); // buf, then write the buf to\\n   } while (in.gcount() > 0);          // the output.\\n\\n   // Check streams for problems...\\n\\n   in.close();\\n   out.close();\\n}\\n</code></pre>\\n<h2>Неблокирующий ввод/вывод</h2>\\n<p>Если в <code>open</code> передать флаг <code>O_NONBLOCK</code>, то в случае невозможности выполнить системный вызов I/O (открытие, чтение, запись) будет возвращена ошибка <code>EAGAIN</code> или <code>EWOULDBLOCK</code> в зависимости от вызова, а не блокировка исполнения как обычно.</p>\\n<p>Неблокирующий I/O может быть использован с пайпами, очередями FIFO, сокетами, терминалами, псевдотерминалами и т.д. Так как файловые дескрипторы для пайпов и сокетов получаются не через <code>open</code>, то для них флаг активируется через вызов <code>fcntl()</code>.</p>\\n<p>Для обычных файлов флаг <code>O_NONBLOCK</code> игнорируется, так как кэш буфера ядра и так гарантирует, что I/O над обычными файлами не блокирующий. </p>\\n<h2>Манипуляции с дескриптором открытого файла</h2>\\n<p>Системным вызовом <code>fcntl</code> можно управлять дескриптором уже открытого файла, например, поменять флаги открытия.</p>\\n<pre><code class=\\\"language-cpp\\\">#include &#x3C;unistd.h>\\n#include &#x3C;fcntl.h>\\n\\nint fcntl(int fd, int cmd, ... /* arg */ );\\n</code></pre>\\n<p>Последний аргумент зависит от второго аргумента <code>cmd</code>, то есть от того действия, которое мы пытаемся осуществить.</p>\\n<p>Мы можем:</p>\\n<h3>получить флаги</h3>\\n<pre><code class=\\\"language-cpp\\\">int flags, accessMode;\\nflags = fcntl(fd, F_GETFL);\\nif(flags == -1) \\n    errExit(\\\"fcntl\\\");\\nif(flags &#x26; O_SYNC)\\n    printf(\\\"writes are synchronized\\\\n\\\");\\n</code></pre>\\n<p>А вот режим доступа проверить не так просто, но все равно можно:</p>\\n<pre><code class=\\\"language-cpp\\\">accessMode = flags &#x26; O_ACCMODE;\\nif(accessMode == O_WRONLY || accessMode == O_RDWR)\\n    printf(\\\"file is writable\\\\n\\\");\\n</code></pre>\\n<h3>установить флаги</h3>\\n<p>Можно модифицировать флаги: <code>O_APPEND</code>, <code>O_NONBLOCK</code>, <code>O_NOATIME</code>, <code>O_ASYNC</code> и <code>O_DIRECT</code>. Попытки модификации других флагов - игнорируются.</p>\\n<p>Причем указание флага <code>O_ASYNC</code> в <code>open()</code> тоже игнорируется - его можно установить только через <code>fcntl()</code>.</p>\\n<pre><code class=\\\"language-cpp\\\">fcntl(fd, F_SETFL, O_ASYNC | O_NONBLOCK);\\n</code></pre>\\n<h2>Альтернативные модели I/O</h2>\\n<p>Традиционная модель работы с файлами имеет 2 существенных недостатка:</p>\\n<ul>\\n<li>работает только с одним дескриптором одновременно</li>\\n<li>каждый системный вызов блокирует выполнение, пока передача данных не завершилась</li>\\n</ul>\\n<p>В некоторых приложениях нам бывает нужно:</p>\\n<ul>\\n<li>проверить, возможен ли ввод/вывод в дескриптор, не блокируя исполнение, если невозможен</li>\\n<li>монитортиь несколько дескрипторов, пока ввод/вывод станет доступен на любом из них</li>\\n</ul>\\n<p>Для этого можно использовать неблокирующий I/O или многопроцессность/многопоточность:</p>\\n<ul>\\n<li>при использовании неблокирующего I/O мы можем открыть N дескрипторов и периодически чтением каждого из них проверять, доступно ли для них I/O. Это, конечно, неэффективно по CPU, а так же при больших интервалах реакция приложения на событие I/O может быть слишком долгой.</li>\\n<li>при использовании многопроцессности мы можем создавать новый процесс, чтобы выполнять I/O. Тогда родительский процесс не будет заблокирован, а дочерний заблокируется, пока I/O не будет выполнен. Недостаток - сложно создавать процессы и понадобится какой-то IPC, чтобы сообщать родителю о статусе операции I/O.</li>\\n<li>при использовании многопоточности можем создавать для I/O не процесс, а поток. Это менее накладно по ресурсам, но IPC все равно понадобится.</li>\\n</ul>\\n<p>Чтобы избежать этих недостатков для решения задачи слежения за несколькими дескрипторами с целью узнать, когда они станут готовы для I/O (без блокирования) применяются следующие техники</p>\\n<h3>Мультиплексирование I/O</h3>\\n<p>Позволяет процессу одновременно следить за несколькими дескрипторами, чтобы узнать когда на любом из них становится доступен неблокирующий I/O. </p>\\n<p>При этом важно понимать, что событие доступности неблокирующего I/O не означает, что последующий вызов I/O сможет <em>успешно</em> передать данные. Например, для обычных файлов неблокирующий вызов доступен всегда, потому что будут возвращены либо данные (хотя возможно и после ощутимой задержки), либо EOF, либо ошибка. А вот для сокетов - только когда действительно по сети пришли данные для чтения, или буфер перестал быть заполненным и в него можно написать еще данных.</p>\\n<p>Самая старая техника, поэтому главное достоинство - портируемость. Главный недостаток - плохая масштабируемость на большие (сотни и тысячи) количества дескрипторов.</p>\\n<p>Мультиплексирование осуществляется вызовами <code>select()</code> и <code>poll()</code>.</p>\\n<h4>select()</h4>\\n<p>Блокироует выполнение, пока один или несколько дескрипторов не станут готовы</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/time.h>  /* Включать для портируемости */\\n#include &#x3C;sys/select.h>\\n\\nint select(int nfds, fd_set * readfds, fd_set * writefds, fd_set * exceptfds, struct timeval * timeout );\\n</code></pre>\\n<p>Возвращает количество готовых дескрипторов, 0 при таймауте, -1 при ошибке. Если какой-либо дескриптор указан в нескольких наборах, то он будет учтен соответствующее количество раз.</p>\\n<ul>\\n<li><code>nfds</code> - число, на 1 большее, чем самый большой дескриптор среди наборов</li>\\n<li><code>readfds</code> - набор дескрипторов на чтение</li>\\n<li><code>writefds</code> - набор дескрипторов на запись</li>\\n<li><code>exceptfds</code> - набор дескрипторов, у которых мы ждем т.н. exception condition (это не имеет ничего общего с ошибками)</li>\\n<li><code>timeout</code> - указывает интервал, в течение которого вызов <code>select()</code> заблокирует выполнение, либо же <code>NULL</code>, если нужно ждать бесконечно. Если указать <code>timeval { tv_sec=0, tv_usec=0}</code>, то блокировки не будет вообще, просто сразу ответит, какие дескрипторы уже готовы.</li>\\n</ul>\\n<p>Вместо любого из наборов можно передать <code>NULL</code>, если этот класс событий нас не интересует.</p>\\n<p>Наборы могут иметь размерность, не большую, чем константа <code>FD_SETSIZE</code>, в Линуксе она равна 1024. </p>\\n<p>С типом <code>fd_set</code> работаем посредством следующих операций:</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/select.h>\\nvoid FD_ZERO(fd_set * fdset );  // инициализирует набор, делая его пустым\\nvoid FD_SET(int fd , fd_set * fdset );  // добавляет дескриптор в набор\\nvoid FD_CLR(int fd , fd_set * fdset );  // удаляет дескриптор из набора\\nint FD_ISSET(int fd , fd_set * fdset ); // возвращает 1, если дескриптор есть в наборе, иначе 0\\n</code></pre>\\n<p>Вызов <code>select()</code> модифицирует переданные в него наборы <code>fd_set</code> таким образом, что после завершения они содержат набор готовых дескрипторов. Но чтобы узнать эти дескрипторы, придется для каждого из интересующих нас дескрипторов, вызвать <code>FD_ISSET</code>.</p>\\n<h4>poll()</h4>\\n<p>Работает так же, как и <code>select()</code>, разница лишь в API. В <code>poll()</code> мы предоставляем список дескрипторов, где для каждого указан набор интересующих событий</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;poll.h>\\nint poll(struct pollfd fds[], nfds_t nfds, int timeout);\\n</code></pre>\\n<p>Возвращает количество готовых дескрипторов, 0 при таймауте, -1 при ошибке.</p>\\n<p><code>fds[]</code> содержит массив дескрипторов. Сртуктура <code>pollfd</code> имеет следующий вид:</p>\\n<pre><code class=\\\"language-c\\\">struct pollfd {\\n    int fd;         // дескриптор\\n    short events;   // бит-маска интересующих ивентов\\n    short revents;  // бит-маска выстреливших ивентов\\n}\\n</code></pre>\\n<p><code>nfds</code> - количество элементов в массиве <code>fds</code>.</p>\\n<p>Далее приведен список битов, которые могут быть выставлены для <code>events</code> и <code>revents</code>:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/d290a97e10b14fdde5d5ab83e4a558f2/ee7d1/events-revents-bits.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 638px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 55.01567398119123%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABcUlEQVQoz22S2a6CQBBE5/+/zhgJbiDggiAgrogsbU4nTe7DnaRCAz1V1TXjlsulXC4XuV6v4nmezGYzieNY5vO51ovFQtbrtf4LgkAej4fc7/d/AY/bbrdSVZUSbjYb3Zgkifi+rzWEx+NRTqeTpGkqZVlKnue6uSiKCbwfDgdxqEK63+9Vves6VXu9XlojFobhREo/73w31HWtQgi63W4njI0TSNq2lefzOdU0Q4A6pABHTISr2+2mPTwx4mgG/DQSnFJ/v98pCmLAAS4NEPV9L8MwKOh1BE5eOMA+KtinhjjLMiVEFFImIh6A6OfzkaZp9KmHQgMbwPv9Vlc0UpMho0RRpILn81lJEaEHV38XvQ4iHOIUy6jZqZMlJ2quICNDyBnfHBqmawNgZ0QWY1MbOfcSGCHk/GON46hgaYar1UodMgakLMKG1FQtQ66MOUXALjTiQB3SzLWhiWauBDVjUZMfcdBn01jm7MOQ1Yj8AMERNEXs/IPBAAAAAElFTkSuQmCC'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Events & Revents bits\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/d290a97e10b14fdde5d5ab83e4a558f2/ee7d1/events-revents-bits.png\\\"\\n        srcset=\\\"/hows-that-again/static/d290a97e10b14fdde5d5ab83e4a558f2/c235e/events-revents-bits.png 163w,\\n/hows-that-again/static/d290a97e10b14fdde5d5ab83e4a558f2/5eba7/events-revents-bits.png 325w,\\n/hows-that-again/static/d290a97e10b14fdde5d5ab83e4a558f2/ee7d1/events-revents-bits.png 638w\\\"\\n        sizes=\\\"(max-width: 638px) 100vw, 638px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Аргумент <code>timeout</code> ведет себя так же, как и у <code>select()</code>, только с другими ключевыми значениями:</p>\\n<ul>\\n<li>-1: блокировать без ограничений по времени</li>\\n<li>0: не блокировать,сразу возвращать</li>\\n<li>\\n<blockquote>\\n<p>0: означает миллисекунды, сколько ждем</p>\\n</blockquote>\\n</li>\\n</ul>\\n<h3>Signal-driven I/O</h3>\\n<p>Процесс просит у ядра послать сигнал, когда I/O становится доступен на определенном дескрипторе. На большом количестве дескрипторов эта техника работает лучше, чем мультиплексирование.</p>\\n<p>Алгоритм использования таков:</p>\\n<ol>\\n<li>\\n<p>Создаем хэндлер для сигнала <code>SIGIO</code>.</p>\\n</li>\\n<li>\\n<p>Вызовом <code>fnctl()</code> устанавливаем владельца дескриптора файла, то есть процесс, который будет получать сигналы о готовности I/O. Обычно это текущий процесс: <code>fcntl(fd, F_SETOWN, pid);</code></p>\\n</li>\\n<li>\\n<p>Через <code>fcntl()</code> устанавливаем дескриптору флаг <code>O_NONBLOCK</code></p>\\n</li>\\n<li>\\n<p>Через <code>fnctl()</code> включаем signal-driven i/o, выставив флаг <code>O_ASYNC</code>. Это может быть объединено с предыдущим шагом:</p>\\n<pre><code class=\\\"language-c\\\">flags = fcntl(fd, F_GETFL); \\nfcntl(fd, F_SETFL, flags | O_ASYNC | O_NONBLOCK);\\n</code></pre>\\n</li>\\n<li>\\n<p>Вызывающий процесс теперь может заниматься своими делами. Когда I/O станет доступен, ядро сгенерит сигнал и вызовет указанный хэндлер</p>\\n</li>\\n<li>\\n<p>Signal-driven I/O генерирует edge-triggered нотификации. Это значит, что при получении нотификации нужно в цикле читать данные из дескриптора до тех пор, пока не получим ошибку <code>EAGAIN</code> или <code>EWOULDBLOCK</code>.</p>\\n</li>\\n</ol>\\n<p>Пример:</p>\\n<pre><code class=\\\"language-cpp\\\">#include &#x3C;csignal>\\n#include &#x3C;fcntl.h>\\n#include &#x3C;unistd.h>\\n\\nstatic void sigioHandler(int sig) {\\n    gotSigio = 1;\\n}\\n\\nint main(int args, char *argv[]) {\\n  struct sigaction sa;                        //\\n  sigemptyset(&#x26;sa.sa_mask);                   //\\n  sa.sa_flags = SA_RESTART;                   //\\n  sa.sa_handler = sigioHandler;               // 1. Создаем хэндлер для сигнала SIGIO.\\n  if (sigaction(SIGIO, &#x26;sa, NULL) == -1) {    //\\n      printf(\\\"sigaction error\\\");              //\\n      return 1;                               //\\n  }                                           //\\n\\n  if (fcntl(STDIN_FILENO, F_SETOWN, getpid()) == -1) {  //\\n      printf(\\\"fcntl(F_SETOWN) error\\\");                  // 2. Вызовом `fnctl()` устанавливаем владельца дескриптора файла\\n      return 1;                                         //\\n  }                                                     //\\n\\n  int flags = fcntl(STDIN_FILENO, F_GETFL);                                 //\\n  if (fcntl(STDIN_FILENO, F_SETFL, flags | O_ASYNC | O_NONBLOCK) == -1) {   //\\n    printf(\\\"fcntl(F_SETFL) error\\\");                                         // 3,4 - устанавливаем флаги O_NONBLOCK, O_ASYNC\\n    return 1;                                                               //\\n  }                                                                         //\\n\\n  int cnt = 0;\\n  for (bool done = false; !done; cnt++) {\\n      for (int j = 0; j &#x3C; 100000000; j++)\\n          continue;\\n\\n      char ch;\\n      if (gotSigio) {\\n          while (read(STDIN_FILENO, &#x26;ch, 1) > 0 &#x26;&#x26; !done) {   // 6 - читаем, пока не получим ошибку\\n              printf(\\\"cnt=%d; read %c\\\\n\\\", cnt, ch);\\n              done = ch == '#';\\n          }\\n      }\\n\\n      gotSigio = 0;\\n\\n  }\\n}\\n</code></pre>\\n<h3>epoll</h3>\\n<p>Техника, доступная только в линуксе. Объединяет достоинства предыдущих двух техник.</p>\\n<p>Не может быть использована с обычными файлами, так как они и так всегда работают в неблокирующем режиме (т.е. всегда есть данные, но это не значит, что они будут возвращаться мгновенно). Если попробовать использовать с обычными файлами, то выдаст ошибку.</p>\\n<p>По сравению с signal-driven имеет преимущества:</p>\\n<ul>\\n<li>не нужно работать с сигналами</li>\\n<li>монжо указать, какой конкретно ивент нас интересует - готовность к чтению, или к записи</li>\\n<li>можно выбрать между level-triggered и edge-triggered нотификациями.</li>\\n</ul>\\n<p>Чтобы использовать аналогичные фичи в модели signal-driven I/O, все равно придется использовать непортируемые линукс-специфичные фичи.</p>\\n<p>По производительности epoll сравним с signal-driven I/O.</p>\\n<p>Работа с <code>epoll API</code> осуществляется через инстанс <code>epoll</code>, который содержит следующие структуры:</p>\\n<ul>\\n<li><strong>interest list</strong> - список файловых дескрипторов, которые мы мониторим</li>\\n<li><strong>ready list</strong> - список файловых дескрипторов, готовых к неблокирующему I/O</li>\\n</ul>\\n<p><code>epoll</code> API состоит из 3 системных вызовов:</p>\\n<h4><code>epoll_create()</code></h4>\\n<p>создает инстанс <code>epoll</code> и возвращает ссылающийся на него файловый дескриптор, или -1 </p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/epoll.h>\\n\\nint epoll_create(int size);\\n</code></pre>\\n<ul>\\n<li><code>size</code> - количество дескрипторов, которые будем мониторить. Это не верхняя граница, а подсказка ядру для эффективной инициализации (с версии ядра 2.6.8 аргумент вообще игнорируется).</li>\\n</ul>\\n<p>При завершении работы с файловым дескриптором <code>epoll</code>, его надо закрыть как обычно через <code>close()</code>.</p>\\n<h4><code>epoll_ctl()</code></h4>\\n<p>изменяет <strong>interest list</strong></p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/epoll.h>\\n\\nint epoll_ctl(int efpd, int op, int fd, struct epoll_event *ev);\\n</code></pre>\\n<ul>\\n<li><code>fd</code> - файловый дескриптор из <strong>interest list</strong>, чьи настройки будем модифицировать (может быть и идентификатором, ссылающимся на другой <code>epoll</code>, таким образом можем построить иерархию). Однако он не может быть дескриптором обычного файла или папки.</li>\\n<li><code>op</code> - операция. Выбирается из списка <code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_MOD</code>, <code>EPOLL_CTL_DEL</code>.</li>\\n<li><code>ev</code> - описание ивента, за которым будем следить.</li>\\n</ul>\\n<pre><code class=\\\"language-c\\\">struct epoll_event {\\n    uint32_t events;\\n    epoll_data_t data;\\n}\\n\\ntypedef union epoll_data {\\n  void *ptr;\\n  int fd;\\n  uint32_t u32;\\n  uint64_t u64;\\n} epoll_data_t;\\n</code></pre>\\n<ul>\\n<li><code>events</code> - битовая маска, определяющая набор отслеживаемых ивентов. Возможные ивенты перечеслены в таблице ниже.</li>\\n<li><code>data</code> - union, один из членов которого может быть испольован, чтобы передать данные процессу, который вызовет <code>epoll_wait()</code>.</li>\\n</ul>\\n<h4><code>epoll_wait()</code></h4>\\n<p>возвращает элементы <strong>ready list</strong>.</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/epoll.h>\\n\\nint epoll_wait(int epfd, struct epoll_event * evlist, int maxevents, int timeout);\\n</code></pre>\\n<p>Возвращает количество готовых дескрипторов, 0 при таймауте, -1 при ошибке.</p>\\n<p>Сами готовые дескрипторы будут возвращены в массиве <code>evlist</code>. Массив создается вызывающей стороной и в <code>maxevents</code> нужно передать его длину. </p>\\n<p>В каждом из элементов возвращенного массива поле <code>events</code> перечисляет произошедшие с дескриптором события. </p>\\n<p>Поле <code>data</code> содержит значение, которое было передано через <code>ev.data</code> в <code>epoll_ctl()</code>. Это поле - <strong>единственный способ узнать, с каким дескриптором произошло событие</strong>.</p>\\n<p>Аргумент <code>timeout</code> работает как всегда, -1 - ждем бесконечно, 0 - не ждем, больше 0 - миллисекунды.</p>\\n<p>Возможные значения ивентов:</p>\\n<p><img src=\\\"epoll-events.png\\\" alt=\\\"Epoll events\\\"></p>\\n<p><code>EPOLLONESHOT</code> используется, когда мы хотим быть информированы о дескрипторе только один раз. Если захочется активировать его заново, можно это сделать через <code>epoll_ctl()</code> с операцией <code>EPOLL_CTL_MOD</code>.</p>\\n<p>Без использования <code>EPOLLONESHOT</code> придется после получения ивента по дескриптору вызывать <code>epoll_ctl()</code> с <code>EPOLL_CTL_DEL</code>.</p>\\n<h4>Edge-triggered notifications</h4>\\n<p>Чтобы использовать edge-triggered нотификации, нужно указать флаг <code>EPOLLET</code> в <code>ev.events</code>:</p>\\n<pre><code class=\\\"language-c\\\">struct epoll_event ev;\\n\\nev.data.fd = fd;\\nev.events = EPOLLIN | EPOLLET;\\nif(epoll_ctl(epfd, EPOLL_CTL_ADD, fd, ev) == -1)\\n  errExit(\\\"epoll_ctl\\\");\\n</code></pre>\\n<p>edge-triggered нотификации обычно используются в сочетании с <code>O_NONBLOCK</code> и чтением в цикле, пока не выстрелит ошибка <code>EAGAIN/EWOULDBLOCK</code>.</p>\\n<h4>Пример</h4>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;iostream>\\n#include &#x3C;sys/epoll.h>\\n#include &#x3C;cstdarg>\\n#include &#x3C;fcntl.h>\\n#include &#x3C;unistd.h>\\n\\n#define MAX_BUF 1000\\n#define MAX_EVENTS 5\\n\\nint main(int argc, char *argv[]) {\\n    struct epoll_event evlist[MAX_EVENTS];\\n    char buf[MAX_BUF];\\n\\n    if(argc &#x3C; 2 || argv[1] == \\\"--help\\\")\\n        usageErr(\\\"%s file...\\\\n\\\", argv[0]);\\n\\n\\n    int epfd = epoll_create(argc-1);\\n    if(epfd == -1)\\n        errExit(\\\"epoll_create\\\");\\n\\n    for(int j = 1; j &#x3C; argc; j++) {\\n        int fd = open(argv[j], O_RDONLY);\\n        if(fd == -1)\\n            errExit(\\\"open\\\");\\n        printf(\\\"Opened \\\\\\\"%s\\\\\\\" on fd %d\\\\n\\\", argv[j], fd);\\n\\n        epoll_event ev;\\n        ev.events = EPOLLIN;\\n        ev.data.fd = fd;\\n        if(epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &#x26;ev) == -1)\\n            errExit(\\\"epoll_ctl\\\");\\n\\n    }\\n\\n    int numOpenFds = argc - 1;\\n\\n    while(numOpenFds > 0) {\\n        printf(\\\"About to epoll_wait()\\\\n\\\");\\n        int ready = epoll_wait(epfd, evlist, MAX_EVENTS, -1);\\n        if(ready == -1) {\\n            if(errno == EINTR)\\n                continue;\\n            else\\n                errExit(\\\"epoll_wait\\\");\\n        }\\n        printf(\\\"Ready: %d\\\\n\\\", ready);\\n\\n        for(int j = 0; j &#x3C; ready; j++) {\\n            printf(\\\"  fd=%d; events: %s%s%s\\\\n\\\", evlist[j].data.fd,\\n                   (evlist[j].events &#x26; EPOLLIN) ? \\\"EPOLLIN \\\" : \\\"\\\",\\n                   (evlist[j].events &#x26; EPOLLHUP) ? \\\"EPOLLHUP \\\" : \\\"\\\",\\n                   (evlist[j].events &#x26; EPOLLERR) ? \\\"EPOLLERR \\\" : \\\"\\\");\\n\\n            if(evlist[j].events &#x26; EPOLLIN) {\\n                size_t s = read(evlist[j].data.fd, buf, MAX_BUF);\\n                if(s == -1)\\n                    errExit(\\\"read\\\");\\n                printf(\\\"  read %d bytes: %.*s\\\\n\\\", s, s, buf);\\n            }\\n            else if(evlist[j].events &#x26; (EPOLLHUP | EPOLLERR)) {\\n                printf(\\\"  closing fd %d\\\\n\\\", evlist[j].data.fd);\\n                if(close(evlist[j].data.fd) == -1)\\n                    errExit(\\\"close\\\");\\n                numOpenFds--;\\n            }\\n        }\\n    }\\n\\n    printf(\\\"All file descriptors closed; bye\\\\n\\\");\\n    exit(EXIT_SUCCESS);\\n}\\n</code></pre>\\n<h3>libevent</h3>\\n<p>Сторонняя библиотека, предоставляющая слой абстракции для мониторинга за файловыми дескрипторами. Использует все вышеперечисленные (и не только) техники и может включать/выключать их в зависимости от ОС.</p>\\n<h3>Типы нотификаций</h3>\\n<ul>\\n<li>Level-triggered: выстреливается, когда дескриптор становится доступен для осуществления системного вызова I/O без блокирования. После этого можно выполнить (а можно и не выполнять) необходимую I/O операцию и повторить мониторинг, чтобы узнать, когда I/O станет доступен снова. Важно, что нам необязательно читать все доступные данные, можем прочитать сколько угодно и повторить мониторинг, просто если мы прочитали не все, то событие выстрелит сразу же.</li>\\n<li>Edge-triggered: выстреливается, когда произошла некоторая I/O активность на дескрипторе (нарпример, стали доступны данные для чтения). Отличие в том, что событие не выстрелит, пока не произойдет следующее событие I/O (например, доступна следующая порция данных на чтение). Кроме того, мы обычно не знаем, сколько именно данных нам стало доступно для неблокирующего I/O. Поэтому обычно мы помещаем дескриптор в неблокирующий режим и совершаем операции в цикле, пока не получим ошибку <code>EAGAIN</code> или <code>EWOULDBLOCK</code>.</li>\\n</ul>\\n<table>\\n<thead>\\n<tr>\\n<th>I/O model</th>\\n<th>Level-triggered?</th>\\n<th>Edge-triggered?</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>select(), poll()</td>\\n<td>X</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>signal-driven</td>\\n<td></td>\\n<td>X</td>\\n</tr>\\n<tr>\\n<td>epoll</td>\\n<td>X</td>\\n<td>X</td>\\n</tr>\\n</tbody>\\n</table>\\n<h1>Сигналы</h1>\\n<p>Сигналы - это, иными словами, \\\"программные прерывания\\\". Они могут быть вызваны ядром в любой момент при наступлении интересующего события, а после выполнения хэндлера, выполнение продолжается с той же строчки, на которой было прервано.</p>\\n<p>Самые популярные сигналы:</p>\\n<ul>\\n<li><code>SIGINT</code>: сигнал, генерируемый нажатием <code>Ctrl+C</code>, просит программу остановить текущее действие и ожидать пользовательского ввода. Неинтерактивные программы обычно обрабатывают его так же, как и <code>SIGTERM</code></li>\\n<li><code>SIGTERM</code>: сигнал убийства процесса, говорит приложению завершиться, но дает время на сохранение стейта, закрытие ресурсов и прочее</li>\\n<li><code>SIGHUP</code>: то же, что и <code>SIGTERM</code>, но автоматически шлется приложениям, когда пользователь отсоединяется от терминала (hung up)</li>\\n</ul>\\n<h2>Подписка на сигнал | SGINT</h2>\\n<p>Есть два способа: <code>signal()</code> и <code>sigaction()</code>.</p>\\n<h3>signal()</h3>\\n<p>Этот вызов более старый, но имеет более простое API. Однако у него есть различия в поведении среди различных имплементаций UNIX, поэтому <code>signal()</code> не рекомендуется к использованию в кросс-платформенных системах.</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;signal.h>\\n\\nvoid ( *signal(int sig, void (*handler)(int)) ) (int);\\n</code></pre>\\n<ul>\\n<li><code>handler</code> - указатель на функцию, принимающую <code>int</code> (туда придет номер возникшего сигнала) и возвращающую ничего</li>\\n<li><code>signal</code> - фукнция, принимающая <code>int</code> и <code>pointer</code>, а возвращающая указатель на функцию, принимающую <code>int</code> и возвращающую ничего.</li>\\n</ul>\\n<p>На самом деле <code>signal</code> возвращает указатель на предыдущий хэндлер. Это нужно для установки \\\"временных\\\" хэндлеров, которые можно потом откатить:</p>\\n<pre><code class=\\\"language-c\\\">void (*oldHandler)(int);\\n\\noldHandler = signal(SIGINT, newHandler);\\n\\n/// здесь сигнал SIGINT обрабатывается новым хэндлером\\n\\nsignal(SIGINT, oldHandler); // возвращаем старый хэндлер\\n</code></pre>\\n<p>Вместо указателя на хэндлер можно подавать:</p>\\n<ul>\\n<li><code>SIG_DFL</code> - откатиться к дефолтному хэндлеру</li>\\n<li><code>SIG_IGN</code> - игнорировать сигнал</li>\\n</ul>\\n<p>Если нужно одним хэндлером обрабатывать несколько сигналов, то нужно несколько раз вызвать функцию, битмаска тут не работает:</p>\\n<pre><code class=\\\"language-c\\\">signal(SIGHUP, signalHandler);\\nsignal(SIGTERM, signalHandler);\\nsignal(SIGINT, signalHandler);\\nsignal(SIGKILL, signalHandler);\\n</code></pre>\\n<h3>sigaction()</h3>\\n<p>Имеет более сложный API, но зато позволяет получить хэндлер, не меняя его, а так же позволяет установить некоторые атрибуты, контролирующие, что произойдет, когда хэндлер будет вызван. Помимо этого, <code>sigaction()</code> более портируем, чем <code>signal()</code>.</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;signal.h>\\n\\nint sigaction(int sig, const struct sigaction *act, struct sigaction *oldact);\\n\\nstruct sigaction {\\n    void (*sa_handler)(int);    // адрес хэндлера\\n    sigset_t sa_mask;           // сигналы, заблокированные во время работы хэндлера\\n    int sa_flags;               // флаги, контролирующие работу хэндлера\\n    void (*sa_restorer)(void);  // не для использования\\n};\\n</code></pre>\\n<p>Так же, как и в <code>signal()</code>, вместо поля <code>sa_handler</code> можно подать <code>SIG_IGN</code> или <code>SIG_DFL</code>.</p>\\n<p><code>sa_mask</code> позволяет перечислить сигналы, которым нельзя прерывать выполнение этого хэндлера. Сигнал, который вызван в хэндлер, автоматически занесен в фильтр, то есть сам себя рекурсивно хэндлер сигнала прервать не может.</p>\\n<p>Вручную добавлять и убирать сигналы из фильтра процесса можно вызовом <code>sigprocmask()</code>.</p>\\n<h3>Наборы сигналов</h3>\\n<p>Несколько сигналов могут быть объединены в страктуру <code>sigset_t</code>. Для управления таким множеством есть специальные функции:</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;signal.h>\\n\\nint sigemptyset(sigset_t *set);     // инициализация нулями, то есть исключает все сигналы\\nint sigfillset(sigset_t *set);      // инициализация единицами, то есть включает все сигналы\\n\\nint sigaddset(sigset_t *set, int sig);  // добавление сигнала в набор\\nint sigdelset(sigset_t *set, int sig);  // удаление сигнала из набора\\n\\nint sigismember(const sigset_t *set, int sig); // 1, если сигнал входит в набор, иначе 0\\n\\nint sigandset(sigset_t *dest, sigset_t *left, sigset_t *right); // кладет пересечение left и right в dest\\nint sigorset(sigset_t *dest, sigset_t *left, sigset_t *right);  // кладет объединение left и right в dest\\n\\nint sigisemptyset(const sigset_t *set);     // 1, если набор пустой, иначе 0\\n</code></pre>\\n<h3>kill()</h3>\\n<p>С помощью вызова <code>kill()</code> можно послать сигнал другому процессу или группе процессов</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;signal.h>\\n\\nint kill(pid_t pid, int sig);\\n</code></pre>\\n<h3>pause()</h3>\\n<p>Системный вызов <code>pause()</code> прерывает исполнение до тех пор, пока не будет вызван какой-либо хэндлер сигнала</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;unistd.h>\\n\\nint pause(void);\\n</code></pre>\\n<p>Всегда возвращает -1 и выставляет <code>errno</code> в <code>EINTR</code>.</p>\\n<h1>Сокеты</h1>\\n<p>Сокет открывается так:</p>\\n<pre><code class=\\\"language-c\\\">int fd = socket(domain, type, protocol);\\n</code></pre>\\n<h2>Основные системные вызовы</h2>\\n<ul>\\n<li><code>socket()</code> - создает новый сокет, возвращает его файловый дескриптор.</li>\\n<li><code>bind()</code> - привязывает сокет к адресу, возвращает 0 при успехе, -1 при ошибке.</li>\\n<li><code>listen()</code> - разрешает потоковому сокету принимать входящие соединения от других сокетов</li>\\n<li><code>accept()</code> - принимает входящее соединение</li>\\n<li><code>connect()</code> - устанавливает соединение с другим сокетом</li>\\n</ul>\\n<p>Ввод/вывод данных из сокетов осуществляется стандартными вызовами <code>read()</code> и <code>write()</code>, или специфичными для сокетов <code>send()</code>, <code>recv()</code> (для TCP), <code>sendto()</code>, <code>recvfrom()</code> (для UDP). По умолчанию все эти вызовы блокирующие. Можно сделать их неблокирующими, используя <code>fcntl()</code> с операцией <code>F_SETFL</code>.</p>\\n<h3>socket()</h3>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/socket.h>\\n\\nint socket(int domain, int type, int protocol)\\n</code></pre>\\n<p>В качестве domain обычно указывается:</p>\\n<ul>\\n<li><code>AF_UNIX</code> - для коммуникаций в рамках одного хоста. Для адреса используется структура <code>sockaddr_un</code>.</li>\\n<li><code>AF_INET</code> - для коммуникаций по протоколу IPv4. Для адреса используется структура <code>sockaddr_in</code>.</li>\\n<li><code>AF_INET6</code> - для коммуникаций по IPv6. Для адреса используется структура <code>sockaddr_in6</code>.</li>\\n</ul>\\n<p><code>AF</code> - значит Address Family.</p>\\n<p>Каждая реализация сокетов предоставляет 2 типа, указываемых вторым аргументом: <strong>stream</strong> (<code>SOCK_STREAM</code>) и <strong>datagram</strong> (<code>SOCK_DGRAM</code>).</p>\\n<ul>\\n<li><strong>stream</strong>: надежный, двунаправленный, потоковый. Обычно использует TCP.</li>\\n<li><strong>datagram</strong>: ненадежный, шлет отдельные сообщения-датаграммы, которые могут прийти в другом порядке, дублироваться, или не прийти вообще. Обычно использует UDP.</li>\\n</ul>\\n<p><code>protocol</code> в большинстве случаев 0.</p>\\n<h3>bind()</h3>\\n<p>Если не вызывать <code>bind()</code>, то при последующем <code>listen()</code> сокет будет автоматически привязан к случайному порту. Получить порт можно затем командой <code>getsockname()</code>.</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/socket.h>\\n\\nint bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\\n</code></pre>\\n<p>Здесь <code>sockfd</code> - файловый дескриптор сокета, <code>addr</code> - структура, описывающая адрес, <code>addrlen</code> - размер структуры <code>addr</code> (можно получить через <code>sizeof(addr)</code>).</p>\\n<p>Конкретный тип структуры <code>addr</code> зависит от указанного при создании сокета <code>domain</code>:</p>\\n<ul>\\n<li><code>AF_UNIX</code> - <code>sockaddr_un</code>.</li>\\n<li><code>AF_INET</code> - <code>sockaddr_in</code>.</li>\\n<li><code>AF_INET6</code> - <code>sockaddr_in6</code>.</li>\\n</ul>\\n<p>Все они являются расширениями структуры <code>sockaddr</code> (хотя и имеют другие поля, но мы все равно можем кастовать их к <code>sockaddr</code> для передачи в вызов <code>bind()</code>):</p>\\n<pre><code class=\\\"language-c\\\">struct sockaddr {\\n  sa_family   sa_family;  /* Константа вида AF_*, например, AF_INET */\\n  char        sa_data[14];     /* Адрес сокета */\\n}\\n</code></pre>\\n<h4>Адрес IPv4</h4>\\n<pre><code class=\\\"language-c\\\">struct sockaddr_in {\\n  sa_family_t     sin_family;   /* AF_INET */\\n  in_port_t       sin_port;     /* номер порта */\\n  struct in_addr  sin_addr;     /* адрес IPv4 */\\n  unsigned char   __pad[X];     /* служебное поле, не трогать */\\n};\\n\\nstruct in_addr {\\n  in_addr_t s_addr; /* беззнаковое 32-битное число */\\n}; \\n</code></pre>\\n<p><code>sin_port</code> и <code>sin_addr</code> имеют сетевой порядок байт (<em>network byte order</em>).</p>\\n<p><code>in_port_t</code> и <code>in_addr_t</code> - беззнаковые целые по 16 и 32 бит соответственно.</p>\\n<h4>Адрес IPv6</h4>\\n<pre><code class=\\\"language-c\\\">struct sockaddr_in6 {\\n  sa_family_t     sin6_family;      /* AF_INET6 */\\n  in_port_t       sin6_port;        /* номер порта */\\n  uint32_t        sin6_flowinfo;    /* IPv6 flow information (???) */\\n  struct in6_addr sin6_addr;        /* адрес IPv6 */\\n  uint32_t        sin6_scope_id;    /* Scope ID (???) */\\n};\\n\\nstruct in6_addr {\\n  uint8_t s6_addr[16]; /* 16 байт = 128 бит */\\n}; \\n</code></pre>\\n<p><code>sin6_port</code> и <code>sin6_addr</code> имеют сетевой порядок байт (<em>network byte order</em>).</p>\\n<p><code>in_port_t</code> - беззнаковое целое на 16 бит.</p>\\n<p><code>sin6_flowinfo</code> и <code>sin6_scope_id</code> можно указывать 0.</p>\\n<h4>Network byte order</h4>\\n<p>Адреса IP и номера портов - целые числа. Чтобы их использовать, нужно привести их от хостового к сетевому порядку байт (big endian, сначала самые значимые байты).</p>\\n<p>Для конвертации есть несколько функций:</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;arpa/inet.h>\\n\\nuint16_t htons(uint16_t host_unit16); /* host-to-network-short, конвертирует 16-битное целое в сетевой порядок байт */\\n\\nuint32_t htonl(uint32_t host_uint32); /* host-to-network-long, конвертирует 32-битное в сетевой */\\n\\nuint16_t ntohs(uint16_t net_uint16); /* network-to-host-short */\\n\\nuint32_t ntohl(uint32_t net_uint32); /* network-to-host-long */\\n</code></pre>\\n<h4>Приведение IP-адреса</h4>\\n<p>Чтобы привести строковый адрес к типу <code>in_addr</code> используются следующие функции:</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;arpa/inet.h>\\n\\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size); // network-to-presentation\\n</code></pre>\\n<p>Преобразует адрес, представленный в виде числа в строку.</p>\\n<ul>\\n<li><code>af</code>: address family, то есть <code>AF_INET</code> или <code>AF_INET6</code>.</li>\\n<li><code>src</code>: указатель на <code>in_addr</code> или <code>in6_addr</code>, где лежит адрес, который нужно преобразовать к строке.</li>\\n<li><code>dst</code>: указатель на строку, куда положить результат</li>\\n<li><code>size</code>: максимальная длина результата</li>\\n</ul>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;arpa/inet.h>\\n\\nint inet_pton(int af, const char *src, void *dst); // presentation-to-network\\n</code></pre>\\n<p>Преобразует адрес в виде строки к <code>in_addr</code> или <code>in6_addr</code>.</p>\\n<ul>\\n<li><code>af</code>: address family, то есть <code>AF_INET</code> или <code>AF_INET6</code>.</li>\\n<li><code>src</code>: указатель на строку, которую нужно преобразовать.</li>\\n<li><code>dst</code>: указатель на <code>in_addr</code> или <code>in6_addr</code>, куда положить результат</li>\\n</ul>\\n<p><strong>Эти функции не осуществляют DNS-поисков, для этого нужно вызыват getaddrinfo()</strong></p>\\n<p>В коде можно еще встретить функции <code>inet_ntoa()</code>, <code>inet_aton()</code>, <code>inet_addr()</code> - они делают то же самое, но устарели, так как не поддерживают IPv6.</p>\\n<h3>listen()</h3>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/socket.h>\\n\\nint listen(int sockfd, int backlog);\\n</code></pre>\\n<p>Перевести сокет в пассивный режим - режим ожидания входящих соединений. Нельзя вызвать на уже соединенном сокете.</p>\\n<p><code>backlog</code> - устанавливает ограничение на количество ожидающих соединений. Соединения до этого лимита будут обслужены моментально. Соединения сверх этого количества будут возвращены с ошибкой <code>ECONNREFUSED</code>, либо проигнорированы и посланы позже. Максимальное значение <code>backlog</code> по умолчанию - 128, но может быть изменено.</p>\\n<h3>accept()</h3>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/socket.h>\\n\\nint accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);\\n</code></pre>\\n<p>Создает новый сокет, который соединяется с внешним сокетом, инициировавшем сединение, и возвращает его файловый дескриптор, либо -1 в случае ошибки. </p>\\n<p>Сокет <code>sockfd</code> остается открытым и готов принимать следующие входящие соединения.</p>\\n<p><code>addr</code> и <code>addrlen</code> характеризуют адрес внешнего сокета, от которого пришло соединение. Конкретный тип, как и в случае <code>bind()</code> зависит от домена. При вызове <code>addrlen</code> должен содержать размер буфера, на который указывает поле <code>sa_data</code> в <code>addr</code>, а по завершении будет содержать количество записанных туда байт. Если адрес входящего сокета нас не интересует, можно передать <code>NULL</code> и 0, соответственно. Потом адрес входящего сокета можно получить вызовом <code>getpeername()</code>.</p>\\n<h3>connect()</h3>\\n<p>Соединяет активный сокет (клиентский) с пассивным слушающим (серверным) сокетом.</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/socket.h>\\n\\nint connect(int sockfd, const struct sockaddr *addr, socklen_t *addrlen);\\n</code></pre>\\n<p>Возвращает 0 при успехе, -1 при ошибке.</p>\\n<p>Если получилась ошибка, то нужно закрыть сокет, создать новый и повторить попытку.</p>\\n<h4>connect() для UDP-сокетов</h4>\\n<p>В случае UDP-сокета, этот вызов указывает т.н. <em>peer socket</em>: это значит, что мы должны принимать входящие сообщения только от сокета с указанным адресом, а посылать можем вызовами <code>write()</code> и <code>send()</code> и сообщения будут сразу посланы на указанный адрес.</p>\\n<p>В дальнейшем внешний сокет можно сменить, повторно вызвав <code>connect()</code>. Можно и удалить связь совсем, вызвав <code>connect()</code> с адресом, у которого <em>address family</em> равно <code>AF_UNSPEC</code>.</p>\\n<p>Эта возможность особенно полезна в приложениях, где нам нужно слать много сообщений на один адрес.</p>\\n<h3>close()</h3>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/socket.h>\\n\\nint close(int sockfd);\\n</code></pre>\\n<p>Если на сокет ссылается несколько дескрипторов, то соединение будет завершено, когда закроются все дескрипторы.</p>\\n<h3>sendto()/recvfrom()</h3>\\n<p>Так как UDP-сокеты не устанавливают соединений, то для них не рекомендуется использовать <code>read()</code> и  <code>write()</code>, а нужно использовать <code>recvfrom()</code>/<code>sendto()</code>, в которых аргументом можно указать адрес.</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/socket.h>\\n\\nssize_t recvfrom(int sockfd, void *buffer, size_t length, int flags, struct sockaddr *src_addr, socklen_t *addrlen);\\n\\nssize_t sendto(int sockfd, const void *buffer, size_t length, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);\\n</code></pre>\\n<p>Возвращаемое значение и первые 3 аргумента - такие же, как у <code>read()</code> и <code>write()</code>.</p>\\n<p><code>flags</code> - описывает специфичные для сокетов I/O фичи, обычно можно указать 0.</p>\\n<p><code>src_addr</code> и <code>addrlen</code> - описывают адрес внешнего сокета. В случае <code>sendto()</code> их нужно указать при вызове, а в случае <code>recvfrom()</code> - через них будет возвращен адрес после вызова (как у <code>accept()</code>).</p>\\n<p>Независимо от указанного <code>length</code>, <code>recvfrom()</code> получит только одно сообщение, а если его длина будет меньше <code>length</code>, то обрежет его.</p>\\n<h3>Ошибки чтения из сокета</h3>\\n<p>Ошибки, возникающие из-за багов в коде:</p>\\n<ul>\\n<li><code>[EBADF]</code>: fildes is not a valid file or socket descriptor open for reading.</li>\\n<li><code>[EFAULT]</code>: Buf points outside the allocated address space.</li>\\n<li><code>[EINVAL]</code>: The pointer associated with fildes was negative.</li>\\n<li><code>[ENXIO]</code>: A requested action cannot be performed by the device.</li>\\n</ul>\\n<p>Ошибки, которые потенциально можно вылечить, но на практике обычно нет, так как лечение требует ручного вмешательства:</p>\\n<ul>\\n<li><code>[EIO]</code>: An I/O error occurred while reading from the file system.</li>\\n<li><code>[ENOBUFS]</code>: An attempt to allocate a memory buffer fails.</li>\\n<li><code>[ENOMEM]</code>: Insufficient memory is available.</li>\\n<li><code>[ETIMEDOUT]</code>: A transmission timeout occurs during a read attempt on a socket.</li>\\n</ul>\\n<p>Ошибки, означающие, что данных больше не придет, потому что соединение разорвано:</p>\\n<ul>\\n<li><code>[ECONNRESET]</code>: The connection is closed by the peer during a read attempt on a socket.</li>\\n<li><code>[ENOTCONN]</code>: A read is attempted on an unconnected socket.</li>\\n</ul>\\n<p>И наконец излечимые (recoverable) ошибки, которые обычно лечатся повтором попытки, возможно после таймаута:</p>\\n<ul>\\n<li><code>[EAGAIN]</code>: The file was marked for non-blocking I/O, and no data were ready to be read.</li>\\n<li><code>[EINTR]</code>: A read from a slow device was interrupted before any data arrived by the delivery of a signal.</li>\\n</ul>\\n<h3>Ошибки записи в сокет</h3>\\n<p>Ошибки, возникающие из-за багов в коде:</p>\\n<ul>\\n<li><code>[EINVAL]</code>: The pointer associated with fildes is negative.</li>\\n<li><code>[EBADF]</code>: fildes is not a valid file descriptor open for writing.</li>\\n<li><code>[ECONNRESET]</code>: A write is attempted on a socket that is not connected.</li>\\n<li><code>[ENXIO]</code>: A request is made of a nonexistent device, or the request is outside the capabilities of the device.</li>\\n<li><code>[EPIPE]</code>: An attempt is made to write to a socket of type SOCK_STREAM that is not connected to a peer socket.</li>\\n</ul>\\n<p>Ошибки, которые потенциально можно вылечить, но на практике обычно нет, так как лечение требует ручного вмешательства:</p>\\n<ul>\\n<li><code>[EDQUOT]</code>: The user's quota of disk blocks on the file system containing the file is exhausted.</li>\\n<li><code>[EFBIG]</code>: An attempt is made to write a file that exceeds the process's file size limit or the maximum file size.</li>\\n<li><code>[EIO]</code>: An I/O error occurs while reading from or writing to the file system.</li>\\n<li><code>[ENETDOWN]</code>: A write is attempted on a socket and the local network interface used to reach the destination is down.</li>\\n<li><code>[ENETUNREACH]</code>: A write is attempted on a socket and no route to the network is present.</li>\\n<li><code>[ENOSPC]</code>: There is no free space remaining on the file system containing the file.</li>\\n</ul>\\n<p>И наконец излечимые (recoverable) ошибки, которые обычно лечатся повтором попытки, возможно после таймаута:</p>\\n<ul>\\n<li><code>[EAGAIN]</code>: The file was marked for non-blocking I/O, and no data were ready to be read.</li>\\n<li><code>[EINTR]</code>: A read from a slow device was interrupted before any data arrived by the delivery of a signal.</li>\\n</ul>\\n<h2>Пример</h2>\\n<p>Сервер:</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;netinet/in.h>\\n#include &#x3C;errno.h>\\n#include &#x3C;stdio.h>\\n#include &#x3C;stdlib.h>\\n#include &#x3C;string.h>\\n#include &#x3C;unistd.h>\\n\\n#define SERVER_BUFFER_SIZE      1024\\n\\nint main()\\n{\\n    int socketId = socket(PF_INET, SOCK_STREAM, 0);\\n\\n    struct sockaddr_in serverAddr;\\n    bzero((char*)&#x26;serverAddr, sizeof(serverAddr));\\n    serverAddr.sin_family       = AF_INET;\\n    serverAddr.sin_port         = htons(8080);\\n    serverAddr.sin_addr.s_addr  = INADDR_ANY;\\n    bind(socketId, (struct sockaddr *) &#x26;serverAddr, sizeof(serverAddr));\\n\\n    listen(socketId, 5);\\n\\n    int                         finished    = 0;\\n    while(!finished)\\n    {\\n        struct  sockaddr_storage    serverStorage;\\n        socklen_t                   addr_size   = sizeof serverStorage;\\n        int newSocket = accept(socketId, (struct sockaddr*)&#x26;serverStorage, &#x26;addr_size);\\n\\n        char        buffer[SERVER_BUFFER_SIZE];\\n        int         get = read(newSocket, buffer, SERVER_BUFFER_SIZE - 1);\\n\\n        buffer[get] = '\\\\0';\\n        fprintf(stdout, \\\"%s\\\\n\\\", buffer);\\n\\n        write(newSocket, \\\"OK\\\", 2);\\n\\n        fprintf(stdout, \\\"Message Complete\\\\n\\\");\\n\\n        close(newSocket);\\n    }\\n    close(socketId);\\n}\\n</code></pre>\\n<p>Клиент:</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;arpa/inet.h>\\n#include &#x3C;errno.h>\\n#include &#x3C;stdio.h>\\n#include &#x3C;stdlib.h>\\n#include &#x3C;string.h>\\n#include &#x3C;unistd.h>\\n\\n#define CLIENT_BUFFER_SIZE     1024\\n\\nint main(int argc, char* argv[])\\n{\\n    if (argc != 3)\\n    {\\n        fprintf(stderr, \\\"Usage: client &#x3C;host> &#x3C;Message>\\\\n\\\");\\n        exit(1);\\n    }\\n\\n    int socketId = socket(PF_INET, SOCK_STREAM, 0);\\n\\n    struct sockaddr_in serverAddr;\\n    socklen_t addrSize = sizeof(serverAddr);\\n    bzero((char*)&#x26;serverAddr, sizeof(serverAddr));\\n    serverAddr.sin_family       = AF_INET;\\n    serverAddr.sin_port         = htons(8080);\\n    serverAddr.sin_addr.s_addr  = inet_addr(argv[1]);\\n    connect(socketId, (struct sockaddr*)&#x26;serverAddr, addrSize);\\n\\n    write(socketId, argv[2], strlen(argv[2]));\\n\\n    shutdown(socketId, SHUT_WR);\\n\\n    char    buffer[CLIENT_BUFFER_SIZE];\\n    size_t  get = read(socketId, buffer, CLIENT_BUFFER_SIZE - 1);\\n\\n    buffer[get] = '\\\\0';\\n    fprintf(stdout, \\\"%s %s\\\\n\\\", \\\"Response from server\\\", buffer);\\n\\n    close(socketId);\\n}\\n</code></pre>\",\"frontmatter\":{\"path\":\"/blog/linux-api\",\"title\":\"Linux API\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---blog-linux-api-92a99c0e0ec520076abb.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>Работа с аргументами запуска</h1>\\n<pre><code class=\\\"language-cpp\\\">while ((opt = getopt(argc, argv, \\\"nt:\\\")) != -1) {\\n   switch (opt) {\\n   case 'n':\\n       flags = 1;\\n       break;\\n   case 't':\\n       nsecs = atoi(optarg);\\n       tfnd = 1;\\n       break;\\n   default: /* '?' */\\n       fprintf(stderr, \\\"Usage: %s [-t nsecs] [-n] name\\\\n\\\",\\n               argv[0]);\\n       exit(EXIT_FAILURE);\\n   }\\n}\\n</code></pre>\\n<p>Третьим аргументом <code>getopt</code> принимает список допустимых опций. Если после символа стоит двоеточие, значит эта опция принимает аргумент, тогда <code>getopt</code> помещает указатель на текст, последующий за буквой опции, либо весь следующий аргумент, в переменную <code>optarg</code>. Если же там 2 двоеточия, то это означает опциональный аргумент, если он отсутствует, то<code>optarg</code> будет равен нулю.</p>\\n<p><code>optind</code> - индекс следующего аргумента, который будет обработан.</p>\\n<h1>Работа с файлами</h1>\\n<p>3 стандартных дескриптора:</p>\\n<ul>\\n<li>0: стандартный ввод</li>\\n<li>1: стандартный вывод</li>\\n<li>2: стандартный поток ошибок</li>\\n</ul>\\n<h2>Системные вызовы для работы с файлами</h2>\\n<ul>\\n<li><code>fd = open(pathname, flags, mode)</code>: открывает указанный файл, возвращает его дескриптор. Если окрыть не удалось, вернется отрицательный дескриптор (ошибку можно будет получить через <code>errno</code>). Во флагах через <code>|</code> можно указать, что файл открывается на чтение/запись, что его нужно создать, если он не существует. <code>mode</code> - разрешения файла, если будет создан новый.</li>\\n<li><code>numread = read(fd, buffer, count)</code>: читать <code>count</code> байт в буфер. Возвращает количество прочтенных байт, или 0, если достигнут EOF.</li>\\n<li><code>numwritten = write(fd, buffer, count)</code>: писать <code>count</code> байт из буфера.</li>\\n<li><code>status = close(fd)</code>: закрывает дескриптор и все связанные с ним ресурсы ядра</li>\\n</ul>\\n<h2>Пример копирования файла</h2>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;iostream>\\n#include &#x3C;fcntl.h>\\n#include &#x3C;unistd.h>\\n\\n#ifndef BUF_SIZE\\n#define BUF_SIZE 1024\\n#endif\\n\\nint main(int argc, char *argv[]) {\\n    int inputFd, outputFd, openFlags;\\n\\n    mode_t filePerms;\\n    ssize_t numRead;\\n\\n    char buf[BUF_SIZE];\\n\\n    if (argc != 3 || argv[1] == \\\"--help\\\") {\\n        std::cout &#x3C;&#x3C; \\\"usage: copy old-file new-file\\\" &#x3C;&#x3C; std::endl;\\n        exit(EXIT_FAILURE);\\n    }\\n\\n    inputFd = open(argv[1], O_RDONLY);\\n    if (inputFd == -1) exit(EXIT_FAILURE);\\n\\n    openFlags = O_CREAT | O_WRONLY | O_TRUNC;\\n    filePerms = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;\\n    outputFd = open(argv[2], openFlags, filePerms);\\n    if(outputFd == -1) return 1;\\n\\n    while(numRead = read(inputFd, buf, BUF_SIZE))\\n    {\\n        if(write(outputFd, buf, numRead) != numRead) exit(EXIT_FAILURE);\\n    }\\n    if(numRead == -1) exit(EXIT_FAILURE);\\n\\n    if(close(inputFd) == -1) exit(EXIT_FAILURE);\\n    if(close(outputFd) == -1) exit(EXIT_FAILURE);\\n\\n    exit(EXIT_SUCCESS);\\n}\\n</code></pre>\\n<p>ПРИМЕЧАНИЕ: в C++ стандартный способ работы с файлами - через <code>ofstream</code>, <code>ifstream</code>, <code>fstream</code>:</p>\\n<pre><code class=\\\"language-cpp\\\">#include &#x3C;iostream>\\n#include &#x3C;fstream>\\n\\nconst static int BUF_SIZE = 4096;\\n\\nusing std::ios_base;\\n\\nint main(int argc, char** argv) {\\n\\n   std::ifstream in(argv[1],\\n      ios_base::in | ios_base::binary);  // Use binary mode so we can\\n   std::ofstream out(argv[2],            // handle all kinds of file\\n      ios_base::out | ios_base::binary); // content.\\n   \\n   // Make sure the streams opened okay...\\n\\n   char buf[BUF_SIZE];\\n\\n   do {\\n      in.read(&#x26;buf[0], BUF_SIZE);      // Read at most n bytes into\\n      out.write(&#x26;buf[0], in.gcount()); // buf, then write the buf to\\n   } while (in.gcount() > 0);          // the output.\\n\\n   // Check streams for problems...\\n\\n   in.close();\\n   out.close();\\n}\\n</code></pre>\\n<h2>Неблокирующий ввод/вывод</h2>\\n<p>Если в <code>open</code> передать флаг <code>O_NONBLOCK</code>, то в случае невозможности выполнить системный вызов I/O (открытие, чтение, запись) будет возвращена ошибка <code>EAGAIN</code> или <code>EWOULDBLOCK</code> в зависимости от вызова, а не блокировка исполнения как обычно.</p>\\n<p>Неблокирующий I/O может быть использован с пайпами, очередями FIFO, сокетами, терминалами, псевдотерминалами и т.д. Так как файловые дескрипторы для пайпов и сокетов получаются не через <code>open</code>, то для них флаг активируется через вызов <code>fcntl()</code>.</p>\\n<p>Для обычных файлов флаг <code>O_NONBLOCK</code> игнорируется, так как кэш буфера ядра и так гарантирует, что I/O над обычными файлами не блокирующий. </p>\\n<h2>Манипуляции с дескриптором открытого файла</h2>\\n<p>Системным вызовом <code>fcntl</code> можно управлять дескриптором уже открытого файла, например, поменять флаги открытия.</p>\\n<pre><code class=\\\"language-cpp\\\">#include &#x3C;unistd.h>\\n#include &#x3C;fcntl.h>\\n\\nint fcntl(int fd, int cmd, ... /* arg */ );\\n</code></pre>\\n<p>Последний аргумент зависит от второго аргумента <code>cmd</code>, то есть от того действия, которое мы пытаемся осуществить.</p>\\n<p>Мы можем:</p>\\n<h3>получить флаги</h3>\\n<pre><code class=\\\"language-cpp\\\">int flags, accessMode;\\nflags = fcntl(fd, F_GETFL);\\nif(flags == -1) \\n    errExit(\\\"fcntl\\\");\\nif(flags &#x26; O_SYNC)\\n    printf(\\\"writes are synchronized\\\\n\\\");\\n</code></pre>\\n<p>А вот режим доступа проверить не так просто, но все равно можно:</p>\\n<pre><code class=\\\"language-cpp\\\">accessMode = flags &#x26; O_ACCMODE;\\nif(accessMode == O_WRONLY || accessMode == O_RDWR)\\n    printf(\\\"file is writable\\\\n\\\");\\n</code></pre>\\n<h3>установить флаги</h3>\\n<p>Можно модифицировать флаги: <code>O_APPEND</code>, <code>O_NONBLOCK</code>, <code>O_NOATIME</code>, <code>O_ASYNC</code> и <code>O_DIRECT</code>. Попытки модификации других флагов - игнорируются.</p>\\n<p>Причем указание флага <code>O_ASYNC</code> в <code>open()</code> тоже игнорируется - его можно установить только через <code>fcntl()</code>.</p>\\n<pre><code class=\\\"language-cpp\\\">fcntl(fd, F_SETFL, O_ASYNC | O_NONBLOCK);\\n</code></pre>\\n<h2>Альтернативные модели I/O</h2>\\n<p>Традиционная модель работы с файлами имеет 2 существенных недостатка:</p>\\n<ul>\\n<li>работает только с одним дескриптором одновременно</li>\\n<li>каждый системный вызов блокирует выполнение, пока передача данных не завершилась</li>\\n</ul>\\n<p>В некоторых приложениях нам бывает нужно:</p>\\n<ul>\\n<li>проверить, возможен ли ввод/вывод в дескриптор, не блокируя исполнение, если невозможен</li>\\n<li>монитортиь несколько дескрипторов, пока ввод/вывод станет доступен на любом из них</li>\\n</ul>\\n<p>Для этого можно использовать неблокирующий I/O или многопроцессность/многопоточность:</p>\\n<ul>\\n<li>при использовании неблокирующего I/O мы можем открыть N дескрипторов и периодически чтением каждого из них проверять, доступно ли для них I/O. Это, конечно, неэффективно по CPU, а так же при больших интервалах реакция приложения на событие I/O может быть слишком долгой.</li>\\n<li>при использовании многопроцессности мы можем создавать новый процесс, чтобы выполнять I/O. Тогда родительский процесс не будет заблокирован, а дочерний заблокируется, пока I/O не будет выполнен. Недостаток - сложно создавать процессы и понадобится какой-то IPC, чтобы сообщать родителю о статусе операции I/O.</li>\\n<li>при использовании многопоточности можем создавать для I/O не процесс, а поток. Это менее накладно по ресурсам, но IPC все равно понадобится.</li>\\n</ul>\\n<p>Чтобы избежать этих недостатков для решения задачи слежения за несколькими дескрипторами с целью узнать, когда они станут готовы для I/O (без блокирования) применяются следующие техники</p>\\n<h3>Мультиплексирование I/O</h3>\\n<p>Позволяет процессу одновременно следить за несколькими дескрипторами, чтобы узнать когда на любом из них становится доступен неблокирующий I/O. </p>\\n<p>При этом важно понимать, что событие доступности неблокирующего I/O не означает, что последующий вызов I/O сможет <em>успешно</em> передать данные. Например, для обычных файлов неблокирующий вызов доступен всегда, потому что будут возвращены либо данные (хотя возможно и после ощутимой задержки), либо EOF, либо ошибка. А вот для сокетов - только когда действительно по сети пришли данные для чтения, или буфер перестал быть заполненным и в него можно написать еще данных.</p>\\n<p>Самая старая техника, поэтому главное достоинство - портируемость. Главный недостаток - плохая масштабируемость на большие (сотни и тысячи) количества дескрипторов.</p>\\n<p>Мультиплексирование осуществляется вызовами <code>select()</code> и <code>poll()</code>.</p>\\n<h4>select()</h4>\\n<p>Блокироует выполнение, пока один или несколько дескрипторов не станут готовы</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/time.h>  /* Включать для портируемости */\\n#include &#x3C;sys/select.h>\\n\\nint select(int nfds, fd_set * readfds, fd_set * writefds, fd_set * exceptfds, struct timeval * timeout );\\n</code></pre>\\n<p>Возвращает количество готовых дескрипторов, 0 при таймауте, -1 при ошибке. Если какой-либо дескриптор указан в нескольких наборах, то он будет учтен соответствующее количество раз.</p>\\n<ul>\\n<li><code>nfds</code> - число, на 1 большее, чем самый большой дескриптор среди наборов</li>\\n<li><code>readfds</code> - набор дескрипторов на чтение</li>\\n<li><code>writefds</code> - набор дескрипторов на запись</li>\\n<li><code>exceptfds</code> - набор дескрипторов, у которых мы ждем т.н. exception condition (это не имеет ничего общего с ошибками)</li>\\n<li><code>timeout</code> - указывает интервал, в течение которого вызов <code>select()</code> заблокирует выполнение, либо же <code>NULL</code>, если нужно ждать бесконечно. Если указать <code>timeval { tv_sec=0, tv_usec=0}</code>, то блокировки не будет вообще, просто сразу ответит, какие дескрипторы уже готовы.</li>\\n</ul>\\n<p>Вместо любого из наборов можно передать <code>NULL</code>, если этот класс событий нас не интересует.</p>\\n<p>Наборы могут иметь размерность, не большую, чем константа <code>FD_SETSIZE</code>, в Линуксе она равна 1024. </p>\\n<p>С типом <code>fd_set</code> работаем посредством следующих операций:</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/select.h>\\nvoid FD_ZERO(fd_set * fdset );  // инициализирует набор, делая его пустым\\nvoid FD_SET(int fd , fd_set * fdset );  // добавляет дескриптор в набор\\nvoid FD_CLR(int fd , fd_set * fdset );  // удаляет дескриптор из набора\\nint FD_ISSET(int fd , fd_set * fdset ); // возвращает 1, если дескриптор есть в наборе, иначе 0\\n</code></pre>\\n<p>Вызов <code>select()</code> модифицирует переданные в него наборы <code>fd_set</code> таким образом, что после завершения они содержат набор готовых дескрипторов. Но чтобы узнать эти дескрипторы, придется для каждого из интересующих нас дескрипторов, вызвать <code>FD_ISSET</code>.</p>\\n<h4>poll()</h4>\\n<p>Работает так же, как и <code>select()</code>, разница лишь в API. В <code>poll()</code> мы предоставляем список дескрипторов, где для каждого указан набор интересующих событий</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;poll.h>\\nint poll(struct pollfd fds[], nfds_t nfds, int timeout);\\n</code></pre>\\n<p>Возвращает количество готовых дескрипторов, 0 при таймауте, -1 при ошибке.</p>\\n<p><code>fds[]</code> содержит массив дескрипторов. Сртуктура <code>pollfd</code> имеет следующий вид:</p>\\n<pre><code class=\\\"language-c\\\">struct pollfd {\\n    int fd;         // дескриптор\\n    short events;   // бит-маска интересующих ивентов\\n    short revents;  // бит-маска выстреливших ивентов\\n}\\n</code></pre>\\n<p><code>nfds</code> - количество элементов в массиве <code>fds</code>.</p>\\n<p>Далее приведен список битов, которые могут быть выставлены для <code>events</code> и <code>revents</code>:</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/d290a97e10b14fdde5d5ab83e4a558f2/ee7d1/events-revents-bits.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 638px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 55.01567398119123%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABcUlEQVQoz22S2a6CQBBE5/+/zhgJbiDggiAgrogsbU4nTe7DnaRCAz1V1TXjlsulXC4XuV6v4nmezGYzieNY5vO51ovFQtbrtf4LgkAej4fc7/d/AY/bbrdSVZUSbjYb3Zgkifi+rzWEx+NRTqeTpGkqZVlKnue6uSiKCbwfDgdxqEK63+9Vves6VXu9XlojFobhREo/73w31HWtQgi63W4njI0TSNq2lefzOdU0Q4A6pABHTISr2+2mPTwx4mgG/DQSnFJ/v98pCmLAAS4NEPV9L8MwKOh1BE5eOMA+KtinhjjLMiVEFFImIh6A6OfzkaZp9KmHQgMbwPv9Vlc0UpMho0RRpILn81lJEaEHV38XvQ4iHOIUy6jZqZMlJ2quICNDyBnfHBqmawNgZ0QWY1MbOfcSGCHk/GON46hgaYar1UodMgakLMKG1FQtQ66MOUXALjTiQB3SzLWhiWauBDVjUZMfcdBn01jm7MOQ1Yj8AMERNEXs/IPBAAAAAElFTkSuQmCC'); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Events & Revents bits\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/d290a97e10b14fdde5d5ab83e4a558f2/ee7d1/events-revents-bits.png\\\"\\n        srcset=\\\"/hows-that-again/static/d290a97e10b14fdde5d5ab83e4a558f2/c235e/events-revents-bits.png 163w,\\n/hows-that-again/static/d290a97e10b14fdde5d5ab83e4a558f2/5eba7/events-revents-bits.png 325w,\\n/hows-that-again/static/d290a97e10b14fdde5d5ab83e4a558f2/ee7d1/events-revents-bits.png 638w\\\"\\n        sizes=\\\"(max-width: 638px) 100vw, 638px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Аргумент <code>timeout</code> ведет себя так же, как и у <code>select()</code>, только с другими ключевыми значениями:</p>\\n<ul>\\n<li>-1: блокировать без ограничений по времени</li>\\n<li>0: не блокировать,сразу возвращать</li>\\n<li>\\n<blockquote>\\n<p>0: означает миллисекунды, сколько ждем</p>\\n</blockquote>\\n</li>\\n</ul>\\n<h3>Signal-driven I/O</h3>\\n<p>Процесс просит у ядра послать сигнал, когда I/O становится доступен на определенном дескрипторе. На большом количестве дескрипторов эта техника работает лучше, чем мультиплексирование.</p>\\n<p>Алгоритм использования таков:</p>\\n<ol>\\n<li>\\n<p>Создаем хэндлер для сигнала <code>SIGIO</code>.</p>\\n</li>\\n<li>\\n<p>Вызовом <code>fnctl()</code> устанавливаем владельца дескриптора файла, то есть процесс, который будет получать сигналы о готовности I/O. Обычно это текущий процесс: <code>fcntl(fd, F_SETOWN, pid);</code></p>\\n</li>\\n<li>\\n<p>Через <code>fcntl()</code> устанавливаем дескриптору флаг <code>O_NONBLOCK</code></p>\\n</li>\\n<li>\\n<p>Через <code>fnctl()</code> включаем signal-driven i/o, выставив флаг <code>O_ASYNC</code>. Это может быть объединено с предыдущим шагом:</p>\\n<pre><code class=\\\"language-c\\\">flags = fcntl(fd, F_GETFL); \\nfcntl(fd, F_SETFL, flags | O_ASYNC | O_NONBLOCK);\\n</code></pre>\\n</li>\\n<li>\\n<p>Вызывающий процесс теперь может заниматься своими делами. Когда I/O станет доступен, ядро сгенерит сигнал и вызовет указанный хэндлер</p>\\n</li>\\n<li>\\n<p>Signal-driven I/O генерирует edge-triggered нотификации. Это значит, что при получении нотификации нужно в цикле читать данные из дескриптора до тех пор, пока не получим ошибку <code>EAGAIN</code> или <code>EWOULDBLOCK</code>.</p>\\n</li>\\n</ol>\\n<p>Пример:</p>\\n<pre><code class=\\\"language-cpp\\\">#include &#x3C;csignal>\\n#include &#x3C;fcntl.h>\\n#include &#x3C;unistd.h>\\n\\nstatic void sigioHandler(int sig) {\\n    gotSigio = 1;\\n}\\n\\nint main(int args, char *argv[]) {\\n  struct sigaction sa;                        //\\n  sigemptyset(&#x26;sa.sa_mask);                   //\\n  sa.sa_flags = SA_RESTART;                   //\\n  sa.sa_handler = sigioHandler;               // 1. Создаем хэндлер для сигнала SIGIO.\\n  if (sigaction(SIGIO, &#x26;sa, NULL) == -1) {    //\\n      printf(\\\"sigaction error\\\");              //\\n      return 1;                               //\\n  }                                           //\\n\\n  if (fcntl(STDIN_FILENO, F_SETOWN, getpid()) == -1) {  //\\n      printf(\\\"fcntl(F_SETOWN) error\\\");                  // 2. Вызовом `fnctl()` устанавливаем владельца дескриптора файла\\n      return 1;                                         //\\n  }                                                     //\\n\\n  int flags = fcntl(STDIN_FILENO, F_GETFL);                                 //\\n  if (fcntl(STDIN_FILENO, F_SETFL, flags | O_ASYNC | O_NONBLOCK) == -1) {   //\\n    printf(\\\"fcntl(F_SETFL) error\\\");                                         // 3,4 - устанавливаем флаги O_NONBLOCK, O_ASYNC\\n    return 1;                                                               //\\n  }                                                                         //\\n\\n  int cnt = 0;\\n  for (bool done = false; !done; cnt++) {\\n      for (int j = 0; j &#x3C; 100000000; j++)\\n          continue;\\n\\n      char ch;\\n      if (gotSigio) {\\n          while (read(STDIN_FILENO, &#x26;ch, 1) > 0 &#x26;&#x26; !done) {   // 6 - читаем, пока не получим ошибку\\n              printf(\\\"cnt=%d; read %c\\\\n\\\", cnt, ch);\\n              done = ch == '#';\\n          }\\n      }\\n\\n      gotSigio = 0;\\n\\n  }\\n}\\n</code></pre>\\n<h3>epoll</h3>\\n<p>Техника, доступная только в линуксе. Объединяет достоинства предыдущих двух техник.</p>\\n<p>Не может быть использована с обычными файлами, так как они и так всегда работают в неблокирующем режиме (т.е. всегда есть данные, но это не значит, что они будут возвращаться мгновенно). Если попробовать использовать с обычными файлами, то выдаст ошибку.</p>\\n<p>По сравению с signal-driven имеет преимущества:</p>\\n<ul>\\n<li>не нужно работать с сигналами</li>\\n<li>монжо указать, какой конкретно ивент нас интересует - готовность к чтению, или к записи</li>\\n<li>можно выбрать между level-triggered и edge-triggered нотификациями.</li>\\n</ul>\\n<p>Чтобы использовать аналогичные фичи в модели signal-driven I/O, все равно придется использовать непортируемые линукс-специфичные фичи.</p>\\n<p>По производительности epoll сравним с signal-driven I/O.</p>\\n<p>Работа с <code>epoll API</code> осуществляется через инстанс <code>epoll</code>, который содержит следующие структуры:</p>\\n<ul>\\n<li><strong>interest list</strong> - список файловых дескрипторов, которые мы мониторим</li>\\n<li><strong>ready list</strong> - список файловых дескрипторов, готовых к неблокирующему I/O</li>\\n</ul>\\n<p><code>epoll</code> API состоит из 3 системных вызовов:</p>\\n<h4><code>epoll_create()</code></h4>\\n<p>создает инстанс <code>epoll</code> и возвращает ссылающийся на него файловый дескриптор, или -1 </p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/epoll.h>\\n\\nint epoll_create(int size);\\n</code></pre>\\n<ul>\\n<li><code>size</code> - количество дескрипторов, которые будем мониторить. Это не верхняя граница, а подсказка ядру для эффективной инициализации (с версии ядра 2.6.8 аргумент вообще игнорируется).</li>\\n</ul>\\n<p>При завершении работы с файловым дескриптором <code>epoll</code>, его надо закрыть как обычно через <code>close()</code>.</p>\\n<h4><code>epoll_ctl()</code></h4>\\n<p>изменяет <strong>interest list</strong></p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/epoll.h>\\n\\nint epoll_ctl(int efpd, int op, int fd, struct epoll_event *ev);\\n</code></pre>\\n<ul>\\n<li><code>fd</code> - файловый дескриптор из <strong>interest list</strong>, чьи настройки будем модифицировать (может быть и идентификатором, ссылающимся на другой <code>epoll</code>, таким образом можем построить иерархию). Однако он не может быть дескриптором обычного файла или папки.</li>\\n<li><code>op</code> - операция. Выбирается из списка <code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_MOD</code>, <code>EPOLL_CTL_DEL</code>.</li>\\n<li><code>ev</code> - описание ивента, за которым будем следить.</li>\\n</ul>\\n<pre><code class=\\\"language-c\\\">struct epoll_event {\\n    uint32_t events;\\n    epoll_data_t data;\\n}\\n\\ntypedef union epoll_data {\\n  void *ptr;\\n  int fd;\\n  uint32_t u32;\\n  uint64_t u64;\\n} epoll_data_t;\\n</code></pre>\\n<ul>\\n<li><code>events</code> - битовая маска, определяющая набор отслеживаемых ивентов. Возможные ивенты перечеслены в таблице ниже.</li>\\n<li><code>data</code> - union, один из членов которого может быть испольован, чтобы передать данные процессу, который вызовет <code>epoll_wait()</code>.</li>\\n</ul>\\n<h4><code>epoll_wait()</code></h4>\\n<p>возвращает элементы <strong>ready list</strong>.</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/epoll.h>\\n\\nint epoll_wait(int epfd, struct epoll_event * evlist, int maxevents, int timeout);\\n</code></pre>\\n<p>Возвращает количество готовых дескрипторов, 0 при таймауте, -1 при ошибке.</p>\\n<p>Сами готовые дескрипторы будут возвращены в массиве <code>evlist</code>. Массив создается вызывающей стороной и в <code>maxevents</code> нужно передать его длину. </p>\\n<p>В каждом из элементов возвращенного массива поле <code>events</code> перечисляет произошедшие с дескриптором события. </p>\\n<p>Поле <code>data</code> содержит значение, которое было передано через <code>ev.data</code> в <code>epoll_ctl()</code>. Это поле - <strong>единственный способ узнать, с каким дескриптором произошло событие</strong>.</p>\\n<p>Аргумент <code>timeout</code> работает как всегда, -1 - ждем бесконечно, 0 - не ждем, больше 0 - миллисекунды.</p>\\n<p>Возможные значения ивентов:</p>\\n<p><img src=\\\"epoll-events.png\\\" alt=\\\"Epoll events\\\"></p>\\n<p><code>EPOLLONESHOT</code> используется, когда мы хотим быть информированы о дескрипторе только один раз. Если захочется активировать его заново, можно это сделать через <code>epoll_ctl()</code> с операцией <code>EPOLL_CTL_MOD</code>.</p>\\n<p>Без использования <code>EPOLLONESHOT</code> придется после получения ивента по дескриптору вызывать <code>epoll_ctl()</code> с <code>EPOLL_CTL_DEL</code>.</p>\\n<h4>Edge-triggered notifications</h4>\\n<p>Чтобы использовать edge-triggered нотификации, нужно указать флаг <code>EPOLLET</code> в <code>ev.events</code>:</p>\\n<pre><code class=\\\"language-c\\\">struct epoll_event ev;\\n\\nev.data.fd = fd;\\nev.events = EPOLLIN | EPOLLET;\\nif(epoll_ctl(epfd, EPOLL_CTL_ADD, fd, ev) == -1)\\n  errExit(\\\"epoll_ctl\\\");\\n</code></pre>\\n<p>edge-triggered нотификации обычно используются в сочетании с <code>O_NONBLOCK</code> и чтением в цикле, пока не выстрелит ошибка <code>EAGAIN/EWOULDBLOCK</code>.</p>\\n<h4>Пример</h4>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;iostream>\\n#include &#x3C;sys/epoll.h>\\n#include &#x3C;cstdarg>\\n#include &#x3C;fcntl.h>\\n#include &#x3C;unistd.h>\\n\\n#define MAX_BUF 1000\\n#define MAX_EVENTS 5\\n\\nint main(int argc, char *argv[]) {\\n    struct epoll_event evlist[MAX_EVENTS];\\n    char buf[MAX_BUF];\\n\\n    if(argc &#x3C; 2 || argv[1] == \\\"--help\\\")\\n        usageErr(\\\"%s file...\\\\n\\\", argv[0]);\\n\\n\\n    int epfd = epoll_create(argc-1);\\n    if(epfd == -1)\\n        errExit(\\\"epoll_create\\\");\\n\\n    for(int j = 1; j &#x3C; argc; j++) {\\n        int fd = open(argv[j], O_RDONLY);\\n        if(fd == -1)\\n            errExit(\\\"open\\\");\\n        printf(\\\"Opened \\\\\\\"%s\\\\\\\" on fd %d\\\\n\\\", argv[j], fd);\\n\\n        epoll_event ev;\\n        ev.events = EPOLLIN;\\n        ev.data.fd = fd;\\n        if(epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &#x26;ev) == -1)\\n            errExit(\\\"epoll_ctl\\\");\\n\\n    }\\n\\n    int numOpenFds = argc - 1;\\n\\n    while(numOpenFds > 0) {\\n        printf(\\\"About to epoll_wait()\\\\n\\\");\\n        int ready = epoll_wait(epfd, evlist, MAX_EVENTS, -1);\\n        if(ready == -1) {\\n            if(errno == EINTR)\\n                continue;\\n            else\\n                errExit(\\\"epoll_wait\\\");\\n        }\\n        printf(\\\"Ready: %d\\\\n\\\", ready);\\n\\n        for(int j = 0; j &#x3C; ready; j++) {\\n            printf(\\\"  fd=%d; events: %s%s%s\\\\n\\\", evlist[j].data.fd,\\n                   (evlist[j].events &#x26; EPOLLIN) ? \\\"EPOLLIN \\\" : \\\"\\\",\\n                   (evlist[j].events &#x26; EPOLLHUP) ? \\\"EPOLLHUP \\\" : \\\"\\\",\\n                   (evlist[j].events &#x26; EPOLLERR) ? \\\"EPOLLERR \\\" : \\\"\\\");\\n\\n            if(evlist[j].events &#x26; EPOLLIN) {\\n                size_t s = read(evlist[j].data.fd, buf, MAX_BUF);\\n                if(s == -1)\\n                    errExit(\\\"read\\\");\\n                printf(\\\"  read %d bytes: %.*s\\\\n\\\", s, s, buf);\\n            }\\n            else if(evlist[j].events &#x26; (EPOLLHUP | EPOLLERR)) {\\n                printf(\\\"  closing fd %d\\\\n\\\", evlist[j].data.fd);\\n                if(close(evlist[j].data.fd) == -1)\\n                    errExit(\\\"close\\\");\\n                numOpenFds--;\\n            }\\n        }\\n    }\\n\\n    printf(\\\"All file descriptors closed; bye\\\\n\\\");\\n    exit(EXIT_SUCCESS);\\n}\\n</code></pre>\\n<h3>libevent</h3>\\n<p>Сторонняя библиотека, предоставляющая слой абстракции для мониторинга за файловыми дескрипторами. Использует все вышеперечисленные (и не только) техники и может включать/выключать их в зависимости от ОС.</p>\\n<h3>Типы нотификаций</h3>\\n<ul>\\n<li>Level-triggered: выстреливается, когда дескриптор становится доступен для осуществления системного вызова I/O без блокирования. После этого можно выполнить (а можно и не выполнять) необходимую I/O операцию и повторить мониторинг, чтобы узнать, когда I/O станет доступен снова. Важно, что нам необязательно читать все доступные данные, можем прочитать сколько угодно и повторить мониторинг, просто если мы прочитали не все, то событие выстрелит сразу же.</li>\\n<li>Edge-triggered: выстреливается, когда произошла некоторая I/O активность на дескрипторе (нарпример, стали доступны данные для чтения). Отличие в том, что событие не выстрелит, пока не произойдет следующее событие I/O (например, доступна следующая порция данных на чтение). Кроме того, мы обычно не знаем, сколько именно данных нам стало доступно для неблокирующего I/O. Поэтому обычно мы помещаем дескриптор в неблокирующий режим и совершаем операции в цикле, пока не получим ошибку <code>EAGAIN</code> или <code>EWOULDBLOCK</code>.</li>\\n</ul>\\n<table>\\n<thead>\\n<tr>\\n<th>I/O model</th>\\n<th>Level-triggered?</th>\\n<th>Edge-triggered?</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>select(), poll()</td>\\n<td>X</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>signal-driven</td>\\n<td></td>\\n<td>X</td>\\n</tr>\\n<tr>\\n<td>epoll</td>\\n<td>X</td>\\n<td>X</td>\\n</tr>\\n</tbody>\\n</table>\\n<h1>Сигналы</h1>\\n<p>Сигналы - это, иными словами, \\\"программные прерывания\\\". Они могут быть вызваны ядром в любой момент при наступлении интересующего события, а после выполнения хэндлера, выполнение продолжается с той же строчки, на которой было прервано.</p>\\n<p>Самые популярные сигналы:</p>\\n<ul>\\n<li><code>SIGINT</code>: сигнал, генерируемый нажатием <code>Ctrl+C</code>, просит программу остановить текущее действие и ожидать пользовательского ввода. Неинтерактивные программы обычно обрабатывают его так же, как и <code>SIGTERM</code></li>\\n<li><code>SIGTERM</code>: сигнал убийства процесса, говорит приложению завершиться, но дает время на сохранение стейта, закрытие ресурсов и прочее</li>\\n<li><code>SIGHUP</code>: то же, что и <code>SIGTERM</code>, но автоматически шлется приложениям, когда пользователь отсоединяется от терминала (hung up)</li>\\n</ul>\\n<h2>Подписка на сигнал | SGINT</h2>\\n<p>Есть два способа: <code>signal()</code> и <code>sigaction()</code>.</p>\\n<h3>signal()</h3>\\n<p>Этот вызов более старый, но имеет более простое API. Однако у него есть различия в поведении среди различных имплементаций UNIX, поэтому <code>signal()</code> не рекомендуется к использованию в кросс-платформенных системах.</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;signal.h>\\n\\nvoid ( *signal(int sig, void (*handler)(int)) ) (int);\\n</code></pre>\\n<ul>\\n<li><code>handler</code> - указатель на функцию, принимающую <code>int</code> (туда придет номер возникшего сигнала) и возвращающую ничего</li>\\n<li><code>signal</code> - фукнция, принимающая <code>int</code> и <code>pointer</code>, а возвращающая указатель на функцию, принимающую <code>int</code> и возвращающую ничего.</li>\\n</ul>\\n<p>На самом деле <code>signal</code> возвращает указатель на предыдущий хэндлер. Это нужно для установки \\\"временных\\\" хэндлеров, которые можно потом откатить:</p>\\n<pre><code class=\\\"language-c\\\">void (*oldHandler)(int);\\n\\noldHandler = signal(SIGINT, newHandler);\\n\\n/// здесь сигнал SIGINT обрабатывается новым хэндлером\\n\\nsignal(SIGINT, oldHandler); // возвращаем старый хэндлер\\n</code></pre>\\n<p>Вместо указателя на хэндлер можно подавать:</p>\\n<ul>\\n<li><code>SIG_DFL</code> - откатиться к дефолтному хэндлеру</li>\\n<li><code>SIG_IGN</code> - игнорировать сигнал</li>\\n</ul>\\n<p>Если нужно одним хэндлером обрабатывать несколько сигналов, то нужно несколько раз вызвать функцию, битмаска тут не работает:</p>\\n<pre><code class=\\\"language-c\\\">signal(SIGHUP, signalHandler);\\nsignal(SIGTERM, signalHandler);\\nsignal(SIGINT, signalHandler);\\nsignal(SIGKILL, signalHandler);\\n</code></pre>\\n<h3>sigaction()</h3>\\n<p>Имеет более сложный API, но зато позволяет получить хэндлер, не меняя его, а так же позволяет установить некоторые атрибуты, контролирующие, что произойдет, когда хэндлер будет вызван. Помимо этого, <code>sigaction()</code> более портируем, чем <code>signal()</code>.</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;signal.h>\\n\\nint sigaction(int sig, const struct sigaction *act, struct sigaction *oldact);\\n\\nstruct sigaction {\\n    void (*sa_handler)(int);    // адрес хэндлера\\n    sigset_t sa_mask;           // сигналы, заблокированные во время работы хэндлера\\n    int sa_flags;               // флаги, контролирующие работу хэндлера\\n    void (*sa_restorer)(void);  // не для использования\\n};\\n</code></pre>\\n<p>Так же, как и в <code>signal()</code>, вместо поля <code>sa_handler</code> можно подать <code>SIG_IGN</code> или <code>SIG_DFL</code>.</p>\\n<p><code>sa_mask</code> позволяет перечислить сигналы, которым нельзя прерывать выполнение этого хэндлера. Сигнал, который вызван в хэндлер, автоматически занесен в фильтр, то есть сам себя рекурсивно хэндлер сигнала прервать не может.</p>\\n<p>Вручную добавлять и убирать сигналы из фильтра процесса можно вызовом <code>sigprocmask()</code>.</p>\\n<h3>Наборы сигналов</h3>\\n<p>Несколько сигналов могут быть объединены в страктуру <code>sigset_t</code>. Для управления таким множеством есть специальные функции:</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;signal.h>\\n\\nint sigemptyset(sigset_t *set);     // инициализация нулями, то есть исключает все сигналы\\nint sigfillset(sigset_t *set);      // инициализация единицами, то есть включает все сигналы\\n\\nint sigaddset(sigset_t *set, int sig);  // добавление сигнала в набор\\nint sigdelset(sigset_t *set, int sig);  // удаление сигнала из набора\\n\\nint sigismember(const sigset_t *set, int sig); // 1, если сигнал входит в набор, иначе 0\\n\\nint sigandset(sigset_t *dest, sigset_t *left, sigset_t *right); // кладет пересечение left и right в dest\\nint sigorset(sigset_t *dest, sigset_t *left, sigset_t *right);  // кладет объединение left и right в dest\\n\\nint sigisemptyset(const sigset_t *set);     // 1, если набор пустой, иначе 0\\n</code></pre>\\n<h3>kill()</h3>\\n<p>С помощью вызова <code>kill()</code> можно послать сигнал другому процессу или группе процессов</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;signal.h>\\n\\nint kill(pid_t pid, int sig);\\n</code></pre>\\n<h3>pause()</h3>\\n<p>Системный вызов <code>pause()</code> прерывает исполнение до тех пор, пока не будет вызван какой-либо хэндлер сигнала</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;unistd.h>\\n\\nint pause(void);\\n</code></pre>\\n<p>Всегда возвращает -1 и выставляет <code>errno</code> в <code>EINTR</code>.</p>\\n<h1>Сокеты</h1>\\n<p>Сокет открывается так:</p>\\n<pre><code class=\\\"language-c\\\">int fd = socket(domain, type, protocol);\\n</code></pre>\\n<h2>Основные системные вызовы</h2>\\n<ul>\\n<li><code>socket()</code> - создает новый сокет, возвращает его файловый дескриптор.</li>\\n<li><code>bind()</code> - привязывает сокет к адресу, возвращает 0 при успехе, -1 при ошибке.</li>\\n<li><code>listen()</code> - разрешает потоковому сокету принимать входящие соединения от других сокетов</li>\\n<li><code>accept()</code> - принимает входящее соединение</li>\\n<li><code>connect()</code> - устанавливает соединение с другим сокетом</li>\\n</ul>\\n<p>Ввод/вывод данных из сокетов осуществляется стандартными вызовами <code>read()</code> и <code>write()</code>, или специфичными для сокетов <code>send()</code>, <code>recv()</code> (для TCP), <code>sendto()</code>, <code>recvfrom()</code> (для UDP). По умолчанию все эти вызовы блокирующие. Можно сделать их неблокирующими, используя <code>fcntl()</code> с операцией <code>F_SETFL</code>.</p>\\n<h3>socket()</h3>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/socket.h>\\n\\nint socket(int domain, int type, int protocol)\\n</code></pre>\\n<p>В качестве domain обычно указывается:</p>\\n<ul>\\n<li><code>AF_UNIX</code> - для коммуникаций в рамках одного хоста. Для адреса используется структура <code>sockaddr_un</code>.</li>\\n<li><code>AF_INET</code> - для коммуникаций по протоколу IPv4. Для адреса используется структура <code>sockaddr_in</code>.</li>\\n<li><code>AF_INET6</code> - для коммуникаций по IPv6. Для адреса используется структура <code>sockaddr_in6</code>.</li>\\n</ul>\\n<p><code>AF</code> - значит Address Family.</p>\\n<p>Каждая реализация сокетов предоставляет 2 типа, указываемых вторым аргументом: <strong>stream</strong> (<code>SOCK_STREAM</code>) и <strong>datagram</strong> (<code>SOCK_DGRAM</code>).</p>\\n<ul>\\n<li><strong>stream</strong>: надежный, двунаправленный, потоковый. Обычно использует TCP.</li>\\n<li><strong>datagram</strong>: ненадежный, шлет отдельные сообщения-датаграммы, которые могут прийти в другом порядке, дублироваться, или не прийти вообще. Обычно использует UDP.</li>\\n</ul>\\n<p><code>protocol</code> в большинстве случаев 0.</p>\\n<h3>bind()</h3>\\n<p>Если не вызывать <code>bind()</code>, то при последующем <code>listen()</code> сокет будет автоматически привязан к случайному порту. Получить порт можно затем командой <code>getsockname()</code>.</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/socket.h>\\n\\nint bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\\n</code></pre>\\n<p>Здесь <code>sockfd</code> - файловый дескриптор сокета, <code>addr</code> - структура, описывающая адрес, <code>addrlen</code> - размер структуры <code>addr</code> (можно получить через <code>sizeof(addr)</code>).</p>\\n<p>Конкретный тип структуры <code>addr</code> зависит от указанного при создании сокета <code>domain</code>:</p>\\n<ul>\\n<li><code>AF_UNIX</code> - <code>sockaddr_un</code>.</li>\\n<li><code>AF_INET</code> - <code>sockaddr_in</code>.</li>\\n<li><code>AF_INET6</code> - <code>sockaddr_in6</code>.</li>\\n</ul>\\n<p>Все они являются расширениями структуры <code>sockaddr</code> (хотя и имеют другие поля, но мы все равно можем кастовать их к <code>sockaddr</code> для передачи в вызов <code>bind()</code>):</p>\\n<pre><code class=\\\"language-c\\\">struct sockaddr {\\n  sa_family   sa_family;  /* Константа вида AF_*, например, AF_INET */\\n  char        sa_data[14];     /* Адрес сокета */\\n}\\n</code></pre>\\n<h4>Адрес IPv4</h4>\\n<pre><code class=\\\"language-c\\\">struct sockaddr_in {\\n  sa_family_t     sin_family;   /* AF_INET */\\n  in_port_t       sin_port;     /* номер порта */\\n  struct in_addr  sin_addr;     /* адрес IPv4 */\\n  unsigned char   __pad[X];     /* служебное поле, не трогать */\\n};\\n\\nstruct in_addr {\\n  in_addr_t s_addr; /* беззнаковое 32-битное число */\\n}; \\n</code></pre>\\n<p><code>sin_port</code> и <code>sin_addr</code> имеют сетевой порядок байт (<em>network byte order</em>).</p>\\n<p><code>in_port_t</code> и <code>in_addr_t</code> - беззнаковые целые по 16 и 32 бит соответственно.</p>\\n<h4>Адрес IPv6</h4>\\n<pre><code class=\\\"language-c\\\">struct sockaddr_in6 {\\n  sa_family_t     sin6_family;      /* AF_INET6 */\\n  in_port_t       sin6_port;        /* номер порта */\\n  uint32_t        sin6_flowinfo;    /* IPv6 flow information (???) */\\n  struct in6_addr sin6_addr;        /* адрес IPv6 */\\n  uint32_t        sin6_scope_id;    /* Scope ID (???) */\\n};\\n\\nstruct in6_addr {\\n  uint8_t s6_addr[16]; /* 16 байт = 128 бит */\\n}; \\n</code></pre>\\n<p><code>sin6_port</code> и <code>sin6_addr</code> имеют сетевой порядок байт (<em>network byte order</em>).</p>\\n<p><code>in_port_t</code> - беззнаковое целое на 16 бит.</p>\\n<p><code>sin6_flowinfo</code> и <code>sin6_scope_id</code> можно указывать 0.</p>\\n<h4>Network byte order</h4>\\n<p>Адреса IP и номера портов - целые числа. Чтобы их использовать, нужно привести их от хостового к сетевому порядку байт (big endian, сначала самые значимые байты).</p>\\n<p>Для конвертации есть несколько функций:</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;arpa/inet.h>\\n\\nuint16_t htons(uint16_t host_unit16); /* host-to-network-short, конвертирует 16-битное целое в сетевой порядок байт */\\n\\nuint32_t htonl(uint32_t host_uint32); /* host-to-network-long, конвертирует 32-битное в сетевой */\\n\\nuint16_t ntohs(uint16_t net_uint16); /* network-to-host-short */\\n\\nuint32_t ntohl(uint32_t net_uint32); /* network-to-host-long */\\n</code></pre>\\n<h4>Приведение IP-адреса</h4>\\n<p>Чтобы привести строковый адрес к типу <code>in_addr</code> используются следующие функции:</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;arpa/inet.h>\\n\\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size); // network-to-presentation\\n</code></pre>\\n<p>Преобразует адрес, представленный в виде числа в строку.</p>\\n<ul>\\n<li><code>af</code>: address family, то есть <code>AF_INET</code> или <code>AF_INET6</code>.</li>\\n<li><code>src</code>: указатель на <code>in_addr</code> или <code>in6_addr</code>, где лежит адрес, который нужно преобразовать к строке.</li>\\n<li><code>dst</code>: указатель на строку, куда положить результат</li>\\n<li><code>size</code>: максимальная длина результата</li>\\n</ul>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;arpa/inet.h>\\n\\nint inet_pton(int af, const char *src, void *dst); // presentation-to-network\\n</code></pre>\\n<p>Преобразует адрес в виде строки к <code>in_addr</code> или <code>in6_addr</code>.</p>\\n<ul>\\n<li><code>af</code>: address family, то есть <code>AF_INET</code> или <code>AF_INET6</code>.</li>\\n<li><code>src</code>: указатель на строку, которую нужно преобразовать.</li>\\n<li><code>dst</code>: указатель на <code>in_addr</code> или <code>in6_addr</code>, куда положить результат</li>\\n</ul>\\n<p><strong>Эти функции не осуществляют DNS-поисков, для этого нужно вызыват getaddrinfo()</strong></p>\\n<p>В коде можно еще встретить функции <code>inet_ntoa()</code>, <code>inet_aton()</code>, <code>inet_addr()</code> - они делают то же самое, но устарели, так как не поддерживают IPv6.</p>\\n<h3>listen()</h3>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/socket.h>\\n\\nint listen(int sockfd, int backlog);\\n</code></pre>\\n<p>Перевести сокет в пассивный режим - режим ожидания входящих соединений. Нельзя вызвать на уже соединенном сокете.</p>\\n<p><code>backlog</code> - устанавливает ограничение на количество ожидающих соединений. Соединения до этого лимита будут обслужены моментально. Соединения сверх этого количества будут возвращены с ошибкой <code>ECONNREFUSED</code>, либо проигнорированы и посланы позже. Максимальное значение <code>backlog</code> по умолчанию - 128, но может быть изменено.</p>\\n<h3>accept()</h3>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/socket.h>\\n\\nint accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);\\n</code></pre>\\n<p>Создает новый сокет, который соединяется с внешним сокетом, инициировавшем сединение, и возвращает его файловый дескриптор, либо -1 в случае ошибки. </p>\\n<p>Сокет <code>sockfd</code> остается открытым и готов принимать следующие входящие соединения.</p>\\n<p><code>addr</code> и <code>addrlen</code> характеризуют адрес внешнего сокета, от которого пришло соединение. Конкретный тип, как и в случае <code>bind()</code> зависит от домена. При вызове <code>addrlen</code> должен содержать размер буфера, на который указывает поле <code>sa_data</code> в <code>addr</code>, а по завершении будет содержать количество записанных туда байт. Если адрес входящего сокета нас не интересует, можно передать <code>NULL</code> и 0, соответственно. Потом адрес входящего сокета можно получить вызовом <code>getpeername()</code>.</p>\\n<h3>connect()</h3>\\n<p>Соединяет активный сокет (клиентский) с пассивным слушающим (серверным) сокетом.</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/socket.h>\\n\\nint connect(int sockfd, const struct sockaddr *addr, socklen_t *addrlen);\\n</code></pre>\\n<p>Возвращает 0 при успехе, -1 при ошибке.</p>\\n<p>Если получилась ошибка, то нужно закрыть сокет, создать новый и повторить попытку.</p>\\n<h4>connect() для UDP-сокетов</h4>\\n<p>В случае UDP-сокета, этот вызов указывает т.н. <em>peer socket</em>: это значит, что мы должны принимать входящие сообщения только от сокета с указанным адресом, а посылать можем вызовами <code>write()</code> и <code>send()</code> и сообщения будут сразу посланы на указанный адрес.</p>\\n<p>В дальнейшем внешний сокет можно сменить, повторно вызвав <code>connect()</code>. Можно и удалить связь совсем, вызвав <code>connect()</code> с адресом, у которого <em>address family</em> равно <code>AF_UNSPEC</code>.</p>\\n<p>Эта возможность особенно полезна в приложениях, где нам нужно слать много сообщений на один адрес.</p>\\n<h3>close()</h3>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/socket.h>\\n\\nint close(int sockfd);\\n</code></pre>\\n<p>Если на сокет ссылается несколько дескрипторов, то соединение будет завершено, когда закроются все дескрипторы.</p>\\n<h3>sendto()/recvfrom()</h3>\\n<p>Так как UDP-сокеты не устанавливают соединений, то для них не рекомендуется использовать <code>read()</code> и  <code>write()</code>, а нужно использовать <code>recvfrom()</code>/<code>sendto()</code>, в которых аргументом можно указать адрес.</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;sys/socket.h>\\n\\nssize_t recvfrom(int sockfd, void *buffer, size_t length, int flags, struct sockaddr *src_addr, socklen_t *addrlen);\\n\\nssize_t sendto(int sockfd, const void *buffer, size_t length, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);\\n</code></pre>\\n<p>Возвращаемое значение и первые 3 аргумента - такие же, как у <code>read()</code> и <code>write()</code>.</p>\\n<p><code>flags</code> - описывает специфичные для сокетов I/O фичи, обычно можно указать 0.</p>\\n<p><code>src_addr</code> и <code>addrlen</code> - описывают адрес внешнего сокета. В случае <code>sendto()</code> их нужно указать при вызове, а в случае <code>recvfrom()</code> - через них будет возвращен адрес после вызова (как у <code>accept()</code>).</p>\\n<p>Независимо от указанного <code>length</code>, <code>recvfrom()</code> получит только одно сообщение, а если его длина будет меньше <code>length</code>, то обрежет его.</p>\\n<h3>Ошибки чтения из сокета</h3>\\n<p>Ошибки, возникающие из-за багов в коде:</p>\\n<ul>\\n<li><code>[EBADF]</code>: fildes is not a valid file or socket descriptor open for reading.</li>\\n<li><code>[EFAULT]</code>: Buf points outside the allocated address space.</li>\\n<li><code>[EINVAL]</code>: The pointer associated with fildes was negative.</li>\\n<li><code>[ENXIO]</code>: A requested action cannot be performed by the device.</li>\\n</ul>\\n<p>Ошибки, которые потенциально можно вылечить, но на практике обычно нет, так как лечение требует ручного вмешательства:</p>\\n<ul>\\n<li><code>[EIO]</code>: An I/O error occurred while reading from the file system.</li>\\n<li><code>[ENOBUFS]</code>: An attempt to allocate a memory buffer fails.</li>\\n<li><code>[ENOMEM]</code>: Insufficient memory is available.</li>\\n<li><code>[ETIMEDOUT]</code>: A transmission timeout occurs during a read attempt on a socket.</li>\\n</ul>\\n<p>Ошибки, означающие, что данных больше не придет, потому что соединение разорвано:</p>\\n<ul>\\n<li><code>[ECONNRESET]</code>: The connection is closed by the peer during a read attempt on a socket.</li>\\n<li><code>[ENOTCONN]</code>: A read is attempted on an unconnected socket.</li>\\n</ul>\\n<p>И наконец излечимые (recoverable) ошибки, которые обычно лечатся повтором попытки, возможно после таймаута:</p>\\n<ul>\\n<li><code>[EAGAIN]</code>: The file was marked for non-blocking I/O, and no data were ready to be read.</li>\\n<li><code>[EINTR]</code>: A read from a slow device was interrupted before any data arrived by the delivery of a signal.</li>\\n</ul>\\n<h3>Ошибки записи в сокет</h3>\\n<p>Ошибки, возникающие из-за багов в коде:</p>\\n<ul>\\n<li><code>[EINVAL]</code>: The pointer associated with fildes is negative.</li>\\n<li><code>[EBADF]</code>: fildes is not a valid file descriptor open for writing.</li>\\n<li><code>[ECONNRESET]</code>: A write is attempted on a socket that is not connected.</li>\\n<li><code>[ENXIO]</code>: A request is made of a nonexistent device, or the request is outside the capabilities of the device.</li>\\n<li><code>[EPIPE]</code>: An attempt is made to write to a socket of type SOCK_STREAM that is not connected to a peer socket.</li>\\n</ul>\\n<p>Ошибки, которые потенциально можно вылечить, но на практике обычно нет, так как лечение требует ручного вмешательства:</p>\\n<ul>\\n<li><code>[EDQUOT]</code>: The user's quota of disk blocks on the file system containing the file is exhausted.</li>\\n<li><code>[EFBIG]</code>: An attempt is made to write a file that exceeds the process's file size limit or the maximum file size.</li>\\n<li><code>[EIO]</code>: An I/O error occurs while reading from or writing to the file system.</li>\\n<li><code>[ENETDOWN]</code>: A write is attempted on a socket and the local network interface used to reach the destination is down.</li>\\n<li><code>[ENETUNREACH]</code>: A write is attempted on a socket and no route to the network is present.</li>\\n<li><code>[ENOSPC]</code>: There is no free space remaining on the file system containing the file.</li>\\n</ul>\\n<p>И наконец излечимые (recoverable) ошибки, которые обычно лечатся повтором попытки, возможно после таймаута:</p>\\n<ul>\\n<li><code>[EAGAIN]</code>: The file was marked for non-blocking I/O, and no data were ready to be read.</li>\\n<li><code>[EINTR]</code>: A read from a slow device was interrupted before any data arrived by the delivery of a signal.</li>\\n</ul>\\n<h2>Пример</h2>\\n<p>Сервер:</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;netinet/in.h>\\n#include &#x3C;errno.h>\\n#include &#x3C;stdio.h>\\n#include &#x3C;stdlib.h>\\n#include &#x3C;string.h>\\n#include &#x3C;unistd.h>\\n\\n#define SERVER_BUFFER_SIZE      1024\\n\\nint main()\\n{\\n    int socketId = socket(PF_INET, SOCK_STREAM, 0);\\n\\n    struct sockaddr_in serverAddr;\\n    bzero((char*)&#x26;serverAddr, sizeof(serverAddr));\\n    serverAddr.sin_family       = AF_INET;\\n    serverAddr.sin_port         = htons(8080);\\n    serverAddr.sin_addr.s_addr  = INADDR_ANY;\\n    bind(socketId, (struct sockaddr *) &#x26;serverAddr, sizeof(serverAddr));\\n\\n    listen(socketId, 5);\\n\\n    int                         finished    = 0;\\n    while(!finished)\\n    {\\n        struct  sockaddr_storage    serverStorage;\\n        socklen_t                   addr_size   = sizeof serverStorage;\\n        int newSocket = accept(socketId, (struct sockaddr*)&#x26;serverStorage, &#x26;addr_size);\\n\\n        char        buffer[SERVER_BUFFER_SIZE];\\n        int         get = read(newSocket, buffer, SERVER_BUFFER_SIZE - 1);\\n\\n        buffer[get] = '\\\\0';\\n        fprintf(stdout, \\\"%s\\\\n\\\", buffer);\\n\\n        write(newSocket, \\\"OK\\\", 2);\\n\\n        fprintf(stdout, \\\"Message Complete\\\\n\\\");\\n\\n        close(newSocket);\\n    }\\n    close(socketId);\\n}\\n</code></pre>\\n<p>Клиент:</p>\\n<pre><code class=\\\"language-c\\\">#include &#x3C;arpa/inet.h>\\n#include &#x3C;errno.h>\\n#include &#x3C;stdio.h>\\n#include &#x3C;stdlib.h>\\n#include &#x3C;string.h>\\n#include &#x3C;unistd.h>\\n\\n#define CLIENT_BUFFER_SIZE     1024\\n\\nint main(int argc, char* argv[])\\n{\\n    if (argc != 3)\\n    {\\n        fprintf(stderr, \\\"Usage: client &#x3C;host> &#x3C;Message>\\\\n\\\");\\n        exit(1);\\n    }\\n\\n    int socketId = socket(PF_INET, SOCK_STREAM, 0);\\n\\n    struct sockaddr_in serverAddr;\\n    socklen_t addrSize = sizeof(serverAddr);\\n    bzero((char*)&#x26;serverAddr, sizeof(serverAddr));\\n    serverAddr.sin_family       = AF_INET;\\n    serverAddr.sin_port         = htons(8080);\\n    serverAddr.sin_addr.s_addr  = inet_addr(argv[1]);\\n    connect(socketId, (struct sockaddr*)&#x26;serverAddr, addrSize);\\n\\n    write(socketId, argv[2], strlen(argv[2]));\\n\\n    shutdown(socketId, SHUT_WR);\\n\\n    char    buffer[CLIENT_BUFFER_SIZE];\\n    size_t  get = read(socketId, buffer, CLIENT_BUFFER_SIZE - 1);\\n\\n    buffer[get] = '\\\\0';\\n    fprintf(stdout, \\\"%s %s\\\\n\\\", \\\"Response from server\\\", buffer);\\n\\n    close(socketId);\\n}\\n</code></pre>\",\"frontmatter\":{\"path\":\"/blog/linux-api\",\"title\":\"Linux API\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/blog-linux-api.json\n// module id = 456\n// module chunks = 79569183618093"],"sourceRoot":""}