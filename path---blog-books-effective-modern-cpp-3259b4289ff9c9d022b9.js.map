{"version":3,"sources":["webpack:///path---blog-books-effective-modern-cpp-3259b4289ff9c9d022b9.js","webpack:///./.cache/json/blog-books-effective-modern-cpp.json"],"names":["webpackJsonp","423","module","exports","data","markdownRemark","html","frontmatter","path","title","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,uupBAAizpBC,aAAgCC,KAAA,mCAAAC,MAAA,0BAA2EC","file":"path---blog-books-effective-modern-cpp-3259b4289ff9c9d022b9.js","sourcesContent":["webpackJsonp([104734089325636],{\n\n/***/ 423:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>Effective Modern C++</h1>\\n<h2>Вывод типов через auto</h2>\\n<p>Тип для <code>auto</code> выводится так же, как и для шаблонов. В том выводе типов у нас есть определение шаблона и его вызов:</p>\\n<pre><code class=\\\"language-cpp\\\">template&#x3C;typename T>\\nvoid f(ParamType param);\\n\\nf(expr);\\n</code></pre>\\n<p>Когда переменная объявляется через <code>auto</code>, то <code>auto</code> выступает в роли <strong>T</strong>, а спецификатор типа - как <code>ParamType</code>. Например:</p>\\n<pre><code class=\\\"language-cpp\\\">auto x = 27;            // auto -> T, auto -> ParamType\\nconst auto cx = x;      // auto -> T, const auto -> ParamType\\nconst auto&#x26; rx = x;     // auto -> T, const auto&#x26; -> ParamType\\n</code></pre>\\n<p>Для вывода представим соответствующие им шаблоны и их вызовы:</p>\\n<pre><code class=\\\"language-cpp\\\">template&#x3C;typename T>\\nvoid func_x(T param);\\n\\nfunc_x(27);     // ParamTYpe -> int, T -> int\\n\\ntemplate&#x3C;typename T>\\nvoid func_cx(const T param);\\n\\nfunc_cx(x);     // ParamType -> const int, T -> int\\n\\ntemplate&#x3C;typename T>\\nvoid func_rx(const T&#x26; param);\\n\\nfunc_rx(x);     // ParamType -> const int&#x26;, T -> int\\n</code></pre>\\n<p>Во всех остальных случаях логика точно такая же как и для вывода типа шаблона. Но есть одно исключение, о нем дальше.</p>\\n<h3>Особый случай для initializer_list</h3>\\n<pre><code class=\\\"language-cpp\\\">auto x1 = 27;       // int\\nauto x2(27);        // int\\nauto x3 = {27};     // std::initializer_list&#x3C;int> = {27}\\nauto x4{27};        // std::initializer_list&#x3C;int> = {27}\\n</code></pre>\\n<p>Так происходит потому что в выводе типов через <code>auto</code> прописано особое правило: <strong>если значение для авто-объявленной переменной заключено в фигурные скобки, то тип ВСЕГДА выводится как std::initializer_list</strong>.</p>\\n<p>При этом в выводе типов для шаблонов такого правила нет и это единственное место где алгоритмы различаются:</p>\\n<pre><code class=\\\"language-cpp\\\">template&#x3C;typename T>\\nvoid f(T param);\\n\\nf({ 11, 23, 9 }); // ОШИБКА КОМПИЛЯЦИИ!\\n\\ntemplate&#x3C;typename T>\\nvoid f2(std::initializer_list&#x3C;T> list);\\n\\nfw({11,23,9});      // все ок, тип T выводится как int\\n</code></pre>\\n<h2>decltype</h2>\\n<p><strong>decltype</strong> - это функция, которая принимает переменную, а возвращает ее тип. Может быть использована там, где ожидается указание типа.</p>\\n<pre><code class=\\\"language-cpp\\\">const int i = 0;            // decltype(i) -> const int\\nbool f(const Widget&#x26;);      // decltype(w) -> const Widget&#x26;, decltype(f) -> bool(const Widget&#x26;)\\n</code></pre>\\n<p>Обычно используется там, где тип возвращаемого значения зависит от типа аргумента:</p>\\n<pre><code class=\\\"language-cpp\\\">template&#x3C;typename Container, typename Index>\\nauto authAndAccess(Container&#x26; c, Index i) -> decltype(c[i]) {\\n    authenticateser();\\n    return c[i];\\n}\\n</code></pre>\\n<p>здесь <code>auto</code> не имеет отношения к выводу типов, а лишь указывает, что возвращаемый тип будет указан после списка параметров (trailing return type syntax). Такой синтаксис необходимо использовать, когда тип возвращаемого значения зависит от типов параметров.</p>\\n<p>В C++14 можно возвращать из функций <code>auto</code>, не указывая тип после стрелочки, но с этим бывают проблемы, поэтому рекомендуется возвращать <code>decltype(auto)</code>.</p>\\n<p>С <code>authAndAccess</code> осталась одна проблема - она не сможет принимать rvalue для контейнера. Модифицируем так, чтобы мог:</p>\\n<pre><code class=\\\"language-cpp\\\">template&#x3C;typename Container, typename Index>\\nauto get(Container&#x26;&#x26; c, Index i) -> decltype(std::forward&#x3C;Container>(c)[i]) {\\n  authenticateUser();\\n  return std::forward&#x3C;Container>(c)[i];\\n}\\n</code></pre>\\n<p>Теперь для <strong>c</strong> типа lvalue функция будет возвращать lvalue, а для rvalue - rvalue.</p>\\n<h3>Особенность поведения decltype</h3>\\n<p>Применение <strong>decltype</strong> к имени переменной возвращает тип этого имени. Однако применение к lvalue, котороя является чем-то более сложным, чем имя, возвращает ссылку на lvalue. То есть <strong>decltype</strong> над выражением не-именем, имеющим тип <strong>T</strong> вернет тип <strong>T&#x26;</strong>. Такое поведение редко на что-либо влияет, однако есть интересное следствие:</p>\\n<pre><code class=\\\"language-cpp\\\">int x = 0;\\ndecltype(x);    // int\\ndecltype((x));  // int&#x26;\\n</code></pre>\\n<p>Как видно, оборачивание значения в скобки может поменять значение, возвращаемое <strong>decltype</strong>. Это особенно важно в C++14, где можно возвращать из функции <code>decltype(auto)</code> и случайно можно вернуть ссылку на элемент вместо элемента.</p>\\n<h2>Используйте auto вместо явных определений типов</h2>\\n<h3>auto не даст создать неинициализированный объект</h3>\\n<pre><code class=\\\"language-cpp\\\">int x;  // не инициализирован!\\n\\nauto x; // не скомпилится!\\n</code></pre>\\n<h3>Позволяет не писать сложные типы</h3>\\n<pre><code class=\\\"language-cpp\\\">template&#x3C;typename It>\\nvoid dwim(It b, It e)\\n{\\n  while (b != e) {\\n    typename std::iterator_traits&#x3C;It>::value_type currValue = *b;\\n    auto currValue2 = *b;\\n    ...\\n  }\\n}\\n</code></pre>\\n<h3>Экономить память при использовании функторов</h3>\\n<p>Тип лямбды неизвестен до компиляции, поэтому описать его точно - невозможно. Приходится использовать тип <code>std::function</code>. </p>\\n<pre><code class=\\\"language-cpp\\\">std::function&#x3C;bool(const std::unique_ptr&#x3C;Widget>&#x26;, const std::unique_ptr&#x3C;Widget>&#x26;)>\\n    funcs = [](const std::unique_ptr&#x3C;Widget>&#x26; a, const std::unique_ptr&#x3C;Widget>&#x26; b) {\\n        return *a &#x3C; *b;\\n    }\\n</code></pre>\\n<p>Но у него есть недостаток - он всегда занимает фиксированный размер в памяти, и если его не хватает, то аллоцирует память в куче. Тогда как реальный тип замыкания, выводимый во время компиляции и используемый с помощью <strong>auto</strong> всегда занимает ровно столько места, сколько ему требуется.</p>\\n<p>Плюс к этому, из-за особенностей реализации, при вызове функции через <code>std::function</code> запрещается инлайнинг и добавляется непрямой вызов функции (indirect function calls), что ухудшает производительность по сравнению с <strong>auto</strong>.</p>\\n<h3>Неявные приведения типов</h3>\\n<p>Допустим, есть такой код:</p>\\n<pre><code class=\\\"language-cpp\\\">std::vector&#x3C;int> v;\\nunsigned sz = v.size();\\n</code></pre>\\n<p>Все бы ничего, да только <code>v.size()</code> возвращает вовсе не <strong>unsigned</strong>, а <code>std::vector&#x3C;int>::size_type</code>.</p>\\n<p>Другой пример:</p>\\n<pre><code class=\\\"language-cpp\\\">std::unordered_map&#x3C;std::string, int> m;\\n\\nfor(const std::pair&#x3C;std::string, int>&#x26; p: m) {\\n    ...\\n}\\n</code></pre>\\n<p>Реальный тип элементов, содержащихся в <code>unordered_map</code> - <code>std::pair&#x3C;const std::string, int></code>. В результате компилятор не сможет привести <code>std::pair&#x3C;const std::string, int></code> к <code>std::pair&#x3C;std::string, int></code> и будет для каждого члена создавать временный объект, ссылку на который копировать в <strong>p</strong>. После каждой итерации временный объект будет уничтожен.</p>\\n<p>Использование <strong>auto</strong> в этом случае делает код проще и производительнее:</p>\\n<pre><code class=\\\"language-cpp\\\">std::unordered_map&#x3C;std::string, int> m;\\n\\nfor(const auto&#x26; p: m) {...}\\n</code></pre>\\n<h2>Иногда auto выводит не то, что нужно</h2>\\n<pre><code class=\\\"language-cpp\\\">std::vector&#x3C;bool> features(const Widget&#x26; w);\\n\\nWidget w;\\nauto highPriority = features(w)[5];\\nprocessWidget(w, highPriority);\\n</code></pre>\\n<p>Как ни удивительно, этот код приводит к undefined behavior. Дело в том, что оператор <code>[]</code> для <code>std::vector&#x3C;bool></code> возвращает <code>std::vector&#x3C;bool>::reference</code>. Так происходит потому, что булевого типа у вектора есть специальная реализация, которая хранит по одному биту на элемент. Теперь оператор <code>[]</code> должен возвращать ссылку на бит, но в C++ запрещены ссылки на биты. Поэтому приходится возвращать тип, который <em>ведет себя</em> как <code>bool&#x26;</code>. ЭТо означает, что он, помимо прочего, должен быть неявно приводим к <code>bool</code>. </p>\\n<p>Получается, что когда мы делаем <code>bool highPriority = features(w)[5]</code>, то возвращается <code>std::vector&#x3C;bool>::reference</code>, который приводится к <code>bool</code> и дальше все нормально.</p>\\n<p>А вот когда мы делаем <code>auto highPriority = features(w)[5]</code>, то дальше все зависит от реализации типа <code>std::vector&#x3C;bool>::reference</code>. Одна из реализаций представляет из себя:</p>\\n<ul>\\n<li>указатель на машинное слово вектора, в котором содержится интересующий бит</li>\\n<li>сдвиг в этом слове</li>\\n</ul>\\n<p>Итак, вызов <code>features</code> возвращает временный объект-вектор. Оператор <code>[]</code> возвращает <code>std::vector&#x3C;bool>::reference</code>, в котором содержится ссылка на элемент внутри временного объекта-вектора. Мы записываем это в <code>highPriority</code>, после чего временный объект уничтожается, а в <code>highPriority</code> остается висячая ссылка на уничтоженный объект.</p>\\n<p>Здесь <code>std::vector&#x3C;bool>::reference</code> - это прокси-класс, который не предназначен для того, чтобы жить дольше, чем одно выражение. Поэтому <strong>auto</strong> очень плохо дружит с прокси-классами.</p>\\n<p>Такие прокси-классы очень тяжело найти заранее, однако когда стало понятно, что проблема в прокси-классе, не стоит избавляться от <strong>auto</strong>. Лучший способ - использовать явное приведение типа:</p>\\n<pre><code class=\\\"language-cpp\\\">auto highPriority = static_cast&#x3C;bool>(features(w)[5]);\\n</code></pre>\\n<h2>Различия между () и {} при инициализации объектов</h2>\\n<p>Для начало важно отличать инициализацию от присвоения:</p>\\n<pre><code class=\\\"language-cpp\\\">Widget w1;          // инициализация, вызван дефолтный конструктор\\nWidget w2 = w1;     // инициализация, вызывается конструктор копирования\\nw1 = w2;            // присвоение, вызывается оператор =\\n</code></pre>\\n<p>В C++ 11 представлена <em>uniform initialization</em> - предпочтительный способ инициализации:</p>\\n<pre><code class=\\\"language-cpp\\\">int x{0};\\nstd::vector&#x3C;int> v{1,2,3,4,5};\\n</code></pre>\\n<p>Тот же синтаксис можно использовать и для задания дефолтных значений не-статическим полям классов, наравне с синтаксисом через <strong>=</strong>:</p>\\n<pre><code class=\\\"language-cpp\\\">class Widget {\\nprivate:\\n    int x{0};   // ОК\\n    int y = 0;  // тоже ок\\n    int z(0);   // ошибка компиляции!\\n}\\n</code></pre>\\n<p>Однако если инициализируем не-копируемый тип, то <strong>{}</strong> валиден наравне с синтаксисом через <strong>()</strong>:</p>\\n<pre><code class=\\\"language-cpp\\\">std::atomic&#x3C;int>ai1{0};     // OK\\nstd::atomic&#x3C;int>ai2(0);     // OK\\nstd::atomic&#x3C;int>ai3 = 0;    // ошибка!\\n</code></pre>\\n<p>Поэтому, чтобы не путаться, лучше всегда использовать универсальную (uniform) инициализацию вида <code>int x{0};</code>.</p>\\n<h3>{} запрещает преобразование типа с потерей точности</h3>\\n<pre><code class=\\\"language-cpp\\\">double x,y,z;\\nint sum1{ x+y+z };      // не скомпилится, так как сумма даблов может быть невыразима через int\\nint sum2( x+y+z );      // спокойно компилится и приводит к неожиданному поведению при выполнении\\nint sum3 = x + y + z;   // аналогично sum2\\n</code></pre>\\n<h3>{} не подвержена most vexing parse</h3>\\n<p>В С++ есть такое правило - все, что может быть интерпретировано как объявелние, должно быть интерпретировано как объявление.</p>\\n<p>Поэтому часто, когда хотим инициализировать переменную дефолтным конструктором через скобки, вместо этого получается объявление функции:</p>\\n<pre><code class=\\\"language-cpp\\\">Widget w1(10);  // когда у конструктора есть параметры, то все норм\\nWidget w2();    // а вот когда хотис использовать дефолтный конструктор, то получается объявление функции\\n</code></pre>\\n<p>С использованием <strong>{}</strong> код выглядит так и не содержит этой проблемы:</p>\\n<pre><code class=\\\"language-cpp\\\">Widget w3{};\\n</code></pre>\\n<h3>Недостаток: опять проблемы с initializer_list</h3>\\n<p>Если при инициализации через <strong>{}</strong> имеется конструктор, принимающий <code>initializer_list</code>, и он может быть теоретически использован, то будет использован именно он:</p>\\n<pre><code class=\\\"language-cpp\\\">class Widget {\\npublic:\\n    Widget(int i, bool b);\\n    Widget(int i, double d);\\n    Widget(std::initializer_list&#x3C;long double> il);\\n};\\n\\nWidget w1(10, true);    // будет вызван первый конструктор\\nWidget w2{10, true};    // 3-й\\nWidget w3(10, 5.0);     // 2-й\\nWidget w4{10, 5.0};     // 3-й\\n</code></pre>\\n<p>Причем иногда путь довольно непрост:</p>\\n<pre><code class=\\\"language-cpp\\\">class Widget {\\npublic:\\n  Widget(int i, bool b);\\n  Widget(int i, double d);\\n  Widget(std::initializer_list&#x3C;long double> il);\\n  operator float() const;       // оператор преобразования Widget во float\\n\\n  // конструктор копирования\\n  // конструктор перемещения\\n... };\\nWidget w5(w4);              // вызывается конструктор копирования \\nWidget w6{w4};              // вызывается преобразование к float и затем конструктор с initializer_list, так как float может быть преобразован к long double\\nWidget w7(std::move(w4));   // конструктор перемещения\\nWidget w8{std::move(w4)};   // опять конструктор с initializer_list через преобразование к float\\n</code></pre>\\n<p>Более того, компилятор настолько сильно хочет использовать <code>initializer_list</code>, что даже идеально подходящие другие конструкторы ему не помеха:</p>\\n<pre><code class=\\\"language-cpp\\\">class Widget {\\npublic:\\n  Widget(int i, bool b);\\n  Widget(int i, double d);\\n  Widget(std::initializer_list&#x3C;bool> il);\\n... \\n};\\n\\nWidget w{10, 5.0};  // ошибка компиляции!\\n</code></pre>\\n<p>Компилятор, несмотря на то, что есть конструктор, принимающий <strong>int</strong> и <strong>double</strong>, опять попытался использовать конструктор с <code>initializer_list</code> и не смог, потому что для этого требуется сужающее приведение <strong>int</strong> и <strong>double</strong> к <strong>bool</strong>, а сужающие приведения запрещены в инициализации через <strong>{}</strong>.</p>\\n<p>Однако и из этого правила есть исключение - если есть дефолтный конструктор и мы вызываем инициализацию без параметров, то дефолтный конструктор имеет высший приоритет над конструктором с <code>initializer_list</code>:</p>\\n<pre><code class=\\\"language-cpp\\\"> class Widget {\\npublic:\\n  Widget();\\n  Widget(std::initializer_list&#x3C;int> il);\\n... };\\nWidget w1;      // дефолтный конструктор\\nWidget w2{};    // дефолтный конструктор\\nWidget w3();    // most vexing parse! объявляет функцию\\n\\nWidget w4({});  // только так мы в этом случае можем вызвать конструктор с initializer_list\\nWidget w5{{}};  // ну или так\\n</code></pre>\\n<p>Один из выводов из всего этого - если вы автор библиотеки, то не стоит добавлять конструктор, принимающий <code>initializer_list</code>, так как тогда возможно клиенты не смогут использовать ваши остальные конструкторы.</p>\\n<h2>Используйте nullptr вместо 0 и NULL</h2>\\n<p>В С++98 использование 0 и NULL приводило к тому, что перегрузки, принимающие указатель, могли не вызываться:</p>\\n<pre><code class=\\\"language-cpp\\\">void f(int);\\nvoid f(bool);\\nvoid f(void*);\\n\\nf(0);           // f(int)\\nf(NULL);        // могло не скомпилиться, но если компилилось, то вызывало f(int)\\n</code></pre>\\n<p>Все потому, что 0 - это целочисленный тип и NULL часто был определен тоже как численный тип.</p>\\n<p>Преимущество <strong>nullptr</strong> - он не может быть интерпретирован как численный тип, только как указатель. Тип <strong>nullptr</strong> - <code>std::nullptr_t</code>. ЭТот тип неявно приводит к себе указатели всех типов, поэтому <strong>nullptr</strong> - универсальный указатель.</p>\\n<pre><code class=\\\"language-cpp\\\">f(nullptr);     // f(void*)\\n</code></pre>\\n<h2>Используйте alias вместо typedef</h2>\\n<p>В С++98 были <strong>typedef</strong>:</p>\\n<pre><code class=\\\"language-cpp\\\">typedef\\n     std::unique_ptr&#x3C;std::unordered_map&#x3C;std::string, std::string>>\\n     UPtrMapSS;\\n</code></pre>\\n<p>Они устарели, когда в C++11 появились алиасы:</p>\\n<pre><code class=\\\"language-cpp\\\"> using UPtrMapSS =\\n     std::unique_ptr&#x3C;std::unordered_map&#x3C;std::string, std::string>>;\\n</code></pre>\\n<p>Еще один пример, демонстрирующий повышенную читаемость алиасов по сравнению с тайпдефом:</p>\\n<pre><code class=\\\"language-cpp\\\">typedef void (*FP)(int, const std::string&#x26;);\\n\\nusing FP = void (*)(int, const std::string&#x26;);\\n</code></pre>\\n<p>Основное преимущество - алиасы могут быть шаблонизированы, а тайпдефы - нет. В С++98 приходилось извращаться и определять тайпдефы внутри шаблонизированных структур:</p>\\n<pre><code class=\\\"language-cpp\\\">template&#x3C;typename T>\\nstruct MyAllocList { \\n    typedef std::list&#x3C;T, MyAlloc&#x3C;T>> type;\\n};\\n\\nMyAllocList&#x3C;Widget>::type lw;\\n</code></pre>\\n<p>Если же после этого мы захотим использовать этот шаблно внутри другого шаблонизированного класса, то придется писать <code>typename</code>:</p>\\n<pre><code class=\\\"language-cpp\\\">template&#x3C;typename T>\\nclass Widget {\\nprivate:\\n    typename MyAllocList&#x3C;T>::type list;\\n... };\\n</code></pre>\\n<p>Кстати, при использовании type traits так и приходится писать, так как они были реализованы с использованием тайпдефов, а не алиасов, несмотря на то, что были введены в C++11. В С++14 признали эту ошибку и для каждого класса <code>std::transformation&#x3C;T>::type</code> теперь есть соответствующий <code>std::transformation_t&#x3C;T></code>, реализованный через алиасы.</p>\\n<p>Так вот, в С++11 есть алиасы и использовать их мы можем так:</p>\\n<pre><code class=\\\"language-cpp\\\">template&#x3C;typename T>\\nusing MyAllocList = std::list&#x3C;T, MyAlloc&#x3C;T>>;\\n\\nMyAllocList&#x3C;Widget> lw;\\n</code></pre>\\n<h2>Используйте scoped enums вместо unscoped enums</h2>\\n<p>Есть такое правило, что имя, объявленное внутри фигурных скобок, видно только внутри области, ограниченной этими скобками. Это правило соблюдается всегда, кроме енумов в C++98.</p>\\n<p>Поэтому енумы в C++98 - unscoped enums:</p>\\n<pre><code class=\\\"language-cpp\\\">enum Color {red, black, white};\\n\\nauto white = false;     // ОШИБКА КОМПИЛЯЦИИ! white уже определен\\n</code></pre>\\n<p>В С++11 им на замену пришли scoped enums:</p>\\n<pre><code class=\\\"language-cpp\\\">enum class Color {red, black, white};\\n\\nauto white = false;     // все норм\\nColor c = white;        // ОШИБКА КОМПИЛЯЦИИ! нет имени white в текущем скоупе\\nColor c = Color::white; // ok\\nauto c = Color::white;  // ok\\n</code></pre>\\n<p>Помимо ограниченной видимости, вторая причина, по которой стоит использовать scoped enums - более строгая типизация. Unscoped enums свободно неявно приводятся к целочисленным типам и типам с плавающей точкой:</p>\\n<pre><code class=\\\"language-cpp\\\">Color c = Color::red;\\n\\nif(c &#x3C; 14.5) {  // ОШИБКА КОМПИЛЯЦИИ\\n    ...\\n}\\n\\nif(static_vast&#x3C;double>(c) &#x3C; 14.5) {     // OK\\n    ...\\n}\\n</code></pre>\\n<p>И еще одно преимущество - при использовании scoped enums не нужно перекомпиливать клиентов енума при добавлении в него нового значения. А с unscoped enums - нужно.</p>\\n<p>Дефолтный тип для scoped enums - int, для unscoped enums - нет дефолтного.</p>\\n<h2>Используйте deleted функции вместо private undefined</h2>\\n<p>В С++98 когда нужно запретить вызов какой-либо функции (обычно конструктора присваивания или копирования), то определяют ее как private и просто не пишут ее реализацию:</p>\\n<pre><code class=\\\"language-cpp\\\">template &#x3C;class charT, class traits = char_traits&#x3C;charT> >\\n   class basic_ios : public ios_base {\\n   public:\\n...\\nprivate:\\n     basic_ios(const basic_ios&#x26; );            // not defined\\n     basic_ios&#x26; operator=(const basic_ios&#x26;);  // not defined\\n   };\\n</code></pre>\\n<p><strong>private</strong> гарантирует, что внешний код не имеет доступ к этим функциям. Отсутствие реализации для таких функций гарантирует, что даже если какой-то какой-то код, имеющий к ним доступ, попытается их вызвать, он получит ошибку на этапе линковки.</p>\\n<p>В C++11 такие функции определяются как удаленные:</p>\\n<pre><code class=\\\"language-cpp\\\">template &#x3C;class charT, class traits = char_traits&#x3C;charT> > \\nclass basic_ios : public ios_base {\\npublic:\\n    ...\\n    basic_ios(const basic_ios&#x26; ) = delete; \\n    basic_ios&#x26; operator=(const basic_ios&#x26;) = delete; \\n    ...\\n}\\n</code></pre>\\n<p>Удаленные функции никак не могут быть использованы и такие попытки приведт к ошибкам на этапе компиляции.</p>\\n<p>А еще, используя удаленные функции, можно запредить использование шаблонных функций с определенными типами:</p>\\n<pre><code class=\\\"language-cpp\\\">template&#x3C;typename T>\\nvoid processPointer(T* ptr);\\n\\ntemplate&#x3C;>\\nvoid processPointer&#x3C;void>(void*) = delete;\\ntemplate&#x3C;>\\nvoid processPointer&#x3C;char>(char*) = delete;\\ntemplate&#x3C;>\\nvoid processPointer&#x3C;const void>(const void*) = delete;\\ntemplate&#x3C;>\\nvoid processPointer&#x3C;const char>(const char*) = delete;\\n</code></pre>\",\"frontmatter\":{\"path\":\"/blog/books/effective-modern-cpp\",\"title\":\"Effective Modern C++\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---blog-books-effective-modern-cpp-3259b4289ff9c9d022b9.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>Effective Modern C++</h1>\\n<h2>Вывод типов через auto</h2>\\n<p>Тип для <code>auto</code> выводится так же, как и для шаблонов. В том выводе типов у нас есть определение шаблона и его вызов:</p>\\n<pre><code class=\\\"language-cpp\\\">template&#x3C;typename T>\\nvoid f(ParamType param);\\n\\nf(expr);\\n</code></pre>\\n<p>Когда переменная объявляется через <code>auto</code>, то <code>auto</code> выступает в роли <strong>T</strong>, а спецификатор типа - как <code>ParamType</code>. Например:</p>\\n<pre><code class=\\\"language-cpp\\\">auto x = 27;            // auto -> T, auto -> ParamType\\nconst auto cx = x;      // auto -> T, const auto -> ParamType\\nconst auto&#x26; rx = x;     // auto -> T, const auto&#x26; -> ParamType\\n</code></pre>\\n<p>Для вывода представим соответствующие им шаблоны и их вызовы:</p>\\n<pre><code class=\\\"language-cpp\\\">template&#x3C;typename T>\\nvoid func_x(T param);\\n\\nfunc_x(27);     // ParamTYpe -> int, T -> int\\n\\ntemplate&#x3C;typename T>\\nvoid func_cx(const T param);\\n\\nfunc_cx(x);     // ParamType -> const int, T -> int\\n\\ntemplate&#x3C;typename T>\\nvoid func_rx(const T&#x26; param);\\n\\nfunc_rx(x);     // ParamType -> const int&#x26;, T -> int\\n</code></pre>\\n<p>Во всех остальных случаях логика точно такая же как и для вывода типа шаблона. Но есть одно исключение, о нем дальше.</p>\\n<h3>Особый случай для initializer_list</h3>\\n<pre><code class=\\\"language-cpp\\\">auto x1 = 27;       // int\\nauto x2(27);        // int\\nauto x3 = {27};     // std::initializer_list&#x3C;int> = {27}\\nauto x4{27};        // std::initializer_list&#x3C;int> = {27}\\n</code></pre>\\n<p>Так происходит потому что в выводе типов через <code>auto</code> прописано особое правило: <strong>если значение для авто-объявленной переменной заключено в фигурные скобки, то тип ВСЕГДА выводится как std::initializer_list</strong>.</p>\\n<p>При этом в выводе типов для шаблонов такого правила нет и это единственное место где алгоритмы различаются:</p>\\n<pre><code class=\\\"language-cpp\\\">template&#x3C;typename T>\\nvoid f(T param);\\n\\nf({ 11, 23, 9 }); // ОШИБКА КОМПИЛЯЦИИ!\\n\\ntemplate&#x3C;typename T>\\nvoid f2(std::initializer_list&#x3C;T> list);\\n\\nfw({11,23,9});      // все ок, тип T выводится как int\\n</code></pre>\\n<h2>decltype</h2>\\n<p><strong>decltype</strong> - это функция, которая принимает переменную, а возвращает ее тип. Может быть использована там, где ожидается указание типа.</p>\\n<pre><code class=\\\"language-cpp\\\">const int i = 0;            // decltype(i) -> const int\\nbool f(const Widget&#x26;);      // decltype(w) -> const Widget&#x26;, decltype(f) -> bool(const Widget&#x26;)\\n</code></pre>\\n<p>Обычно используется там, где тип возвращаемого значения зависит от типа аргумента:</p>\\n<pre><code class=\\\"language-cpp\\\">template&#x3C;typename Container, typename Index>\\nauto authAndAccess(Container&#x26; c, Index i) -> decltype(c[i]) {\\n    authenticateser();\\n    return c[i];\\n}\\n</code></pre>\\n<p>здесь <code>auto</code> не имеет отношения к выводу типов, а лишь указывает, что возвращаемый тип будет указан после списка параметров (trailing return type syntax). Такой синтаксис необходимо использовать, когда тип возвращаемого значения зависит от типов параметров.</p>\\n<p>В C++14 можно возвращать из функций <code>auto</code>, не указывая тип после стрелочки, но с этим бывают проблемы, поэтому рекомендуется возвращать <code>decltype(auto)</code>.</p>\\n<p>С <code>authAndAccess</code> осталась одна проблема - она не сможет принимать rvalue для контейнера. Модифицируем так, чтобы мог:</p>\\n<pre><code class=\\\"language-cpp\\\">template&#x3C;typename Container, typename Index>\\nauto get(Container&#x26;&#x26; c, Index i) -> decltype(std::forward&#x3C;Container>(c)[i]) {\\n  authenticateUser();\\n  return std::forward&#x3C;Container>(c)[i];\\n}\\n</code></pre>\\n<p>Теперь для <strong>c</strong> типа lvalue функция будет возвращать lvalue, а для rvalue - rvalue.</p>\\n<h3>Особенность поведения decltype</h3>\\n<p>Применение <strong>decltype</strong> к имени переменной возвращает тип этого имени. Однако применение к lvalue, котороя является чем-то более сложным, чем имя, возвращает ссылку на lvalue. То есть <strong>decltype</strong> над выражением не-именем, имеющим тип <strong>T</strong> вернет тип <strong>T&#x26;</strong>. Такое поведение редко на что-либо влияет, однако есть интересное следствие:</p>\\n<pre><code class=\\\"language-cpp\\\">int x = 0;\\ndecltype(x);    // int\\ndecltype((x));  // int&#x26;\\n</code></pre>\\n<p>Как видно, оборачивание значения в скобки может поменять значение, возвращаемое <strong>decltype</strong>. Это особенно важно в C++14, где можно возвращать из функции <code>decltype(auto)</code> и случайно можно вернуть ссылку на элемент вместо элемента.</p>\\n<h2>Используйте auto вместо явных определений типов</h2>\\n<h3>auto не даст создать неинициализированный объект</h3>\\n<pre><code class=\\\"language-cpp\\\">int x;  // не инициализирован!\\n\\nauto x; // не скомпилится!\\n</code></pre>\\n<h3>Позволяет не писать сложные типы</h3>\\n<pre><code class=\\\"language-cpp\\\">template&#x3C;typename It>\\nvoid dwim(It b, It e)\\n{\\n  while (b != e) {\\n    typename std::iterator_traits&#x3C;It>::value_type currValue = *b;\\n    auto currValue2 = *b;\\n    ...\\n  }\\n}\\n</code></pre>\\n<h3>Экономить память при использовании функторов</h3>\\n<p>Тип лямбды неизвестен до компиляции, поэтому описать его точно - невозможно. Приходится использовать тип <code>std::function</code>. </p>\\n<pre><code class=\\\"language-cpp\\\">std::function&#x3C;bool(const std::unique_ptr&#x3C;Widget>&#x26;, const std::unique_ptr&#x3C;Widget>&#x26;)>\\n    funcs = [](const std::unique_ptr&#x3C;Widget>&#x26; a, const std::unique_ptr&#x3C;Widget>&#x26; b) {\\n        return *a &#x3C; *b;\\n    }\\n</code></pre>\\n<p>Но у него есть недостаток - он всегда занимает фиксированный размер в памяти, и если его не хватает, то аллоцирует память в куче. Тогда как реальный тип замыкания, выводимый во время компиляции и используемый с помощью <strong>auto</strong> всегда занимает ровно столько места, сколько ему требуется.</p>\\n<p>Плюс к этому, из-за особенностей реализации, при вызове функции через <code>std::function</code> запрещается инлайнинг и добавляется непрямой вызов функции (indirect function calls), что ухудшает производительность по сравнению с <strong>auto</strong>.</p>\\n<h3>Неявные приведения типов</h3>\\n<p>Допустим, есть такой код:</p>\\n<pre><code class=\\\"language-cpp\\\">std::vector&#x3C;int> v;\\nunsigned sz = v.size();\\n</code></pre>\\n<p>Все бы ничего, да только <code>v.size()</code> возвращает вовсе не <strong>unsigned</strong>, а <code>std::vector&#x3C;int>::size_type</code>.</p>\\n<p>Другой пример:</p>\\n<pre><code class=\\\"language-cpp\\\">std::unordered_map&#x3C;std::string, int> m;\\n\\nfor(const std::pair&#x3C;std::string, int>&#x26; p: m) {\\n    ...\\n}\\n</code></pre>\\n<p>Реальный тип элементов, содержащихся в <code>unordered_map</code> - <code>std::pair&#x3C;const std::string, int></code>. В результате компилятор не сможет привести <code>std::pair&#x3C;const std::string, int></code> к <code>std::pair&#x3C;std::string, int></code> и будет для каждого члена создавать временный объект, ссылку на который копировать в <strong>p</strong>. После каждой итерации временный объект будет уничтожен.</p>\\n<p>Использование <strong>auto</strong> в этом случае делает код проще и производительнее:</p>\\n<pre><code class=\\\"language-cpp\\\">std::unordered_map&#x3C;std::string, int> m;\\n\\nfor(const auto&#x26; p: m) {...}\\n</code></pre>\\n<h2>Иногда auto выводит не то, что нужно</h2>\\n<pre><code class=\\\"language-cpp\\\">std::vector&#x3C;bool> features(const Widget&#x26; w);\\n\\nWidget w;\\nauto highPriority = features(w)[5];\\nprocessWidget(w, highPriority);\\n</code></pre>\\n<p>Как ни удивительно, этот код приводит к undefined behavior. Дело в том, что оператор <code>[]</code> для <code>std::vector&#x3C;bool></code> возвращает <code>std::vector&#x3C;bool>::reference</code>. Так происходит потому, что булевого типа у вектора есть специальная реализация, которая хранит по одному биту на элемент. Теперь оператор <code>[]</code> должен возвращать ссылку на бит, но в C++ запрещены ссылки на биты. Поэтому приходится возвращать тип, который <em>ведет себя</em> как <code>bool&#x26;</code>. ЭТо означает, что он, помимо прочего, должен быть неявно приводим к <code>bool</code>. </p>\\n<p>Получается, что когда мы делаем <code>bool highPriority = features(w)[5]</code>, то возвращается <code>std::vector&#x3C;bool>::reference</code>, который приводится к <code>bool</code> и дальше все нормально.</p>\\n<p>А вот когда мы делаем <code>auto highPriority = features(w)[5]</code>, то дальше все зависит от реализации типа <code>std::vector&#x3C;bool>::reference</code>. Одна из реализаций представляет из себя:</p>\\n<ul>\\n<li>указатель на машинное слово вектора, в котором содержится интересующий бит</li>\\n<li>сдвиг в этом слове</li>\\n</ul>\\n<p>Итак, вызов <code>features</code> возвращает временный объект-вектор. Оператор <code>[]</code> возвращает <code>std::vector&#x3C;bool>::reference</code>, в котором содержится ссылка на элемент внутри временного объекта-вектора. Мы записываем это в <code>highPriority</code>, после чего временный объект уничтожается, а в <code>highPriority</code> остается висячая ссылка на уничтоженный объект.</p>\\n<p>Здесь <code>std::vector&#x3C;bool>::reference</code> - это прокси-класс, который не предназначен для того, чтобы жить дольше, чем одно выражение. Поэтому <strong>auto</strong> очень плохо дружит с прокси-классами.</p>\\n<p>Такие прокси-классы очень тяжело найти заранее, однако когда стало понятно, что проблема в прокси-классе, не стоит избавляться от <strong>auto</strong>. Лучший способ - использовать явное приведение типа:</p>\\n<pre><code class=\\\"language-cpp\\\">auto highPriority = static_cast&#x3C;bool>(features(w)[5]);\\n</code></pre>\\n<h2>Различия между () и {} при инициализации объектов</h2>\\n<p>Для начало важно отличать инициализацию от присвоения:</p>\\n<pre><code class=\\\"language-cpp\\\">Widget w1;          // инициализация, вызван дефолтный конструктор\\nWidget w2 = w1;     // инициализация, вызывается конструктор копирования\\nw1 = w2;            // присвоение, вызывается оператор =\\n</code></pre>\\n<p>В C++ 11 представлена <em>uniform initialization</em> - предпочтительный способ инициализации:</p>\\n<pre><code class=\\\"language-cpp\\\">int x{0};\\nstd::vector&#x3C;int> v{1,2,3,4,5};\\n</code></pre>\\n<p>Тот же синтаксис можно использовать и для задания дефолтных значений не-статическим полям классов, наравне с синтаксисом через <strong>=</strong>:</p>\\n<pre><code class=\\\"language-cpp\\\">class Widget {\\nprivate:\\n    int x{0};   // ОК\\n    int y = 0;  // тоже ок\\n    int z(0);   // ошибка компиляции!\\n}\\n</code></pre>\\n<p>Однако если инициализируем не-копируемый тип, то <strong>{}</strong> валиден наравне с синтаксисом через <strong>()</strong>:</p>\\n<pre><code class=\\\"language-cpp\\\">std::atomic&#x3C;int>ai1{0};     // OK\\nstd::atomic&#x3C;int>ai2(0);     // OK\\nstd::atomic&#x3C;int>ai3 = 0;    // ошибка!\\n</code></pre>\\n<p>Поэтому, чтобы не путаться, лучше всегда использовать универсальную (uniform) инициализацию вида <code>int x{0};</code>.</p>\\n<h3>{} запрещает преобразование типа с потерей точности</h3>\\n<pre><code class=\\\"language-cpp\\\">double x,y,z;\\nint sum1{ x+y+z };      // не скомпилится, так как сумма даблов может быть невыразима через int\\nint sum2( x+y+z );      // спокойно компилится и приводит к неожиданному поведению при выполнении\\nint sum3 = x + y + z;   // аналогично sum2\\n</code></pre>\\n<h3>{} не подвержена most vexing parse</h3>\\n<p>В С++ есть такое правило - все, что может быть интерпретировано как объявелние, должно быть интерпретировано как объявление.</p>\\n<p>Поэтому часто, когда хотим инициализировать переменную дефолтным конструктором через скобки, вместо этого получается объявление функции:</p>\\n<pre><code class=\\\"language-cpp\\\">Widget w1(10);  // когда у конструктора есть параметры, то все норм\\nWidget w2();    // а вот когда хотис использовать дефолтный конструктор, то получается объявление функции\\n</code></pre>\\n<p>С использованием <strong>{}</strong> код выглядит так и не содержит этой проблемы:</p>\\n<pre><code class=\\\"language-cpp\\\">Widget w3{};\\n</code></pre>\\n<h3>Недостаток: опять проблемы с initializer_list</h3>\\n<p>Если при инициализации через <strong>{}</strong> имеется конструктор, принимающий <code>initializer_list</code>, и он может быть теоретически использован, то будет использован именно он:</p>\\n<pre><code class=\\\"language-cpp\\\">class Widget {\\npublic:\\n    Widget(int i, bool b);\\n    Widget(int i, double d);\\n    Widget(std::initializer_list&#x3C;long double> il);\\n};\\n\\nWidget w1(10, true);    // будет вызван первый конструктор\\nWidget w2{10, true};    // 3-й\\nWidget w3(10, 5.0);     // 2-й\\nWidget w4{10, 5.0};     // 3-й\\n</code></pre>\\n<p>Причем иногда путь довольно непрост:</p>\\n<pre><code class=\\\"language-cpp\\\">class Widget {\\npublic:\\n  Widget(int i, bool b);\\n  Widget(int i, double d);\\n  Widget(std::initializer_list&#x3C;long double> il);\\n  operator float() const;       // оператор преобразования Widget во float\\n\\n  // конструктор копирования\\n  // конструктор перемещения\\n... };\\nWidget w5(w4);              // вызывается конструктор копирования \\nWidget w6{w4};              // вызывается преобразование к float и затем конструктор с initializer_list, так как float может быть преобразован к long double\\nWidget w7(std::move(w4));   // конструктор перемещения\\nWidget w8{std::move(w4)};   // опять конструктор с initializer_list через преобразование к float\\n</code></pre>\\n<p>Более того, компилятор настолько сильно хочет использовать <code>initializer_list</code>, что даже идеально подходящие другие конструкторы ему не помеха:</p>\\n<pre><code class=\\\"language-cpp\\\">class Widget {\\npublic:\\n  Widget(int i, bool b);\\n  Widget(int i, double d);\\n  Widget(std::initializer_list&#x3C;bool> il);\\n... \\n};\\n\\nWidget w{10, 5.0};  // ошибка компиляции!\\n</code></pre>\\n<p>Компилятор, несмотря на то, что есть конструктор, принимающий <strong>int</strong> и <strong>double</strong>, опять попытался использовать конструктор с <code>initializer_list</code> и не смог, потому что для этого требуется сужающее приведение <strong>int</strong> и <strong>double</strong> к <strong>bool</strong>, а сужающие приведения запрещены в инициализации через <strong>{}</strong>.</p>\\n<p>Однако и из этого правила есть исключение - если есть дефолтный конструктор и мы вызываем инициализацию без параметров, то дефолтный конструктор имеет высший приоритет над конструктором с <code>initializer_list</code>:</p>\\n<pre><code class=\\\"language-cpp\\\"> class Widget {\\npublic:\\n  Widget();\\n  Widget(std::initializer_list&#x3C;int> il);\\n... };\\nWidget w1;      // дефолтный конструктор\\nWidget w2{};    // дефолтный конструктор\\nWidget w3();    // most vexing parse! объявляет функцию\\n\\nWidget w4({});  // только так мы в этом случае можем вызвать конструктор с initializer_list\\nWidget w5{{}};  // ну или так\\n</code></pre>\\n<p>Один из выводов из всего этого - если вы автор библиотеки, то не стоит добавлять конструктор, принимающий <code>initializer_list</code>, так как тогда возможно клиенты не смогут использовать ваши остальные конструкторы.</p>\\n<h2>Используйте nullptr вместо 0 и NULL</h2>\\n<p>В С++98 использование 0 и NULL приводило к тому, что перегрузки, принимающие указатель, могли не вызываться:</p>\\n<pre><code class=\\\"language-cpp\\\">void f(int);\\nvoid f(bool);\\nvoid f(void*);\\n\\nf(0);           // f(int)\\nf(NULL);        // могло не скомпилиться, но если компилилось, то вызывало f(int)\\n</code></pre>\\n<p>Все потому, что 0 - это целочисленный тип и NULL часто был определен тоже как численный тип.</p>\\n<p>Преимущество <strong>nullptr</strong> - он не может быть интерпретирован как численный тип, только как указатель. Тип <strong>nullptr</strong> - <code>std::nullptr_t</code>. ЭТот тип неявно приводит к себе указатели всех типов, поэтому <strong>nullptr</strong> - универсальный указатель.</p>\\n<pre><code class=\\\"language-cpp\\\">f(nullptr);     // f(void*)\\n</code></pre>\\n<h2>Используйте alias вместо typedef</h2>\\n<p>В С++98 были <strong>typedef</strong>:</p>\\n<pre><code class=\\\"language-cpp\\\">typedef\\n     std::unique_ptr&#x3C;std::unordered_map&#x3C;std::string, std::string>>\\n     UPtrMapSS;\\n</code></pre>\\n<p>Они устарели, когда в C++11 появились алиасы:</p>\\n<pre><code class=\\\"language-cpp\\\"> using UPtrMapSS =\\n     std::unique_ptr&#x3C;std::unordered_map&#x3C;std::string, std::string>>;\\n</code></pre>\\n<p>Еще один пример, демонстрирующий повышенную читаемость алиасов по сравнению с тайпдефом:</p>\\n<pre><code class=\\\"language-cpp\\\">typedef void (*FP)(int, const std::string&#x26;);\\n\\nusing FP = void (*)(int, const std::string&#x26;);\\n</code></pre>\\n<p>Основное преимущество - алиасы могут быть шаблонизированы, а тайпдефы - нет. В С++98 приходилось извращаться и определять тайпдефы внутри шаблонизированных структур:</p>\\n<pre><code class=\\\"language-cpp\\\">template&#x3C;typename T>\\nstruct MyAllocList { \\n    typedef std::list&#x3C;T, MyAlloc&#x3C;T>> type;\\n};\\n\\nMyAllocList&#x3C;Widget>::type lw;\\n</code></pre>\\n<p>Если же после этого мы захотим использовать этот шаблно внутри другого шаблонизированного класса, то придется писать <code>typename</code>:</p>\\n<pre><code class=\\\"language-cpp\\\">template&#x3C;typename T>\\nclass Widget {\\nprivate:\\n    typename MyAllocList&#x3C;T>::type list;\\n... };\\n</code></pre>\\n<p>Кстати, при использовании type traits так и приходится писать, так как они были реализованы с использованием тайпдефов, а не алиасов, несмотря на то, что были введены в C++11. В С++14 признали эту ошибку и для каждого класса <code>std::transformation&#x3C;T>::type</code> теперь есть соответствующий <code>std::transformation_t&#x3C;T></code>, реализованный через алиасы.</p>\\n<p>Так вот, в С++11 есть алиасы и использовать их мы можем так:</p>\\n<pre><code class=\\\"language-cpp\\\">template&#x3C;typename T>\\nusing MyAllocList = std::list&#x3C;T, MyAlloc&#x3C;T>>;\\n\\nMyAllocList&#x3C;Widget> lw;\\n</code></pre>\\n<h2>Используйте scoped enums вместо unscoped enums</h2>\\n<p>Есть такое правило, что имя, объявленное внутри фигурных скобок, видно только внутри области, ограниченной этими скобками. Это правило соблюдается всегда, кроме енумов в C++98.</p>\\n<p>Поэтому енумы в C++98 - unscoped enums:</p>\\n<pre><code class=\\\"language-cpp\\\">enum Color {red, black, white};\\n\\nauto white = false;     // ОШИБКА КОМПИЛЯЦИИ! white уже определен\\n</code></pre>\\n<p>В С++11 им на замену пришли scoped enums:</p>\\n<pre><code class=\\\"language-cpp\\\">enum class Color {red, black, white};\\n\\nauto white = false;     // все норм\\nColor c = white;        // ОШИБКА КОМПИЛЯЦИИ! нет имени white в текущем скоупе\\nColor c = Color::white; // ok\\nauto c = Color::white;  // ok\\n</code></pre>\\n<p>Помимо ограниченной видимости, вторая причина, по которой стоит использовать scoped enums - более строгая типизация. Unscoped enums свободно неявно приводятся к целочисленным типам и типам с плавающей точкой:</p>\\n<pre><code class=\\\"language-cpp\\\">Color c = Color::red;\\n\\nif(c &#x3C; 14.5) {  // ОШИБКА КОМПИЛЯЦИИ\\n    ...\\n}\\n\\nif(static_vast&#x3C;double>(c) &#x3C; 14.5) {     // OK\\n    ...\\n}\\n</code></pre>\\n<p>И еще одно преимущество - при использовании scoped enums не нужно перекомпиливать клиентов енума при добавлении в него нового значения. А с unscoped enums - нужно.</p>\\n<p>Дефолтный тип для scoped enums - int, для unscoped enums - нет дефолтного.</p>\\n<h2>Используйте deleted функции вместо private undefined</h2>\\n<p>В С++98 когда нужно запретить вызов какой-либо функции (обычно конструктора присваивания или копирования), то определяют ее как private и просто не пишут ее реализацию:</p>\\n<pre><code class=\\\"language-cpp\\\">template &#x3C;class charT, class traits = char_traits&#x3C;charT> >\\n   class basic_ios : public ios_base {\\n   public:\\n...\\nprivate:\\n     basic_ios(const basic_ios&#x26; );            // not defined\\n     basic_ios&#x26; operator=(const basic_ios&#x26;);  // not defined\\n   };\\n</code></pre>\\n<p><strong>private</strong> гарантирует, что внешний код не имеет доступ к этим функциям. Отсутствие реализации для таких функций гарантирует, что даже если какой-то какой-то код, имеющий к ним доступ, попытается их вызвать, он получит ошибку на этапе линковки.</p>\\n<p>В C++11 такие функции определяются как удаленные:</p>\\n<pre><code class=\\\"language-cpp\\\">template &#x3C;class charT, class traits = char_traits&#x3C;charT> > \\nclass basic_ios : public ios_base {\\npublic:\\n    ...\\n    basic_ios(const basic_ios&#x26; ) = delete; \\n    basic_ios&#x26; operator=(const basic_ios&#x26;) = delete; \\n    ...\\n}\\n</code></pre>\\n<p>Удаленные функции никак не могут быть использованы и такие попытки приведт к ошибкам на этапе компиляции.</p>\\n<p>А еще, используя удаленные функции, можно запредить использование шаблонных функций с определенными типами:</p>\\n<pre><code class=\\\"language-cpp\\\">template&#x3C;typename T>\\nvoid processPointer(T* ptr);\\n\\ntemplate&#x3C;>\\nvoid processPointer&#x3C;void>(void*) = delete;\\ntemplate&#x3C;>\\nvoid processPointer&#x3C;char>(char*) = delete;\\ntemplate&#x3C;>\\nvoid processPointer&#x3C;const void>(const void*) = delete;\\ntemplate&#x3C;>\\nvoid processPointer&#x3C;const char>(const char*) = delete;\\n</code></pre>\",\"frontmatter\":{\"path\":\"/blog/books/effective-modern-cpp\",\"title\":\"Effective Modern C++\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/blog-books-effective-modern-cpp.json\n// module id = 423\n// module chunks = 104734089325636"],"sourceRoot":""}