webpackJsonp([0xe3124748ad1d],{428:function(e,n){e.exports={data:{markdownRemark:{html:'<h1>CSS</h1>\n<h2>Базовый дизайн страницы</h2>\n<p>По мотивам <a href="https://jgthms.com/web-design-in-4-minutes/#font-family">https://jgthms.com/web-design-in-4-minutes/#font-family</a></p>\n<pre><code class="language-css">body {\n  margin: 0 auto;\n  max-width: 50em;\n  font-family: "Helvetica", "Arial", sans-serif;\n  line-height: 1.5;\n  padding: 4em 1em;\n  color: #555;\n}\n\nh2 {\n  margin-top: 1em;\n  padding-top: 1em;\n}\n\nh1,\nh2,\nstrong {\n  color: #333;\n}\n\ncode,\npre {\n  background: #eee;\n}\n\ncode {\n  padding: 2px 4px;\n  vertical-align: text-bottom;\n}\n\npre {\n  padding: 1em;\n}\n</code></pre>\n<h2>display</h2>\n<h3>block</h3>\n<p>Блочные элементы</p>\n<p>Начинаются с новой строки и занимают всю доступную ширину.</p>\n<p>К блочным элементам относятся: <code>div</code>, <code>p</code>, <code>form</code>, <code>li</code>, <code>header</code>, <code>footer</code>, <code>section</code> и другие.</p>\n<h3>inline</h3>\n<p>Строчные элементы</p>\n<p>Вставляются в абзац, не нарушая его структуры. К строчным относятся <code>span</code>, <code>a</code>.</p>\n<h3>none</h3>\n<p>Элемент не показывается, как будто бы не существует (в случае <code>visibility:hidden</code> элемент продолжает занимать место, просто становится невидим).</p>\n<h2>margin:auto</h2>\n<p>При установке блочному элементу левого и правого марджина в <code>auto</code> он автоматически центруется по горизонтали.</p>\n<h2>max-width</h2>\n<p>Если установить блоку абсолютный <code>width</code>, то при уменьшении размера браузера появится горизонтальный скролл. Поэтому лучше указывать <code>max-width</code>, тогда блок будет стремиться занять указанную ширину, но сжиматься, если не умещается.</p>\n<h2>box model</h2>\n<p>Размеры <code>padding</code> и <code>border</code> выходят за пределы указанных размеров <code>width</code> и <code>height</code>. То есть если указано:</p>\n<pre><code class="language-css">width: 50px;\nborder: 1px solid;\npadding: 5px;\n</code></pre>\n<p>То реальная ширина элемента будет 57 пикселей (50+1+1+5)</p>\n<p>Чтобы этого не происходило, можно указать:</p>\n<pre><code class="language-css">box-sizing:border-box;\n</code></pre>\n<p>Тогда у элемента будет ширина ровно 50 пикселей.</p>\n<h2>position</h2>\n<h3>static</h3>\n<p>Значение по умолчанию.</p>\n<h3>relative</h3>\n<p>Ведет себя как <code>static</code>, пока не будут добавлены <code>top</code>, <code>right</code>, <code>bottom</code> или <code>left</code>. Они позволяют сдвигать положение элемента относительно его изначального расположения. При этом все элементы вокруг двигаться не будут и будут располагаться так, как будто все эти свойства равны нулю.</p>\n<p>Помимо этого, <code>position:relative</code> позволяет использовать <code>z-index</code>. <strong>Без <code>position:relative</code> <code>z-index</code> работать не будет!</strong></p>\n<h2>fixed</h2>\n<p>Занимает фиксированное положение на экране. Можно задать расположеное элементами <code>top</code>, <code>right</code>, <code>bottom</code> или <code>left</code>.</p>\n<h2>absolute</h2>\n<p>Ведет себя как <code>fixed</code> за исключением того, что позиционирование отсчитывается относительно <em>ближайшего родителя с position != static</em>. Если такого родителя нет, то считается относительно окна браузера.</p>\n<p>Помимо этого, элемент "исключается" из нормальной структуры документа, то есть остальные элементы будут вести себя так, как будто его нет на странице!</p>\n<h2>float</h2>\n<p>Предназначен для обертывания текста вокруг изображений. При его использовании получается следующее:</p>\n<ul>\n<li>нижеследующие элементы без <code>float</code> позиционируются, как будто элемента с <code>float</code> не существует.</li>\n<li>однако текст в них "обтекает" элемент с <code>float</code>.</li>\n<li>при этом обтекание текста происходит так, будто элементы, содержащие текст, никуда не позиционировались! </li>\n<li>каждый нижеследующий элемент с <code>float</code> обтекает предыдущий</li>\n</ul>\n<p>Чтобы действие элемента с <code>float</code> прекратилось, нужно указать свойство <code>clear:[left|right|both]</code> тому элементу, начиная с которого обтекать больше не нужно. </p>\n<h2>media queries</h2>\n<pre><code class="language-css">@media screen and (min-width:600px) {\n    ...\n}\n\n@media screen and (max-width:599px) {\n    ...\n}\n</code></pre>\n<p>Список таргетов для медиа-запросов: <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media#Media_features">https://developer.mozilla.org/en-US/docs/Web/CSS/@media#Media_features</a></p>\n<h2>inline-block</h2>\n<p>Похожи на <code>inline</code> элементы, но имеют ширину и высоту.</p>\n<h1>Странности</h1>\n<h2>Collapsing margins</h2>\n<p>Если есть несколько граничащих марджинов (т.е. между ними нет никакого контента, паддинга, бордера или зазора) двух или более элементов (как соседних так и вложенных), то они объединяются, чтобы образовать единый марджин, размер которого будет равер размеру максимального из объединенных.</p>\n<p>Иными словами, если вертикальные марджины двух элементов соприкасаются, то оставляется только тот марджин, который больше, а другой будет "схлопнут". Если у одного из элементов марджин отрицательный, то правило не работает и марджины будут суммированы. Если оба отрицательны, то используется наибольший.</p>\n<p>В следующих случаях правило не работает:</p>\n<ul>\n<li>"плавающие" (floated) элементы</li>\n<li>абсолютно позиционированные элементы</li>\n<li>элементы <code>inline-block</code></li>\n<li>элементы со значением <code>overflow</code>, любым кроме <code>visible</code></li>\n<li>"очищенные" элементы</li>\n<li>корневой элемент</li>\n</ul>\n<p>Здесь есть примеры: <a href="https://www.sitepoint.com/collapsing-margins/">https://www.sitepoint.com/collapsing-margins/</a></p>\n<h2>Height</h2>\n<p>Иногда бывает так, что применяешь на элементе <code>height</code> в процентах, а он игнорится. Тут нужно понимать несколько вещей про поведение этого атрибута:</p>\n<ul>\n<li>если у родительского элемента не указана высота, то у дочернего атрибут <code>height</code> игнорируется!</li>\n<li>значение в процентах означает, сколько процентов от высоты родительского элемента будет занимать этот</li>\n<li>значение вычисляется от <strong>реальной</strong> высоты родительского контейнера</li>\n</ul>\n<h1>Hints</h1>\n<h2>Спрятать скролл-бар</h2>\n<pre><code class="language-css">#parent{\n    height: 100%;\n    width: 100%;\n    overflow: hidden;\n}\n\n#child{\n    width: 100%;\n    height: 100%;\n    overflow-y: scroll;\n    padding-right: 17px; /* Increase/decrease this value for cross-browser compatibility */\n    box-sizing: content-box; /* So the width will be 100% + 17px */\n}\n</code></pre>\n<p><a href="http://jsfiddle.net/5GCsJ/20882/">http://jsfiddle.net/5GCsJ/20882/</a></p>\n<h2>Диву-потомку задать ту же ширину/высоту, что и у дива-родителя</h2>\n<pre><code class="language-css">#child {\n  width: 100%;\n  height: 100%;\n}\n</code></pre>\n<h2>Див, занимающий всю доступную высоту, в котором все элементы растягиваются, а нижний имеет фиксированную высоту</h2>\n<p>Мы снизу у контейнера сделаем марджин, в котором и будет находиться наш элемент с фиксированной высотой. То есть он будет как бы за пределами контейнера, но при этом не будет мешать соседним элементам, так как целиком находится в марджине.</p>\n<pre><code class="language-html">&#x3C;div class="container">\n  &#x3C;div class="panel1"/>\n  &#x3C;div class="panel2"/>\n  &#x3C;div class="footer"/>\n&#x3C;/div>\n</code></pre>\n<pre><code class="language-css">.container {\n  height: 100%;\n  padding-bottom: 60px; // высота футера\n}\n\n.panel1 {\n  height: 60%;\n}\n\n.panel2 {\n  height: 40%;\n}\n\n.footer {\n  height: 60px;\n}\n</code></pre>',frontmatter:{path:"/blog/css",title:"CSS"}}},pathContext:{}}}});
//# sourceMappingURL=path---blog-css-293623988a319b100ba5.js.map