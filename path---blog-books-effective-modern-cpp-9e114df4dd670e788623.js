webpackJsonp([0x5f414e30ac44],{423:function(e,n){e.exports={data:{markdownRemark:{html:'<h1>Effective Modern C++</h1>\n<h2>Вывод типов через auto</h2>\n<p>Тип для <code>auto</code> выводится так же, как и для шаблонов. В том выводе типов у нас есть определение шаблона и его вызов:</p>\n<pre><code class="language-cpp">template&#x3C;typename T>\nvoid f(ParamType param);\n\nf(expr);\n</code></pre>\n<p>Когда переменная объявляется через <code>auto</code>, то <code>auto</code> выступает в роли <strong>T</strong>, а спецификатор типа - как <code>ParamType</code>. Например:</p>\n<pre><code class="language-cpp">auto x = 27;            // auto -> T, auto -> ParamType\nconst auto cx = x;      // auto -> T, const auto -> ParamType\nconst auto&#x26; rx = x;     // auto -> T, const auto&#x26; -> ParamType\n</code></pre>\n<p>Для вывода представим соответствующие им шаблоны и их вызовы:</p>\n<pre><code class="language-cpp">template&#x3C;typename T>\nvoid func_x(T param);\n\nfunc_x(27);     // ParamTYpe -> int, T -> int\n\ntemplate&#x3C;typename T>\nvoid func_cx(const T param);\n\nfunc_cx(x);     // ParamType -> const int, T -> int\n\ntemplate&#x3C;typename T>\nvoid func_rx(const T&#x26; param);\n\nfunc_rx(x);     // ParamType -> const int&#x26;, T -> int\n</code></pre>\n<p>Во всех остальных случаях логика точно такая же как и для вывода типа шаблона. Но есть одно исключение, о нем дальше.</p>\n<h3>Особый случай для initializer_list</h3>\n<pre><code class="language-cpp">auto x1 = 27;       // int\nauto x2(27);        // int\nauto x3 = {27};     // std::initializer_list&#x3C;int> = {27}\nauto x4{27};        // std::initializer_list&#x3C;int> = {27}\n</code></pre>\n<p>Так происходит потому что в выводе типов через <code>auto</code> прописано особое правило: <strong>если значение для авто-объявленной переменной заключено в фигурные скобки, то тип ВСЕГДА выводится как std::initializer_list</strong>.</p>\n<p>При этом в выводе типов для шаблонов такого правила нет и это единственное место где алгоритмы различаются:</p>\n<pre><code class="language-cpp">template&#x3C;typename T>\nvoid f(T param);\n\nf({ 11, 23, 9 }); // ОШИБКА КОМПИЛЯЦИИ!\n\ntemplate&#x3C;typename T>\nvoid f2(std::initializer_list&#x3C;T> list);\n\nfw({11,23,9});      // все ок, тип T выводится как int\n</code></pre>\n<h2>decltype</h2>\n<p><strong>decltype</strong> - это функция, которая принимает переменную, а возвращает ее тип. Может быть использована там, где ожидается указание типа.</p>\n<pre><code class="language-cpp">const int i = 0;            // decltype(i) -> const int\nbool f(const Widget&#x26;);      // decltype(w) -> const Widget&#x26;, decltype(f) -> bool(const Widget&#x26;)\n</code></pre>\n<p>Обычно используется там, где тип возвращаемого значения зависит от типа аргумента:</p>\n<pre><code class="language-cpp">template&#x3C;typename Container, typename Index>\nauto authAndAccess(Container&#x26; c, Index i) -> decltype(c[i]) {\n    authenticateser();\n    return c[i];\n}\n</code></pre>\n<p>здесь <code>auto</code> не имеет отношения к выводу типов, а лишь указывает, что возвращаемый тип будет указан после списка параметров (trailing return type syntax). Такой синтаксис необходимо использовать, когда тип возвращаемого значения зависит от типов параметров.</p>\n<p>В C++14 можно возвращать из функций <code>auto</code>, не указывая тип после стрелочки, но с этим бывают проблемы, поэтому рекомендуется возвращать <code>decltype(auto)</code>.</p>\n<p>С <code>authAndAccess</code> осталась одна проблема - она не сможет принимать rvalue для контейнера. Модифицируем так, чтобы мог:</p>\n<pre><code class="language-cpp">template&#x3C;typename Container, typename Index>\nauto get(Container&#x26;&#x26; c, Index i) -> decltype(std::forward&#x3C;Container>(c)[i]) {\n  authenticateUser();\n  return std::forward&#x3C;Container>(c)[i];\n}\n</code></pre>\n<p>Теперь для <strong>c</strong> типа lvalue функция будет возвращать lvalue, а для rvalue - rvalue.</p>\n<h3>Особенность поведения decltype</h3>\n<p>Применение <strong>decltype</strong> к имени переменной возвращает тип этого имени. Однако применение к lvalue, котороя является чем-то более сложным, чем имя, возвращает ссылку на lvalue. То есть <strong>decltype</strong> над выражением не-именем, имеющим тип <strong>T</strong> вернет тип <strong>T&#x26;</strong>. Такое поведение редко на что-либо влияет, однако есть интересное следствие:</p>\n<pre><code class="language-cpp">int x = 0;\ndecltype(x);    // int\ndecltype((x));  // int&#x26;\n</code></pre>\n<p>Как видно, оборачивание значения в скобки может поменять значение, возвращаемое <strong>decltype</strong>. Это особенно важно в C++14, где можно возвращать из функции <code>decltype(auto)</code> и случайно можно вернуть ссылку на элемент вместо элемента.</p>\n<h2>Используйте auto вместо явных определений типов</h2>\n<h3>auto не даст создать неинициализированный объект</h3>\n<pre><code class="language-cpp">int x;  // не инициализирован!\n\nauto x; // не скомпилится!\n</code></pre>\n<h3>Позволяет не писать сложные типы</h3>\n<pre><code class="language-cpp">template&#x3C;typename It>\nvoid dwim(It b, It e)\n{\n  while (b != e) {\n    typename std::iterator_traits&#x3C;It>::value_type currValue = *b;\n    auto currValue2 = *b;\n    ...\n  }\n}\n</code></pre>\n<h3>Экономить память при использовании функторов</h3>\n<p>Тип лямбды неизвестен до компиляции, поэтому описать его точно - невозможно. Приходится использовать тип <code>std::function</code>. </p>\n<pre><code class="language-cpp">std::function&#x3C;bool(const std::unique_ptr&#x3C;Widget>&#x26;, const std::unique_ptr&#x3C;Widget>&#x26;)>\n    funcs = [](const std::unique_ptr&#x3C;Widget>&#x26; a, const std::unique_ptr&#x3C;Widget>&#x26; b) {\n        return *a &#x3C; *b;\n    }\n</code></pre>\n<p>Но у него есть недостаток - он всегда занимает фиксированный размер в памяти, и если его не хватает, то аллоцирует память в куче. Тогда как реальный тип замыкания, выводимый во время компиляции и используемый с помощью <strong>auto</strong> всегда занимает ровно столько места, сколько ему требуется.</p>\n<p>Плюс к этому, из-за особенностей реализации, при вызове функции через <code>std::function</code> запрещается инлайнинг и добавляется непрямой вызов функции (indirect function calls), что ухудшает производительность по сравнению с <strong>auto</strong>.</p>\n<h3>Неявные приведения типов</h3>\n<p>Допустим, есть такой код:</p>\n<pre><code class="language-cpp">std::vector&#x3C;int> v;\nunsigned sz = v.size();\n</code></pre>\n<p>Все бы ничего, да только <code>v.size()</code> возвращает вовсе не <strong>unsigned</strong>, а <code>std::vector&#x3C;int>::size_type</code>.</p>\n<p>Другой пример:</p>\n<pre><code class="language-cpp">std::unordered_map&#x3C;std::string, int> m;\n\nfor(const std::pair&#x3C;std::string, int>&#x26; p: m) {\n    ...\n}\n</code></pre>\n<p>Реальный тип элементов, содержащихся в <code>unordered_map</code> - <code>std::pair&#x3C;const std::string, int></code>. В результате компилятор не сможет привести <code>std::pair&#x3C;const std::string, int></code> к <code>std::pair&#x3C;std::string, int></code> и будет для каждого члена создавать временный объект, ссылку на который копировать в <strong>p</strong>. После каждой итерации временный объект будет уничтожен.</p>\n<p>Использование <strong>auto</strong> в этом случае делает код проще и производительнее:</p>\n<pre><code class="language-cpp">std::unordered_map&#x3C;std::string, int> m;\n\nfor(const auto&#x26; p: m) {...}\n</code></pre>\n<h2>Иногда auto выводит не то, что нужно</h2>\n<pre><code class="language-cpp">std::vector&#x3C;bool> features(const Widget&#x26; w);\n\nWidget w;\nauto highPriority = features(w)[5];\nprocessWidget(w, highPriority);\n</code></pre>\n<p>Как ни удивительно, этот код приводит к undefined behavior. Дело в том, что оператор <code>[]</code> для <code>std::vector&#x3C;bool></code> возвращает <code>std::vector&#x3C;bool>::reference</code>. Так происходит потому, что булевого типа у вектора есть специальная реализация, которая хранит по одному биту на элемент. Теперь оператор <code>[]</code> должен возвращать ссылку на бит, но в C++ запрещены ссылки на биты. Поэтому приходится возвращать тип, который <em>ведет себя</em> как <code>bool&#x26;</code>. ЭТо означает, что он, помимо прочего, должен быть неявно приводим к <code>bool</code>. </p>\n<p>Получается, что когда мы делаем <code>bool highPriority = features(w)[5]</code>, то возвращается <code>std::vector&#x3C;bool>::reference</code>, который приводится к <code>bool</code> и дальше все нормально.</p>\n<p>А вот когда мы делаем <code>auto highPriority = features(w)[5]</code>, то дальше все зависит от реализации типа <code>std::vector&#x3C;bool>::reference</code>. Одна из реализаций представляет из себя:</p>\n<ul>\n<li>указатель на машинное слово вектора, в котором содержится интересующий бит</li>\n<li>сдвиг в этом слове</li>\n</ul>\n<p>Итак, вызов <code>features</code> возвращает временный объект-вектор. Оператор <code>[]</code> возвращает <code>std::vector&#x3C;bool>::reference</code>, в котором содержится ссылка на элемент внутри временного объекта-вектора. Мы записываем это в <code>highPriority</code>, после чего временный объект уничтожается, а в <code>highPriority</code> остается висячая ссылка на уничтоженный объект.</p>\n<p>Здесь <code>std::vector&#x3C;bool>::reference</code> - это прокси-класс, который не предназначен для того, чтобы жить дольше, чем одно выражение. Поэтому <strong>auto</strong> очень плохо дружит с прокси-классами.</p>\n<p>Такие прокси-классы очень тяжело найти заранее, однако когда стало понятно, что проблема в прокси-классе, не стоит избавляться от <strong>auto</strong>. Лучший способ - использовать явное приведение типа:</p>\n<pre><code class="language-cpp">auto highPriority = static_cast&#x3C;bool>(features(w)[5]);\n</code></pre>\n<h2>Различия между () и {} при инициализации объектов</h2>\n<p>Для начало важно отличать инициализацию от присвоения:</p>\n<pre><code class="language-cpp">Widget w1;          // инициализация, вызван дефолтный конструктор\nWidget w2 = w1;     // инициализация, вызывается конструктор копирования\nw1 = w2;            // присвоение, вызывается оператор =\n</code></pre>\n<p>В C++ 11 представлена <em>uniform initialization</em> - предпочтительный способ инициализации:</p>\n<pre><code class="language-cpp">int x{0};\nstd::vector&#x3C;int> v{1,2,3,4,5};\n</code></pre>\n<p>Тот же синтаксис можно использовать и для задания дефолтных значений не-статическим полям классов, наравне с синтаксисом через <strong>=</strong>:</p>\n<pre><code class="language-cpp">class Widget {\nprivate:\n    int x{0};   // ОК\n    int y = 0;  // тоже ок\n    int z(0);   // ошибка компиляции!\n}\n</code></pre>\n<p>Однако если инициализируем не-копируемый тип, то <strong>{}</strong> валиден наравне с синтаксисом через <strong>()</strong>:</p>\n<pre><code class="language-cpp">std::atomic&#x3C;int>ai1{0};     // OK\nstd::atomic&#x3C;int>ai2(0);     // OK\nstd::atomic&#x3C;int>ai3 = 0;    // ошибка!\n</code></pre>\n<p>Поэтому, чтобы не путаться, лучше всегда использовать универсальную (uniform) инициализацию вида <code>int x{0};</code>.</p>\n<h3>{} запрещает преобразование типа с потерей точности</h3>\n<pre><code class="language-cpp">double x,y,z;\nint sum1{ x+y+z };      // не скомпилится, так как сумма даблов может быть невыразима через int\nint sum2( x+y+z );      // спокойно компилится и приводит к неожиданному поведению при выполнении\nint sum3 = x + y + z;   // аналогично sum2\n</code></pre>\n<h3>{} не подвержена most vexing parse</h3>\n<p>В С++ есть такое правило - все, что может быть интерпретировано как объявелние, должно быть интерпретировано как объявление.</p>\n<p>Поэтому часто, когда хотим инициализировать переменную дефолтным конструктором через скобки, вместо этого получается объявление функции:</p>\n<pre><code class="language-cpp">Widget w1(10);  // когда у конструктора есть параметры, то все норм\nWidget w2();    // а вот когда хотис использовать дефолтный конструктор, то получается объявление функции\n</code></pre>\n<p>С использованием <strong>{}</strong> код выглядит так и не содержит этой проблемы:</p>\n<pre><code class="language-cpp">Widget w3{};\n</code></pre>\n<h3>Недостаток: опять проблемы с initializer_list</h3>\n<p>Если при инициализации через <strong>{}</strong> имеется конструктор, принимающий <code>initializer_list</code>, и он может быть теоретически использован, то будет использован именно он:</p>\n<pre><code class="language-cpp">class Widget {\npublic:\n    Widget(int i, bool b);\n    Widget(int i, double d);\n    Widget(std::initializer_list&#x3C;long double> il);\n};\n\nWidget w1(10, true);    // будет вызван первый конструктор\nWidget w2{10, true};    // 3-й\nWidget w3(10, 5.0);     // 2-й\nWidget w4{10, 5.0};     // 3-й\n</code></pre>\n<p>Причем иногда путь довольно непрост:</p>\n<pre><code class="language-cpp">class Widget {\npublic:\n  Widget(int i, bool b);\n  Widget(int i, double d);\n  Widget(std::initializer_list&#x3C;long double> il);\n  operator float() const;       // оператор преобразования Widget во float\n\n  // конструктор копирования\n  // конструктор перемещения\n... };\nWidget w5(w4);              // вызывается конструктор копирования \nWidget w6{w4};              // вызывается преобразование к float и затем конструктор с initializer_list, так как float может быть преобразован к long double\nWidget w7(std::move(w4));   // конструктор перемещения\nWidget w8{std::move(w4)};   // опять конструктор с initializer_list через преобразование к float\n</code></pre>\n<p>Более того, компилятор настолько сильно хочет использовать <code>initializer_list</code>, что даже идеально подходящие другие конструкторы ему не помеха:</p>\n<pre><code class="language-cpp">class Widget {\npublic:\n  Widget(int i, bool b);\n  Widget(int i, double d);\n  Widget(std::initializer_list&#x3C;bool> il);\n... \n};\n\nWidget w{10, 5.0};  // ошибка компиляции!\n</code></pre>\n<p>Компилятор, несмотря на то, что есть конструктор, принимающий <strong>int</strong> и <strong>double</strong>, опять попытался использовать конструктор с <code>initializer_list</code> и не смог, потому что для этого требуется сужающее приведение <strong>int</strong> и <strong>double</strong> к <strong>bool</strong>, а сужающие приведения запрещены в инициализации через <strong>{}</strong>.</p>\n<p>Однако и из этого правила есть исключение - если есть дефолтный конструктор и мы вызываем инициализацию без параметров, то дефолтный конструктор имеет высший приоритет над конструктором с <code>initializer_list</code>:</p>\n<pre><code class="language-cpp"> class Widget {\npublic:\n  Widget();\n  Widget(std::initializer_list&#x3C;int> il);\n... };\nWidget w1;      // дефолтный конструктор\nWidget w2{};    // дефолтный конструктор\nWidget w3();    // most vexing parse! объявляет функцию\n\nWidget w4({});  // только так мы в этом случае можем вызвать конструктор с initializer_list\nWidget w5{{}};  // ну или так\n</code></pre>\n<p>Один из выводов из всего этого - если вы автор библиотеки, то не стоит добавлять конструктор, принимающий <code>initializer_list</code>, так как тогда возможно клиенты не смогут использовать ваши остальные конструкторы.</p>',frontmatter:{path:"/blog/books/effective-modern-cpp",title:"Effective Modern C++"}}},pathContext:{}}}});
//# sourceMappingURL=path---blog-books-effective-modern-cpp-9e114df4dd670e788623.js.map