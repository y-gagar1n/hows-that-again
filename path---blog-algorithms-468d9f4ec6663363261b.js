webpackJsonp([0x6afb0d4cad43],{406:function(n,e){n.exports={data:{markdownRemark:{html:'<h1>Алгоритмы</h1>\n<h2>Merge Sort</h2>\n<p>Главный недостаток - необходимость использовать дополнительную память для массива размером N, куда мержим. Можно использовать только размер N/2, если копировать в него левую половину массива и потом мержить этот массив и правую половину сразу в оригинал, так что заполняться будет сначала левая половина.</p>\n<p>Достоинства:</p>\n<ul>\n<li>работает на устройствах последовательного доступа</li>\n<li>хорошо сочетается с подкачкой и кэшированием памяти</li>\n<li>можно легко параллелить</li>\n<li>не имеет "трудных" входных данных</li>\n<li>стабильная</li>\n</ul>\n<h2>Selection sort</h2>\n<p>Идем слева направо, ищем минимальный элемент в неотсортированной части массива, когда находим - свапаем с самым левым элементом несортированной части. Этот легче всего реализовать на бумажке.</p>\n<h2>Insertion sort</h2>\n<p>Идем слева направо, берем самый левый элемент несортированной части и проходим справа налево по сортированной, ищем где его место. Когда находим место - вставляем туда, сдвигая элементы сортированной части направо. </p>\n<p>Сильно ускорить можно, если при обмене не менять значения, а просто сдвигать левый направо. Элемент, для которого ищем место, все равно держим в памяти, поэтому в конце просто ставим его в найденное место.</p>\n<h2>Shellsort</h2>\n<p>Сложность в лучшем случае: <code>O(n log n)</code></p>\n<p>В худшем: <code>O(n log^2 n)</code> - для лучшей известной последовательности пропусков</p>\n<p>В среднем случае - зависит от последовательности пропусков.</p>\n<p>Совершенствует Insertion Sort. Проблема Insertion Sort в том, что он всегда сравнивает только соседние элементы, поэтому он очень хорошо работает на почти упорядоченном массиве и очень плохо - на обратно упорядоченном.</p>\n<p>Shellsort делает несколько проходов Insertion Sort, но на каждом он сортирует каждый <code>k</code>-й элемент массива, постепенно уменьшая <code>k</code> до 1. Этого можно достигнуть, если в условиях внутреннего цикла Insertion Sort уменьшать индекс при каждой итерации не на 1, а на <code>k</code>.</p>\n<p>Есть много вариантов последовательностей <code>k</code>, самая производительная на сегодняшний день такова: <code>[701, 301, 132, 57, 23, 10, 4, 1]</code>.</p>\n<h2>Heap</h2>\n<p>Представляем дерево в виде массива, у которого <code>a[0]</code> - корень, а для <code>a[i]</code> дочерними являются элементы <code>a[2*i+1], a[2*i+2]</code>.</p>\n<p>Свойства кучи:</p>\n<ol>\n<li>Значение в любой вершине не меньше, чем значения её потомков.</li>\n<li>Глубина всех листьев (расстояние до корня) отличается не более чем на 1 слой.</li>\n<li>Последний слой заполняется слева направо без «дырок».</li>\n</ol>\n<p>Свойства 2 и 3 выполняются автоматически, когда храним кучу в массиве.</p>\n<p>Для выполнения свойства 1 нужно при каждом изменении элементов вызывать функцию Heapify. Она работает так:</p>\n<pre><code>Если i-й элемент меньше, чем любой из его сыновей, то меняем местами i-й элемент с наибольшим из его сыновей, после чего выполняем Heapify для этого сына.\nЕсли же i-й элемент больше своего родителя, то меняем его местами с родителем и вызываем Heapify для родителя.\n</code></pre>\n<h3>Добавление</h3>\n<p>Кладем элемент в конец массива и вызываем Heapify на этом элементе</p>\n<h3>Инициализация</h3>\n<p>Чтобы построить кучу из массива, нужно просто вызвать Heapify для всех его элементов, начиная с последнего и кончая первым. Более того, так как начиная с N/2 все элементы - листья, не содержащие потомков, то можем начинать сразу с N/2.</p>\n<h3>Удаление максимума</h3>\n<p>Ставим последний элемент на место первого, уменьшаем размер, вызываем <code>Heapify(0)</code>.</p>\n<h2>Heap Sort</h2>\n<p>Использует бинарное сортирующее дерево (она же куча). </p>\n<p>Сам алгоритм состоит из 2 этапов:</p>\n<ol>\n<li>Строим кучу (О(n) операций)</li>\n<li>Удаляем по одному элементу за раз и перестраиваем дерево. Только удаленные элементы мы будем класть сразу в конец нашего массива, в котором и хранится дерево. То есть сначала меняем местами <code>a[0]</code> и <code>a[n-1]</code>, перестраиваем дерево, состоящее из элементов <code>a[0] ... a[n-2]</code>. Потом меняем местами <code>a[0]</code> и <code>a[n-2]</code>, перестраиваем дерево <code>a[0] ... a[n-3]</code> и так далее (О(n log n) операций).</li>\n</ol>\n<p>Достоинства:</p>\n<ul>\n<li>сортирует на месте, если хранить и дерево и результат в одном массиве</li>\n<li>всегда работает с одинаковой сложностью</li>\n</ul>\n<p>Недостатки:</p>\n<ul>\n<li>неустойчив</li>\n<li>на почти отсортированных работает так же, как и на хаотичных</li>\n<li>выборка делается хаотично по всему массиву, поэтому плохо сочетается с кэшированием и подкачкой</li>\n<li>не работает на связанных списках и других структурах последовательного доступа</li>\n<li>из-за сложности выигрыш начинается только от больших n (от нескольких тысяч)</li>\n</ul>\n<h2>Quick Sort</h2>\n<h3>Разбиение Ломуто</h3>\n<p>Проще в реализации, но менее эффективно.</p>\n<pre><code>algorithm partition(A, lo, hi) is\n    pivot := A[hi]\n    i := lo    \n    for j := lo to hi - 1 do\n        if A[j] ≤ pivot then\n            swap A[i] with A[j]\n            i := i + 1\n    swap A[i] with A[hi]\n    return i\n</code></pre>\n<h3>Разбиение Хоара</h3>\n<p>Данная схема использует два индекса (один в начале массива, другой в конце), которые приближаются друг к другу, пока не найдётся пара элементов, где один больше опорного и расположен перед ним, а второй меньше и расположен после. Эти элементы меняются местами. Обмен происходит до тех пор, пока индексы не пересекутся. Очень важно в качетсве изначальной <code>pivot</code>-точки брать именно серединную, а в циклах сдвига <code>left</code> и <code>right</code> делать строгое меньше и строгое больше, это гарантирует нам что они остановятся в середине, а не пойдут в другую половину и не улетят за край массива. Алгоритм возвращает последний индекс. Схема Хоара эффективнее схемы Ломуто, так как происходит в среднем в три раза меньше обменов (swap) элементов, и разбиение эффективнее, даже когда все элементы равны.</p>\n<pre><code>algorithm partition(A, lo, hi) is\n    pivot := A[(hi+lo)/2]\n    i := lo - 1\n    j := hi + 1\n    loop forever\n        do\n            i := i + 1\n        while A[i] &#x3C; pivot\n\n        do\n            j := j - 1\n        while A[j] > pivot\n\n        if i >= j then\n            return j\n\n        swap A[i] with A[j]\n</code></pre>\n<p>Опорный элемент остается в начале, таким образом попадает в подмножество чисел, которые меньше или равны опорному.</p>\n<h3>Варианты улучшения</h3>\n<ul>\n<li>Insertion Sort на малых подмассивах</li>\n<li>Использовать в качестве <code>pivot</code>-точки медиану из первого, последнего и серединного значения массива</li>\n<li>Если в массиве есть множество элементов с одинаковыми ключами, то можно разбивать на 3 партишна, посередине - с элементами, равными <code>pivot</code>. Это можно сделать разбиением Ломуто, только нужно вести 2 счетчика, один вначале серединного партишна и идет слева направо, другой - в конце серединного партишна и идет справа налево.</li>\n</ul>\n<h2>Radix Heap</h2>\n<p>(<a href="http://ssp.impulsetrain.com/radix-heap.html">http://ssp.impulsetrain.com/radix-heap.html</a>)</p>\n<p>Монотонная очередь с приоритетом. Все ключи должны быть натуральными числами. Разница между максимальным и минимальным ключом не больше определенной константы. Свойство монотонности означает, что нельзя добавлять элементы с ключом, меньшим, чем все имеющиеся к куче ключи.</p>\n<p>Все элементы лежат по бакетам, как в Dictionary. Отдельно хранится переменная <code>last_deleted</code>. Элементы, лежащие в бакете <code>k</code> должны отличаться от <code>last_deleted</code> в бите с номером <code>k-1</code> (нумерация с 0 и с самого младшего бита), могут отличаться в битах, младших чем <code>k-1</code> и <strong>не должны</strong> отличаться в битах, старших чем <code>k-1</code>.</p>\n<p>Например, пусть в <code>last_deleted</code> лежит 8 и мы пытается посчитать, в каком бакете лежит 10.</p>\n<pre><code>8 = 01000\n10 = 01010\n</code></pre>\n<p>Нам нушно найти самый старший бит, в котором они различаются, поэтому идем от самого старшего к самому младшему. </p>\n<pre><code>4: 0 == 0\n3: 1 == 1\n2: 0 == 0\n1: 0 != 1\n</code></pre>\n<p>Значит самый старший отличающийся бит имеет индекс 1, а бакет имеет номер 1 + 1 = 2.</p>\n<p>Посчитаем, куда идет ключ 30:</p>\n<pre><code>8 =  001000\n10 = 011110\n\n5: 0 == 0\n4: 0 != 1\n\nk - 1 = 4, k = 5\n</code></pre>\n<p>Получили пятый бакет.</p>\n<p>Теперь рассмотрим операции:</p>\n<h3>Вставка</h3>\n<p>Тут все просто - вычисляем номер бакета и добавляем в него. Номер бакета можно вычислить через XOR:</p>\n<pre><code>bucket_no = highest_bit (new_element XOR last_deleted) + 1\n</code></pre>\n<p><strong>ВАЖНО</strong> если на вход функции <code>highest_bit</code> поступает 0, то она должна возвращать -1!</p>\n<h3>Извлечение</h3>\n<p>Находим минимальный бакет, в котором есть элементы, затем линейным поиском ищем в этом бакете минимальный элемент и возвращаем, попутно записав его в <code>last_deleted</code>. После этого нам нужно перераспределить оставшиеся элементы в этом бакете в соответствии с новым <code>last_deleted</code>, но более старшие бакеты трогать не надо, так как для них ничего не изменилось, их совпадающие биты все еще на совпадают.</p>\n<h2>Counting Sort</h2>\n<p>Алгоритм сортировки для небольших положительных целых чисел. </p>\n<p>Для работы понадобится массив с размером, равным максимально возможному используемому числу. Поэтому применение этого алгоритма целесообразно лишь тогда, когда сортируемые числа имеют (или их можно отобразить в) диапазон возможных значений, который достаточно мал по сравнению с сортируемым множеством. Например, миллион натуральных чисел, меньших 1000.</p>\n<p>Состоит из 3 шагов:</p>\n<ol>\n<li>Вычисление частот</li>\n<li>Вычисление индексов</li>\n<li>Заполнение результата</li>\n</ol>\n<pre><code>function countingSort(array, k) is\n  count ← new array of k zeros\n  for i = 1 to length(array) do\n    count[array[i]] ← count[array[i]] + 1\n  for i = 2 to k do\n    count[i] ← count[i] + count[i - 1]\n  for i = length(array) downto 1 do\n    output[count[array[i]]] ← array[i]\n    count[array[i]] ← count[array[i]] - 1\n  return output\n</code></pre>\n<p>После первого цикла в массиве <code>count</code> хранится для каждого числа количество, сколько раз оно встречается во входном массиве.</p>\n<p>Во втором цикле мы записываем в массив <code>count</code> т.н. префиксные суммы и после его завершения <code>i</code>-е значение массива означает, сколько чисел в исходном массиве меньше, чем <code>i</code>. То есть это индекс, на котором должно стоять <code>i</code> в результирующем упорядоченном массиве.</p>\n<p>В третьем цикле мы заполняем результирующий массив в соответствии с полученным массивом <code>count</code>. Мы берем очередное число из входного массива, смотрим какой записан для него индекс в массиве <code>count</code> и записываем число в результат по этому индексу. После этого индекс в <code>count</code> нужно увеличить, атк как следующее такое число нужно записывать уже на следующую позицию. Сложная логика в этом цикле обусловлена тем, что обычно мы сортируем не просто целые числа, а некие объекты, у которых ключами являются целые числа. Кроме того так мы обеспечиваем стабильность сортировки. </p>\n<p>Если же мы сортируем просто целые числа, то мы сразу после первого цикла можем идти по массиву <code>count</code> и вставлять в результат <code>count[i]</code> копий числа <code>i</code>.</p>\n<h2>Radix Sort</h2>\n<p>Предназначен для сортировки целых чисел, или же любых объектов, которые можно представить в виде целых чисел. Но сложность алгоритма зависит от длины ключа, поэтому лучше чтобы он был не сильно большой.</p>\n<p>Алгоритм хорош тем, что его сложность составляет <code>O(n * m)</code>, где <code>n</code> - количество элементов, а <code>m</code> - количество знаков в них. В то же время сложность остальных алгоритмов, основанных на сравнении, не может быть ниже чем <code>O(n * log n)</code>.</p>\n<p>Бывают 2 вида: least significant radix (LSD) и most significant radix (MSD).</p>\n<h3>LSD</h3>\n<p>Исходя из этого, алгоритм часто используют для сортировки строк.</p>\n<p>Для алгоритма нужно выбрать значение <code>r</code>, то есть по какому основанию мы будем работать с числами. Вместе с тем это и количество бакетов. При маленьких <code>r</code> алгоритм становится все больше похож на Counting Sort. Ну и вообще, в своей эффективной реализации алгоритм использует Counting Sort, просто повторяет ее для каждого разряда.</p>\n<p>Суть алгоритма в том, что мы сначала сортируем по самому младшему разряду, потом по следующему и так до самого старшего.</p>\n<p>Например, отсортируем следующий массив (<code>r=10</code>):</p>\n<p>170, 45, 75, 90, 2, 802, 2, 66</p>\n<p>Сортируем сначала по самому младшему разряду:</p>\n<p>17<strong>0</strong>, 9<strong>0</strong>, 0<strong>2</strong>, 80<strong>2</strong>, <strong>2</strong>, 4<strong>5</strong>, 7<strong>5</strong>, 6<strong>6</strong></p>\n<p>Теперь по второму:</p>\n<p><strong>0</strong>2, 8<strong>0</strong>2, <strong>0</strong>2, <strong>4</strong>5, <strong>6</strong>6, 1<strong>7</strong>0, <strong>7</strong>5, <strong>9</strong>0</p>\n<p>И наконец по третьему:</p>\n<p><strong>0</strong>02, <strong>0</strong>02, <strong>0</strong>45, <strong>0</strong>66, <strong>0</strong>75, <strong>0</strong>90, <strong>1</strong>70, <strong>8</strong>02</p>\n<h4>Неэффективная реализация</h4>\n<p>Самая простая, неэффективная реализация использует массив очередей (или других массивов), где в очереди <code>i</code> лежат элементы, у которых в разряде, соответствующем текущей итерации, записано <code>i</code>.</p>\n<p>В нашем примере после первого прохода получим следующий массив очередей:</p>\n<pre><code>0: 170, 090\n1: \n2: 002, 802, 002\n3: \n4: \n5: 045, 075\n6: 066\n7–9: \n</code></pre>\n<p>Затем по порядку вычитываем элементы в одномерный массив:</p>\n<pre><code>170 090 002 802 002 045 075 066\n</code></pre>\n<p>Затем опять записываем в массив очередей, ориентируясь уже на второй справа разряд:</p>\n<pre><code>0: 002, 802, 002\n1–3: \n4: 045\n5: \n6: 066\n7: 170, 075\n8: \n9: 090\n</code></pre>\n<p>Выписываем в 1-мерный массив:</p>\n<pre><code>002 802 002 045 066 170 075 090\n</code></pre>\n<p>Третий проход:</p>\n<pre><code>0: 002, 002, 045, 066, 075, 090\n1: 170\n2–7: \n8: 802\n9: \n</code></pre>\n<p>Выписываем результат:</p>\n<pre><code>002 002 045 066 075 090 170 802\n</code></pre>\n<h4>Эффективная реализация</h4>\n<p>Проходим по числам от наименее значимого к наиболее значимому и для каждого осуществляем Counting Sort.</p>\n<p>Если в качестве <code>r</code> использовать степени двойки, то разряды будет очень удобно получать двоичными операциями сдвига и XOR:</p>\n<pre><code>b = количество бит в двоичной записи r\nmask = 1 &#x3C;&#x3C; b\nshift = 0\n\nfor ...\n    c = (a[i] >> shift) &#x26; mask\n    shift += b\n</code></pre>\n<h3>MSD</h3>\n<p>Все в основном то же самое, но сортировать начинаем с самого значимого знака. Не гарантирует стабильность. Используется, когда нам нужно, например, отсортировать строки по N первых символов. На каждом этапе разбивает массив на несколько подмассивов (по одному на каждый символ алфавита), которые потом можно сортировать рекурсивно. То есть лучше параллелится, чем LSD.</p>\n<h2>Одновременный поиск минимума и максимума в массиве</h2>\n<p>Если искать простым линейным поиском, то получим сложность <code>O(2n-1)</code> (количество сравнений в худшем случае). Но есть более эффективный алгоритм со сложностью <code>O(3n/2)</code>:</p>\n<ol>\n<li>Разбиваем массив на подмассивы по 2 элемента.</li>\n<li>Упорядочиваем каждый из них (n/2 сравнений). После этого у нас на нечетных местах стоят минимальные элементы из пар, а на четных - максимальные.</li>\n<li>Находим минимальный среди всех нечетных (n/2 сравнений). При этом если количество элементов нечетное, то взять в качестве начального значения последний элемент.</li>\n<li>Находим максимальный среди всех четных (n/2 сравнений). При этом если количество элементов нечетное, то взять в качестве начального значения последний элемент.</li>\n</ol>\n<p>Итого - 3n/2 сравнений.</p>\n<h2>Поиск n-го наименьшего элемента массива без сортировки</h2>\n<p>Обычно требуется найти такой элемент за время O(n), а сортировка потребует O(n * log n).</p>\n<h3>Quickselect</h3>\n<p>Самым популярным алгоритмом тут является Quickselect (от создателя Quicksort). Он работает по тому же принципу что и Quicksort, но на каждом этапе продолжает работать только с одним из полученнхы партишнов, за счет этого и получается снижение сложности до O(N) в среднем и O(N^2) - в худшем случае.</p>\n<h3>Медиана медиан</h3>\n<p>Еще есть алгоритм, который обеспечивает O(N) даже в худшем случае. Он похож на Quickselect, но в качестве pivot-точки на каждом этапе выбирается медиана медиан. Для того чтобы ее найти, мы разбиваем массив на подмассивы по 5 элементов, каждый из них сортируем методом вставки (Insertion sort) и выбираем медиану. Затем формируем массив найденных медиан, и рекурсивно ищем его медиану. Когда массив медиан становится &#x3C;= 5, то используем Insertion sort чтоб найти его медиану. В результате получаем индекс медианы медиан, который используем как точку pivot.</p>\n<p>Засчет того, что точка pivot у нас всегда является медианой массива, худший случай становится средним и мы получаем сложность O(N) в худшем случае. На практике большое количество операций для поиска точки разбиения сильно раздувает константу и этот метод практически не используется.</p>\n<p>Выбор 5 в качетсве длины группы объясняется тем, что:</p>\n<ul>\n<li>в массивах нечетной длины легче искать медиану, т.к. в четных приходится брать середину двух срединных элементов</li>\n</ul>\n<h2>Хэш-таблица с открытой адресацией</h2>\n<p>Обычная хэш-таблица имеет закрытую адресацию - это когда в случае коллизии элемент кладется в список.</p>\n<p>В случае открытой адресации при коллизии берется какой-то другой элемент этого же массива. Например, следующий. Если он тоже занят - то следующий за ним. Так как есть коэффициент заполнения, то пустой элемент рано или поздно будет найден.</p>\n<p>В случае чтения - точно так же, находим нужный элемент, сравниваем ключ, если не равен - берем следующий, и так пока не найдем нужный.</p>\n<p>Когда берем следующий элемент - это называется <strong>линейный поиск</strong> (Linear probing).</p>\n<p><strong>Квадратичный поиск</strong> (Quadratic probing) - это когда интервал увеличивается как значение некоторого полинома второй степени.</p>\n<p>При использовании метода <strong>двойного хэширования</strong> (иногда его называют <strong>Rehashing</strong>) интервал вычисляется с помощью еще одной хэш-функции. Этот метод приводит к уменьшению коллизий, так как следующий проверяемый элемент зависит от самого ключа. Даже если два разных ключа дают один и тот же хэш, то последовательность просматриваемых элементов для них будет разная.</p>\n<h2>Префиксное дерево</h2>\n<p>Дерево для хранения данных, ключами которых являются строки. Для каждого узла реба, соединяющие его с сыновьями, помечены разными символами. Узлы соответствующие концу слова, должны быть помечены. Чтобы найти элемент, нужно начинать с корня и выбирать на i-м уровне то ребро, которое помечено i-м символом в искомом ключе.</p>\n<p>Таким образом, ключ, идентифицирующий некий узел, не явно хранится в каком-либо узле, а задается положением узла в дереве. Ключ корня - пустая строка.</p>\n<h2>Union-Find (задача динамической связности)</h2>\n<p>Дано N точек с идентификаторами от 0 до N-1. Затем дается список связей между этими точками. Связи транзитивные, то есть если А связано с Б, а Б с В, значит А связано с В. Если на вход подается связь между точками А и Б, а они уже связаны, то эта пара игнорируется. Иначе - точки связываются. В конце выдать, сколько получилось кластеров и каких.</p>\n<p>Воспользуемся тем, что точки имеют идентификаторы от 0 до N-1 и будем хранить их в массиве на N элементов. Индекс - идентификатор точки, а значение - идентификатор предыдущего элемента кластера, как если бы элементы кластера были представлены в виде связных списков. </p>\n<p>На самом деле для удобного объединения кластеров мы будем хранить их в деревьях, но деревья будут представлены в виде массивов. Каждый элемент хранит индекс родительского элемента, а если индекс элемента равен самому элементу, значит этот элемент - корень своего кластера.</p>\n<p>Для поиска, какому кластеру принадлежит элемент, нам нужно "подниматься" в дереве от этого элемента, пока не достигнем корня. А чтобы объединить кластеры, нужно всего лишь корню одного кластера присвоить значение корня другого.</p>\n<p>Тогда операции объединения и поиска будут выглядеть так:</p>\n<pre><code class="language-csharp">public int find (int id) {\n    var p = id;\n    while (_ids[p] != p) p = _ids[p];\n    return p;\n}\n\npublic void union (int a, int b) {\n    int ca = find (a),\n        cb = find (b);\n    if (ca == cb) return;\n\n    _ids[ca] = cb;\n}\n</code></pre>\n<p>В операции <code>union</code> есть недостаток - мы не знаем, какой из кластеров больше и в результате у нас получается несбалансированное дерево, по которому операция <code>find</code> будет выполняться все дольше и дольше. Для решения проблемы мы можем завести отдельный массив, где храним веса кластеров и всегда мержить меньший кластер к бОльшему.</p>\n<h2>Проверка правильности скобок</h2>\n<p>Написать функцию, проверяющую правильно расставленные скобки; </p>\n<pre><code>check("{()}[]") // true     check("{[}]") // false\n</code></pre>\n<p>Тут решается простым стэком, в котором мы храним открывающие скобки. Когда встречаем открывающую - пушим в стек. Когда встречаем закрывающую - проверяем, что матчится с той, которая лежит на вершине стека и если да, то попим из стэка. </p>\n<p>Самое главное:</p>\n<ul>\n<li>если у нас закрывающая скобка, то сначала проверить, что в стэке еще есть элементы!</li>\n<li>когда строка закончилась, проверить что стэек пуст, иначе возвращаем false!</li>\n</ul>\n<h2>Генерация последовательности скобок</h2>\n<p>Делаем через рекурсию, других способов не знаю. Только надо помнить, сколько скобок уже открыли и сколько закрыли. И еще важно <strong>НЕ</strong> ставить <code>else</code> между рекурсивными вызовами Generate.</p>\n<pre><code class="language-csharp">if (i == 2 * n) {\n    result.Add (new string (a));\n    return;\n}\nif (open &#x3C; n) {\n    a[i] = \'(\';\n    Generate (result, a, i + 1, n, open + 1, close);\n}\nif (close &#x3C; open) {\n    a[i] = \')\';\n    Generate (result, a, i + 1, n, open, close + 1);\n}\n</code></pre>\n<h2>Дерево отрезков</h2>\n<p>Структура данных, позволяющая за время O(log n) получить значение некой функции для любого последовательного интервала элементов массива. </p>\n<p>Например, у нас есть массив:</p>\n<pre><code>4, 7, -12, 23, -9, 19, 0, 22, 7, 6, -4, 15\n</code></pre>\n<p>Дерево отрезков поможет нам быстро найти значение некой аггрегирующей функции (например, поиск минимума/максимума, сумма, произведение) для любого подмассива, например, для <code>7, -12, 23, -9, 19</code> или <code>-9, 19, 0</code> или любого другого.</p>\n<p>Поддерживается операция обновления (тоже O(log n)).</p>\n<p>Рассмотрим работу алгоритма на примере подсчета суммы элементов.</p>\n<p>В корне дерева хранится сумма всех элементов массива. В левом ребенке - сумма элементов левой половины, в правом - элементов правой. И так далее рекурсивно вниз, а в листьях хранятся значения функции над единичным интервалом, то есть в случае суммы- сами единичные элементы.</p>\n<p>Строится дерево снизу вверх - сначала заполняем нижний уровень, затем считаем значения предыдущего уровня как сумму двух листьев, затем предыдущего и так далее. Строится такое дерево за <code>O(n)</code>.</p>\n<p>При запросе суммы мы принимаем на вход интервал <code>[l..r]</code>, для которого посчитать сумму, встаем в корень дерева и сначала смотрим, совпадают ли границы интервала, соответствующего корню, границам искомого отрезка. Если да - то просто возвращаем значение корня. Если же нет, то смотрим, в какие из двух сыновей попадает отрезок <code>[l..r]</code>. Если он целиком попадает в одного из сыновей, то рекурсивно запускаем запрос для этого сына. Если же он пересекается с обоими, то рекурсивно запускаем запрос по левому дереву для отрезка <code>[l..n/2]</code>, потом по правому по отрезка <code>[n/2+1..r]</code> и суммируем результаты.</p>\n<p>Хранится дерево отрезков обычно в виде массива (по аналогии с кучей), где в каждом элементе хранится значение функции над соответствующим элементу интервалом, а детьми элемента с индексом <code>i</code> являются элементы <code>2*i+1</code> и <code>2*i+2</code>. Для массива длиной <code>n</code> количество будет не больше, чем <code>2n</code>, <strong>НО для массива нужно выделить длину 4<em>n, потому что дерево получится несбалансированное и индексы нижнего уровня могут выходить за пределы 2</em>n</strong>.</p>\n<h3>Построение</h3>\n<p><code>a</code> - исходный массив, <code>v</code> - текущая вершина, <code>tl</code> и <code>tr</code> - границы отрезка, соответствующего текущей вершине дерева. Из основной программы вызывается с параметрами: <code>v=0, tl=0,tr=n-1</code>.</p>\n<pre><code class="language-cs">void build (int a[], int v, int tl, int tr) {\n    if (tl == tr)\n        t[v] = a[tl];\n    else {\n        int tm = (tl + tr) / 2;\n        build (a, v*2, tl, tm);\n        build (a, v*2+1, tm+1, tr);\n        t[v] = t[v*2] + t[v*2+1];\n    }\n}\n</code></pre>\n<h3>Запрос суммы</h3>\n<p><code>v</code> - текущая вершина, <code>tl</code> и <code>tr</code> - границы отрезка, соответствующего текущей вершине дерева, <code>l</code> и <code>r</code> - границы запроса. При первом запуске подаются параметры <code>v=0, tl=0, tr=n-1</code>.</p>\n<pre><code class="language-cs">int sum (int v, int tl, int tr, int l, int r) {\n    if (l > r)\n        return 0;\n    if (l == tl &#x26;&#x26; r == tr)\n        return t[v];\n    int tm = (tl + tr) / 2;\n    return sum (v*2, tl, tm, l, min(r,tm))\n        + sum (v*2+1, tm+1, tr, max(l,tm+1), r);\n}\n</code></pre>\n<h3>Запрос модификации</h3>\n<p><code>v</code> - текущая вершина, <code>tl</code> и <code>tr</code> - границы отрезка текущей вершины, <code>pos</code> - иднекс меняющегося элемента, <code>new_val</code> - его новое значение.</p>\n<pre><code class="language-cs">void update (int v, int tl, int tr, int pos, int new_val) {\n    if (tl == tr)\n        t[v] = new_val;\n    else {\n        int tm = (tl + tr) / 2;\n        if (pos &#x3C;= tm)\n            update (v*2, tl, tm, pos, new_val);\n        else\n            update (v*2+1, tm+1, tr, pos, new_val);\n        t[v] = t[v*2] + t[v*2+1];\n    }\n}\n</code></pre>\n<h2>Алгоритм Кнута-Морриса-Пратта</h2>\n<p>Алгоритм поиска подстроки длиной <code>n</code> в строке длиной <code>m</code>. Основывается на префикс-функции. Решает задачу за <code>O(n+m)</code> и <code>O(n)</code> памяти.</p>\n<h3>Префикс-функция</h3>\n<p>Для строки <code>s</code> длиной <code>n</code> префикс-функция это такой массив <code>p</code> длиной <code>n</code>, в котором <code>p[i]</code> означает длину наибольшего нетривиального (не равного самой строке) префикса, совпадающего с суффиксом для строки <code>s[0..i]</code></p>\n<p>Например, для строки "abcabcd" префикс-функция равна: <code>[0, 0, 0, 1, 2, 3, 0]</code>, что означает:</p>\n<ul>\n<li>у строки "a" нет нетривиального префикса, совпадающего с суффиксом;</li>\n<li>у строки "ab" нет нетривиального префикса, совпадающего с суффиксом;</li>\n<li>у строки "abc" нет нетривиального префикса, совпадающего с суффиксом;</li>\n<li>у строки "abca" префикс длины 1 совпадает с суффиксом;</li>\n<li>у строки "abcab" префикс длины 2 совпадает с суффиксом;</li>\n<li>у строки "abcabc" префикс длины 3 совпадает с суффиксом;</li>\n<li>у строки "abcabcd" нет нетривиального префикса, совпадающего с суффиксом.</li>\n</ul>\n<h4>Нахождение префикс-функции</h4>\n<p>Этот алгоритм не содержит явных сравнений строк и выполняет <code>O(n)</code> действий.</p>\n<p>Пусть мы, идя от <code>s[0]</code> к <code>s[n]</code> дошли до некоторого индекса <code>i</code> и вычислили его префикс-функцию <code>p[i] = j</code>.</p>\n<p>Тогда для <code>i+1</code> префикс-функция увеличится на 1 только в том случае, если <code>s[i+1] == s[j]</code>. (1)</p>\n<p>Если же они не равны, то нам нужно найти такое значение <code>k</code>, которое меньше <code>p[i]</code>, но при этом для него все еще выполняется условие "префикс равен суффиксу", и когда мы найдем такое значение, сможем попробовать условие <code>s[i+1] == s[k]</code> для него. То есть мы знаем, что <code>s[0..j-1] == s[i-j..i-1]</code> и нам нужно найти <code>k</code>, такое, что <code>k&#x3C;j</code> и <code>s[0..k-1] == s[i-k..i-1]</code>. Но у нас уже есть такое значение, мы его получили, когда вычисляли префикс-функцию для строки <code>s[0..j-1]</code>. Поэтому берем <code>j=p[j-1]</code> и проверяем, выпонляется ли условие 1: <code>s[i+1] == s[j]</code>. Если нет, то повторяем уменьшение <code>j</code>, пока не дойдем до нуля.</p>\n<p>Итак, получили такой алгоритм:</p>\n<ul>\n<li>Считать значения префикс-функции <code>p[i]</code> будем по очереди: от <code>i=1</code> к <code>i=n-1</code> (значение <code>p[0]</code> просто присвоим равным нулю).</li>\n<li>Для подсчёта текущего значения <code>p[i]</code> мы заводим переменную <code>j</code>, обозначающую длину текущего рассматриваемого образца. Изначально <code>j = p[i-1]</code>.</li>\n<li>Тестируем образец длины <code>j</code>, для чего сравниваем символы <code>s[j]</code> и <code>s[i]</code>. Если они совпадают — то полагаем <code>p[i] = j+1</code> и переходим к следующему индексу <code>i+1</code>. Если же символы отличаются, то уменьшаем длину <code>j</code>, полагая её равной <code>p[j-1]</code>, и повторяем этот шаг алгоритма с начала.</li>\n<li>Если мы дошли до длины <code>j=0</code> и так и не нашли совпадения, то останавливаем процесс перебора образцов и полагаем <code>p[i] = 0</code> и переходим к следующему индексу <code>i+1</code>.</li>\n</ul>\n<h3>Поиск подстроки</h3>\n<p>Допустим, нам надо найти подстроку <code>s</code> длиной <code>n</code> в тексте <code>t</code>. Для этого мы: </p>\n<ol>\n<li>выбираем некий специальный символ <code>#</code>, которого точно нет ни в <code>s</code>, ни в <code>t</code></li>\n<li>составляем строку <code>Q = s + "#" + t</code></li>\n<li>вычисляем префикс-функцию <code>P</code> для <code>Q</code></li>\n<li>просматриваем значения <code>P</code>, начиная с индекса <code>n+1</code>. Там, где <code>P[i] == n</code> - <code>i</code> обозначает индекс очередного вхождения <code>s</code> в <code>t</code>, а начало вхождения будет по индексу <code>i - (n + 1) - n + 1 = i - 2n</code>.</li>\n</ol>\n<h2>Сумма двух</h2>\n<p>Имея массив целых чисел, нужно вернуть индексы двух элементов, сумма которых будет равна заданному числу</p>\n<h3>Пример</h3>\n<p>Допустим, у нас есть массив <code>nums == [2, 7, 11, 15]</code> и нужно получить число 9.</p>\n<p>Так как <code>nums[0] + nums[1] == 2 + 7 == 9</code>, то возвращаем массив индексов <code>[0,1]</code>.</p>\n<h3>Решение</h3>\n<ol>\n<li>Сортируем массив по возрастанию;</li>\n<li>Идем по массиву с двух концов навстречу друг другу счетчиками i (слева) и j (справа);</li>\n<li>Если <code>nums[i] + nums[j] &#x3C; target</code>, то увеличиваем i;</li>\n<li>Иначе, если <code>nums[i] + nums[j] > target</code>, то уменьшаем j;</li>\n<li>Если же <code>nums[i] + nums[j] == target</code>, то очевидно возвращаем <code>[i, j]</code>.</li>\n</ol>\n<h2>Самая длинная подстрока без повторяющихся символов</h2>\n<p>Имея строку, найти в ней самую длинную подстроку без повторяющихся символов.</p>\n<h3>Примеры</h3>\n<p>"abcabcbb" => "abc"</p>\n<p>"bbbbb" => "b"</p>\n<p>pwwkew => "wke"</p>\n<h3>Решение</h3>\n<p>Для решения используем так называемое скользящее окно - это подстрока нашей входной строки <code>input</code>, которая не содержит повторяющихся символов, начинается в начале <code>input</code> и постепенно движется (скользит) по направлению к ее концу.</p>\n<p>Нам понадобится словарь символов, у которого ключом будет символ, а значением - индекс последнего такого символа в строке, который нам встретился. Назовем этот словарь <strong>s</strong>. Если известно, что все символы входят в некое подмножество/алфавит (например, символы латинского алфавита a-z), то можно вместо словаря использовать массив на <code>n</code> элементов, где n = длина алфавита.</p>\n<ol>\n<li>Инициализируем <code>start=0</code>, это будет левая граница нашего скользящего окна.</li>\n<li>Идем счетчиком <code>i</code> с левого края.</li>\n<li>\n<p>Если <code>s</code> содержит <code>input[i]</code> и <code>s[input[i]]>=start</code>, то мы встретили первый повторяющийся символ в текущем окне.</p>\n<ol>\n<li>Длина соответствующей подстроки равна <code>i-start+1</code>, нужно ее сравнить с текущим максимумом. Если эта длина больше текущего максимума, то запоминаем строку и обновляем максимум.</li>\n<li>Теперь нам нужно сдвинуть левый край окна и мы можем его сдвинуть сразу к символу справа от первого (левого) повторяющегося символа из нашей пары, т.к. для любого края левее этого, подстрока уже заведомо будет содержать повторяющийся символ. Таким образом, <code>start = s[input[i]] + 1</code>.</li>\n</ol>\n</li>\n<li>Запоминаем в наше множество индекс текущего символа: <code>s[input[i]] = i</code>.</li>\n</ol>\n<h2>Медиана 2 отсортированных массивов</h2>\n<p>Имея 2 отсортированных массива, найти их медиану. Сложность должна быть <code>O(log(n+m))</code>. Медиана - это число, разделяющее множество на 2 подмножества одинаковой длины, одно из которых всегда меньше другого.</p>\n<h3>Пример</h3>\n<p>Для массивов [1, 3] и [2] медиана равна 2.0.</p>\n<p>Для [1, 2] и [3, 4] медиана равна (2 + 3) / 2 = 2.5</p>\n<h3>Решение</h3>\n<p>Пусть на входе у нас есть массивы <code>a</code> и <code>b</code>, обозначим их длины как <code>m</code> и <code>n</code> соответственно.</p>\n<p>Чтобы выполнить условия задачи, нам нужно разбить входное множество, состоящее из элементов массивов <code>m</code> и <code>n</code> на 2 подмножества, удовлетворяющие следующим критериям:</p>\n<ol>\n<li>Критерий равенства длин - в подмножествах одинаковое количество элементов.</li>\n<li>Критерий соотношения граничных элементов отсортированных подмножеств - максимальный элемент левого подмножества должен быть меньше или равен минимальному элементу правого.</li>\n</ol>\n<p>Сейчас обьясню, что это значит. Допустим, мы разбиваем массив A в точке i, а массив B в точке j.</p>\n<pre><code>left | right\n\nA[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1]\n\nB[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1]\n</code></pre>\n<p>Тогда условия будут выглядеть так:</p>\n<ol>\n<li><code>len(left) == len(right) -> i + j == (m - i) + (n - j) -> j == (m + n) / 2 - i -> (учтем нечетные длины, прибавив к числителю 1) j == (m + n + 1) / 2 - i</code></li>\n<li><code>max(left) &#x3C;= min(right) -> A[i-1] &#x3C;= B[j] &#x26;&#x26; B[j-1] &#x3C;= A[i]</code></li>\n</ol>\n<p>Если эти условия соблюдены, то искомая медиана будет равна:</p>\n<p><code>median = (max(left) + min(right)) / 2</code></p>\n<p>Значит, задача свелась к следующей:</p>\n<blockquote>\n<p>Найти <code>i</code> в <code>[0, m]</code>, такую, что:\n<code>A[i-1] &#x3C;= B[j] &#x26;&#x26; B[j-1] &#x3C;= A[i] где j = (m + n + 1) / 2 - i</code></p>\n</blockquote>\n<p>Это мы можем сделать половинным делением.</p>\n<p>Когда нашли i, медиана будет равна:</p>\n<blockquote>\n<p><code>max(A[i-1], B[j-1])</code>, если <code>m+n</code> нечетное\nи <code>(max(A[i-1], B[j-1]) + min(A[i], B[j])) / 2</code>, если <code>m+n</code> четное</p>\n</blockquote>\n<h2>Найти подмассив с максимальной суммой</h2>\n<h3>Вариант 1. Разделяй и властвуй</h3>\n<p>Делим массив на 2 половины и возвращаем максимум из:</p>\n<ol>\n<li>максимальная сумма в левой половине</li>\n<li>максимальная сумма в правой половине</li>\n<li>максимальная сумма в подмассиве, пересекающем середину</li>\n</ol>\n<p>1 и 2 пункт - это просто рекурсивные вызовы.</p>\n<p>3 пункт посложнее - там нужно от середины идти влево и вправо, и считать масимальную сумму элементов левой и правой половины, а потом суммировать их.</p>\n<p>Рассмотрим пример, допустим у нас такой массив:</p>\n<pre><code>6 1 -3 4 -1 3 -5 4\n</code></pre>\n<p>Максимальная сумма идущих подряд элементов в левой половине = 7 для последовательности <code>6 1</code>.</p>\n<p>Максимальная сумма идущих подряд элементов в правой половине = 4 для последовательности <code>4</code>.</p>\n<p>Максимальная сумма в подмассиве, пересекающем середину - складывается из:</p>\n<ul>\n<li>максимальной суммы идущих подряд элементов левой половины, включающих самый <strong>правый</strong> элемент левой половины. В данном случае это 8 для последовательности <code>6 1 -3 4</code>.</li>\n<li>максимальной суммы идущих подряд элементов правой половины, включающих самый <strong>левый</strong> элемент правой половины. В данном случае это 2 для последовательности <code>-1 3</code>.</li>\n</ul>\n<p>Получили максимальную сумму в подмассиве, пересекающем середину = 8 + 2 = 10.</p>\n<p>Результат выбираем как максимум из трех полученных максимумов, то есть <code>max(7, 4, 10) == 10</code>, то есть последовательность <code>6 1 -3 4 -1 3</code>.</p>\n<p>Сложность - <code>O(nlogn)</code></p>\n<h3>Вариант 2. Алгоритм Кадане.</h3>\n<p>Алгоритм Кадане - это специализированный алгоритм именно для этой задачи. Объяснять это словами будет тяжело, лучше сразу кодом.</p>\n<p>На псевдокоде описывается очень просто:</p>\n<pre><code>Initialize:\nmax_so_far = 0\nmax_ending_here = 0\n\nLoop for each element of the array:\n  max_ending_here = max_ending_here + a[i]\n  if(max_ending_here &#x3C; 0)\n    max_ending_here = 0\n  if(max_so_far &#x3C; max_ending_here)\n    max_so_far = max_ending_here\nreturn max_so_far\n</code></pre>\n<p>Идея так же проста - идем по массиву скользящим окном, ищем последовательные подмассивы, сумма которых больше нуля и берем максимальную сумму из них.</p>\n<p>Пример:</p>\n<pre><code>2 -3 8 -1\n</code></pre>\n<p>Алгоритм выдаст 8 и это правильно.</p>\n<p>Если бы кусок перед 8 выдавал результат больше нуля, то он бы увеличивал масимальную сумму и мы бы его взяли.</p>\n<p>Если он меньше нуля, то он точно уменьшает сумму и мы его не берем.</p>\n<p>Более сложный пример:</p>\n<pre><code>3 2 -7 2 1 -2 4 -1 3 -5 4\n</code></pre>\n<p>Идем слева направо, считаем сумму:</p>\n<pre><code>3 => max = 3\n3 + 2 = 5 => max = 5\n3 + 2 - 7 = -2 &#x3C; 0 начинаем считать заново\n2 &#x3C; max\n2 + 1 = 3 &#x3C; max\n2 + 1 - 2 = 1 &#x3C; max\n2 + 1 - 2 + 4 = 5 == max\n2 + 1 - 2 + 4 - 1 = 4 &#x3C; max\n2 + 1 - 2 + 4 - 1 + 3 = 7 > max обновляем max = 7\n2 + 1 - 2 + 4 - 1 + 3 - 5 = 2 &#x3C; max\n2 + 1 - 2 + 4 - 1 + 3 - 5 + 4 = 6 &#x3C; max\n</code></pre>\n<p>Итог: максимум = 7 для последовательности <code>2 1 -2 4 -1 3</code>.</p>\n<h2>Найти отсутствующий элемент</h2>\n<p>Есть массив из N-1 различных чисел от 1 до N. Нужно найти отсутствующий элемент.</p>\n<h3>Решение 1</h3>\n<p>Суммируем все элементы массива и вычитаем результат из ожидаемой суммы всех чисел от 1 до N, которая равна <code>n \\* (n+1) / 2</code>. Результат вычитания будет ответом.</p>\n<h3>Решение 2</h3>\n<p>XOR-им все числа от 1 до N, затем поверх этого XOR-им все элементы нашего массива. Результат будет ответом.</p>\n<p>Вот почему это работает:</p>\n<pre><code>(A1 ^ A2 ^ A3) ^ (A1 ^ A3) = (A1 ^ A1) ^ A2 ^ (A3 ^ A3) = 0 ^ A2 ^ 0 = A2\n</code></pre>\n<h2>Найти точку эквилибриума в массиве</h2>\n<p>Точка эквилибриума - это такой элемент массива, у которого сумма всех элементов слева равна сумме всех элементов справа.</p>\n<h3>Решение 1</h3>\n<p>Допустим, наш исходный массив <code>input</code> равен <code>[1, 2, 3, 4, 5, 6, 7, 2, 9, 10]</code>.</p>\n<p>Создаем массив аггрегированных сумм, где каждый <code>i</code>-й элемент равен сумме элементов <code>0..i-1</code> исходного массива. Полученный массив <code>sums</code> будет таким: <code>[1, 3, 6, 10, 15, 21, 28, 30, 39, 49]</code></p>\n<p>Теперь идем по <code>input</code> справа налево и так же считаем аггрегированные суммы, но на каждом шаге сравниваем полученный элемент с элементом массива <code>sums</code>, стоящим на 2 позиции левее.</p>\n<p>Потом идем справа налево, так же считаем подвижную сумму и сравниваем ее с элементом в массиве сумм на 2 левее текущего. Как только эти значения становятся равны, мы останавливаемся и выдаем в качестве результата элемент, стоящий между ними.</p>\n<p>Для нашего примера, идем по <code>input</code> справа налево и считаем аггрегированную сумму <code>rsum</code>:</p>\n<ol>\n<li>Крайний правый элемент <code>input</code> равен 10, значит <code>rsum = 10</code>. Индекс крайнего правого элемента равен <strong>9</strong>, сравниваем его с <code>sum[7]==30</code>. <strong>10 &#x3C; 30</strong>, поэтому продолжаем.</li>\n<li>Следующий справа элемент <code>input[8]</code> равен 9, сумма <code>rsum</code> становится <strong>10+9=19</strong>, индекс равен <strong>8</strong>, сравниваем с <code>sum[6]==28</code>. <strong>19&#x3C;28</strong>, продолжаем.</li>\n<li>Следующий справа элемент <code>input[7]</code> равен 2, сумма <code>rsum</code> становится <strong>19+2=21</strong>, индекс равен <strong>7</strong>, сравниваем с <code>sum[5]==21</code>. <strong>21==21</strong>, условие выхода выполнилось. Индекс эквилибриума равен <strong>7-1==6</strong>, поэтому возвращаем <code>input[6] == 7</code>.</li>\n</ol>\n<p>Недостаток этого решения в том, что нужен дополнительный массив.</p>\n<h3>Решение 2</h3>\n<p>Этот вариант решения сложнее для реализации, но ему не нужен дополнительный массив.</p>\n<pre><code>Считаем сумму всех элементов массива sum\nleftsum = 0\nrightsum = sum\nИдем по массиву слева направо, на каждом шаге:\n  rightsum -= a[i]\n  Если leftsum == rightsum, то точка эквилибриума найдена\n  leftsum += a[i]\n</code></pre>\n<p>Рассмотрим на нашем примере <code>[1, 2, 3, 4, 5, 6, 7, 2, 9, 10]</code>.</p>\n<table>\n<thead>\n<tr>\n<th>i</th>\n<th>a\n[\ni\n]</th>\n<th>rightsum</th>\n<th>leftsum</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-</td>\n<td>-</td>\n<td>49</td>\n<td>0</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>48</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>2</td>\n<td>46</td>\n<td>3</td>\n</tr>\n<tr>\n<td>2</td>\n<td>3</td>\n<td>43</td>\n<td>6</td>\n</tr>\n<tr>\n<td>3</td>\n<td>4</td>\n<td>39</td>\n<td>10</td>\n</tr>\n<tr>\n<td>4</td>\n<td>5</td>\n<td>34</td>\n<td>15</td>\n</tr>\n<tr>\n<td>5</td>\n<td>6</td>\n<td>28</td>\n<td>21</td>\n</tr>\n<tr>\n<td>6</td>\n<td>7</td>\n<td>21</td>\n<td>21</td>\n</tr>\n</tbody>\n</table>\n<p>В последней строке суммы сошлись, точка эквилибриума найдена, возвращаем <code>a[i]</code>==<strong>7</strong>.</p>\n<h2>External sorting (внешняя сортировка)</h2>\n<p>Применяется для сортировки огромных массивов данных, которые не уменьшаются в память. Массив делится на чанки, помещающиеся в память, каждый из чанков сортируется и пишется на диск. Затем из каждого файла берется начальный мини-чанк и между мини-чанками производится merging на диск. Когда какой-то из мини-чанков пустеет, он заполняется следующими данными из своего файла.</p>\n<h3>Пример</h3>\n<p>Есть 900 МБ файл и 100 МБ памяти.</p>\n<ol>\n<li>Делим файл на 9 чанков по 100 МБ, сортируем каждый quicksort-ом и пишем в отдельный файл на диске.</li>\n<li>Из каждого файла берем первые 10 МБ (мини-чанки) и еще 10 МБ выделяем на выходной буфер.</li>\n<li>Проходим по 9 мини-чанкам, берем первый элемент, ищем минимальный. Когда нашли - аппендим его в выходной буфер, а из мини-чанка удаляем.</li>\n<li>Если после очередного удаления мини-чанк опустел, то заполняем его следующими 10 МБ из его файла.</li>\n<li>Если после очередной записи в выходной буфер он заполнился, то флашим его на диск и очищаем.</li>\n</ol>\n<p>Этап мержа (шаг 3) здесь неэффективен, так как требует приблизительно <code>N * (k - 1)</code> сравнений.</p>\n<p>Можно на этом этапе использовать <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">min-heap</a> с ключом равным первому элементу чанка.</p>\n<h2>QuickSort</h2>\n<pre><code class="language-csharp">public static class QuickSort\n{\n    public static void Sort&#x3C;T>(T[] input) where T:IComparable\n    {\n        SortImpl(input, 0, input.Length);\n    }\n    private static void SortImpl&#x3C;T>(T[] a, int lo, int hi) where T : IComparable\n    {\n        if (hi - lo &#x3C;= 1) return;\n        T pivot = a[lo];\n        int l = lo, r = hi - 1;\n        while (l &#x3C;= r)\n        {\n            while (a[l].CompareTo(pivot) &#x3C; 0 &#x26;&#x26; l &#x3C; hi) l++;\n            while (a[r].CompareTo(pivot) > 0 &#x26;&#x26; r >= lo) r--;\n            if (l &#x3C;= r)\n            {\n                Swap(a, l, r);\n                l++;\n                r--;\n            }\n        }\n\n        Swap(a, lo, l - 1);\n        SortImpl&#x3C;T>(a, lo, l);\n        SortImpl&#x3C;T>(a, l, hi);\n    }\n\n    private static void Swap&#x3C;T>(T[] input, int a, int b)\n    {\n        T tmp = input[a];\n        input[a] = input[b];\n        input[b] = tmp;\n    }\n}\n</code></pre>\n<h2>Красно-черные деревья</h2>\n<p>Это бинарные поисковые деревья, удовлетворяющие следующим условиям:</p>\n<ol>\n<li>Каждый узел может быть либо красным, либо черным</li>\n<li>Корень всегда черный</li>\n<li>Родителем красного узла не может быть красный узел</li>\n<li>Для каждого листового узла количество черных узлов на пути до корня одинаково</li>\n</ol>\n<p>Для обеспечения этих свойств при вставке узла проводится ребалансировка дерева. Сначала пробуем <strong>перекрашивание</strong>, если оно не работает, то <strong>вращение</strong>. Если дядя красный, то перекрашиваем, если черный - то вращаем и/или перекрашиваем.</p>\n<p>Алгоритм вставки (x - вставляемый узел):</p>\n<ol>\n<li>Делаем x красным и производим стандартную вставку в поисковое бинарное дерево</li>\n<li>Если x - корень, то делаем его черным и завершаем вставку, иначе - красным</li>\n<li>Если родитель x - красный и он корень, то просто делаем его черным и завершаем вставку</li>\n<li>\n<p>Если x не корень или родитель x не черный (в этом случае дедушка точно будет черный), то мы получили <strong>красный-красный-черный</strong>, что нарушает свойство 3. Попробуем это исправить:</p>\n<ol>\n<li>если дядя x - красный, то мы можем просто перекрасить папу и дядю, так как они оба красные и перекрашивание их в черный увеличит количество черных узлов для обоих ветвей деда и не нарушит свойство 4. Однако чтобы не менять количество черных в ветвях нашего поддерева и чтобы не пришлось ребалансировать поддерево брата деда, мы еще и перекрашиваем деда в красный:</li>\n<li>перекрашиваем родителя и дядю в черный</li>\n<li>перекрашиваем деда в красный</li>\n</ol>\n</li>\n</ol>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/hows-that-again/static/82ecefc9e11f24696b8b495830836e0a/12550/redBlackCase2.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block;  max-width: 598px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 44.14715719063545%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAA7CAAAOwgEVKEqAAAABxUlEQVQoz21STW/TQBD1/78CV0AKPXCDIiT6QUTiAI1KXYdEiVKrcm23tmN7i5P6e71+zK4bFYmO5N3x7sybN29WA1knBC0dqqpC27bKlzafz6DrY5z9/IHh8CviOFbnrYxvGnRlhU1cg7EaedGiLAU0IS/JcgJ79fIFxpOJ+g/CCuGmQBTnlFCQnyFNa2zTVt07Hz5iPXgPa12hrAHeCHDeQVMVvVvMvxzhwjTx69sIO+M3QvcB5iLDYplhucrguCUcr4YfMpycnsI6m8I9P8d0+h0s6ZlTawRY13AOP8E+/NyfOS7sdwdo4hR+3ML3S/hBRYxLBIGAfjzE67dvsMtzZJQ7GBzAMAyVKrvVGFViIx32agXbdREuFvhj3xCzJZ6s11RcXyE4PkGwvsLasrCkWNu2FWBeFCpG8/QJkssZNlFEDAJqKYQgAI9k4C15jwOSGjvGJW5HYzwwhpDiQ4rlnKthFXtAuZgzE1lRPvERPYjE2g/Nsq4RJQw3JInreXjOZHFNZnWdoJFzYlmRXqWacER+RE9iE/XPgt1z3N2VSFjzqFenAP79FMO9U9cC6ZZju+Mqid03iJMekLfdf0ye26X9BfJwpTrUOmaWAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="red-black tree"\n        title="red black case"\n        src="/hows-that-again/static/82ecefc9e11f24696b8b495830836e0a/12550/redBlackCase2.png"\n        srcset="/hows-that-again/static/82ecefc9e11f24696b8b495830836e0a/412d1/redBlackCase2.png 163w,\n/hows-that-again/static/82ecefc9e11f24696b8b495830836e0a/7102a/redBlackCase2.png 325w,\n/hows-that-again/static/82ecefc9e11f24696b8b495830836e0a/12550/redBlackCase2.png 598w"\n        sizes="(max-width: 598px) 100vw, 598px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<ol start="5">\n<li>\n<p>eсли дяди нет, или дядя х - черный, то мы не можем перекрасить папу в черный, т.к. это увеличит количество черных узлов на одной ветви, оставим неизменным на остальных и автоматически нарушится свойство 4. Поэтому приходится вертеть:</p>\n<ol>\n<li>p - parent узла х, g - grandfather узла х</li>\n<li>возможны 4 случая:</li>\n<li>p слева от g, x слева от p</li>\n<li>p слева от g, x справа от p</li>\n<li>p справа от g, x справа от p</li>\n<li>p справа от g, x слева от p</li>\n<li>Для каждого из этих 4 случаев нам нужно нарушающий свойство 3 путь от x вида <strong>красный-красный-черный</strong> в <strong>красный с двумя черными детьми</strong>. Как это сделать - смотрим на картинке (картинка из другой книги, поэтому там добавляемый узел - не x, а просто тот, который самый нижний и в кружочке. На этих случаях всегда x &#x3C; y &#x3C; z, поэтому y в результате становится корнем поддерева:</li>\n</ol>\n</li>\n</ol>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/hows-that-again/static/9ec20784df658f1f1fc12f837ee7599e/51429/redBlackCase3.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block;  max-width: 414px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 121.73913043478262%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB3ElEQVQ4y6WUWavjMAyF8/9/UZ9KaV8KpaXQQvd93/d90fAZFBwnmdy5IxAxcnQsHR/Z+36/Euefz0ewUqkknU7HrInpvm0a834CCNh4PA4k6vrxeMjr9foZILbb7aRer8t2u/UTsc1mI+l0Wvr9vtm/XC4mngi4Wq1MAvZ+v/34ZDKRVColrVZLarWa7Pf7ZECcyqiCSrVN7Ha7yWw2k/V6bfz5fCYDwiFtxnHoWiSH7i3S5nw+N5y5/yoFtnsuZ24VtALh9/vdv/U4yQQAMYjN5XIhUJWGDUYsk8n43EUCns9nKRQKAQFjSr4NyAH5fD5Qdajldrsty+VSTqeTD4p1u12ZTqeB2OFwMAehgBCgBqrVqqmSJL4YGuRSSBwMBuY/OOVL1WgwEpDKSFCg6/Vqvtls1iQi4GKxaGJckE4LB6moDaC20Gg0ZDQaBWYYWZDEtADK2t5jTQcUonR4SvBisQgRTyVMBFMCr1Stt6pGZ7jmeCoBeCGJk12taTW27lSjHGrneVFj5D5fzWZThsPhX9/D2NGLeg8rlYr0er0QYJQnPl96MQBCjTtq/wzIheHlctmX1K8BFZSpQFK23n4FqBwyDdpyUgGJLQPqavS/AKnqeDwa/myNxvkfZIdT3G/0F04AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="red-black tree"\n        title="red black case"\n        src="/hows-that-again/static/9ec20784df658f1f1fc12f837ee7599e/51429/redBlackCase3.png"\n        srcset="/hows-that-again/static/9ec20784df658f1f1fc12f837ee7599e/1e948/redBlackCase3.png 163w,\n/hows-that-again/static/9ec20784df658f1f1fc12f837ee7599e/19658/redBlackCase3.png 325w,\n/hows-that-again/static/9ec20784df658f1f1fc12f837ee7599e/51429/redBlackCase3.png 414w"\n        sizes="(max-width: 414px) 100vw, 414px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<ol start="6">\n<li>После этого нужно перекрасить наше поддерево, сделав корень черным, а его детей красным.</li>\n</ol>\n<p>Вращение дерева:</p>\n<p><img src="./Tree_Rotations.gif" alt="tree rotation" title="tree rotation"></p>',
frontmatter:{path:"/blog/algorithms",title:"Algorithms"}}},pathContext:{}}}});
//# sourceMappingURL=path---blog-algorithms-468d9f4ec6663363261b.js.map