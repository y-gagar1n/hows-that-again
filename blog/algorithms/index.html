<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/hows-that-again/commons.aea16760827cdd6e3f81.css">html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:112.5%/1.45em georgia,serif;box-sizing:border-box;overflow-y:scroll}*,:after,:before{box-sizing:inherit}body{color:rgba(0,0,0,.8);font-family:georgia,serif;font-weight:400;word-wrap:break-word;-webkit-font-kerning:normal;font-kerning:normal;-ms-font-feature-settings:"kern","liga","clig","calt";font-feature-settings:"kern","liga","clig","calt"}img{max-width:100%;padding:0;margin:0 0 1.45rem}h1{font-size:2.25rem}h1,h2{padding:0;margin:0 0 1.45rem;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h2{font-size:1.62671rem}h3{font-size:1.38316rem}h3,h4{padding:0;margin:0 0 1.45rem;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h4{font-size:1rem}h5{font-size:.85028rem}h5,h6{padding:0;margin:0 0 1.45rem;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h6{font-size:.78405rem}hgroup{padding:0;margin:0 0 1.45rem}ol,ul{padding:0;margin:0 0 1.45rem 1.45rem;list-style-position:outside;list-style-image:none}dd,dl,figure,p{padding:0;margin:0 0 1.45rem}pre{margin:0 0 1.45rem;font-size:.85rem;line-height:1.42;background:rgba(0,0,0,.04);border-radius:3px;overflow:auto;word-wrap:normal;padding:1.45rem}table{font-size:1rem;line-height:1.45rem;border-collapse:collapse;width:100%}fieldset,table{padding:0;margin:0 0 1.45rem}blockquote{padding:0;margin:0 1.45rem 1.45rem}form,iframe,noscript{padding:0;margin:0 0 1.45rem}hr{padding:0;margin:0 0 calc(1.45rem - 1px);background:rgba(0,0,0,.2);border:none;height:1px}address{padding:0;margin:0 0 1.45rem}b,dt,strong,th{font-weight:700}li{margin-bottom:.725rem}ol li,ul li{padding-left:0}li>ol,li>ul{margin-left:1.45rem;margin-bottom:.725rem;margin-top:.725rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,abbr[title],acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}abbr[title]{text-decoration:none}td,th,thead{text-align:left}td,th{border-bottom:1px solid rgba(0,0,0,.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding:.725rem .96667rem calc(.725rem - 1px)}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:SFMono-Regular,Consolas,Roboto Mono,Droid Sans Mono,Liberation Mono,Menlo,Courier,monospace;padding:.2em 0}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{letter-spacing:-.2em;content:" "}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}@media only screen and (max-width:480px){html{font-size:100%}}code[class*=language-],pre[class*=language-]{color:#657b83;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-]::-moz-selection,code[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection{background:#073642}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{background:#073642}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-],pre[class*=language-]{background-color:#fdf6e3}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#93a1a1}.token.punctuation{color:#586e75}.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#268bd2}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string,.token.url{color:#2aa198}.token.entity{color:#657b83;background:#eee8d5}.token.atrule,.token.attr-value,.token.keyword{color:#859900}.token.class-name,.token.function{color:#b58900}.token.important,.token.regex,.token.variable{color:#cb4b16}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}</style><meta name="generator" content="Gatsby 2.15.1"/><title data-react-helmet="true">How&#x27;s that again?</title><meta data-react-helmet="true" name="description" content="Sample"/><meta data-react-helmet="true" name="keywords" content="sample, something"/><style type="text/css">.gatsby-resp-image-image{width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;color:transparent;}</style><link as="script" rel="preload" href="/hows-that-again/app-bf7cab58733aac78b88a.js"/><link as="script" rel="preload" href="/hows-that-again/component---src-templates-blog-template-js-5ea17c1fd24e2203c3a7.js"/><link as="script" rel="preload" href="/hows-that-again/commons-c5dc1b2d2534490c916f.js"/><link as="script" rel="preload" href="/hows-that-again/webpack-runtime-db480cd44fa667b30320.js"/><link as="fetch" rel="preload" href="/hows-that-again/page-data/blog/algorithms/page-data.json" crossorigin="anonymous"/></head><body><noscript id="gatsby-noscript">This app works best with JavaScript enabled.</noscript><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group" id="gatsby-focus-wrapper"><div><div style="background:rebeccapurple;margin-bottom:1.45rem"><div style="margin:0 auto;max-width:960px;padding:1.45rem 1.0875rem;display:flex;justify-content:space-between"><h1 style="margin:0"><a style="color:white;text-decoration:none" href="/hows-that-again/">How&#x27;s that again?</a></h1><span style="margin:auto 0"><form style="margin-bottom:0" method="get" action="https://encrypted.google.com/search"><input type="hidden" name="as_sitesearch" value="y-gagar1n.github.io/hows-that-again"/><input type="text" name="as_q"/><input type="submit" style="margin-left:5px" value="Search"/></form></span></div></div><div style="margin:0 auto;max-width:960px;padding:0px 1.0875rem 1.45rem;padding-top:0"><div class="blog-post-container"><div class="blog-post"><div class="blog-post-content"><h1>Алгоритмы</h1>
<h2>Merge Sort</h2>
<p>Главный недостаток - необходимость использовать дополнительную память для массива размером N, куда мержим. Можно использовать только размер N/2, если копировать в него левый массив и потом мержить этот дополнительный массив и правый массив сразу в оригинал, так что заполняться будет сначала левая половина, потом правая. Это нам сэкономит и память и не надо будет потом смерженный массив копировать в оригинал, так как мы сливаем сразу в оригинале.</p>
<p>Есть два стандартных подхода к реализации - <em>TopDown</em> и <em>BottomUp</em></p>
<p><strong>TopDown</strong> - обычный, через рекурсию</p>
<p><strong>BottomUp</strong> - заводим k, на каждой итерации массив делится на блоки размером 2^k (на первой итерации - 2^0=1), мержим соседние блоки.</p>
<p><strong>BottomUp</strong> по сути делает тоже самое, что и <em>TopDown</em>, только без использования рекурсии, поэтому рекомендуется использовать его.</p>
<h3>In-place реализация</h3>
<p>На практике не используется из-за огромных накладных расходов.</p>
<p>Идея в том, что если у нас есть дополнительная память размером N, в которой допустимо перемешать ключи, то мы можем использовать ее в качестве рабочей области. </p>
<p>Итак, мы сливаем наши два массива, а результат не просто пишем в доп. память, а свапаем с тем значением, которое находится. В конце меняем содержимое доп. памяти и наших двух массивов. Теперь важно, что в качестве этой доп. памяти мы можем использовать еще не отсортированную половину нашего сортируемого массива, например, для сортировки правой половины использовать левую, но второй раз этот трюк использовать не получится, так как если мы теперь для сортировки левой будем использовать уже отсортированную правую, то в ней перемешаются ключи.</p>
<p>Теперь сам алгоритм:</p>
<ol>
<li>Сортируем правую половину, используя левую в качестве рабочей области</li>
<li>Левую половину делим еще на две половины и сортируем левую половину левой половины, используя правую половину левой половины в качестве раб. области</li>
<li>Теперь у нас отсортирована первая 1/4, потом неотсортированная 1/4, потом отсортированная 1/2. Мы мержим обменами сортированную четвертинку и половинку, а выходной итератор устанавливаем в начало несортированной области. После этого у нас сначала идет несортированная 1/4, потом сортированные 3/4.</li>
<li>Делим несортированную 1/4 на 2 половины и повторяем шаги со 2 по 4, но уже для массива размером в 1/4 от общей длины массива. Продолжаем, пока несортированная часть не станет совсем маленькой, после чего вставляем эту часть в сортированный массив, как в методе вставки.</li>
</ol>
<h3>Достоинства:</h3>
<ul>
<li>работает на устройствах последовательного доступа</li>
<li>хорошо сочетается с подкачкой и кэшированием памяти</li>
<li>можно легко параллелить</li>
<li>не имеет "трудных" входных данных</li>
<li>стабильная</li>
</ul>
<h2>Selection sort</h2>
<p>Идем слева направо, ищем минимальный элемент в неотсортированной части массива, когда находим - свапаем с самым правым элементом несортированной части. Этот легче всего реализовать на бумажке.</p>
<h2>Insertion sort</h2>
<p>Идем слева направо, берем самый левый элемент несортированной части и проходим справа налево по сортированной, ищем где его место. Когда находим место - вставляем туда, сдвигая элементы сортированной части направо. </p>
<p>Сильно ускорить можно, если при обмене не менять значения, а просто сдвигать левый направо. Элемент, для которого ищем место, все равно держим в памяти, поэтому в конце просто ставим его в найденное место.</p>
<h2>Shellsort</h2>
<p>Сложность в лучшем случае: <code class="language-text">O(n log n)</code></p>
<p>В худшем: <code class="language-text">O(n log^2 n)</code> - для лучшей известной последовательности пропусков</p>
<p>В среднем случае - зависит от последовательности пропусков.</p>
<p>Совершенствует Insertion Sort. Проблема Insertion Sort в том, что он всегда сравнивает только соседние элементы, поэтому он очень хорошо работает на почти упорядоченном массиве и очень плохо - на обратно упорядоченном.</p>
<p>Shellsort делает несколько проходов Insertion Sort, но на каждом он сортирует каждый <code class="language-text">k</code>-й элемент массива, постепенно уменьшая <code class="language-text">k</code> до 1. Этого можно достигнуть, если в условиях внутреннего цикла Insertion Sort уменьшать индекс при каждой итерации не на 1, а на <code class="language-text">k</code>.</p>
<p>Есть много вариантов последовательностей <code class="language-text">k</code>, самая производительная на сегодняшний день такова: <code class="language-text">[701, 301, 132, 57, 23, 10, 4, 1]</code>.</p>
<h2>Heap</h2>
<p>Представляем дерево в виде массива, у которого <code class="language-text">a[0]</code> - корень, а для <code class="language-text">a[i]</code> дочерними являются элементы <code class="language-text">a[2*i+1], a[2*i+2]</code>.</p>
<p>Свойства кучи:</p>
<ol>
<li>Значение в любой вершине не меньше, чем значения её потомков.</li>
<li>Глубина всех листьев (расстояние до корня) отличается не более чем на 1 слой.</li>
<li>Последний слой заполняется слева направо без «дырок».</li>
</ol>
<p>Свойства 2 и 3 выполняются автоматически, когда храним кучу в массиве.</p>
<p>Для выполнения свойства 1 нужно при каждом изменении элементов вызывать функцию Heapify. Она работает так:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Если i-й элемент меньше, чем любой из его сыновей, то меняем местами i-й элемент с наибольшим из его сыновей, после чего выполняем Heapify для этого сына.
Если же i-й элемент больше своего родителя, то меняем его местами с родителем и вызываем Heapify для родителя.</code></pre></div>
<h3>Добавление</h3>
<p>Кладем элемент в конец массива и вызываем Heapify на этом элементе</p>
<h3>Инициализация</h3>
<p>Чтобы построить кучу из массива, нужно просто вызвать Heapify для всех его элементов, начиная с последнего и кончая первым. Более того, так как начиная с N/2 все элементы - листья, не содержащие потомков, то можем начинать сразу с N/2. В этом случае дерево будет построено за O(N).</p>
<h3>Удаление максимума</h3>
<p>Ставим последний элемент на место первого, уменьшаем размер, вызываем <code class="language-text">Heapify(0)</code>.</p>
<h2>Heap Sort</h2>
<p>Использует бинарное сортирующее дерево (она же куча). </p>
<p>Сам алгоритм состоит из 2 этапов:</p>
<ol>
<li>Строим кучу (О(n) операций)</li>
<li>Удаляем по одному элементу за раз и перестраиваем дерево. Только удаленные элементы мы будем класть сразу в конец нашего массива, в котором и хранится дерево. То есть сначала меняем местами <code class="language-text">a[0]</code> и <code class="language-text">a[n-1]</code>, перестраиваем дерево, состоящее из элементов <code class="language-text">a[0] ... a[n-2]</code>. Потом меняем местами <code class="language-text">a[0]</code> и <code class="language-text">a[n-2]</code>, перестраиваем дерево <code class="language-text">a[0] ... a[n-3]</code> и так далее (О(n log n) операций).</li>
</ol>
<p>Достоинства:</p>
<ul>
<li>сортирует на месте, если хранить и дерево и результат в одном массиве</li>
<li>всегда работает с одинаковой сложностью</li>
</ul>
<p>Недостатки:</p>
<ul>
<li>неустойчив</li>
<li>на почти отсортированных работает так же, как и на хаотичных</li>
<li>выборка делается хаотично по всему массиву, поэтому плохо сочетается с кэшированием и подкачкой</li>
<li>не работает на связанных списках и других структурах последовательного доступа</li>
<li>из-за сложности выигрыш начинается только от больших n (от нескольких тысяч)</li>
</ul>
<h2>Quick Sort</h2>
<h3>Разбиение Ломуто</h3>
<p>Проще в реализации, но менее эффективно.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">algorithm partition(A, lo, hi) is
    pivot := A[hi]
    i := lo    
    for j := lo to hi - 1 do
        if A[j] ≤ pivot then
            swap A[i] with A[j]
            i := i + 1
    swap A[i] with A[hi]
    return i</code></pre></div>
<h3>Разбиение Хоара</h3>
<p>Данная схема использует два индекса (один в начале массива, другой в конце), которые приближаются друг к другу, пока не найдётся пара элементов, где один больше опорного и расположен перед ним, а второй меньше и расположен после. Эти элементы меняются местами. Обмен происходит до тех пор, пока индексы не пересекутся. Очень важно в качестве изначальной <code class="language-text">pivot</code>-точки брать именно серединную, а в циклах сдвига <code class="language-text">left</code> и <code class="language-text">right</code> делать строгое меньше и строгое больше, это гарантирует нам что они остановятся в середине, а не пойдут в другую половину и не улетят за край массива. Алгоритм возвращает последний индекс. Схема Хоара эффективнее схемы Ломуто, так как происходит в среднем в три раза меньше обменов (swap) элементов, и разбиение эффективнее, даже когда все элементы равны.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">algorithm partition(A, lo, hi) is
    pivot := A[(hi+lo)/2]
    i := lo - 1
    j := hi + 1
    loop forever
        do
            i := i + 1
        while A[i] &lt; pivot

        do
            j := j - 1
        while A[j] &gt; pivot

        if i &gt;= j then
            return j

        swap A[i] with A[j]</code></pre></div>
<p>Опорный элемент остается в начале, таким образом попадает в подмножество чисел, которые меньше или равны опорному.</p>
<h3>Варианты улучшения</h3>
<ul>
<li>Insertion Sort на малых подмассивах</li>
<li>Использовать в качестве <code class="language-text">pivot</code>-точки медиану из первого, последнего и серединного значения массива</li>
<li>Если в массиве есть множество элементов с одинаковыми ключами, то можно разбивать на 3 партишна, посередине - с элементами, равными <code class="language-text">pivot</code>. Это можно сделать разбиением Ломуто, только нужно вести 2 счетчика, один вначале серединного партишна и идет слева направо, другой - в конце серединного партишна и идет справа налево</li>
<li>можно уменьшить рекурсивный стек, чтобы он всегда был O(log n) даже для несбалансированного дерева сравнений. Для этого на каждом этапе первый рекурсивный вызов делать для той части массива, которая длинее, а второй вызов элиминировать как хвостовую рекурсию. Если их не менять местами, то дерево получится опять не сбалансировано, так как например в левой части много элементов, в правой 1, мы элиминировали хвостовую рекурсию для правой части, но ничего от этого не выиграли, т.к. там 1 элемент. (можно конечно совсем избавиться от рекурсии, создав ручной стэк и кладя туда элементы, но так мы потратим столько же памяти, сколько и на рекурсивный стек, хотя рекурсии и не будет)</li>
</ul>
<h2>Radix Heap</h2>
<p>(<a href="http://ssp.impulsetrain.com/radix-heap.html">http://ssp.impulsetrain.com/radix-heap.html</a>)</p>
<p>Монотонная очередь с приоритетом. Все ключи должны быть натуральными числами. Разница между максимальным и минимальным ключом не больше определенной константы. Свойство монотонности означает, что нельзя добавлять элементы с ключом, меньшим, чем все имеющиеся к куче ключи.</p>
<p>Сложность операций зависит от разницы между максимальным и минимальным элементом в куые.</p>
<p>Все элементы лежат по бакетам, как в Dictionary. Отдельно хранится переменная <code class="language-text">last_deleted</code>. Элементы, лежащие в бакете <code class="language-text">k</code> <strong>должны</strong> отличаться от <code class="language-text">last_deleted</code> в бите с номером <code class="language-text">k-1</code> (нумерация с 0/с самого младшего бита), <strong>могут</strong> отличаться в битах, младших чем <code class="language-text">k-1</code> и <strong>не должны</strong> отличаться в битах, старших чем <code class="language-text">k-1</code>.</p>
<p>Например, пусть в <code class="language-text">last_deleted</code> лежит 8 и мы пытается посчитать, в каком бакете лежит 10.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">8 = 01000
10 = 01010</code></pre></div>
<p>Нам нушно найти самый старший бит, в котором они различаются, поэтому идем от самого старшего к самому младшему. </p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">4: 0 == 0
3: 1 == 1
2: 0 == 0
1: 0 != 1</code></pre></div>
<p>Значит самый старший отличающийся бит имеет индекс 1, а бакет имеет номер 1 + 1 = 2.</p>
<p>Посчитаем, куда идет ключ 30:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">8 =  001000
30 = 011110

5: 0 == 0
4: 0 != 1

k - 1 = 4, k = 5</code></pre></div>
<p>Получили пятый бакет.</p>
<p>Теперь рассмотрим операции:</p>
<h3>Вставка</h3>
<p>Тут все просто - вычисляем номер бакета и добавляем в него. Номер бакета можно вычислить через XOR:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">bucket_no = highest_bit (new_element XOR last_deleted) + 1</code></pre></div>
<p><strong>ВАЖНО</strong> если на вход функции <code class="language-text">highest_bit</code> поступает 0, то она должна возвращать -1!</p>
<h3>Извлечение</h3>
<p>Находим минимальный бакет, в котором есть элементы, затем линейным поиском ищем в этом бакете минимальный элемент и возвращаем, попутно записав его в <code class="language-text">last_deleted</code>. После этого нам нужно перераспределить оставшиеся элементы в этом бакете в соответствии с новым <code class="language-text">last_deleted</code>, но остальные бакеты перераспределять не надо, так как младшие и так уже пустые, а для старших ничего не изменилось, их не совпадающие биты все еще не совпадают.</p>
<h2>Counting Sort</h2>
<p>Алгоритм сортировки для небольших положительных целых чисел. </p>
<p>Для работы понадобится массив с размером, равным максимально возможному используемому числу. Поэтому применение этого алгоритма целесообразно лишь тогда, когда сортируемые числа имеют (или их можно отобразить в) диапазон возможных значений, который достаточно мал по сравнению с сортируемым множеством. Например, миллион натуральных чисел, меньших 1000.</p>
<p>Состоит из 3 шагов:</p>
<ol>
<li>Вычисление частот</li>
<li>Вычисление индексов</li>
<li>Заполнение результата</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">function countingSort(array, k) is
  count ← new array of k zeros
  for i = 1 to length(array) do
    count[array[i]] ← count[array[i]] + 1
  for i = 2 to k do
    count[i] ← count[i] + count[i - 1]
  for i = length(array) downto 1 do
    output[count[array[i]]] ← array[i]
    count[array[i]] ← count[array[i]] - 1
  return output</code></pre></div>
<p>После первого цикла в массиве <code class="language-text">count</code> хранится для каждого числа количество, сколько раз оно встречается во входном массиве.</p>
<p>Во втором цикле мы записываем в массив <code class="language-text">count</code> т.н. префиксные суммы и после его завершения <code class="language-text">i</code>-е значение массива означает, сколько чисел в исходном массиве меньше, чем <code class="language-text">i</code>. То есть это индекс, на котором должно стоять <code class="language-text">i</code> в результирующем упорядоченном массиве.</p>
<p>В третьем цикле мы заполняем результирующий массив в соответствии с полученным массивом <code class="language-text">count</code>. Мы берем очередное число из входного массива, смотрим какой записан для него индекс в массиве <code class="language-text">count</code> и записываем число в результат по этому индексу. После этого индекс в <code class="language-text">count</code> нужно увеличить, атк как следующее такое число нужно записывать уже на следующую позицию. Сложная логика в этом цикле обусловлена тем, что обычно мы сортируем не просто целые числа, а некие объекты, у которых ключами являются целые числа. Кроме того так мы обеспечиваем стабильность сортировки. </p>
<p>Если же мы сортируем просто целые числа, то мы сразу после первого цикла можем идти по массиву <code class="language-text">count</code> и вставлять в результат <code class="language-text">count[i]</code> копий числа <code class="language-text">i</code>.</p>
<h2>Radix Sort</h2>
<p>Предназначен для сортировки целых чисел, или же любых объектов, которые можно представить в виде целых чисел. Но сложность алгоритма зависит от длины ключа, поэтому лучше чтобы он был не сильно большой.</p>
<p>Исходя из этого, алгоритм часто используют для сортировки строк.</p>
<p>Алгоритм хорош тем, что его сложность составляет <code class="language-text">O(n * m)</code>, где <code class="language-text">n</code> - количество элементов, а <code class="language-text">m</code> - количество знаков в них. В то же время сложность остальных алгоритмов, основанных на сравнении, не может быть ниже чем <code class="language-text">O(n * log n)</code>.</p>
<p>Бывают 2 вида: least significant radix (LSD) и most significant radix (MSD).</p>
<h3>LSD</h3>
<p>Для алгоритма нужно выбрать значение <code class="language-text">r</code>, то есть по какому основанию мы будем работать с числами. Вместе с тем это и количество бакетов. При маленьких <code class="language-text">r</code> алгоритм становится все больше похож на Counting Sort. Ну и вообще, в своей эффективной реализации алгоритм использует Counting Sort, просто повторяет ее для каждого разряда.</p>
<p>Суть алгоритма в том, что мы сначала сортируем по самому младшему разряду, потом по следующему и так до самого старшего.</p>
<p>Например, отсортируем следующий массив (<code class="language-text">r=10</code>):</p>
<p>170, 45, 75, 90, 2, 802, 2, 66</p>
<p>Сортируем сначала по самому младшему разряду:</p>
<p>17<strong>0</strong>, 9<strong>0</strong>, 0<strong>2</strong>, 80<strong>2</strong>, <strong>2</strong>, 4<strong>5</strong>, 7<strong>5</strong>, 6<strong>6</strong></p>
<p>Теперь по второму:</p>
<p><strong>0</strong>2, 8<strong>0</strong>2, <strong>0</strong>2, <strong>4</strong>5, <strong>6</strong>6, 1<strong>7</strong>0, <strong>7</strong>5, <strong>9</strong>0</p>
<p>И наконец по третьему:</p>
<p><strong>0</strong>02, <strong>0</strong>02, <strong>0</strong>45, <strong>0</strong>66, <strong>0</strong>75, <strong>0</strong>90, <strong>1</strong>70, <strong>8</strong>02</p>
<h4>Неэффективная реализация</h4>
<p>Самая простая, неэффективная реализация использует массив очередей (или других массивов), где в очереди <code class="language-text">i</code> лежат элементы, у которых в разряде, соответствующем текущей итерации, записано <code class="language-text">i</code>.</p>
<p>В нашем примере после первого прохода получим следующий массив очередей:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">0: 170, 090
1: 
2: 002, 802, 002
3: 
4: 
5: 045, 075
6: 066
7–9: </code></pre></div>
<p>Затем по порядку вычитываем элементы в одномерный массив:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">170 090 002 802 002 045 075 066</code></pre></div>
<p>Затем опять записываем в массив очередей, ориентируясь уже на второй справа разряд:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">0: 002, 802, 002
1–3: 
4: 045
5: 
6: 066
7: 170, 075
8: 
9: 090</code></pre></div>
<p>Выписываем в 1-мерный массив:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">002 802 002 045 066 170 075 090</code></pre></div>
<p>Третий проход:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">0: 002, 002, 045, 066, 075, 090
1: 170
2–7: 
8: 802
9: </code></pre></div>
<p>Выписываем результат:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">002 002 045 066 075 090 170 802</code></pre></div>
<h4>Эффективная реализация</h4>
<p>Проходим по знакам в числах от наименее значимого к наиболее значимому и для каждого осуществляем Counting Sort.</p>
<p>Если в качестве <code class="language-text">r</code> использовать степени двойки, то разряды будет очень удобно получать двоичными операциями сдвига и XOR:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">b = количество бит в двоичной записи r
mask = 1 &lt;&lt; b
shift = 0

for ...
    c = (a[i] &gt;&gt; shift) &amp; mask
    shift += b</code></pre></div>
<h3>MSD</h3>
<p>Все в основном то же самое, но сортировать начинаем с самого значимого знака. Не гарантирует стабильность. Используется, когда нам нужно, например, отсортировать строки по N первых символов. На каждом этапе разбивает массив на несколько подмассивов (по одному на каждый символ алфавита), которые потом можно сортировать рекурсивно. То есть лучше параллелится, чем LSD.</p>
<h2>Одновременный поиск минимума и максимума в массиве</h2>
<p>Если искать простым линейным поиском, то получим сложность <code class="language-text">O(2n-1)</code> (количество сравнений в худшем случае). Но есть более эффективный алгоритм со сложностью <code class="language-text">O(3n/2)</code>:</p>
<ol>
<li>Разбиваем массив на подмассивы по 2 элемента.</li>
<li>Упорядочиваем каждый из них (n/2 сравнений). После этого у нас на нечетных местах стоят минимальные элементы из пар, а на четных - максимальные.</li>
<li>Находим минимальный среди всех нечетных (n/2 сравнений). При этом если количество элементов нечетное, то взять в качестве начального значения последний элемент.</li>
<li>Находим максимальный среди всех четных (n/2 сравнений). При этом если количество элементов нечетное, то взять в качестве начального значения последний элемент.</li>
</ol>
<p>Итого - 3n/2 сравнений.</p>
<h2>Поиск n-го наименьшего элемента массива без сортировки</h2>
<p>Обычно требуется найти такой элемент за время O(n), а сортировка потребует O(n * log n).</p>
<h3>Quickselect</h3>
<p>Самым популярным алгоритмом тут является Quickselect (от создателя Quicksort). Он работает по тому же принципу что и Quicksort, но на каждом этапе продолжает работать только с одним из полученных партишнов, за счет этого и получается снижение сложности до O(N) в среднем и O(N^2) - в худшем случае.</p>
<h3>Медиана медиан</h3>
<p>Еще есть алгоритм, который обеспечивает O(N) даже в худшем случае. Он похож на Quickselect, но в качестве pivot-точки на каждом этапе выбирается медиана медиан. Для того чтобы ее найти, мы разбиваем массив на подмассивы по 5 элементов, каждый из них сортируем методом вставки (Insertion sort) и выбираем медиану. Затем формируем массив найденных медиан, и рекурсивно ищем его медиану. Когда массив медиан становится &#x3C;= 5, то используем Insertion sort чтоб найти его медиану. В результате получаем индекс медианы медиан, который используем как точку pivot.</p>
<p>Засчет того, что точка pivot у нас всегда является медианой массива, худший случай становится средним и мы получаем сложность O(N) в худшем случае. На практике большое количество операций для поиска точки разбиения сильно раздувает константу и этот метод практически не используется.</p>
<p>Выбор 5 в качестве длины группы объясняется тем, что:</p>
<ul>
<li>в массивах нечетной длины легче искать медиану, т.к. в четных приходится брать середину двух срединных элементов</li>
</ul>
<h2>Хэш-таблица с открытой адресацией</h2>
<p>Обычная хэш-таблица имеет закрытую адресацию - это когда в случае коллизии элемент кладется в список.</p>
<p>В случае открытой адресации при коллизии берется какой-то другой элемент этого же массива. Например, следующий. Если он тоже занят - то следующий за ним. Так как есть коэффициент заполнения, то пустой элемент рано или поздно будет найден.</p>
<p>В случае чтения - точно так же, находим нужный элемент, сравниваем ключ, если не равен - берем следующий, и так пока не найдем нужный.</p>
<p>Когда берем следующий элемент - это называется <strong>линейный поиск</strong> (Linear probing).</p>
<p><strong>Квадратичный поиск</strong> (Quadratic probing) - это когда интервал увеличивается как значение некоторого полинома второй степени.</p>
<p>При использовании метода <strong>двойного хэширования</strong> (иногда его называют <strong>Rehashing</strong>) интервал вычисляется с помощью еще одной хэш-функции. Этот метод приводит к уменьшению коллизий, так как следующий проверяемый элемент зависит от самого ключа. Даже если два разных ключа дают один и тот же хэш, то последовательность просматриваемых элементов для них будет разная.</p>
<h2>Префиксное дерево</h2>
<p>Дерево для хранения данных, ключами которых являются строки. Для каждого узла ребра, соединяющие его с сыновьями, помечены разными символами. Узлы соответствующие концу слова, должны быть помечены. Чтобы найти элемент, нужно начинать с корня и выбирать на i-м уровне то ребро, которое помечено i-м символом в искомом ключе.</p>
<p>Таким образом, ключ, идентифицирующий некий узел, не явно хранится в каком-либо узле, а задается положением узла в дереве. Ключ корня - пустая строка.</p>
<h2>Третичное поисковое дерево</h2>
<p>Тоже дерево для хранения данных со строковыми ключами. Альтернатива префиксным деревьям, тоже может использоваться для автокомплишена.</p>
<p>Каждый узел хранит символ <code class="language-text">c</code> и ссылки на 3 дочерних узла. Слева - все ключи, у которых следующий символ меньше текущего, справа - больше, посередине - равны. Таким образом, влево и вправо мы идем, если нас не устраивает текущий символ, а посередине идем, если он устроил, мы его дописываем к текущему ключу.</p>
<p>Пример:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">          c
        / | \
       a  u  h
       |  |  | \
       t  t  e  u
     /  / |   / |
    s  p  e  i  s</code></pre></div>
<p>В этом дереве записаны слова: "cute","cup","at","as","he","us" и "i".</p>
<p>Эта структура имеет большую сложность поиска, чем префиксное дерево, но при этом для не сильно больших словарей занимает гораздо меньше места, так как для каждого узла хранится всего 3 указателя, а не столько, сколько символов есть в алфавите.</p>
<h2>Union-Find (задача динамической связности)</h2>
<p>Дано N точек с идентификаторами от 0 до N-1. Затем дается список связей между этими точками. Связи транзитивные, то есть если А связано с Б, а Б с В, значит А связано с В. Если на вход подается связь между точками А и Б, а они уже связаны, то эта пара игнорируется. Иначе - точки связываются. В конце выдать, сколько получилось кластеров и каких.</p>
<p>Воспользуемся тем, что точки имеют идентификаторы от 0 до N-1 и будем хранить их в массиве на N элементов. Индекс - идентификатор точки, а значение - идентификатор предыдущего элемента кластера, как если бы элементы кластера были представлены в виде связных списков. </p>
<p>На самом деле для удобного объединения кластеров мы будем хранить их в деревьях, но деревья будут представлены в виде массивов. Каждый элемент хранит индекс родительского элемента, а если индекс элемента равен самому элементу, значит этот элемент - корень своего кластера.</p>
<p>Для поиска, какому кластеру принадлежит элемент, нам нужно "подниматься" в дереве от этого элемента, пока не достигнем корня. А чтобы объединить кластеры, нужно всего лишь корню одного кластера присвоить значение корня другого.</p>
<p>Тогда операции объединения и поиска будут выглядеть так:</p>
<div class="gatsby-highlight" data-language="csharp"><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">int</span> find <span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> p <span class="token operator">=</span> id<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>_ids<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">!=</span> p<span class="token punctuation">)</span> p <span class="token operator">=</span> _ids<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> union <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> ca <span class="token operator">=</span> find <span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>
        cb <span class="token operator">=</span> find <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ca <span class="token operator">==</span> cb<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

    _ids<span class="token punctuation">[</span>ca<span class="token punctuation">]</span> <span class="token operator">=</span> cb<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>В операции <code class="language-text">union</code> есть недостаток - мы не знаем, какой из кластеров больше и в результате у нас получается несбалансированное дерево, по которому операция <code class="language-text">find</code> будет выполняться все дольше и дольше. Для решения проблемы мы можем завести отдельный массив, где храним веса кластеров и всегда мержить меньший кластер к бОльшему.</p>
<h2>Проверка правильности скобок</h2>
<p>Написать функцию, проверяющую правильно расставленные скобки; </p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">check(&quot;{()}[]&quot;) // true     check(&quot;{[}]&quot;) // false</code></pre></div>
<p>Тут решается простым стэком, в котором мы храним открывающие скобки. Когда встречаем открывающую - пушим в стек. Когда встречаем закрывающую - проверяем, что матчится с той, которая лежит на вершине стека и если да, то попим из стэка. </p>
<p>Самое главное:</p>
<ul>
<li>если у нас закрывающая скобка, то сначала проверить, что в стэке еще есть элементы!</li>
<li>когда строка закончилась, проверить что стэк пуст, иначе возвращаем false!</li>
</ul>
<h2>Генерация последовательности скобок</h2>
<p>Делаем через рекурсию, других способов не знаю. Только надо помнить, сколько скобок уже открыли и сколько закрыли. И еще важно <strong>НЕ</strong> ставить <code class="language-text">else</code> между рекурсивными вызовами Generate.</p>
<div class="gatsby-highlight" data-language="csharp"><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">*</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result<span class="token punctuation">.</span>Add <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">string</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>open <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'('</span><span class="token punctuation">;</span>
    Generate <span class="token punctuation">(</span>result<span class="token punctuation">,</span> a<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> open <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> close<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>close <span class="token operator">&lt;</span> open<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">')'</span><span class="token punctuation">;</span>
    Generate <span class="token punctuation">(</span>result<span class="token punctuation">,</span> a<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> open<span class="token punctuation">,</span> close <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<h2>Дерево отрезков</h2>
<p>Структура данных, позволяющая за время O(log n) получить значение некой функции для любого последовательного интервала элементов массива. </p>
<p>Например, у нас есть массив:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">4, 7, -12, 23, -9, 19, 0, 22, 7, 6, -4, 15</code></pre></div>
<p>Дерево отрезков поможет нам быстро найти значение некой аггрегирующей функции (например, поиск минимума/максимума, сумма, произведение) для любого подмассива, например, для <code class="language-text">[7, -12, 23, -9, 19]</code> или <code class="language-text">[-9, 19, 0]</code> или любого другого.</p>
<p>Поддерживается операция обновления (тоже O(log n)).</p>
<p>Рассмотрим работу алгоритма на примере подсчета суммы элементов.</p>
<p>В корне дерева хранится сумма всех элементов массива. В левом ребенке - сумма элементов левой половины, в правом - элементов правой. И так далее рекурсивно вниз, а в листьях хранятся значения функции над единичным интервалом, то есть в случае суммы- сами единичные элементы.</p>
<p>Строится дерево снизу вверх - сначала заполняем нижний уровень, затем считаем значения предыдущего уровня как сумму двух листьев, затем предыдущего и так далее. Строится такое дерево за <code class="language-text">O(n)</code>.</p>
<p>При запросе суммы мы принимаем на вход интервал <code class="language-text">[l..r]</code>, для которого посчитать сумму, встаем в корень дерева и сначала смотрим, совпадают ли границы интервала, соответствующего корню, границам искомого отрезка. Если да - то просто возвращаем значение корня. Если же нет, то смотрим, в какие из двух сыновей попадает отрезок <code class="language-text">[l..r]</code>. Если он целиком попадает в одного из сыновей, то рекурсивно запускаем запрос для этого сына. Если же он пересекается с обоими, то рекурсивно запускаем запрос по левому дереву для отрезка <code class="language-text">[l..n/2]</code>, потом по правому по отрезка <code class="language-text">[n/2+1..r]</code> и суммируем результаты.</p>
<p>Хранится дерево отрезков обычно в виде массива (по аналогии с кучей), где в каждом элементе хранится значение функции над соответствующим элементу интервалом, а детьми элемента с индексом <code class="language-text">i</code> являются элементы <code class="language-text">2*i+1</code> и <code class="language-text">2*i+2</code>. Для массива длиной <code class="language-text">n</code> количество будет не больше, чем <code class="language-text">2n</code>, <strong>НО для массива нужно выделить длину 4<em>n, потому что дерево получится несбалансированное и индексы нижнего уровня могут выходить за пределы 2</em>n</strong>.</p>
<h3>Построение</h3>
<p><code class="language-text">a</code> - исходный массив, <code class="language-text">v</code> - текущая вершина, <code class="language-text">tl</code> и <code class="language-text">tr</code> - границы отрезка, соответствующего текущей вершине дерева. Из основной программы вызывается с параметрами: <code class="language-text">v=0, tl=0,tr=n-1</code>.</p>
<div class="gatsby-highlight" data-language="cs"><pre class="language-cs"><code class="language-cs"><span class="token keyword">void</span> build <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> tl<span class="token punctuation">,</span> <span class="token keyword">int</span> tr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tl <span class="token operator">==</span> tr<span class="token punctuation">)</span>
        t<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>tl<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> tm <span class="token operator">=</span> <span class="token punctuation">(</span>tl <span class="token operator">+</span> tr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        build <span class="token punctuation">(</span>a<span class="token punctuation">,</span> v<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">,</span> tl<span class="token punctuation">,</span> tm<span class="token punctuation">)</span><span class="token punctuation">;</span>
        build <span class="token punctuation">(</span>a<span class="token punctuation">,</span> v<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> tm<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> tr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">[</span>v<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> t<span class="token punctuation">[</span>v<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<h3>Запрос суммы</h3>
<p><code class="language-text">v</code> - текущая вершина, <code class="language-text">tl</code> и <code class="language-text">tr</code> - границы отрезка, соответствующего текущей вершине дерева, <code class="language-text">l</code> и <code class="language-text">r</code> - границы запроса. При первом запуске подаются параметры <code class="language-text">v=0, tl=0, tr=n-1</code>.</p>
<div class="gatsby-highlight" data-language="cs"><pre class="language-cs"><code class="language-cs"><span class="token keyword">int</span> sum <span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> tl<span class="token punctuation">,</span> <span class="token keyword">int</span> tr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">></span> r<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> tl <span class="token operator">&amp;&amp;</span> r <span class="token operator">==</span> tr<span class="token punctuation">)</span>
        <span class="token keyword">return</span> t<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> tm <span class="token operator">=</span> <span class="token punctuation">(</span>tl <span class="token operator">+</span> tr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sum <span class="token punctuation">(</span>v<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">,</span> tl<span class="token punctuation">,</span> tm<span class="token punctuation">,</span> l<span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span>tm<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token operator">+</span> sum <span class="token punctuation">(</span>v<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> tm<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> tr<span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>tm<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<h3>Запрос модификации</h3>
<p><code class="language-text">v</code> - текущая вершина, <code class="language-text">tl</code> и <code class="language-text">tr</code> - границы отрезка текущей вершины, <code class="language-text">pos</code> - индекс меняющегося элемента, <code class="language-text">new_val</code> - его новое значение.</p>
<div class="gatsby-highlight" data-language="cs"><pre class="language-cs"><code class="language-cs"><span class="token keyword">void</span> update <span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> tl<span class="token punctuation">,</span> <span class="token keyword">int</span> tr<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> new_val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tl <span class="token operator">==</span> tr<span class="token punctuation">)</span>
        t<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> new_val<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> tm <span class="token operator">=</span> <span class="token punctuation">(</span>tl <span class="token operator">+</span> tr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;=</span> tm<span class="token punctuation">)</span>
            update <span class="token punctuation">(</span>v<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">,</span> tl<span class="token punctuation">,</span> tm<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> new_val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            update <span class="token punctuation">(</span>v<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> tm<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> tr<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> new_val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">[</span>v<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> t<span class="token punctuation">[</span>v<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<h2>Алгоритм Кнута-Морриса-Пратта</h2>
<p>Алгоритм поиска подстроки длиной <code class="language-text">n</code> в строке длиной <code class="language-text">m</code>. Основывается на префикс-функции. Решает задачу за <code class="language-text">O(n+m)</code> и <code class="language-text">O(n)</code> памяти.</p>
<h3>Префикс-функция</h3>
<p>Для строки <code class="language-text">s</code> длиной <code class="language-text">n</code> префикс-функция это такой массив <code class="language-text">p</code> длиной <code class="language-text">n</code>, в котором <code class="language-text">p[i]</code> означает длину наибольшего нетривиального (не равного самой строке) префикса, совпадающего с суффиксом для строки <code class="language-text">s[0..i]</code></p>
<p>Например, для строки "abcabcd" префикс-функция равна: <code class="language-text">[0, 0, 0, 1, 2, 3, 0]</code>, что означает:</p>
<ul>
<li>у строки "a" нет нетривиального префикса, совпадающего с суффиксом;</li>
<li>у строки "ab" нет нетривиального префикса, совпадающего с суффиксом;</li>
<li>у строки "abc" нет нетривиального префикса, совпадающего с суффиксом;</li>
<li>у строки "abca" префикс длины 1 совпадает с суффиксом;</li>
<li>у строки "abcab" префикс длины 2 совпадает с суффиксом;</li>
<li>у строки "abcabc" префикс длины 3 совпадает с суффиксом;</li>
<li>у строки "abcabcd" нет нетривиального префикса, совпадающего с суффиксом.</li>
</ul>
<h4>Нахождение префикс-функции</h4>
<p>Этот алгоритм не содержит явных сравнений строк и выполняет <code class="language-text">O(n)</code> действий.</p>
<p>Пусть мы, идя от <code class="language-text">s[0]</code> к <code class="language-text">s[n]</code> дошли до некоторого индекса <code class="language-text">i</code> и вычислили его префикс-функцию <code class="language-text">p[i] = j</code>.</p>
<p>Тогда для <code class="language-text">i+1</code> префикс-функция увеличится на 1 только в том случае, если <code class="language-text">s[i+1] == s[j]</code>. (1)</p>
<p>Если же они не равны, то нам нужно найти такое значение <code class="language-text">k</code>, которое меньше <code class="language-text">p[i]</code>, но при этом для него все еще выполняется условие "префикс равен суффиксу", и когда мы найдем такое значение, сможем попробовать условие <code class="language-text">s[i+1] == s[k]</code> для него. То есть мы знаем, что <code class="language-text">s[0..j-1] == s[i-j..i-1]</code> и нам нужно найти <code class="language-text">k</code>, такое, что <code class="language-text">k&lt;j</code> и <code class="language-text">s[0..k-1] == s[i-k..i-1]</code>. Но у нас уже есть такое значение, мы его получили, когда вычисляли префикс-функцию для строки <code class="language-text">s[0..j-1]</code>. Поэтому берем <code class="language-text">j=p[j-1]</code> и проверяем, выпонляется ли условие 1: <code class="language-text">s[i+1] == s[j]</code>. Если нет, то повторяем уменьшение <code class="language-text">j</code>, пока не дойдем до нуля.</p>
<p>Итак, получили такой алгоритм:</p>
<ul>
<li>Считать значения префикс-функции <code class="language-text">p[i]</code> будем по очереди: от <code class="language-text">i=1</code> к <code class="language-text">i=n-1</code> (значение <code class="language-text">p[0]</code> просто присвоим равным нулю).</li>
<li>Для подсчёта текущего значения <code class="language-text">p[i]</code> мы заводим переменную <code class="language-text">j</code>, обозначающую длину текущего рассматриваемого образца. Изначально <code class="language-text">j = p[i-1]</code>.</li>
<li>Тестируем образец длины <code class="language-text">j</code>, для чего сравниваем символы <code class="language-text">s[j]</code> и <code class="language-text">s[i]</code>. Если они совпадают — то полагаем <code class="language-text">p[i] = j+1</code> и переходим к следующему индексу <code class="language-text">i+1</code>. Если же символы отличаются, то уменьшаем длину <code class="language-text">j</code>, полагая её равной <code class="language-text">p[j-1]</code>, и повторяем этот шаг алгоритма с начала.</li>
<li>Если мы дошли до длины <code class="language-text">j=0</code> и так и не нашли совпадения, то останавливаем процесс перебора образцов и полагаем <code class="language-text">p[i] = 0</code> и переходим к следующему индексу <code class="language-text">i+1</code>.</li>
</ul>
<p>Алгоритм требует хранения самой строки и предыдущих вычисленных значений префикс-функции, однако, как нетрудно заметить, если нам заранее известно максимальное значение, которое может принимать префикс-функция на всей строке, то достаточно будет хранить лишь на единицу большее количество первых символов строки и значений префикс-функции.</p>
<h3>Поиск подстроки</h3>
<p>Допустим, нам надо найти подстроку <code class="language-text">s</code> длиной <code class="language-text">n</code> в тексте <code class="language-text">t</code>. Для этого мы: </p>
<ol>
<li>выбираем некий специальный символ <code class="language-text">#</code>, которого точно нет ни в <code class="language-text">s</code>, ни в <code class="language-text">t</code></li>
<li>составляем строку <code class="language-text">Q = s + &quot;#&quot; + t</code></li>
<li>вычисляем префикс-функцию <code class="language-text">P</code> для <code class="language-text">Q</code></li>
<li>просматриваем значения <code class="language-text">P</code>, начиная с индекса <code class="language-text">n+1</code>. Там, где <code class="language-text">P[i] == n</code> - <code class="language-text">i</code> обозначает индекс очередного вхождения <code class="language-text">s</code> в <code class="language-text">t</code>, а начало вхождения будет по индексу <code class="language-text">i - (n + 1) - n + 1 = i - 2n</code>.</li>
</ol>
<h3>Количество различных подстрок в строке</h3>
<p>Допустим, мы знаем текущее количество подстрок и хотим посчитать новое количество при добавлении одного символа (допустим, это символ <code class="language-text">c</code>).</p>
<p>В идеале при добавлении символа <code class="language-text">c</code> к строке <code class="language-text">s</code> длиной <code class="language-text">n</code> мы получаем <code class="language-text">n</code>+1 новых подстрок, каждая из которых оканчивается на <code class="language-text">c</code>. (не обязательно различных).</p>
<p>Теперь узнаем, какие из них уже были в строке <code class="language-text">s</code>.</p>
<p>Для этого мы добавляем символ <code class="language-text">c</code>, разворачиваем полученную строку <code class="language-text">s+c</code> и ищем для нее префикс-функцию. Она нам покажет, встречались ли уже внутри <code class="language-text">s</code> каждая из подстрок, оканчивающихся на <code class="language-text">c</code> . Найдя максимум префикс функции <code class="language-text">m=max(p[0..n])</code>, мы можем быть уверены, что подстрока длиной <code class="language-text">m</code>, оканчивающаяся на символ <code class="language-text">c</code> уже встречалась ранее в строке <code class="language-text">s</code>, а значит и все строки длиной <code class="language-text">1..m</code> тоже там встречались.</p>
<p>Итак, при добавлении 1 символа добавляются <code class="language-text">s.length + 1 - max(p[0..s.length + 1])</code> различных подстрок. </p>
<p>Построение префикс функции - O(n), выполнение вышеописанной операции для каждого символа - O(n), итого получили O(N^2).</p>
<h2>Алгоритм Бойера-Мура</h2>
<p>Алгоритм поиска подстроки в строке, считается наиболее быстрым среди алгоритмов общего назначения, предназначенных для поиска подстроки в строке. </p>
<p>Суть алгоритма в том, что мы идем по тексту слева направо (допустим, переменной <code class="language-text">i</code>), а с паттерном сверяем справа налево (допустим, переменной <code class="language-text">j</code>). Как только встречаем несовпадающий символ (допустим, в паттерне <code class="language-text">p</code>, а в тексте <code class="language-text">c</code>) - шаблон сразу сдвигается на <em>несколько</em> символов вправо и сверять начинаем опять с конца.</p>
<p>Важно то, как определить, сколько символов эти <em>несколько</em>:</p>
<ol>
<li>если в паттерне вообще нет символа <code class="language-text">c</code> - сдвигаем паттерн на <code class="language-text">j+1</code></li>
<li>если есть, то сдвигаем на <code class="language-text">j</code> минуc самая правая позиция, в которой <code class="language-text">c</code> встречается в паттерне. Чтобы знать эти значения, таблица таких позиций составляется заранее</li>
<li>если же паттерн в результате не сдвинулся вправо (сдвиг получился меньшим или равным нулю), принудительно его сдвигаем на 1 позицию</li>
</ol>
<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token class-name">BoyerMoore</span><span class="token punctuation">(</span><span class="token class-name">String</span> pat<span class="token punctuation">)</span>
<span class="token punctuation">{</span>                               <span class="token comment">// Compute skip table.</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>pat <span class="token operator">=</span> pat<span class="token punctuation">;</span>
  <span class="token keyword">int</span> <span class="token class-name">M</span> <span class="token operator">=</span> pat<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> <span class="token class-name">R</span> <span class="token operator">=</span> <span class="token number">256</span><span class="token punctuation">;</span>
  right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">R</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> <span class="token class-name">R</span><span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span>
     right<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>             <span class="token comment">// -1 for chars not in pattern</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token class-name">M</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token comment">// rightmost position for</span>
     right<span class="token punctuation">[</span>pat<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>  <span class="token comment">//   chars in pattern</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token class-name">String</span> txt<span class="token punctuation">)</span>
<span class="token punctuation">{</span>  <span class="token comment">// Search for pattern in txt.</span>
    <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> txt<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token class-name">M</span> <span class="token operator">=</span> pat<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> skip<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">N</span><span class="token operator">-</span><span class="token class-name">M</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> skip<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>  <span class="token comment">// Does the pattern match the text at position i ?</span>
       skip <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token class-name">M</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>pat<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">!=</span> txt<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token punctuation">{</span>
             skip <span class="token operator">=</span> j <span class="token operator">-</span> right<span class="token punctuation">[</span>txt<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
             <span class="token keyword">if</span> <span class="token punctuation">(</span>skip <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> skip <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
             <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>skip <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token class-name">N</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<h2>Двоичное дерево</h2>
<p>В левом поддереве - значения строго меньше корня. В правом - больше или равные корню.</p>
<p>Здесь самое сложное - это удаление.</p>
<h3>Удаление элемента</h3>
<p>Сначала находим удаляемый узел. </p>
<p>Если детей у него нет - прекрасно, просто удаляем.</p>
<p>Если есть один ребенок - тоже неплохо, удаляем узел, ставим вместо него ребенка.</p>
<p>Если же 2 ребенка, то берем следующий по возрастанию элемент, а это будет самый левый узел правого поддерева удаляемого узла, и ставим его на место удаляемого, не забыв связать с детьми.</p>
<p>А если у правого поддерева нет левого узла, то ставим правого ребенка удаляемого узла на место удаляемого.</p>
<h2>Динамическое программирование</h2>
<p><em>Динамическое программирование — это когда у нас есть задача, которую непонятно как решать, и мы разбиваем ее на меньшие задачи, которые тоже непонятно как решать. (с) А.Кумок</em></p>
<p>Способ решения сложных задач путем разбиения их на более простые подзадачи. Применим к задачам с <strong>оптимальной подструктурой</strong>, выглядящим как набор перекрывающихся подзадач, сложность которых чуть меньше исходной.</p>
<p>Задача имеет <strong>оптимальную подструктуру</strong>, если её оптимальное решение может быть рационально составлено из оптимальных решений её подзадач.</p>
<p>Два главных приема, используемых в динамическом программировании:</p>
<ol>
<li>Мемоизация</li>
<li>Восходящий анализ</li>
</ol>
<p>Например, такая задача: есть доска, игрок стартует в левом верхнем углу, может идти только вниз и направо. Посчитать количество маршрутов до правого нижнего угла.</p>
<p>Легко заметить, что количество маршрутов в любую точку можно получить как сумму количества маршрутов в соседнюю сверху и соседнюю слева точку. Но если мы будем решать задачу рекурсивно "сверху вниз", то это будет слишком неэффективно, поэтому задачи динамического программирования обычно решаются "снизу вверх" (в этом случае обязательно должны быть заданы начальные состояния), как здесь:</p>
<div class="gatsby-highlight" data-language="cs"><pre class="language-cs"><code class="language-cs"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">Imax</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">Jmax</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>Imax<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>Jmax<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment">// Если это левая или верхняя граница, то есть только один способ туда попасть. Это и есть наши начальные состояния.</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
        
System<span class="token punctuation">.</span><span class="token keyword">out</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token class-name">Imax</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">Jmax</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Другая задача:</p>
<p>При переработке радиоактивных материалов образуются отходы двух видов — особо опасные (тип A) и неопасные (тип B). Для их хранения используются одинаковые контейнеры. После помещения отходов в контейнеры последние укладываются вертикальной стопкой. Стопка считается взрывоопасной, если в ней подряд идет более одного контейнера типа A. Стопка считается безопасной, если она не является взрывоопасной. Для заданного количества контейнеров N определить количество возможных типов безопасных стопок.</p>
<p>Здесь количество способов сложить стопку высотой i складывается из </p>
<ul>
<li>количества стопок высотой i-1, на которые мы можем положить B </li>
<li>количества стопок высотой i-1 с контейнером В на вершине, на который мы можем положить А</li>
</ul>
<p>Второе количество в свою очередь получается как количество стопок высотой i-2, так как на каждую такую стопку мы можем положить сверху контейнер В</p>
<p>Итак, получили такой алгоритм:</p>
<div class="gatsby-highlight" data-language="cs"><pre class="language-cs"><code class="language-cs"><span class="token keyword">static</span> <span class="token keyword">int</span> Calculate <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<h2>Решатель математических выражений</h2>
<p>Разберем парсинг и решение выражений на примере самой базовой формы - когда все операторы разделены пробелами, а пары операторов - скобками. Нам нужно понять только основной принцип, поэтому остальное бдует мешать.</p>
<p>Пример входа:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">( 1 + ( ( 2 + 3 ) * ( 4 * 5 ) ) )</code></pre></div>
<h3>Алгоритм</h3>
<p>Заводим 2 стэка - один для операндов, другой для операторов.</p>
<p>Проходим по всем токенам слева направо.</p>
<p>Если текущий токен - число: пушим его в стэк операндов</p>
<p>Если текущий токен - оператор: пушим его в стэк операторов</p>
<p>Если текущий токен - закрывающая скобка: попаем 2 операнда и один оператор, выполняем соответствующую операцию, результат пушим в стэк операндов</p>
<p>Если текущий токен - открывающая скобка: игнорируем</p>
<p>Когда закончим итерировать по выражению, если оно составлено правильно, то в стэке операторов останется один элемент, который и будет общим результатом.</p>
<h2>Графы</h2>
<h3>Поиск в глубину</h3>
<ol>
<li>Начинаем с указанной вершины v</li>
<li>Помечаем v как посещенный</li>
<li>Выбираем не помеченных соседей v</li>
<li>Для каждого из них рекурсивно вызываем процедуру поиска (если не нравится рекурсия - можно в стэк складывать вершины, потом возвращаться в пункт 1 и доставать из стэка следующую, только не забыть проверить ее метку, прежде чем начинать с ней работать)</li>
</ol>
<p>Все!</p>
<h4>Применение</h4>
<ul>
<li>поиск маршрута между вершинами. Для этого в процессе поиска в глубину заводим массив <code class="language-text">edgeTo</code>, куда для каждой вершины <code class="language-text">w</code> пишем вершину <code class="language-text">v</code>, из которой мы в нее пришли. В результате получаем массив, по которому за O(n) можем выдать маршрут (не обязательно кратчайший) из любой вершины в указанную.</li>
<li>поиск связанных компонент. Для этого делаем DFS, после завершения все помеченные вершины будут принадлежать одному связанному компоненту. Чтобы найти остальные - берем первую непомеченную вершину и запускаем поиск в глубину от нее. Лучше всего - идти в цикле по всем вершинам и запускать DFS для непомеченных, так рано или поздно будут помечены все.</li>
<li>топологическая сортировка. Похоже на поиск связанных компонент, только каждую обработанную вершину кладем в стек, ну или очередь, в зависимости от направления связи. И еще - такой алгоритм сработает только при использовании рекурсии. </li>
<li>поиск циклов в графе. Похож на поиск маршрута, но основывается на идее что если в текущем стэке нам два раза встретилась одна и та же вершина, значит цикл есть. Поэтому заводим новый массив <code class="language-text">bool[] onStack</code>, устанавливаем в <code class="language-text">true</code> текущую вершину в начале работы с ней, а в конце - ставим <code class="language-text">false</code>, и когда берем очередную вершину <code class="language-text">i</code> - проверяем, не равен ли истине <code class="language-text">onStack[i]</code>. Если нужно вернуть сам цикл, то поддерживаем еще и <code class="language-text">edgeTo</code> так же, как и в задаче поиска пути</li>
<li>в направленном графе применяется для поиска достижимых объектов при сборке мусора</li>
</ul>
<h3>Поиск в ширину</h3>
<p>Позволяет найти самый короткий маршрут между вершинами. Используется, например, для нахождения числа Кевина Бэйкона.</p>
<p>В целом тоже самое, что и поиск в глубину, только на 4 шаге вместо стэка используем очередь.</p>
<h3>Минимальное остовное дерево</h3>
<p>Остовное дерево - это дерево, соединяющее все вершины графа. Минимальное остовное дерево взвешенного графа - остовное дерево, имеющее минимальный вес.</p>
<p>Сразу оговоримся, что указанные здесь алгоритмы <strong>не работают для направленных графов</strong>. Для них проблема носит другое название - <em>minimum cost arborescence</em> problem.</p>
<h4>Алгоритм Прима</h4>
<p>При количестве ребер, равном Е, алгоритм использует О(E) места и О(E log E) времени.</p>
<p>Сначала берётся произвольная вершина и находится ребро, инцидентное данной вершине и обладающее наименьшей стоимостью. Найденное ребро и соединяемые им две вершины образуют дерево. Затем, рассматриваются рёбра графа, один конец которых — уже принадлежащая вершине дерева, а другой — нет; из этих рёбер выбирается ребро наименьшей стоимости. Выбираемое на каждом шаге ребро присоединяется к дереву. Рост дерева происходит до тех пор, пока не будут исчерпаны все вершины исходного графа.</p>
<p>Здесь главная сложность - в том, чтобы на каждом шаге находить ребро наименьшей стоимости. </p>
<p>Для этого нам понадобятся:</p>
<ul>
<li>массив <code class="language-text">marked</code>, в котором истиной обозначены те вершины, которые уже внесены в остовное дерево</li>
<li>массив <code class="language-text">edgeTo</code>, в который мы будем заносить ребра, внесенные в остовное дерево</li>
<li>очередь с приоритетом <code class="language-text">MinPQ&lt;Edge&gt;</code> содержащая все ребра от внесенных вершин к еще не внесенным. Эта очередь позволит нам на каждой итерации брать ребро с наименьшим весом.</li>
</ul>
<p>При добавлении новой вершины мы добавляем в очередь все ее ребра, которые соединяют ее с вершинами, еще не внесенными в <code class="language-text">marked</code>.</p>
<p>А еще, когда добавляем новую вершину, то нужно пройтись по очереди приоритетов и удалить ребра, которые содиняют добавленную вершину с добавленными ранее вершинами. Но можно это сейчас не делать, а просто когда достаем ребра из очереди, проверять, что оно соединяет включенную вершину с еще не включенной.</p>
<h4>Алгоритм Крускала</h4>
<p>Алгоритм Крускала изначально помещает каждую вершину в своё дерево, а затем постепенно объединяет эти деревья, объединяя на каждой итерации два некоторых дерева некоторым ребром. Перед началом выполнения алгоритма, все рёбра сортируются по весу (в порядке неубывания). Затем начинается процесс объединения: перебираются все рёбра от первого до последнего (в порядке сортировки), и если у текущего ребра его концы принадлежат разным поддеревьям, то эти поддеревья объединяются, а ребро добавляется к ответу. По окончании перебора всех рёбер (E=V-1) все вершины окажутся принадлежащими одному поддереву, и ответ найден.</p>
<p>Для поддержания леса деревьев и быстрого поиска циклов можем использовать структуру <strong>Union-Find</strong>. Либо же простой массив <code class="language-text">tree_id[n]</code>, но линейный поиск по нему навредит нашему перформансу.</p>
<h3>Поиск кратчайшего пути в направленном взвешенном графе</h3>
<h4>Алгоритм Дейкстры</h4>
<p>Алгоритм использует O(V) места и O(E log V) времени. Работает, даже если в графе есть циклы.</p>
<p>Находит минимальные расстояния от некой вершины <code class="language-text">a</code> до всех остальных вершин графа.</p>
<p>Каждой вершине графа сопоставим метку — минимальное известное расстояние от этой вершины до <code class="language-text">a</code>. Алгоритм работает пошагово — на каждом шаге он «посещает» одну вершину и пытается уменьшать (<em>relax</em>) метки. Работа алгоритма завершается, когда все вершины посещены. Теперь подробнее.</p>
<p><strong>Инициализация.</strong> Метка самой вершины <code class="language-text">a</code> полагается равной 0, метки остальных вершин — бесконечности. Это отражает то, что расстояния от <code class="language-text">a</code> до других вершин пока неизвестны. Все вершины графа помечаются как непосещённые.</p>
<p><strong>Шаг алгоритма.</strong> Если все вершины посещены, алгоритм завершается. В противном случае, из ещё не посещённых вершин выбирается вершина <code class="language-text">u</code>, имеющая минимальную метку (на первом шаге это будет <code class="language-text">a</code>, так как ее метка равна 0, а метки всех остальных вершин - бесконечности). Мы рассматриваем всевозможные маршруты, в которых <code class="language-text">u</code> является предпоследним пунктом. Вершины, в которые ведут рёбра из u, назовём соседями этой вершины. Для каждого соседа вершины <code class="language-text">u</code>, кроме отмеченных как посещённые, рассмотрим новую длину пути, равную сумме значений текущей метки <code class="language-text">u</code> и длины ребра, соединяющего <code class="language-text">u</code> с этим соседом. Если полученное значение длины меньше значения метки соседа, заменим значение метки полученным значением длины. Рассмотрев всех соседей, пометим вершину u как посещённую и повторим шаг алгоритма.</p>
<p>Вообще алгоритм похож на алгоритм Прима, только там на каждом шаге к дереву добавляется вершина, которая ближе всего к <em>дереву</em>, а здесь - та, которая ближе всего к <em>источнику</em>.</p>
<h5>Реализация</h5>
<p>Нвм понадобятся:</p>
<ul>
<li>очередь с приоритетом, чтобы всегда знать, у какой вершины минимальная метка. Причем эта очередь должна поддерживать возможность изменения элементов, а значит поддерживать внутри себя еще словарь, ассоциирующий ключ с индексом элемента во внутренней коллекции.</li>
<li>массив <code class="language-text">distTo[n]</code>, в котором для каждой вершины будет храниться ее метка (она же текущее минимальное расстояние от нее до <code class="language-text">a</code>). Он нам нужен, чтобы, проходя по всем соседям выбранной вершины, знать их метки</li>
<li>массив <code class="language-text">edgeTo[n]</code>, в котором для каждой вершины хранится ее родительская на кратчайшем пути от <code class="language-text">a</code> к ней. Этот массив нам нужен, чтобы иметь возможность в конце выдать найденный путь</li>
</ul>
<h4>Быстрый алгоритм для ацикличных графов</h4>
<p>Если графов точно нет, то можно воспользоваться гораздо более простым и быстрым алгоритмом:</p>
<ul>
<li>массив <code class="language-text">distTo</code> инициализируется так же, каки в алгоритме Дейкстры - 0 для стартовой вершины, бесконечность для остальных</li>
<li>идем по вершинам графа в порядке топологической сортировки</li>
<li>для каждой вершины вызываем процедуру ослабления, то есть проходим по всем ребрам, исходящим из нее и для всех вторых вершин смотрим, является ли их текущая метка больше, чем вес ребра плюс метка первой вершины, и если да, то обновляем</li>
</ul>
<h3>LSM-дерево</h3>
<p>Состоит из:</p>
<ul>
<li>лога на диске, куда последовательно записываются все новые данные</li>
<li>один большой и несколько маленьких SSTable на диске - индексы по логу</li>
<li>MemTable - сбалансированное бинарное дерево поиска, хранимое в памяти.</li>
</ul>
<p>SSTable - представляет из себя последовательные записи ключ-значение, отсортированные по ключу. SSTable иммутабелен, как только он создан и сохранен на диск, он больше никогда не меняется. </p>
<p>SSTable состоит из множества блоков по 64 КБ (настраивается), и индекса в конце. Индекс держится в памяти. Когда нам нужно что-то найти, то проходимся по этому индексу бинарным поиском, узнаем в каком блоке лежит этот ключ, читаем с диска весь блок за раз и последовательно проходим по нему в поисках нужного нам ключа.</p>
<h4>Запись</h4>
<ol>
<li>Пишем данные в лог на диск</li>
<li>Пишем смещение в логе для этого ключа в MemTable в памяти</li>
<li>Когда MemTable становится большим - пишем его на диск в виде SSTable. Это легко сделать, так как из дерева поиска легко получить отсортированный массив.</li>
<li>Когда SSTable-ов становится слишком много, мержим их в один большой сегмент.</li>
</ol>
<h4>Поиск</h4>
<ol>
<li>Сначала ищем в MemTable</li>
<li>Если не нашли - ищем в последнем записанном на диск SSTable</li>
<li>Если не нашли - то в предыдущем, и так далее.</li>
</ol>
<p>Очень затратно будет искать ключ, которого нет, поэтому обычно для каждого SSTable поддерживается еще фильтр Блума, который позволяет однозначно сказать, если какого-то ключа в индексе нет.</p>
<h4>Обновление</h4>
<p>Просто пишем  новое значение, старое остается на диске, но так как при поиске мы ищем от новых к старым, то старое в дальнейшем будет игнорироваться.</p>
<h4>Удаление</h4>
<p>Через tombstone.</p>
<h2>Сумма двух</h2>
<p>Имея массив целых чисел, нужно вернуть индексы двух элементов, сумма которых будет равна заданному числу</p>
<h3>Пример</h3>
<p>Допустим, у нас есть массив <code class="language-text">nums == [2, 7, 11, 15]</code> и нужно получить число 9.</p>
<p>Так как <code class="language-text">nums[0] + nums[1] == 2 + 7 == 9</code>, то возвращаем массив индексов <code class="language-text">[0,1]</code>.</p>
<h3>Решение</h3>
<ol>
<li>Сортируем массив по возрастанию;</li>
<li>Идем по массиву с двух концов навстречу друг другу счетчиками i (слева) и j (справа);</li>
<li>Если <code class="language-text">nums[i] + nums[j] &lt; target</code>, то увеличиваем i;</li>
<li>Иначе, если <code class="language-text">nums[i] + nums[j] &gt; target</code>, то уменьшаем j;</li>
<li>Если же <code class="language-text">nums[i] + nums[j] == target</code>, то очевидно возвращаем <code class="language-text">[i, j]</code>.</li>
</ol>
<h2>Самая длинная подстрока без повторяющихся символов</h2>
<p>Имея строку, найти в ней самую длинную подстроку без повторяющихся символов.</p>
<h3>Примеры</h3>
<p>"abcabcbb" => "abc"</p>
<p>"bbbbb" => "b"</p>
<p>pwwkew => "wke"</p>
<h3>Решение</h3>
<p>Для решения используем так называемое скользящее окно - это подстрока нашей входной строки <code class="language-text">input</code>, которая не содержит повторяющихся символов, начинается в начале <code class="language-text">input</code> и постепенно движется (скользит) по направлению к ее концу.</p>
<p>Нам понадобится словарь символов, у которого ключом будет символ, а значением - индекс последнего такого символа в строке, который нам встретился. Назовем этот словарь <strong>s</strong>. Если известно, что все символы входят в некое подмножество/алфавит (например, символы латинского алфавита a-z), то можно вместо словаря использовать массив на <code class="language-text">n</code> элементов, где n = длина алфавита.</p>
<ol>
<li>Инициализируем <code class="language-text">start=0</code>, это будет левая граница нашего скользящего окна.</li>
<li>Идем счетчиком <code class="language-text">i</code> с левого края.</li>
<li>
<p>Если <code class="language-text">s</code> содержит <code class="language-text">input[i]</code> и <code class="language-text">s[input[i]]&gt;=start</code>, то мы встретили первый повторяющийся символ в текущем окне.</p>
<ol>
<li>Длина соответствующей подстроки равна <code class="language-text">i-start+1</code>, нужно ее сравнить с текущим максимумом. Если эта длина больше текущего максимума, то запоминаем строку и обновляем максимум.</li>
<li>Теперь нам нужно сдвинуть левый край окна и мы можем его сдвинуть сразу к символу справа от первого (левого) повторяющегося символа из нашей пары, т.к. для любого края левее этого, подстрока уже заведомо будет содержать повторяющийся символ. Таким образом, <code class="language-text">start = s[input[i]] + 1</code>.</li>
</ol>
</li>
<li>Запоминаем в наше множество индекс текущего символа: <code class="language-text">s[input[i]] = i</code>.</li>
</ol>
<h2>Медиана 2 отсортированных массивов</h2>
<p>Имея 2 отсортированных массива, найти их медиану. Сложность должна быть <code class="language-text">O(log(n+m))</code>. Медиана - это число, разделяющее множество на 2 подмножества одинаковой длины, одно из которых всегда меньше другого.</p>
<h3>Пример</h3>
<p>Для массивов [1, 3] и [2] медиана равна 2.0.</p>
<p>Для [1, 2] и [3, 4] медиана равна (2 + 3) / 2 = 2.5</p>
<h3>Решение</h3>
<p>Пусть на входе у нас есть массивы <code class="language-text">a</code> и <code class="language-text">b</code>, обозначим их длины как <code class="language-text">m</code> и <code class="language-text">n</code> соответственно.</p>
<p>Чтобы выполнить условия задачи, нам нужно разбить входное множество, состоящее из элементов массивов <code class="language-text">m</code> и <code class="language-text">n</code> на 2 подмножества, удовлетворяющие следующим критериям:</p>
<ol>
<li>Критерий равенства длин - в подмножествах одинаковое количество элементов.</li>
<li>Критерий соотношения граничных элементов отсортированных подмножеств - максимальный элемент левого подмножества должен быть меньше или равен минимальному элементу правого.</li>
</ol>
<p>Сейчас обьясню, что это значит. Допустим, мы разбиваем массив A в точке i, а массив B в точке j.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">left | right

A[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1]

B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1]</code></pre></div>
<p>Тогда условия будут выглядеть так:</p>
<ol>
<li><code class="language-text">len(left) == len(right) -&gt; i + j == (m - i) + (n - j) -&gt; j == (m + n) / 2 - i -&gt; (учтем нечетные длины, прибавив к числителю 1) j == (m + n + 1) / 2 - i</code></li>
<li><code class="language-text">max(left) &lt;= min(right) -&gt; A[i-1] &lt;= B[j] &amp;&amp; B[j-1] &lt;= A[i]</code></li>
</ol>
<p>Если эти условия соблюдены, то искомая медиана будет равна:</p>
<p><code class="language-text">median = (max(left) + min(right)) / 2</code></p>
<p>Значит, задача свелась к следующей:</p>
<blockquote>
<p>Найти <code class="language-text">i</code> в <code class="language-text">[0, m]</code>, такую, что:
<code class="language-text">A[i-1] &lt;= B[j] &amp;&amp; B[j-1] &lt;= A[i] где j = (m + n + 1) / 2 - i</code></p>
</blockquote>
<p>Это мы можем сделать половинным делением.</p>
<p>Когда нашли i, медиана будет равна:</p>
<blockquote>
<p><code class="language-text">max(A[i-1], B[j-1])</code>, если <code class="language-text">m+n</code> нечетное
и <code class="language-text">(max(A[i-1], B[j-1]) + min(A[i], B[j])) / 2</code>, если <code class="language-text">m+n</code> четное</p>
</blockquote>
<h2>Найти подмассив с максимальной суммой</h2>
<h3>Вариант 1. Разделяй и властвуй</h3>
<p>Делим массив на 2 половины и возвращаем максимум из:</p>
<ol>
<li>максимальная сумма в левой половине</li>
<li>максимальная сумма в правой половине</li>
<li>максимальная сумма в подмассиве, пересекающем середину</li>
</ol>
<p>1 и 2 пункт - это просто рекурсивные вызовы.</p>
<p>3 пункт посложнее - там нужно от середины идти влево и вправо, и считать масимальную сумму элементов левой и правой половины, а потом суммировать их.</p>
<p>Рассмотрим пример, допустим у нас такой массив:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">6 1 -3 4 -1 3 -5 4</code></pre></div>
<p>Максимальная сумма идущих подряд элементов в левой половине = 7 для последовательности <code class="language-text">6 1</code>.</p>
<p>Максимальная сумма идущих подряд элементов в правой половине = 4 для последовательности <code class="language-text">4</code>.</p>
<p>Максимальная сумма в подмассиве, пересекающем середину - складывается из:</p>
<ul>
<li>максимальной суммы идущих подряд элементов левой половины, включающих самый <strong>правый</strong> элемент левой половины. В данном случае это 8 для последовательности <code class="language-text">6 1 -3 4</code>.</li>
<li>максимальной суммы идущих подряд элементов правой половины, включающих самый <strong>левый</strong> элемент правой половины. В данном случае это 2 для последовательности <code class="language-text">-1 3</code>.</li>
</ul>
<p>Получили максимальную сумму в подмассиве, пересекающем середину = 8 + 2 = 10.</p>
<p>Результат выбираем как максимум из трех полученных максимумов, то есть <code class="language-text">max(7, 4, 10) == 10</code>, то есть последовательность <code class="language-text">6 1 -3 4 -1 3</code>.</p>
<p>Сложность - <code class="language-text">O(nlogn)</code></p>
<h3>Вариант 2. Алгоритм Кадане.</h3>
<p>Алгоритм Кадане - это специализированный алгоритм именно для этой задачи. Объяснять это словами будет тяжело, лучше сразу кодом.</p>
<p>На псевдокоде описывается очень просто:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Initialize:
max_so_far = 0
max_ending_here = 0

Loop for each element of the array:
  max_ending_here = max_ending_here + a[i]
  if(max_ending_here &lt; 0)
    max_ending_here = 0
  if(max_so_far &lt; max_ending_here)
    max_so_far = max_ending_here
return max_so_far</code></pre></div>
<p>Идея так же проста - идем по массиву скользящим окном, ищем последовательные подмассивы, сумма которых больше нуля и берем максимальную сумму из них.</p>
<p>Пример:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">2 -3 8 -1</code></pre></div>
<p>Алгоритм выдаст 8 и это правильно.</p>
<p>Если бы кусок перед 8 выдавал результат больше нуля, то он бы увеличивал масимальную сумму и мы бы его взяли.</p>
<p>Если он меньше нуля, то он точно уменьшает сумму и мы его не берем.</p>
<p>Более сложный пример:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">3 2 -7 2 1 -2 4 -1 3 -5 4</code></pre></div>
<p>Идем слева направо, считаем сумму:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">3 =&gt; max = 3
3 + 2 = 5 =&gt; max = 5
3 + 2 - 7 = -2 &lt; 0 начинаем считать заново
2 &lt; max
2 + 1 = 3 &lt; max
2 + 1 - 2 = 1 &lt; max
2 + 1 - 2 + 4 = 5 == max
2 + 1 - 2 + 4 - 1 = 4 &lt; max
2 + 1 - 2 + 4 - 1 + 3 = 7 &gt; max обновляем max = 7
2 + 1 - 2 + 4 - 1 + 3 - 5 = 2 &lt; max
2 + 1 - 2 + 4 - 1 + 3 - 5 + 4 = 6 &lt; max</code></pre></div>
<p>Итог: максимум = 7 для последовательности <code class="language-text">2 1 -2 4 -1 3</code>.</p>
<h2>Найти отсутствующий элемент</h2>
<p>Есть массив из N-1 различных чисел от 1 до N. Нужно найти отсутствующий элемент.</p>
<h3>Решение 1</h3>
<p>Суммируем все элементы массива и вычитаем результат из ожидаемой суммы всех чисел от 1 до N, которая равна <code class="language-text">n \* (n+1) / 2</code>. Результат вычитания будет ответом.</p>
<h3>Решение 2</h3>
<p>XOR-им все числа от 1 до N, затем поверх этого XOR-им все элементы нашего массива. Результат будет ответом.</p>
<p>Вот почему это работает:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">(A1 ^ A2 ^ A3) ^ (A1 ^ A3) = (A1 ^ A1) ^ A2 ^ (A3 ^ A3) = 0 ^ A2 ^ 0 = A2</code></pre></div>
<h2>Найти точку эквилибриума в массиве</h2>
<p>Точка эквилибриума - это такой элемент массива, у которого сумма всех элементов слева равна сумме всех элементов справа.</p>
<h3>Решение 1</h3>
<p>Допустим, наш исходный массив <code class="language-text">input</code> равен <code class="language-text">[1, 2, 3, 4, 5, 6, 7, 2, 9, 10]</code>.</p>
<p>Создаем массив аггрегированных сумм, где каждый <code class="language-text">i</code>-й элемент равен сумме элементов <code class="language-text">0..i-1</code> исходного массива. Полученный массив <code class="language-text">sums</code> будет таким: <code class="language-text">[1, 3, 6, 10, 15, 21, 28, 30, 39, 49]</code></p>
<p>Теперь идем по <code class="language-text">input</code> справа налево и так же считаем аггрегированные суммы, но на каждом шаге сравниваем полученный элемент с элементом массива <code class="language-text">sums</code>, стоящим на 2 позиции левее.</p>
<p>Потом идем по <code class="language-text">input</code> справа налево, так же считаем подвижную сумму и сравниваем ее с элементом в <code class="language-text">sums</code> на 2 левее текущего. Как только эти значения становятся равны, мы останавливаемся и выдаем в качестве результата элемент, стоящий между ними.</p>
<p>Для нашего примера, идем по <code class="language-text">input</code> справа налево и считаем аггрегированную сумму <code class="language-text">rsum</code>:</p>
<ol>
<li>Крайний правый элемент <code class="language-text">input</code> равен 10, значит <code class="language-text">rsum = 10</code>. Индекс крайнего правого элемента равен <strong>9</strong>, сравниваем его с <code class="language-text">sum[7]==30</code>. <strong>10 &#x3C; 30</strong>, поэтому продолжаем.</li>
<li>Следующий справа элемент <code class="language-text">input[8]</code> равен 9, сумма <code class="language-text">rsum</code> становится <strong>10+9=19</strong>, индекс равен <strong>8</strong>, сравниваем с <code class="language-text">sum[6]==28</code>. <strong>19&#x3C;28</strong>, продолжаем.</li>
<li>Следующий справа элемент <code class="language-text">input[7]</code> равен 2, сумма <code class="language-text">rsum</code> становится <strong>19+2=21</strong>, индекс равен <strong>7</strong>, сравниваем с <code class="language-text">sum[5]==21</code>. <strong>21==21</strong>, условие выхода выполнилось. Индекс эквилибриума равен <strong>7-1==6</strong>, поэтому возвращаем <code class="language-text">input[6] == 7</code>.</li>
</ol>
<p>Недостаток этого решения в том, что нужен дополнительный массив.</p>
<h3>Решение 2</h3>
<p>Этот вариант решения сложнее для реализации, но ему не нужен дополнительный массив.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Считаем сумму всех элементов массива sum
leftsum = 0
rightsum = sum
Идем по массиву слева направо, на каждом шаге:
  rightsum -= a[i]
  Если leftsum == rightsum, то точка эквилибриума найдена
  leftsum += a[i]</code></pre></div>
<p>Рассмотрим на нашем примере <code class="language-text">[1, 2, 3, 4, 5, 6, 7, 2, 9, 10]</code>.</p>
<table>
<thead>
<tr>
<th>i</th>
<th>a[i]</th>
<th>rightsum</th>
<th>leftsum</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>-</td>
<td>49</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>48</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>46</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>43</td>
<td>6</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>39</td>
<td>10</td>
</tr>
<tr>
<td>4</td>
<td>5</td>
<td>34</td>
<td>15</td>
</tr>
<tr>
<td>5</td>
<td>6</td>
<td>28</td>
<td>21</td>
</tr>
<tr>
<td>6</td>
<td>7</td>
<td>21</td>
<td>21</td>
</tr>
</tbody>
</table>
<p>В последней строке суммы сошлись, точка эквилибриума найдена, возвращаем <code class="language-text">a[i]</code>==<strong>7</strong>.</p>
<h2>External sorting (внешняя сортировка)</h2>
<p>Применяется для сортировки огромных массивов данных, которые не уменьшаются в память. Массив делится на чанки, помещающиеся в память, каждый из чанков сортируется и пишется на диск. Затем из каждого файла берется начальный мини-чанк и между мини-чанками производится merging на диск. Когда какой-то из мини-чанков пустеет, он заполняется следующими данными из своего файла.</p>
<h3>Пример</h3>
<p>Есть 900 МБ файл и 100 МБ памяти.</p>
<ol>
<li>Делим файл на 9 чанков по 100 МБ, сортируем каждый quicksort-ом и пишем в отдельный файл на диске.</li>
<li>Из каждого файла берем первые 10 МБ (мини-чанки) и еще 10 МБ выделяем на выходной буфер.</li>
<li>Проходим по 9 мини-чанкам, берем первый элемент, ищем минимальный. Когда нашли - аппендим его в выходной буфер, а из мини-чанка удаляем.</li>
<li>Если после очередного удаления мини-чанк опустел, то заполняем его следующими 10 МБ из его файла.</li>
<li>Если после очередной записи в выходной буфер он заполнился, то флашим его на диск и очищаем.</li>
</ol>
<p>Этап мержа (шаг 3) здесь неэффективен, так как требует приблизительно <code class="language-text">N * (k - 1)</code> сравнений.</p>
<p>Можно на этом этапе использовать <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">min-heap</a> с ключом равным первому элементу чанка.</p>
<h2>QuickSort</h2>
<div class="gatsby-highlight" data-language="csharp"><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">QuickSort</span>
<span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token generic-method"><span class="token function">Sort</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> input<span class="token punctuation">)</span> <span class="token keyword">where</span> T<span class="token punctuation">:</span>IComparable
	<span class="token punctuation">{</span>
		<span class="token function">SortImpl</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> input<span class="token punctuation">.</span>Length<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token generic-method"><span class="token function">SortImpl</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> lo<span class="token punctuation">,</span> <span class="token keyword">int</span> hi<span class="token punctuation">)</span> <span class="token keyword">where</span> T <span class="token punctuation">:</span> IComparable
	<span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>hi <span class="token operator">-</span> lo <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token class-name">T</span> pivot <span class="token operator">=</span> a<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> l <span class="token operator">=</span> lo<span class="token punctuation">,</span> r <span class="token operator">=</span> hi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>pivot<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> l <span class="token operator">&lt;</span> hi<span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">CompareTo</span><span class="token punctuation">(</span>pivot<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> r <span class="token operator">>=</span> lo<span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>
			<span class="token punctuation">{</span>
				<span class="token function">Swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
				l<span class="token operator">++</span><span class="token punctuation">;</span>
				r<span class="token operator">--</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token function">Swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token generic-method"><span class="token function">SortImpl</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token generic-method"><span class="token function">SortImpl</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> l<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token generic-method"><span class="token function">Swap</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> input<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token class-name">T</span> tmp <span class="token operator">=</span> input<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>
		input<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> input<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>
		input<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<h2>Красно-черные деревья</h2>
<p>Это бинарные поисковые деревья, удовлетворяющие следующим условиям:</p>
<ol>
<li>Каждый узел может быть либо красным, либо черным</li>
<li>Корень всегда черный</li>
<li>Родителем красного узла не может быть красный узел</li>
<li>Для каждого листового узла количество черных узлов на пути до корня одинаково</li>
</ol>
<p>Для обеспечения этих свойств при вставке узла проводится ребалансировка дерева. Сначала пробуем <strong>перекрашивание</strong>, если оно не работает, то <strong>вращение</strong>. Если дядя красный, то перекрашиваем, если черный - то вращаем и/или перекрашиваем.</p>
<p>Алгоритм вставки (x - вставляемый узел):</p>
<ol>
<li>Делаем x красным и производим стандартную вставку в поисковое бинарное дерево</li>
<li>Если x - корень, то делаем его черным и завершаем вставку, иначе - красным</li>
<li>Если родитель x - красный и он корень, то просто делаем его черным и завершаем вставку</li>
<li>
<p>Если x не корень или родитель x не черный (в этом случае дедушка точно будет черный), то мы получили <strong>красный-красный-черный</strong>, что нарушает свойство 3. Попробуем это исправить:</p>
<ol>
<li>если дядя x - красный, то мы можем просто перекрасить папу и дядю, так как они оба красные и перекрашивание их в черный увеличит количество черных узлов для обоих ветвей деда и не нарушит свойство 4. Однако чтобы не менять количество черных в ветвях нашего поддерева и чтобы не пришлось ребалансировать поддерево брата деда, мы еще и перекрашиваем деда в красный:</li>
<li>перекрашиваем родителя и дядю в черный</li>
<li>перекрашиваем деда в красный</li>
</ol>
</li>
</ol>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 598px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/82ecefc9e11f24696b8b495830836e0a/16bf3/redBlackCase2.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 44.14715719063545%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAA7CAAAOwgEVKEqAAAABxUlEQVQoz21STW/TQBD1/78CV0AKPXCDIiT6QUTiAI1KXYdEiVKrcm23tmN7i5P6e71+zK4bFYmO5N3x7sybN29WA1knBC0dqqpC27bKlzafz6DrY5z9/IHh8CviOFbnrYxvGnRlhU1cg7EaedGiLAU0IS/JcgJ79fIFxpOJ+g/CCuGmQBTnlFCQnyFNa2zTVt07Hz5iPXgPa12hrAHeCHDeQVMVvVvMvxzhwjTx69sIO+M3QvcB5iLDYplhucrguCUcr4YfMpycnsI6m8I9P8d0+h0s6ZlTawRY13AOP8E+/NyfOS7sdwdo4hR+3ML3S/hBRYxLBIGAfjzE67dvsMtzZJQ7GBzAMAyVKrvVGFViIx32agXbdREuFvhj3xCzJZ6s11RcXyE4PkGwvsLasrCkWNu2FWBeFCpG8/QJkssZNlFEDAJqKYQgAI9k4C15jwOSGjvGJW5HYzwwhpDiQ4rlnKthFXtAuZgzE1lRPvERPYjE2g/Nsq4RJQw3JInreXjOZHFNZnWdoJFzYlmRXqWacER+RE9iE/XPgt1z3N2VSFjzqFenAP79FMO9U9cC6ZZju+Mqid03iJMekLfdf0ye26X9BfJwpTrUOmaWAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="red-black tree"
        title="red black case"
        src="/hows-that-again/static/82ecefc9e11f24696b8b495830836e0a/16bf3/redBlackCase2.png"
        srcset="/hows-that-again/static/82ecefc9e11f24696b8b495830836e0a/19bd1/redBlackCase2.png 163w,
/hows-that-again/static/82ecefc9e11f24696b8b495830836e0a/d3bcb/redBlackCase2.png 325w,
/hows-that-again/static/82ecefc9e11f24696b8b495830836e0a/16bf3/redBlackCase2.png 598w"
        sizes="(max-width: 598px) 100vw, 598px"
        loading="lazy"
      />
  </a>
    </span></p>
<ol start="5">
<li>
<p>eсли дяди нет, или дядя х - черный, то мы не можем перекрасить папу в черный, т.к. это увеличит количество черных узлов на одной ветви, оставим неизменным на остальных и автоматически нарушится свойство 4. Поэтому приходится вертеть:</p>
<ol>
<li>p - parent узла х, g - grandfather узла х</li>
<li>возможны 4 случая:</li>
<li>p слева от g, x слева от p</li>
<li>p слева от g, x справа от p</li>
<li>p справа от g, x справа от p</li>
<li>p справа от g, x слева от p</li>
<li>Для каждого из этих 4 случаев нам нужно нарушающий свойство 3 путь от x вида <strong>красный-красный-черный</strong> в <strong>красный с двумя черными детьми</strong>. Как это сделать - смотрим на картинке (картинка из другой книги, поэтому там добавляемый узел - не x, а просто тот, который самый нижний и в кружочке. На этих случаях всегда x &#x3C; y &#x3C; z, поэтому y в результате становится корнем поддерева:</li>
</ol>
</li>
</ol>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 414px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/9ec20784df658f1f1fc12f837ee7599e/07a90/redBlackCase3.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 121.73913043478262%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB3ElEQVQ4y6WUWavjMAyF8/9/UZ9KaV8KpaXQQvd93/d90fAZFBwnmdy5IxAxcnQsHR/Z+36/Euefz0ewUqkknU7HrInpvm0a834CCNh4PA4k6vrxeMjr9foZILbb7aRer8t2u/UTsc1mI+l0Wvr9vtm/XC4mngi4Wq1MAvZ+v/34ZDKRVColrVZLarWa7Pf7ZECcyqiCSrVN7Ha7yWw2k/V6bfz5fCYDwiFtxnHoWiSH7i3S5nw+N5y5/yoFtnsuZ24VtALh9/vdv/U4yQQAMYjN5XIhUJWGDUYsk8n43EUCns9nKRQKAQFjSr4NyAH5fD5Qdajldrsty+VSTqeTD4p1u12ZTqeB2OFwMAehgBCgBqrVqqmSJL4YGuRSSBwMBuY/OOVL1WgwEpDKSFCg6/Vqvtls1iQi4GKxaGJckE4LB6moDaC20Gg0ZDQaBWYYWZDEtADK2t5jTQcUonR4SvBisQgRTyVMBFMCr1Stt6pGZ7jmeCoBeCGJk12taTW27lSjHGrneVFj5D5fzWZThsPhX9/D2NGLeg8rlYr0er0QYJQnPl96MQBCjTtq/wzIheHlctmX1K8BFZSpQFK23n4FqBwyDdpyUgGJLQPqavS/AKnqeDwa/myNxvkfZIdT3G/0F04AAAAASUVORK5CYII='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="red-black tree"
        title="red black case"
        src="/hows-that-again/static/9ec20784df658f1f1fc12f837ee7599e/07a90/redBlackCase3.png"
        srcset="/hows-that-again/static/9ec20784df658f1f1fc12f837ee7599e/19bd1/redBlackCase3.png 163w,
/hows-that-again/static/9ec20784df658f1f1fc12f837ee7599e/d3bcb/redBlackCase3.png 325w,
/hows-that-again/static/9ec20784df658f1f1fc12f837ee7599e/07a90/redBlackCase3.png 414w"
        sizes="(max-width: 414px) 100vw, 414px"
        loading="lazy"
      />
  </a>
    </span></p>
<ol start="6">
<li>После этого нужно перекрасить наше поддерево, сделав корень черным, а его детей красным.</li>
</ol>
<p>Вращение дерева:</p>
<p><img src="./Tree_Rotations.gif" alt="tree rotation" title="tree rotation"></p>
<h2>Декартово дерево</h2>
<p>Это тоже сбалансированное дерево поиска, но в нем каждая вершина обладает двумя значениями - ключом и приоритетом. По ключам структура обладает свойствами двоичного поиска, а по приоритета - свойствами кучи. Из-за этого в литературе структуру чатсо называют <em>treap</em>.</p>
<p>Соответствующей теоремой доказывается, что для любого набора ключей и приоритетов есть только один вариант такого дерева. Случайный выбор приоритетов позволит в среднем получить не вырожденное дерево с асимптотикой O(log N).</p>
<p>Поиск в таком дереве осуществляектся за O(log N).</p>
<p>Операции добавления и удаления элементов осуществляются при помощи вспомогательных операций Merge и Split, по O(log N) каждая.</p>
<p>Так же, благодаря операции Merge, такие кучи можно сливать, но только если одно из деревьев строго меньше другого по ключам. </p>
<p>Построить дерево, при определенных ухищрениях, можно за O(N).</p>
<p>В результате получаем: </p>
<ul>
<li>обладает почти гарантированно логарифмической высотой относительно количества своих вершин;</li>
<li>позволяет за логарифмическое время искать любой ключ в дереве, добавлять его и удалять;</li>
<li>исходный код всех её методов не превышает 20 строк, они легко понимаются и в них крайне сложно ошибиться</li>
<li>содержит некоторый overhead по памяти, сравнительно с истинно самобалансирующимися деревьями, на хранение приоритетов.</li>
</ul>
<p>Более подробное описание операций <a href="https://habr.com/ru/post/101818/">здесь</a> и <a href="http://e-maxx.ru/algo/treap">здесь</a>.</p>
<h3>Неявное декартово дерево</h3>
<p>При помощи небольшой модификации (а именно, вместо ключа использовать индекс элемента в массиве), получаем возможность использовать следующие операции за время O(log N):</p>
<ul>
<li>Вставка элемента в массив в любую позицию</li>
<li>Удаление произвольного элемента</li>
<li>Сумма, минимум/максимум на произвольном отрезке, и т.д.</li>
<li>Прибавление, покраска на отрезке</li>
<li>Переворот (перестановка элементов в обратном порядке) на отрезке</li>
</ul></div></div></div></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/blog/algorithms";window.webpackCompilationHash="bad039ef2599af93861f";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-bf7cab58733aac78b88a.js"],"component---src-templates-blog-template-js":["/component---src-templates-blog-template-js-5ea17c1fd24e2203c3a7.js"],"component---src-pages-404-js":["/component---src-pages-404-js-136ed2540751178671ed.js"],"component---src-pages-index-jsx":["/component---src-pages-index-jsx-9ffb42122f7e83d433a2.js"],"component---src-pages-page-2-js":["/component---src-pages-page-2-js-afcbca9b861e9fe7fcde.js"]};/*]]>*/</script><script src="/hows-that-again/webpack-runtime-db480cd44fa667b30320.js" async=""></script><script src="/hows-that-again/commons-c5dc1b2d2534490c916f.js" async=""></script><script src="/hows-that-again/component---src-templates-blog-template-js-5ea17c1fd24e2203c3a7.js" async=""></script><script src="/hows-that-again/app-bf7cab58733aac78b88a.js" async=""></script></body></html>