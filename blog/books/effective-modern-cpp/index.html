<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/hows-that-again/commons.8860d49cbcb6ddba17d1.css">html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:112.5%/1.45em georgia,serif;box-sizing:border-box;overflow-y:scroll}*,:after,:before{box-sizing:inherit}body{color:rgba(0,0,0,.8);font-family:georgia,serif;font-weight:400;word-wrap:break-word;-webkit-font-kerning:normal;font-kerning:normal;-ms-font-feature-settings:"kern","liga","clig","calt";font-feature-settings:"kern","liga","clig","calt"}img{max-width:100%;padding:0;margin:0 0 1.45rem}h1{font-size:2.25rem}h1,h2{padding:0;margin:0 0 1.45rem;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h2{font-size:1.62671rem}h3{font-size:1.38316rem}h3,h4{padding:0;margin:0 0 1.45rem;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h4{font-size:1rem}h5{font-size:.85028rem}h5,h6{padding:0;margin:0 0 1.45rem;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h6{font-size:.78405rem}hgroup{padding:0;margin:0 0 1.45rem}ol,ul{padding:0;margin:0 0 1.45rem 1.45rem;list-style-position:outside;list-style-image:none}dd,dl,figure,p{padding:0;margin:0 0 1.45rem}pre{margin:0 0 1.45rem;font-size:.85rem;line-height:1.42;background:rgba(0,0,0,.04);border-radius:3px;overflow:auto;word-wrap:normal;padding:1.45rem}table{font-size:1rem;line-height:1.45rem;border-collapse:collapse;width:100%}fieldset,table{padding:0;margin:0 0 1.45rem}blockquote{padding:0;margin:0 1.45rem 1.45rem}form,iframe,noscript{padding:0;margin:0 0 1.45rem}hr{padding:0;margin:0 0 calc(1.45rem - 1px);background:rgba(0,0,0,.2);border:none;height:1px}address{padding:0;margin:0 0 1.45rem}b,dt,strong,th{font-weight:700}li{margin-bottom:.725rem}ol li,ul li{padding-left:0}li>ol,li>ul{margin-left:1.45rem;margin-bottom:.725rem;margin-top:.725rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,abbr[title],acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}abbr[title]{text-decoration:none}td,th,thead{text-align:left}td,th{border-bottom:1px solid rgba(0,0,0,.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding:.725rem .96667rem calc(.725rem - 1px)}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:SFMono-Regular,Consolas,Roboto Mono,Droid Sans Mono,Liberation Mono,Menlo,Courier,monospace;padding:.2em 0}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{letter-spacing:-.2em;content:" "}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}@media only screen and (max-width:480px){html{font-size:100%}}code[class*=language-],pre[class*=language-]{color:#657b83;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-]::-moz-selection,code[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection{background:#073642}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{background:#073642}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-],pre[class*=language-]{background-color:#fdf6e3}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#93a1a1}.token.punctuation{color:#586e75}.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#268bd2}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string,.token.url{color:#2aa198}.token.entity{color:#657b83;background:#eee8d5}.token.atrule,.token.attr-value,.token.keyword{color:#859900}.token.class-name,.token.function{color:#b58900}.token.important,.token.regex,.token.variable{color:#cb4b16}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}</style><meta name="generator" content="Gatsby 2.15.1"/><title data-react-helmet="true">How&#x27;s that again?</title><meta data-react-helmet="true" name="description" content="Sample"/><meta data-react-helmet="true" name="keywords" content="sample, something"/><style type="text/css">.gatsby-resp-image-image{width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;color:transparent;}</style><link as="script" rel="preload" href="/hows-that-again/webpack-runtime-307e2eaa7f3c16e7ad2c.js"/><link as="script" rel="preload" href="/hows-that-again/app-c14483461df837b8e0ee.js"/><link as="script" rel="preload" href="/hows-that-again/commons-313b70b8b727bdc3ecf8.js"/><link as="script" rel="preload" href="/hows-that-again/component---src-templates-blog-template-js-e63d8ebd92abd897e273.js"/><link as="fetch" rel="preload" href="/hows-that-again/page-data/blog/books/effective-modern-cpp/page-data.json" crossorigin="anonymous"/></head><body><noscript id="gatsby-noscript">This app works best with JavaScript enabled.</noscript><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group" id="gatsby-focus-wrapper"><div><div style="background:rebeccapurple;margin-bottom:1.45rem"><div style="margin:0 auto;max-width:960px;padding:1.45rem 1.0875rem;display:flex;justify-content:space-between"><h1 style="margin:0"><a style="color:white;text-decoration:none" href="/hows-that-again/">How&#x27;s that again?</a></h1><span style="margin:auto 0"><form style="margin-bottom:0" method="get" action="https://encrypted.google.com/search"><input type="hidden" name="as_sitesearch" value="y-gagar1n.github.io/hows-that-again"/><input type="text" name="as_q"/><input type="submit" style="margin-left:5px" value="Search"/></form></span></div></div><div style="margin:0 auto;max-width:960px;padding:0px 1.0875rem 1.45rem;padding-top:0"><div class="blog-post-container"><div class="blog-post"><div class="blog-post-content"><h1>Effective Modern C++</h1>
<h2>Вывод типов через auto</h2>
<p>Тип для <code class="language-text">auto</code> выводится так же, как и для шаблонов. В том выводе типов у нас есть определение шаблона и его вызов:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f</span><span class="token punctuation">(</span>ParamType param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Когда переменная объявляется через <code class="language-text">auto</code>, то <code class="language-text">auto</code> выступает в роли <strong>T</strong>, а спецификатор типа - как <code class="language-text">ParamType</code>. Например:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>			<span class="token comment">// auto -> T, auto -> ParamType</span>
const auto cx <span class="token operator">=</span> x<span class="token punctuation">;</span>		<span class="token comment">// auto -> T, const auto -> ParamType</span>
const auto<span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span>		<span class="token comment">// auto -> T, const auto&amp; -> ParamType</span></code></pre></div>
<p>Для вывода представим соответствующие им шаблоны и их вызовы:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">func_x</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">func_x</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// ParamTYpe -> int, T -> int</span>

template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">func_cx</span><span class="token punctuation">(</span>const T param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">func_cx</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// ParamType -> const int, T -> int</span>

template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">func_rx</span><span class="token punctuation">(</span>const T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">func_rx</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// ParamType -> const int&amp;, T -> int</span></code></pre></div>
<p>Во всех остальных случаях логика точно такая же как и для вывода типа шаблона. Но есть одно исключение, о нем дальше.</p>
<h3>Особый случай для initializer_list</h3>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto x1 <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>		<span class="token comment">// int</span>
auto <span class="token function">x2</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// int</span>
auto x3 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">27</span><span class="token punctuation">}</span><span class="token punctuation">;</span>		<span class="token comment">// std::initializer_list&lt;int> = {27}</span>
auto x4<span class="token punctuation">{</span><span class="token number">27</span><span class="token punctuation">}</span><span class="token punctuation">;</span>		<span class="token comment">// std::initializer_list&lt;int> = {27}</span></code></pre></div>
<p>Так происходит потому что в выводе типов через <code class="language-text">auto</code> прописано особое правило: <strong>если значение для авто-объявленной переменной заключено в фигурные скобки, то тип ВСЕГДА выводится как std::initializer_list</strong>.</p>
<p>При этом в выводе типов для шаблонов такого правила нет и это единственное место где алгоритмы различаются:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ОШИБКА КОМПИЛЯЦИИ!</span>

template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f2</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">></span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">fw</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// все ок, тип T выводится как int</span></code></pre></div>
<h2>decltype</h2>
<p><strong>decltype</strong> - это функция, которая принимает переменную, а возвращает ее тип. Может быть использована там, где ожидается указание типа.</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">const int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>			<span class="token comment">// decltype(i) -> const int</span>
bool <span class="token function">f</span><span class="token punctuation">(</span>const Widget<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// decltype(w) -> const Widget&amp;, decltype(f) -> bool(const Widget&amp;)</span></code></pre></div>
<p>Обычно используется там, где тип возвращаемого значения зависит от типа аргумента:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename Container<span class="token punctuation">,</span> typename Index<span class="token operator">></span>
auto <span class="token function">authAndAccess</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">decltype</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">authenticateser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>здесь <code class="language-text">auto</code> не имеет отношения к выводу типов, а лишь указывает, что возвращаемый тип будет указан после списка параметров (trailing return type syntax). Такой синтаксис необходимо использовать, когда тип возвращаемого значения зависит от типов параметров.</p>
<p>В C++14 можно возвращать из функций <code class="language-text">auto</code>, не указывая тип после стрелочки, но с этим бывают проблемы, поэтому рекомендуется возвращать <code class="language-text">decltype(auto)</code>.</p>
<p>С <code class="language-text">authAndAccess</code> осталась одна проблема - она не сможет принимать rvalue для контейнера. Модифицируем так, чтобы мог:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename Container<span class="token punctuation">,</span> typename Index<span class="token operator">></span>
auto <span class="token function">get</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">decltype</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>Container<span class="token operator">></span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">authenticateUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>Container<span class="token operator">></span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Теперь для <strong>c</strong> типа lvalue функция будет возвращать lvalue, а для rvalue - rvalue.</p>
<h3>Особенность поведения decltype</h3>
<p>Применение <strong>decltype</strong> к имени переменной возвращает тип этого имени. Однако применение к lvalue, котороя является чем-то более сложным, чем имя, возвращает ссылку на lvalue. То есть <strong>decltype</strong> над выражением не-именем, имеющим тип <strong>T</strong> вернет тип <strong>T&#x26;</strong>. Такое поведение редко на что-либо влияет, однако есть интересное следствие:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">int x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// int</span>
<span class="token function">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// int&amp;</span></code></pre></div>
<p>Как видно, оборачивание значения в скобки может поменять значение, возвращаемое <strong>decltype</strong>. Это особенно важно в C++14, где можно возвращать из функции <code class="language-text">decltype(auto)</code> и случайно можно вернуть ссылку на элемент вместо элемента.</p>
<h2>Используйте auto вместо явных определений типов</h2>
<h3>auto не даст создать неинициализированный объект</h3>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">int x<span class="token punctuation">;</span>	<span class="token comment">// не инициализирован!</span>

auto x<span class="token punctuation">;</span> <span class="token comment">// не скомпилится!</span></code></pre></div>
<h3>Позволяет не писать сложные типы</h3>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename It<span class="token operator">></span>
void <span class="token function">dwim</span><span class="token punctuation">(</span>It b<span class="token punctuation">,</span> It e<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	typename std<span class="token punctuation">:</span><span class="token punctuation">:</span>iterator_traits<span class="token operator">&lt;</span>It<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>value_type currValue <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
	auto currValue2 <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<h3>Экономить память при использовании функторов</h3>
<p>Тип лямбды неизвестен до компиляции, поэтому описать его точно - невозможно. Приходится использовать тип <code class="language-text">std::function</code>. </p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">function</span><span class="token operator">&lt;</span><span class="token function">bool</span><span class="token punctuation">(</span>const std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">,</span> const std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">></span>
	funcs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>const std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> const std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token operator">*</span>a <span class="token operator">&lt;</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
	<span class="token punctuation">}</span></code></pre></div>
<p>Но у него есть недостаток - он всегда занимает фиксированный размер в памяти, и если его не хватает, то аллоцирует память в куче. Тогда как реальный тип замыкания, выводимый во время компиляции и используемый с помощью <strong>auto</strong> всегда занимает ровно столько места, сколько ему требуется.</p>
<p>Плюс к этому, из-за особенностей реализации, при вызове функции через <code class="language-text">std::function</code> запрещается инлайнинг и добавляется непрямой вызов функции (indirect function calls), что ухудшает производительность по сравнению с <strong>auto</strong>.</p>
<h3>Неявные приведения типов</h3>
<p>Допустим, есть такой код:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>int<span class="token operator">></span> v<span class="token punctuation">;</span>
unsigned sz <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Все бы ничего, да только <code class="language-text">v.size()</code> возвращает вовсе не <strong>unsigned</strong>, а <code class="language-text">std::vector&lt;int&gt;::size_type</code>.</p>
<p>Другой пример:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>unordered_map<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token punctuation">,</span> int<span class="token operator">></span> m<span class="token punctuation">;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span>const std<span class="token punctuation">:</span><span class="token punctuation">:</span>pair<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token punctuation">,</span> int<span class="token operator">></span><span class="token operator">&amp;</span> p<span class="token punctuation">:</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Реальный тип элементов, содержащихся в <code class="language-text">unordered_map</code> - <code class="language-text">std::pair&lt;const std::string, int&gt;</code>. В результате компилятор не сможет привести <code class="language-text">std::pair&lt;const std::string, int&gt;</code> к <code class="language-text">std::pair&lt;std::string, int&gt;</code> и будет для каждого члена создавать временный объект, ссылку на который копировать в <strong>p</strong>. После каждой итерации временный объект будет уничтожен.</p>
<p>Использование <strong>auto</strong> в этом случае делает код проще и производительнее:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>unordered_map<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token punctuation">,</span> int<span class="token operator">></span> m<span class="token punctuation">;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span>const auto<span class="token operator">&amp;</span> p<span class="token punctuation">:</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre></div>
<h2>Иногда auto выводит не то, что нужно</h2>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>bool<span class="token operator">></span> <span class="token function">features</span><span class="token punctuation">(</span>const Widget<span class="token operator">&amp;</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>

Widget w<span class="token punctuation">;</span>
auto highPriority <span class="token operator">=</span> <span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">processWidget</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> highPriority<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Как ни удивительно, этот код приводит к undefined behavior. Дело в том, что оператор <code class="language-text">[]</code> для <code class="language-text">std::vector&lt;bool&gt;</code> возвращает <code class="language-text">std::vector&lt;bool&gt;::reference</code>. Так происходит потому, что булевого типа у вектора есть специальная реализация, которая хранит по одному биту на элемент. Теперь оператор <code class="language-text">[]</code> должен возвращать ссылку на бит, но в C++ запрещены ссылки на биты. Поэтому приходится возвращать тип, который <em>ведет себя</em> как <code class="language-text">bool&amp;</code>. ЭТо означает, что он, помимо прочего, должен быть неявно приводим к <code class="language-text">bool</code>. </p>
<p>Получается, что когда мы делаем <code class="language-text">bool highPriority = features(w)[5]</code>, то возвращается <code class="language-text">std::vector&lt;bool&gt;::reference</code>, который приводится к <code class="language-text">bool</code> и дальше все нормально.</p>
<p>А вот когда мы делаем <code class="language-text">auto highPriority = features(w)[5]</code>, то дальше все зависит от реализации типа <code class="language-text">std::vector&lt;bool&gt;::reference</code>. Одна из реализаций представляет из себя:</p>
<ul>
<li>указатель на машинное слово вектора, в котором содержится интересующий бит</li>
<li>сдвиг в этом слове</li>
</ul>
<p>Итак, вызов <code class="language-text">features</code> возвращает временный объект-вектор. Оператор <code class="language-text">[]</code> возвращает <code class="language-text">std::vector&lt;bool&gt;::reference</code>, в котором содержится ссылка на элемент внутри временного объекта-вектора. Мы записываем это в <code class="language-text">highPriority</code>, после чего временный объект уничтожается, а в <code class="language-text">highPriority</code> остается висячая ссылка на уничтоженный объект.</p>
<p>Здесь <code class="language-text">std::vector&lt;bool&gt;::reference</code> - это прокси-класс, который не предназначен для того, чтобы жить дольше, чем одно выражение. Поэтому <strong>auto</strong> очень плохо дружит с прокси-классами.</p>
<p>Такие прокси-классы очень тяжело найти заранее, однако когда стало понятно, что проблема в прокси-классе, не стоит избавляться от <strong>auto</strong>. Лучший способ - использовать явное приведение типа:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto highPriority <span class="token operator">=</span> static_cast<span class="token operator">&lt;</span>bool<span class="token operator">></span><span class="token punctuation">(</span><span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<h2>Различия между () и {} при инициализации объектов</h2>
<p>Для начало важно отличать инициализацию от присвоения:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">Widget w1<span class="token punctuation">;</span>			<span class="token comment">// инициализация, вызван дефолтный конструктор</span>
Widget w2 <span class="token operator">=</span> w1<span class="token punctuation">;</span>		<span class="token comment">// инициализация, вызывается конструктор копирования</span>
w1 <span class="token operator">=</span> w2<span class="token punctuation">;</span>			<span class="token comment">// присвоение, вызывается оператор =</span></code></pre></div>
<p>В C++ 11 представлена <em>uniform initialization</em> - предпочтительный способ инициализации:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">int x<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>int<span class="token operator">></span> v<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>Тот же синтаксис можно использовать и для задания дефолтных значений не-статическим полям классов, наравне с синтаксисом через <strong>=</strong>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
private<span class="token punctuation">:</span>
	int x<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>	<span class="token comment">// ОК</span>
	int y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	<span class="token comment">// тоже ок</span>
	int <span class="token function">z</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// ошибка компиляции!</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Однако если инициализируем не-копируемый тип, то <strong>{}</strong> валиден наравне с синтаксисом через <strong>()</strong>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>atomic<span class="token operator">&lt;</span>int<span class="token operator">></span>ai1<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>		<span class="token comment">// OK</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>atomic<span class="token operator">&lt;</span>int<span class="token operator">></span><span class="token function">ai2</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// OK</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>atomic<span class="token operator">&lt;</span>int<span class="token operator">></span>ai3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	<span class="token comment">// ошибка!</span></code></pre></div>
<p>Поэтому, чтобы не путаться, лучше всегда использовать универсальную (uniform) инициализацию вида <code class="language-text">int x{0};</code>.</p>
<h3>{} запрещает преобразование типа с потерей точности</h3>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">double x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">;</span>
int sum1<span class="token punctuation">{</span> x<span class="token operator">+</span>y<span class="token operator">+</span>z <span class="token punctuation">}</span><span class="token punctuation">;</span>		<span class="token comment">// не скомпилится, так как сумма даблов может быть невыразима через int</span>
int <span class="token function">sum2</span><span class="token punctuation">(</span> x<span class="token operator">+</span>y<span class="token operator">+</span>z <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// спокойно компилится и приводит к неожиданному поведению при выполнении</span>
int sum3 <span class="token operator">=</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>	<span class="token comment">// аналогично sum2</span></code></pre></div>
<h3>{} не подвержена most vexing parse</h3>
<p>В С++ есть такое правило - все, что может быть интерпретировано как объявелние, должно быть интерпретировано как объявление.</p>
<p>Поэтому часто, когда хотим инициализировать переменную дефолтным конструктором через скобки, вместо этого получается объявление функции:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">Widget <span class="token function">w1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// когда у конструктора есть параметры, то все норм</span>
Widget <span class="token function">w2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// а вот когда хотис использовать дефолтный конструктор, то получается объявление функции</span></code></pre></div>
<p>С использованием <strong>{}</strong> код выглядит так и не содержит этой проблемы:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">Widget w3<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<h3>Недостаток: опять проблемы с initializer_list</h3>
<p>Если при инициализации через <strong>{}</strong> имеется конструктор, принимающий <code class="language-text">initializer_list</code>, и он может быть теоретически использован, то будет использован именно он:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
	<span class="token function">Widget</span><span class="token punctuation">(</span>int i<span class="token punctuation">,</span> bool b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Widget</span><span class="token punctuation">(</span>int i<span class="token punctuation">,</span> double d<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Widget</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>initializer_list<span class="token operator">&lt;</span>long double<span class="token operator">></span> il<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Widget <span class="token function">w1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// будет вызван первый конструктор</span>
Widget w2<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">;</span>	<span class="token comment">// 3-й</span>
Widget <span class="token function">w3</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 2-й</span>
Widget w4<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>		<span class="token comment">// 3-й</span></code></pre></div>
<p>Причем иногда путь довольно непрост:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  <span class="token function">Widget</span><span class="token punctuation">(</span>int i<span class="token punctuation">,</span> bool b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">Widget</span><span class="token punctuation">(</span>int i<span class="token punctuation">,</span> double d<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">Widget</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>initializer_list<span class="token operator">&lt;</span>long double<span class="token operator">></span> il<span class="token punctuation">)</span><span class="token punctuation">;</span>
  operator <span class="token function">float</span><span class="token punctuation">(</span><span class="token punctuation">)</span> const<span class="token punctuation">;</span>		<span class="token comment">// оператор преобразования Widget во float</span>

  <span class="token comment">// конструктор копирования</span>
  <span class="token comment">// конструктор перемещения</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
Widget <span class="token function">w5</span><span class="token punctuation">(</span>w4<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// вызывается конструктор копирования </span>
Widget w6<span class="token punctuation">{</span>w4<span class="token punctuation">}</span><span class="token punctuation">;</span>				<span class="token comment">// вызывается преобразование к float и затем конструктор с initializer_list, так как float может быть преобразован к long double</span>
Widget <span class="token function">w7</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">move</span><span class="token punctuation">(</span>w4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// конструктор перемещения</span>
Widget w8<span class="token punctuation">{</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">move</span><span class="token punctuation">(</span>w4<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>	<span class="token comment">// опять конструктор с initializer_list через преобразование к float</span></code></pre></div>
<p>Более того, компилятор настолько сильно хочет использовать <code class="language-text">initializer_list</code>, что даже идеально подходящие другие конструкторы ему не помеха:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  <span class="token function">Widget</span><span class="token punctuation">(</span>int i<span class="token punctuation">,</span> bool b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">Widget</span><span class="token punctuation">(</span>int i<span class="token punctuation">,</span> double d<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">Widget</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>initializer_list<span class="token operator">&lt;</span>bool<span class="token operator">></span> il<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Widget w<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>	<span class="token comment">// ошибка компиляции!</span></code></pre></div>
<p>Компилятор, несмотря на то, что есть конструктор, принимающий <strong>int</strong> и <strong>double</strong>, опять попытался использовать конструктор с <code class="language-text">initializer_list</code> и не смог, потому что для этого требуется сужающее приведение <strong>int</strong> и <strong>double</strong> к <strong>bool</strong>, а сужающие приведения запрещены в инициализации через <strong>{}</strong>.</p>
<p>Однако и из этого правила есть исключение - если есть дефолтный конструктор и мы вызываем инициализацию без параметров, то дефолтный конструктор имеет высший приоритет над конструктором с <code class="language-text">initializer_list</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"> class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">Widget</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>initializer_list<span class="token operator">&lt;</span>int<span class="token operator">></span> il<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
Widget w1<span class="token punctuation">;</span>		<span class="token comment">// дефолтный конструктор</span>
Widget w2<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>	<span class="token comment">// дефолтный конструктор</span>
Widget <span class="token function">w3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// most vexing parse! объявляет функцию</span>

Widget <span class="token function">w4</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// только так мы в этом случае можем вызвать конструктор с initializer_list</span>
Widget w5<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>	<span class="token comment">// ну или так</span></code></pre></div>
<p>Один из выводов из всего этого - если вы автор библиотеки, то не стоит добавлять конструктор, принимающий <code class="language-text">initializer_list</code>, так как тогда возможно клиенты не смогут использовать ваши остальные конструкторы.</p>
<h2>Используйте nullptr вместо 0 и NULL</h2>
<p>В С++98 использование 0 и NULL приводило к тому, что перегрузки, принимающие указатель, могли не вызываться:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">void <span class="token function">f</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token punctuation">;</span>
void <span class="token function">f</span><span class="token punctuation">(</span>bool<span class="token punctuation">)</span><span class="token punctuation">;</span>
void <span class="token function">f</span><span class="token punctuation">(</span>void<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// f(int)</span>
<span class="token function">f</span><span class="token punctuation">(</span>NULL<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// могло не скомпилиться, но если компилилось, то вызывало f(int)</span></code></pre></div>
<p>Все потому, что 0 - это целочисленный тип и NULL часто был определен тоже как численный тип.</p>
<p>Преимущество <strong>nullptr</strong> - он не может быть интерпретирован как численный тип, только как указатель. Тип <strong>nullptr</strong> - <code class="language-text">std::nullptr_t</code>. ЭТот тип неявно приводит к себе указатели всех типов, поэтому <strong>nullptr</strong> - универсальный указатель.</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token function">f</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// f(void*)</span></code></pre></div>
<h2>Используйте alias вместо typedef</h2>
<p>В С++98 были <strong>typedef</strong>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">typedef
     std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>unordered_map<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token operator">></span><span class="token operator">></span>
     UPtrMapSS<span class="token punctuation">;</span></code></pre></div>
<p>Они устарели, когда в C++11 появились алиасы:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"> using UPtrMapSS <span class="token operator">=</span>
     std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>unordered_map<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token operator">></span><span class="token operator">></span><span class="token punctuation">;</span></code></pre></div>
<p>Еще один пример, демонстрирующий повышенную читаемость алиасов по сравнению с тайпдефом:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">typedef void <span class="token punctuation">(</span><span class="token operator">*</span>FP<span class="token punctuation">)</span><span class="token punctuation">(</span>int<span class="token punctuation">,</span> const std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

using FP <span class="token operator">=</span> void <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>int<span class="token punctuation">,</span> const std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Основное преимущество - алиасы могут быть шаблонизированы, а тайпдефы - нет. В С++98 приходилось извращаться и определять тайпдефы внутри шаблонизированных структур:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
struct MyAllocList <span class="token punctuation">{</span> 
	typedef std<span class="token punctuation">:</span><span class="token punctuation">:</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">></span> type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

MyAllocList<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>type lw<span class="token punctuation">;</span></code></pre></div>
<p>Если же после этого мы захотим использовать этот шаблно внутри другого шаблонизированного класса, то придется писать <code class="language-text">typename</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
private<span class="token punctuation">:</span>
	typename MyAllocList<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>type list<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>Кстати, при использовании type traits так и приходится писать, так как они были реализованы с использованием тайпдефов, а не алиасов, несмотря на то, что были введены в C++11. В С++14 признали эту ошибку и для каждого класса <code class="language-text">std::transformation&lt;T&gt;::type</code> теперь есть соответствующий <code class="language-text">std::transformation_t&lt;T&gt;</code>, реализованный через алиасы.</p>
<p>Так вот, в С++11 есть алиасы и использовать их мы можем так:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
using MyAllocList <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">></span><span class="token punctuation">;</span>

MyAllocList<span class="token operator">&lt;</span>Widget<span class="token operator">></span> lw<span class="token punctuation">;</span></code></pre></div>
<h2>Используйте scoped enums вместо unscoped enums</h2>
<p>Есть такое правило, что имя, объявленное внутри фигурных скобок, видно только внутри области, ограниченной этими скобками. Это правило соблюдается всегда, кроме енумов в C++98.</p>
<p>Поэтому енумы в C++98 - unscoped enums:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">enum Color <span class="token punctuation">{</span>red<span class="token punctuation">,</span> black<span class="token punctuation">,</span> white<span class="token punctuation">}</span><span class="token punctuation">;</span>

auto white <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>		<span class="token comment">// ОШИБКА КОМПИЛЯЦИИ! white уже определен</span></code></pre></div>
<p>В С++11 им на замену пришли scoped enums:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">enum class <span class="token class-name">Color</span> <span class="token punctuation">{</span>red<span class="token punctuation">,</span> black<span class="token punctuation">,</span> white<span class="token punctuation">}</span><span class="token punctuation">;</span>

auto white <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>		<span class="token comment">// все норм</span>
Color c <span class="token operator">=</span> white<span class="token punctuation">;</span>		<span class="token comment">// ОШИБКА КОМПИЛЯЦИИ! нет имени white в текущем скоупе</span>
Color c <span class="token operator">=</span> Color<span class="token punctuation">:</span><span class="token punctuation">:</span>white<span class="token punctuation">;</span>	<span class="token comment">// ok</span>
auto c <span class="token operator">=</span> Color<span class="token punctuation">:</span><span class="token punctuation">:</span>white<span class="token punctuation">;</span>	<span class="token comment">// ok</span></code></pre></div>
<p>Помимо ограниченной видимости, вторая причина, по которой стоит использовать scoped enums - более строгая типизация. Unscoped enums свободно неявно приводятся к целочисленным типам и типам с плавающей точкой:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">Color c <span class="token operator">=</span> Color<span class="token punctuation">:</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span>

<span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token number">14.5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">// ОШИБКА КОМПИЛЯЦИИ</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">if</span><span class="token punctuation">(</span>static_vast<span class="token operator">&lt;</span>double<span class="token operator">></span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">14.5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>		<span class="token comment">// OK</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre></div>
<p>И еще одно преимущество - при использовании scoped enums не нужно перекомпиливать клиентов енума при добавлении в него нового значения. А с unscoped enums - нужно.</p>
<p>Дефолтный тип для scoped enums - int, для unscoped enums - нет дефолтного.</p>
<h2>Используйте deleted функции вместо private undefined</h2>
<p>В С++98 когда нужно запретить вызов какой-либо функции (обычно конструктора присваивания или копирования), то определяют ее как private и просто не пишут ее реализацию:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template <span class="token operator">&lt;</span>class <span class="token class-name">charT</span><span class="token punctuation">,</span> class <span class="token class-name">traits</span> <span class="token operator">=</span> char_traits<span class="token operator">&lt;</span>charT<span class="token operator">></span> <span class="token operator">></span>
   class <span class="token class-name">basic_ios</span> <span class="token punctuation">:</span> public ios_base <span class="token punctuation">{</span>
   public<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
private<span class="token punctuation">:</span>
     <span class="token function">basic_ios</span><span class="token punctuation">(</span>const basic_ios<span class="token operator">&amp;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// not defined</span>
     basic_ios<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span>const basic_ios<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// not defined</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p><strong>private</strong> гарантирует, что внешний код не имеет доступ к этим функциям. Отсутствие реализации для таких функций гарантирует, что даже если какой-то какой-то код, имеющий к ним доступ, попытается их вызвать, он получит ошибку на этапе линковки.</p>
<p>В C++11 такие функции определяются как удаленные:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template <span class="token operator">&lt;</span>class <span class="token class-name">charT</span><span class="token punctuation">,</span> class <span class="token class-name">traits</span> <span class="token operator">=</span> char_traits<span class="token operator">&lt;</span>charT<span class="token operator">></span> <span class="token operator">></span> 
class <span class="token class-name">basic_ios</span> <span class="token punctuation">:</span> public ios_base <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token function">basic_ios</span><span class="token punctuation">(</span>const basic_ios<span class="token operator">&amp;</span> <span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span> 
	basic_ios<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span>const basic_ios<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span> 
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Удаленные функции никак не могут быть использованы и такие попытки приведт к ошибкам на этапе компиляции.</p>
<p>А еще, используя удаленные функции, можно запретить использование шаблонных функций с определенными типами:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">processPointer</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

template<span class="token operator">&lt;</span><span class="token operator">></span>
void processPointer<span class="token operator">&lt;</span>void<span class="token operator">></span><span class="token punctuation">(</span>void<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span>
template<span class="token operator">&lt;</span><span class="token operator">></span>
void processPointer<span class="token operator">&lt;</span>char<span class="token operator">></span><span class="token punctuation">(</span>char<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span>
template<span class="token operator">&lt;</span><span class="token operator">></span>
void processPointer<span class="token operator">&lt;</span>const void<span class="token operator">></span><span class="token punctuation">(</span>const void<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span>
template<span class="token operator">&lt;</span><span class="token operator">></span>
void processPointer<span class="token operator">&lt;</span>const char<span class="token operator">></span><span class="token punctuation">(</span>const char<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span></code></pre></div>
<h2>Declare overriding functions override.</h2>
<p>Для переопределения виртуальной функции должны совпадать: названия функций, типы аргументов, константность функций, квалификаторы ссылок.</p>
<p>Должны быть совместимыми: возвращаемый тип и exception specification.</p>
<p>Помимо этого, конечно же, метоб в базовом классе должен быть обозначен как virtual.</p>
<p>ПРИМЕЧАНИЕ: Квалификаторы ссылок это такие вот штуки:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  void <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span>  <span class="token comment">// может быть вызвана, только когда *this - lvalue</span>
  void <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>   <span class="token comment">// *this - rvalue</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

w<span class="token punctuation">.</span><span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// вызовется первый</span>

makeWidget<span class="token punctuation">.</span><span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// вызовется второй</span></code></pre></div>
<p>Так вот, все эти ограничения означают, что очень легко допустить ошибку при использовании виртуальных функций. Если ограничения не соблюдены, то код скомпилиться, но в наследнике вместо переопределения будет создана новая функция.</p>
<p>В C++11 для решения этой проблемы появилось ключевое слово <code class="language-text">override</code>.</p>
<h2>Prefer const_terators to iterators</h2>
<p>В C++11 добавились функции <code class="language-text">cbegin</code> и <code class="language-text">cend</code>, которые возвращают <code class="language-text">const_iterator</code> даже для не-константных контейнеров.</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>int<span class="token operator">></span> values<span class="token punctuation">;</span>
auto it <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">find</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> values<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1983</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
values<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> <span class="token number">1998</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Единственный недостаток у таких функций - в C++11 у них нет non-member версий, как у <code class="language-text">begin</code> и <code class="language-text">end</code>. В С++14 - уже есть.</p>
<p>В generic-коде лучше использовать non-member версии.</p>
<h2>Declare functions noexcept if they won't emit exceptions</h2>
<ul>
<li>вызывающие функции могут проверять наличие <code class="language-text">noexcept</code> у функции и использовать более безопасный/производительный код</li>
</ul>
<p>Например, при <code class="language-text">push_back</code> в <code class="language-text">std::vector</code>, если длина превышает вместимость, то создается новый вектор побольше и все элементы копируются туда. Затем, когда все успешно скопировались, старый вектор уничтожается. Это нужно для защиты от исключений - если на копировании N-го элемента возникнет исключение, то старый вектор останется неизменным.</p>
<p>Но если имеется конструктор перемещения и он помечен как <code class="language-text">noexcept</code>, то в этом алгоритме может быть использовано перемещение вместо копирования, ведь мы точно знаем, что исключения на N-м элементе возникнуть не может.</p>
<ul>
<li>компилятор генерирует более производительный код, потому что <strong>может</strong> не генерировать код разматывания стека при исключении для функций, помеченных как <code class="language-text">noexcept</code>.</li>
</ul>
<p>Вторая причина очень важна. Оптимизаторам не нужно хранить где-то заранее размотанный стэк на случай исключения, не нужно гарантировать, что объекты в <code class="language-text">noexcept</code> функции будут уничтожены в обратном порядке создания в случае исключения.</p>
<p>Однако в этом случае, если в функции произойдет исключение, и оно покинет функцию, то моментально будет вызван <code class="language-text">std::terminate</code></p>
<h3>Условный noexcept</h3>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template <span class="token operator">&lt;</span>class <span class="token class-name">T</span><span class="token punctuation">,</span> size_t N<span class="token operator">></span>
void <span class="token function">swap</span><span class="token punctuation">(</span>T <span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>
          T <span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">noexcept</span><span class="token punctuation">(</span><span class="token function">noexcept</span><span class="token punctuation">(</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

template <span class="token operator">&lt;</span>class <span class="token class-name">T1</span><span class="token punctuation">,</span> class <span class="token class-name">T2</span><span class="token operator">></span>
struct pair <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  void <span class="token function">swap</span><span class="token punctuation">(</span>pair<span class="token operator">&amp;</span> p<span class="token punctuation">)</span> <span class="token function">noexcept</span><span class="token punctuation">(</span><span class="token function">noexcept</span><span class="token punctuation">(</span><span class="token function">swap</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> p<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">noexcept</span><span class="token punctuation">(</span><span class="token function">swap</span><span class="token punctuation">(</span>second<span class="token punctuation">,</span> p<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>Здесь noexcept-ность нашей функции обмена зависит от noexcept-ности обмена внутренних элементов - первого элемента массива, либо обоих элементов структуры pair.</p>
<h2>Use constexpr whenever possible</h2>
<h3>constexpr objects</h3>
<p>Когда применяется к объектам, <code class="language-text">constexpr</code> определяет значение, которое не только константно, но еще и известно во время компиляции.</p>
<p>ТАкие значения могут быть помещены в read-only память. Могут быть применены там, где требуется <em>integral constant expression</em>, например, в качестве длин массивов, аргументов шаблонов, значений енумов, спецификаторов выравнивания.</p>
<h3>constexpr functions</h3>
<p>Когда применяется к функциям, то все сложнее. Такие функции возвращают константы времени компиляции только когда их аргументами являются константы времени компиляции. В остальных случаях они возвращают обычные значения и работают в рантайме.</p>
<p>Преимущество в том, что не нужны 2 разных функции, одна из которых работает в компайл-тайме, а другая в рантайме.</p>
<p>Ограничения constexpr-функции:</p>
<ul>
<li>В C++11 должна содержать не больше одного выражения. Однако оно может быть сколь угодно сложным. Вместо if-else можно использовать "?:", а вместо циклов - рекурсию. В С++14 такого ограничения нет.</li>
<li>Может принимать и возвращать только типы-литералы, то есть типы, чьи значения определены на этапе компиляции. В C++11 это все типы, кроме <code class="language-text">void</code>. Пользовательские типы могут быть литералами, когда коструктор и все используемые функции определены как <code class="language-text">constexpr</code>.</li>
</ul>
<h2>Make const member functions thread safe</h2>
<p>Члены класса, помеченные, как <code class="language-text">mutable</code>, могут быть изменены const-функциями. В этом случае только разработчик ответственнен за то, что изменение mutable-поля не разрушит константность функции.</p>
<p>mutable-поля могут быть полезны, например, при реализации кэширования в константной функции.</p>
<p>Пользователь const-функции не знает, используются ли внутри mutable переменные, поэтому он всегда предполагает, что такая функция потокобезопасна. </p>
<p>Поэтому при использовании mutable-полей, нужно обеспечить потокобезопасность для своей функции, например, через <code class="language-text">std::atomic</code>, или мютексы, если таких полей несколько. </p>
<p>При использовании мютекса, конечно, его придется тоже сделать <code class="language-text">mutable</code>.</p>
<p>Пример:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Point</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  double <span class="token function">distanceFromOrigin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> const noexcept
  <span class="token punctuation">{</span>
    <span class="token operator">++</span>callCount<span class="token punctuation">;</span>
    <span class="token keyword">return</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>y <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

private<span class="token punctuation">:</span>
     mutable std<span class="token punctuation">:</span><span class="token punctuation">:</span>atomic<span class="token operator">&lt;</span>unsigned<span class="token operator">></span> callCount<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
     double x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<h2>Understand special member function generation</h2>
<p>В C++98 автогененерировались:</p>
<ul>
<li>дефолтный конструктор: <code class="language-text">Widget()</code></li>
<li>деструктор: <code class="language-text">~Widget()</code></li>
<li>конструктор копирования: <code class="language-text">Widget(const Widget&amp;)</code></li>
<li>оператор присваивания копии: <code class="language-text">Widget&amp; operator=(const Widget&amp;)</code></li>
</ul>
<p>Они генерировались только, если реально использовались в коде. Все эти фунции генерируются как <code class="language-text">public inline</code>. Все, кроме деструктора - не виртуальные. Деструктор генерируется как виртуальный, когда это деструктор в наследованном классе, а в родительском он виртуальный.</p>
<p>В С++11 в списку автогенерируемых функций добавились:</p>
<ul>
<li>конструктор перемещения: <code class="language-text">Widget(Widget&amp;&amp; rhs)</code></li>
<li>оператор присваивания перемещением: <code class="language-text">Widget&amp; operator=(Widget&amp;&amp; rhs)</code></li>
</ul>
<p>Эти операции так же генерируются только, если нужны, и их дефолтные реализации осуществляют memberwise move не-статических членов класса. То есть конструктор перемещения вызывает конструктор перемещения для всхе не-статических членов, передавая туда соответствующие члены из <code class="language-text">rhs</code>, а оператор присваивания перемещением аналогичным образом присваивает членам <code class="language-text">lhs</code> соответствующие члены <code class="language-text">rhs</code>.</p>
<p>Конструктор перемещения также конструирует перемещением все члены базовых классов, а оператор присваивания перемещением присваивает их перемещением.</p>
<p>Когда речь идет о конструировании перемещением, или присваивании перемением, то это еще не значит, что перемещение обязательно произойдет. На самом деле будет выполнен "запрос перемещения", потому что не-перемещаемые типы будут просто скопированы. Внутри каждого конструктора перемещения и присваивания перемещением все равно находится обычный <code class="language-text">std::move</code>, который полагается на наличие соответствующих функций.</p>
<h3>Генерация копирования и перемещения</h3>
<p><strong>Две операции копирования генерируются независимо друг от друга.</strong> То есть, если пользователь объявил конструктор копирования, но не объявил присваивание копированием, а потом написал код, который требует присваивание копированием, то оператор присваивания копированием будет сгенерирован.</p>
<p><strong>Операции перемещения, напротив, генерируются зависимо.</strong> Если пользователь определил одну из них, это не дает компилятору сгенерировать другую. Мотивация такова - если пользовать определил, например, конструктор перемещением, значит, есть что-то, что его не устраивает в дефолтной memberwise-реализации перемещения. А значит оператор присваивания перемещением тоже будет сгенерирован неправильно.</p>
<p>Более того, <strong>операции перемещения не генерируются, если определена хотя бы одна операция копирования</strong>. Мотивация такая же - если явно определена операция копирования, значит дефолтная не устраивает, значит дефолтная memberwise-реализация перемещения, скорее всего, тоже будет ошибочна.</p>
<p>В обратную сторону работает точно так же. <strong>Операции копирования не генерируются, если определена хотя бы одна операция перемещения</strong>.</p>
<p>Помимо этого, <strong>операции перемещения не генерируются, если определен деструктор</strong>, потому что наличие деструктора обычно говорит о том, что здесь происходит какой-то менеджмент ресурсов, а в этом случае при копировании нужно тоже что-то с ресурсом сделать. См. Правило Трех.</p>
<p>Итак, операции перемещения генерируются только когда в классе соблюдаются следующие правила:</p>
<ul>
<li>Не определена ни одна операция копирования</li>
<li>Не определена ни одна операция перемещения</li>
<li>Не определен деструктор</li>
</ul>
<p>Последнее правило может привести к серьезному ухудшению производительности при простом добавлении деструктора в класс, так как операции перемещения перестанут генерироваться и класс будет всегда копироваться. Поэтому при указании деструктора нужно всегда обязательно добавлять операции перемещения и копирования, даже если они реализуются через <code class="language-text">=default</code>.</p>
<p>Итак, окончательный список автогенерируемых функций таков:</p>
<table>
<thead>
<tr>
<th>Операция</th>
<th>Сигнатура</th>
<th>Правило  автогенерации</th>
</tr>
</thead>
<tbody>
<tr>
<td>Дефолтный конструктор</td>
<td><code class="language-text">Widget()</code></td>
<td>Только если в классе не определено никаких конструкторов</td>
</tr>
<tr>
<td>Деструктор</td>
<td><code class="language-text">~Widget()</code></td>
<td>По умолчанию <code class="language-text">noexcept</code>. Виртуальный, если деструктор родительского класса тоже виртуальный</td>
</tr>
<tr>
<td>Конструктор копирования</td>
<td><code class="language-text">Widget(const Widget&amp;)</code></td>
<td>memberwise-копирование не-статических членов. Только, если не определен явно. Удаляется, если определена операция перемещения. Не рекомендуется использовать автосгенерируемый, если в классе есть оператор присваивания копированием, или деструктор.</td>
</tr>
<tr>
<td>Оператор присваивания копированием</td>
<td><code class="language-text">Widget&amp; operator=(const Widget&amp;)</code></td>
<td>memberwise-копирование не-статических членов. Только если не определен явно. Удаляется, если определена операция перемещения. Не рекомендуется использовать автосгенерируемый, если в классе есть конструктор копирования, или деструктор.</td>
</tr>
<tr>
<td>Конструктор перемещения</td>
<td><code class="language-text">Widget(Widget&amp;&amp; rhs</code>)</td>
<td>memberwise-перемещение не-статических членов. Только если в классе не определена ни одна операция копирования, перемещения, или деструктор.</td>
</tr>
<tr>
<td>Оператор присваивания перемещением</td>
<td><code class="language-text">Widget&amp; operator=(Widget&amp;&amp; rhs)</code></td>
<td>Аналогично конструктору перемещения</td>
</tr>
</tbody>
</table>
<h2>Use std::unique_ptr for exclusive-ownership resource management</h2>
<p>Имеют такой же размер, как и сырые указатели (если не используются кастомные делетеры). Для большинства операций генерируют те же инструкции.</p>
<p>Перемещение <code class="language-text">std::unique_ptr</code> перемещает владение от пойнтера-источника к пойнтеру-назначению. Пойнтер-источник при этом выставляется в null. </p>
<p>Копирование <code class="language-text">std::unique_ptr</code> запрещено.</p>
<p>Типичный кейс - тип возвращаемого значения для фабричной функции.</p>
<p>Может быть задан специфичный делетер:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto delInvmt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Investment<span class="token operator">*</span> pInvestment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">makeLogEntry</span><span class="token punctuation">(</span>pInvestment<span class="token punctuation">)</span><span class="token punctuation">;</span>
  delete pInvestment<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token punctuation">,</span> <span class="token function">decltype</span><span class="token punctuation">(</span>delInvmt<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">pInv</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">,</span> delInvmt<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Кастомные делетеры увеличивают размер пойнтера. </p>
<p>Если делетер указан в виде указателя на функцию, то размер пойнтера увеличивается с 1 слова до 2. </p>
<p>Если же это функтор, то дельта размера зависит от того, сколько состояния хранится в функторе. Функторы без состояния (например, лямбды без захваченных переменных) не увеличивают размер вообще. </p>
<p>Поэтому когда кастомный делетер может быть реализован как функция, либо как лямбда без состояния, лучше выбирать лямбду.</p>
<h3>std::unique_ptr&#x3C;T[]></h3>
<p>Для массивов используется вторая форма <code class="language-text">unique_ptr</code>. Благодаря этому, всегда однозначно известно, на какой тип сущности указывает пойнтер. </p>
<p>Для сингл-формы не определен оператор индексации, а мульти-форма не имеет оператора разыменования.</p>
<h3>std::unique<em>ptr -> std::shared</em>ptr</h3>
<p><code class="language-text">std::unique_ptr</code> легко и эффективно конвертируется в <code class="language-text">std::shared_ptr</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> sp <span class="token operator">=</span> <span class="token function">makeInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">makeInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Поэтому клиент фабрики может сам решать, какая модель владения ему нужна.</p>
<h2>Use std::shared_ptr for shared-ownership resource management</h2>
<p>У каждого <code class="language-text">shared_ptr</code> есть счетчик ссылок. Это конечно влияет на производительность:</p>
<ul>
<li>размер <code class="language-text">std::shared_ptr</code> в 2 раза больше размера сырого указателя</li>
<li>память для счетчика ссылок аллоцируется динамически. Объект, на который ссылается указатель, ничего о счетчике не знает, поэтому счетчик должен храниться вне его. Использование <code class="language-text">std::make_shared</code> избегает оверхеда динамической аллокации.</li>
<li>инкременты и декременты счетчика ссылок атомарны, потому что могут быть одновременные читатели и писатели в разных потоках. Поэтому операции увеличения и уменьшения сетчика ссылок довольно медленные.</li>
</ul>
<p>При перемещении <code class="language-text">std::shared_ptr</code> счетчик ссылок остается неизменным, поэтому перемещение таких указателей быстрее, чем копирование.</p>
<p><code class="language-text">std::shared_ptr</code> тоже поддерживает кастомные делетеры, но у них тип делетера не является частью типа указателя:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto loggingDel <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Widget <span class="token operator">*</span>pw<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Widget</span><span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span></code></pre></div>
<p>Благодаря этому указатели с разными типами делетеров могут быть помещены в одну коллекцию, переданы в одну и ту же функцию и быть приводимы один к другому.</p>
<p>Еще одно отличие от <code class="language-text">std::unique_ptr</code> - указание кастомного делетера не увеличивает размер указателя. Размер всегда равняется двум обычным указателям. На самом деле, память под делетер выделяется, но она просто не является частью указателя. Дело в том, что второй указатель в <code class="language-text">std::shared_ptr</code> - указатель не просто на счетчик ссылок, а на так называетмый управляющий блок - <em>control block</em>. Такой блок есть для каждого объекта, управляемого <code class="language-text">std::shared_ptr</code>. Этот блок содержит:</p>
<ul>
<li>счетчик ссылок</li>
<li>копию кастомного делетера</li>
<li>копию кастомного аллокатора, если указан</li>
<li>вторичный счетчик ссылок, используемый для <code class="language-text">std::weak_ptr</code>.</li>
</ul>
<p>Управляющий блок создается функцией, которая создает первый <code class="language-text">std::shared_ptr</code> на объект. Но так как в момент создания невозможно узнать, является ли этот указатель первым, то происходит следующее:</p>
<ul>
<li><code class="language-text">std::make_shared</code> <strong>всегда</strong> создает управляющий блок.</li>
<li>управляющий блок создается, когда <code class="language-text">std::shared_ptr</code> конструируется из <code class="language-text">std::unique_ptr</code> или <code class="language-text">std::auto_ptr</code>. Это возможно, потому что эти указатели не используют контрольных блоков, так что созданный точно будет первым.</li>
<li>управляющий блок создается, когда <code class="language-text">std::shared_ptr</code> создается из сырого указателя.</li>
</ul>
<p>Получается, что управляющий блок не создается, когда <code class="language-text">std::shared_ptr</code> создается из другого <code class="language-text">std::shared_ptr</code> или <code class="language-text">std::weak_ptr</code>.</p>
<p>Следствием этих правил является то, что если мы создаем больше одного <code class="language-text">std::shared_ptr</code> из одного сырого указателя, то получаем гарантированное undefined behavior, потому что объект будет иметь несколько контрольных блоков, что значит несколько счетчиков ссылок, что значит он будет уничтожен несколько раз.</p>
<p>Отсюда следует правило: не передавать сырые указатели в конструктор <code class="language-text">std::shared_ptr</code>. Вместо этого следует использовать <code class="language-text">std::make_shared</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> spw1 <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>make_shared<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Однако это невозможно, если нужно указать кастомый делетер. В таком случае сырой указатель можно передать, но нужно удостовериться, что он передается как <em>rvalue</em> и не сохраняется ни в какую переменную, что увеличило бы риск повторного создания <code class="language-text">std::shared_ptr</code> из этой переменной:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Widget</span><span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<h3>shared<em>from</em>this</h3>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">></span> processedWidgets<span class="token punctuation">;</span>

class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  void <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    processedWidgets<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Это очень опасный код. Опасен он тем, что при вызове <code class="language-text">emplace_back</code> в вектор кладется не <code class="language-text">shared_ptr</code>, а сырой указатель<code class="language-text">this</code>. Он будет приведен к <code class="language-text">shared_ptr</code>, а значит, будет создан новый управляющий блок на <code class="language-text">this</code>. Если есть еще какие-нибудь <code class="language-text">std::shared_ptr</code>, ссылающиеся на наш объект, то рано или поздно это приведет к undefined behavior.</p>
<p>Выход - использовать <code class="language-text">std::enable_shared_from_this</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">></span> processedWidgets<span class="token punctuation">;</span>

class <span class="token class-name">Widget</span><span class="token punctuation">:</span> public std<span class="token punctuation">:</span><span class="token punctuation">:</span>enable_shared_from_this<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  void <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    processedWidgets<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Функция <code class="language-text">shared_from_this</code> обращается к управляющему блоку, ассоциированному с текущим объектом и выбросит исключение, если такового нет. Поэтому обычно наследники <code class="language-text">std::enable_shared_from_this</code> закрывают конструктор и делают фабричную функцию, возвращающую <code class="language-text">std::shared_ptr</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Widget</span><span class="token punctuation">:</span> public std<span class="token punctuation">:</span><span class="token punctuation">:</span>enable_shared_from_this<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  template<span class="token operator">&lt;</span>typename<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>
  static std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  void <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
private<span class="token punctuation">:</span>
  <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<h3>std::shared_ptr&#x3C;T[]></h3>
<p>Перегрузки для массивов - нет, в отличие от <code class="language-text">std::unique_ptr</code>. И не стоит пытаться передавать туда массив. Во-первых, <code class="language-text">std::shared_ptr</code> не поддерживает оператор <strong>[]</strong>. Во-вторых, <code class="language-text">std::shared_ptr</code> поддерживает конвертацию devived-to-base, которая работает для отдельных объектов, но плохо будет работать с массивами. </p>
<h2>Use std::weak<em>ptr for std::shared</em>ptr-like pointers that can dangle</h2>
<p>Иногда бывает нужно использовать указатель, который ведет тебя как <code class="language-text">shared_ptr</code>, но при этом не участвует в подсчете ссылок. ТАкой указатель есть - это <code class="language-text">std::weak_ptr</code>. Он знает, когда он указывает в пустоту, то есть когда объект, на который он указывает, больше не существует.</p>
<p>На самом деле <code class="language-text">std::weak_ptr</code> не является умным указателем, это улучшение над <code class="language-text">std::shared_ptr</code>. Поэтому <code class="language-text">std::weak_ptr</code> нельзя разыменовать и нельзя проверить его на равенство null.</p>
<p><code class="language-text">std::weak_ptr</code> обычно конструируются из <code class="language-text">std::shared_ptr</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto spw <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>make_shared<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>weak_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">wpw</span><span class="token punctuation">(</span>spw<span class="token punctuation">)</span><span class="token punctuation">;</span>
spw <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>wpw<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"weak_ptr is dangling now"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Операции разыменования нет по причине того, что нельзя разделять операцию проверки на <code class="language-text">expired</code> и операцию разыменования - ведь объект может уничтожиться между этими вызовами. Поэтому есть атомарная операция, объединяющая эти две:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> spw1 <span class="token operator">=</span> wpw<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

auto spw2 <span class="token operator">=</span> wpw<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span><span class="token punctuation">(</span>spw2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Если объект заэкспайрился, то <code class="language-text">lock()</code> вернет <em>null</em>.</p>
<p>Второй вариант - создать <code class="language-text">shared_ptr</code> из <code class="language-text">weak_ptr</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw3</span><span class="token punctuation">(</span>wpw<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p><code class="language-text">std::weak_ptr</code> полезен при реализации кэширования - в этом случае кэширующий указатель стоит реализовать в виде <code class="language-text">weak_ptr</code>.</p>
<p>Еще его используют при реализации паттерна Observer. В нем наблюдатели держат копию субъекта таким <code class="language-text">std::weak_ptr</code>, чтобы не расширять его лайфтайм.</p>
<p>Ну и наконец третий кейс - циклические ссылки. При использовании <code class="language-text">shared_ptr</code> мы получили бы утечку памяти, а если одну из ссылок сделать <code class="language-text">weak_ptr</code>, то все хорошо.</p>
<p>Размер у <code class="language-text">std::weak_ptr</code> - такой же, как у <code class="language-text">shared_ptr</code>, они используют те же управляющие блоки. Операции создания, уничтожения и присваивания изменяют вторичный счетчик ссылок в управляющем блоке.</p>
<h2>Prefer std::make<em>unique and std::make</em>shared to direct use of new</h2>
<p>Рассмотрим код:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Widget</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">computePriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Как ни странно, этот код может привести к утечке памяти. Это происходит, если операции располагаются при компиляции следующим образом:</p>
<ol>
<li><code class="language-text">new Widget()</code></li>
<li><code class="language-text">computePriority()</code></li>
<li><code class="language-text">std::shared_ptr()</code></li>
</ol>
<p>Если на 2 шаге наша функция выстрелит исключение, то мы получим зависший <code class="language-text">new Widget</code>, на который никто не указывает - получили утечку.</p>
<p>Другая причина - эффективность. Посмотрим на код:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Widget</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Здесь производится не одна, а две динамических аллокации. Сначала создается <code class="language-text">Widget</code>, а потом управляющий блок для него.</p>
<p>Если же мы используем <code class="language-text">make_shared</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto spw <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>make_shared<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>то осуществляется лишь одна аллокация, потому что <code class="language-text">make_shared</code> аллоцирует один кусок памяти и для <code class="language-text">Widget</code> и для его управляющего блока. Помимо того, уменьшается и размер программы, потому что становится меньше инструкций аллоцирования.</p>
<h3>Ограничения</h3>
<ul>
<li><code class="language-text">make</code>-функции не позволяют указать кастомный делетер</li>
<li>есть традиционная путаница с <code class="language-text">initializer_list</code>:</li>
</ul>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto upv <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>make_unique<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>int<span class="token operator">></span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Здесь будет создан вектор с 10 элементами, каждый из которых равен 20. А значит внутри для инициализации используется синтаксис с круглыми скобками, а не с фигурными.</p>
<ul>
<li>контрольный блок должен существовать, пока не будет уничтоен последний <code class="language-text">shared_ptr</code>, ссылающийся на него <strong>И</strong> последний <code class="language-text">weak_ptr</code>, ссылающийся на него. А так как <code class="language-text">make_shared</code> аллоцирует один кусок памяти для контрольного блока и для объекта, то и память, выделенная для объекта не может быть освобождена, пока не уничтожится последний <code class="language-text">std::weak_ptr</code>. То есть объект давно уничтожился, но он продолжает занимать память. В случае использования <code class="language-text">new</code> память освободится, как только объект уничтожится, независимо от наличия <code class="language-text">weak_ptr</code>, ссылающися на него.</li>
</ul>
<h2>When using the Pimpl Idiom, define special member function in the implementation file</h2>
<p>Pimpl Idiom - техника, используемая для уменьшения времени билда. Члены класса заменяются на указатель на класс/структуру реализации, члены класса перемещаются в класс реализации и обращение к ним осуществляется через указатель.</p>
<p>До применения:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token comment">// Widget.h</span>

#include <span class="token string">"Gadget.h"</span>
#include <span class="token operator">&lt;</span>string<span class="token operator">></span>
#include <span class="token operator">&lt;</span>vector<span class="token operator">></span>

class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
private<span class="token punctuation">:</span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>string name<span class="token punctuation">;</span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>double<span class="token operator">></span> data<span class="token punctuation">;</span>
  Gadget g1<span class="token punctuation">,</span> g2<span class="token punctuation">,</span> g3<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>Клиенты <code class="language-text">Widget</code> должны включать <code class="language-text">&lt;string&gt;</code>, <code class="language-text">&lt;vector&gt;</code> и <code class="language-text">gadget.h</code>. Главная проблема здесь в том, что если заголовок <code class="language-text">gadget.h</code> меняется, то все клиенты должны перестроиться.</p>
<p>После применения для С++98:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token comment">// Widget.h</span>
class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
private<span class="token punctuation">:</span>
  struct Impl<span class="token punctuation">;</span>
  Impl <span class="token operator">*</span>pImpl<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Структура <code class="language-text">Widget::Impl</code> определена где-то в другом файле. Здесь мы видим <em>неполный тип</em>. С таким типом можно сделать очень мало вещей, и одна из них - определение указателя.</p>
<p>Вторая часть паттерна - динамическое создание и уничтожение <code class="language-text">Widget::Impl</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token comment">// Widget.cpp</span>

#include <span class="token string">"Widget.h"</span>
#include <span class="token string">"Gadget.h"</span>
#include <span class="token operator">&lt;</span>string<span class="token operator">></span>
#include <span class="token operator">&lt;</span>vector<span class="token operator">></span>

struct Widget<span class="token punctuation">:</span><span class="token punctuation">:</span>Impl <span class="token punctuation">{</span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>string name<span class="token punctuation">;</span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>double<span class="token operator">></span> data<span class="token punctuation">;</span>
  Gadget g1<span class="token punctuation">,</span> g2<span class="token punctuation">,</span> g3<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Widget<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Impl</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

Widget<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> delete pImpl<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre></div>
<p>Зависимости от <code class="language-text">std::string</code>, <code class="language-text">std::vector</code> и <code class="language-text">Gadget</code> остались, но они переехали из <code class="language-text">Widget.h</code> в <code class="language-text">Widget.cpp</code>.</p>
<p>В С++11 можем использовать <code class="language-text">std::unique_ptr</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token comment">// Widget.h</span>

class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span> 
  <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
private<span class="token punctuation">:</span>
  struct Impl<span class="token punctuation">;</span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>Impl<span class="token operator">></span> pImpl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token comment">// Widget.cpp</span>

#include <span class="token string">"Widget.h"</span>
#include <span class="token string">"Gadget.h"</span>
#include <span class="token operator">&lt;</span>string<span class="token operator">></span>
#include <span class="token operator">&lt;</span>vector<span class="token operator">></span>

struct Widget<span class="token punctuation">:</span><span class="token punctuation">:</span>Impl <span class="token punctuation">{</span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>string name<span class="token punctuation">;</span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>double<span class="token operator">></span> data<span class="token punctuation">;</span>
  Gadget g1<span class="token punctuation">,</span> g2<span class="token punctuation">,</span> g3<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Widget<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>make_unique<span class="token operator">&lt;</span>Impl<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre></div>
<p>Реализация <code class="language-text">make_unique</code> в C++11 может выглядеть так:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token punctuation">,</span> typename<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">make_unique</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<h2>Understand std::move and std::forward</h2>
<p><code class="language-text">std::move</code> ничего не перемещает, а <code class="language-text">std::forward</code> ничего не форвардит. В рантайме они не делают ничего, потому что даже не генерируют исполняемого кода. Все что они делают - конвертируют типы.</p>
<p><code class="language-text">std::move</code> приводит аргумент к <em>rvalue</em>.</p>
<p><code class="language-text">std::forward</code> тоже приводит к <em>rvalue</em>, но только если аргумент был инициализирован как <em>rvalue</em>.</p>
<p>Пример реализации <code class="language-text">std::move</code>: </p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
typename remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>type<span class="token operator">&amp;&amp;</span>
<span class="token function">move</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  using ReturnType <span class="token operator">=</span> typename remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>type<span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> static_cast<span class="token operator">&lt;</span>ReturnType<span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Так как тип аргумента <code class="language-text">T&amp;&amp;</code> может означать как <code class="language-text">rvalue</code>, так и <code class="language-text">lvalue</code>, то нам нужен тип <code class="language-text">remove_reference</code>. Он снимает ссылку, если <code class="language-text">T</code> - ссылочный тип и оставляет все как есть, если нет.</p>
<p>Все <code class="language-text">rvalue</code> передаются перемещением, поэтому после применения <code class="language-text">std::move</code> на объекте, он сможет быть переданным куда-то путем перемещения, а не копирования.</p>
<p>Однако не всегда <code class="language-text">rvalue</code> передаются перемещением, а значит и <code class="language-text">std::move</code> не всегда будет перемещать. Например, значение не будет перещеаться из константы:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Annotation</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  explicit <span class="token function">Annotation</span><span class="token punctuation">(</span>const std<span class="token punctuation">:</span><span class="token punctuation">:</span>string text<span class="token punctuation">)</span>
    <span class="token punctuation">:</span> <span class="token function">value</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">move</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
private<span class="token punctuation">:</span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>string value<span class="token punctuation">;</span>    
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>В примере выше text в value попадет путем копирования, так как он не может переместиться из константы.</p>
<h2>Distinquish universal references from rvalue references</h2>
<p><code class="language-text">T&amp;&amp;</code> имеет два значения:</p>
<ul>
<li>rvalue reference</li>
<li>universal reference</li>
</ul>
<p>Универсальная ссылка может быть привязана к rvalue, lvalue, константам, не-константам, volatile, не-volatile, и даже к <code class="language-text">const volatile</code>-объектам.</p>
<p>Обычно универсальные ссылки используются в типах шаблонов и в auto-декларациях:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

auto<span class="token operator">&amp;&amp;</span> var2 <span class="token operator">=</span> var1<span class="token punctuation">;</span></code></pre></div>
<p>В обоих этих случаях присутствует вывод типа, поэтому используется универсальная ссылка. </p>
<p>Если вывода типа (к которому относится <strong>&#x26;&#x26;</strong>) нет, то <code class="language-text">T&amp;&amp;</code> означает ссылку на rvalue:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">void <span class="token function">f</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

Widget<span class="token operator">&amp;&amp;</span> var1 <span class="token operator">=</span> <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Форма вывода типа очень важна, чтобы использовалась универсальная ссылка, тип <strong>обязательно</strong> должен быть <code class="language-text">T&amp;&amp;</code>. В следующем примере правило не соблюдается и поэтому используется ссылка на rvalue:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f2</span><span class="token punctuation">(</span>const T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>int<span class="token operator">></span> v<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ОШИБКА, lvalue не принимается</span>

<span class="token function">f2</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ОШИБКА, lvalue не принимается</span></code></pre></div>
<p>Более того, не всегда присутствие <code class="language-text">T&amp;&amp;</code> в шаблоне означает использование универсальной ссылки. Вот пример:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>class <span class="token class-name">T</span><span class="token punctuation">,</span> class <span class="token class-name">Allocator</span> <span class="token operator">=</span> allocator<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">></span>
class <span class="token class-name">vector</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  void <span class="token function">push_back</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>Это не является универсальной ссылкой, так как <code class="language-text">T</code> полностью определяется конкретным классом с подставленными типамию Например, для класса <code class="language-text">Widget</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">vector</span><span class="token operator">&lt;</span>Widget<span class="token punctuation">,</span> allocator<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">></span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  void <span class="token function">push_back</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>Никакого вывода типов здесь нет.</p>
<p>В то же время, функция <code class="language-text">employ_back</code> <em>использует</em> вывод типа, а значит и универсальную ссылку:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>class <span class="token class-name">T</span><span class="token punctuation">,</span> class <span class="token class-name">Allocator</span> <span class="token operator">=</span> allocator<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">></span>
class <span class="token class-name">vector</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  template <span class="token operator">&lt;</span>class<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>
  void <span class="token function">emplace_back</span><span class="token punctuation">(</span>Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>Если поьзователь сам указывает типы при использовании шаблона, то вывода типов опять нет и универсальная ссылка не используется.</p>
<h2>Use std::move on rvalue references, std::forward on universal references</h2>
<p>Если у нас есть ссылка на rvalue, то этот объект точно может быть перемещен. Но внутри функции это уже становится ссылкой на lvalue. Чтобы не потратить возможность впустую, такие аргументы <strong>всегда</strong> должны передаваться через <code class="language-text">std::move</code>, чтобы они привелись к rvalue:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  <span class="token function">Widget</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span>      <span class="token comment">// ссылка на rvalue</span>
  <span class="token punctuation">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">move</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">p</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">move</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre></div>
<p>В свою очередь, универсальная ссылка <em>может</em> быть привязана к объекту, который может быть перемещен. Их нужно перемещать (т.е. приводить к rvalue) только если они были инициализированы rvalue:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
  void <span class="token function">setName</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span>     <span class="token comment">// универсальная ссылка</span>
  <span class="token punctuation">{</span> name <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Такой код не скопилится, если в него передавать <code class="language-text">newName</code> с типом, отличным от <strong>string</strong>. При этом он будет работать чуть производительнее кода, в котором аргументом принимается <code class="language-text">std::string&amp;&amp;</code>, так как в том варианте нужно создавать временный <strong>string</strong> для принятия аргумента, потом еще деструктить его, а здесь - этого всего не нужно, муваем напрямую из литерала.</p>
<p><strong>Отсюда вывод</strong>: замена шаблона, принимающего универсальную ссылку парой функций, принимающих ссылки на rvalue и lvalue добавит оверхеда в рантайме. Помимо этого такая замена может привести к комбинаторному взрывы, когда аргументов станет больше одного.</p>
<p>Еще одно правило - не стоит <strong>никогда</strong> использовать <code class="language-text">std::move</code> на универсальных ссылках, потому что тогда может оказаться, что нам пришла ссылка на lvalue, а мы превратим ее объект в пустое значение.</p>
<h3>return std::move не работает для локальных переменных</h3>
<p>Все, сказанное выше, справедливо лишь для аргументов, полученных на вход функции. Если же у нас есть локальная переменная, которую мы хотим вернуть, то бессмысленно и даже вредно передавать ее через <code class="language-text">std::move</code>, потому что таким образом мы помешаем компилятору провести оптимизацию <em>return value optimization (RVO)</em>.</p>
<p>Эта оптимизация конструирует возвращаемую локальную переменную сразу в той памяти, которая выделена для возвращаемого значения функции.</p>
<p>RVO используется, когда:</p>
<ol>
<li>Тип локальной переменной точно такой же, как и возвращаемый тип функции</li>
<li>Возвращается локальная переменная</li>
</ol>
<p>Пример:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Widget w<span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">return</span> w<span class="token punctuation">;</span>     <span class="token comment">// здесь будет произведено перемещение, а не копирование</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Если же мы возвращаем <code class="language-text">std::move(w)</code>, то мы возвращаем ссылку на <code class="language-text">w</code>, а не саму <code class="language-text">w</code>. Это значит, что правило 1 о совпадении типов больше не соблюдается и RVO применена быть не может.</p>
<p>Но допустим, мы предполагаем, что в каком-то сложном коде компилятор не сможет применить RVO и решаем там заюзать <code class="language-text">std::move</code>. Как ни странно, это все еще плохая идея. Стандарт говорит, что если условия RVO выполнены, но компилятор решает не применять оптимизацию, то возвращаемый объект <em>должен быть обработан как rvalue</em>. То есть он сам за вас подставит <code class="language-text">std::move</code>.</p>
<p>То же правило справедливо и для аргументов, принимаемых по значению. То есть такой код:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Widget w<span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">return</span> w<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>будет на самом деле скомпилирован как:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Widget w<span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">return</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">move</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>При передаче аргументов-по-ссылке или локальных переменных в другие функции такие оптимизации не применяются, поэтому здесь можно спокойно использовать <code class="language-text">std::move</code>.</p>
<p>Резюме:</p>
<ul>
<li>применяйте <code class="language-text">std::move</code> к ссылкам на rvalue и <code class="language-text">std::forward</code> к универсальным ссылкам при последнем их использовании</li>
<li>делаейте то же самое для ссылок, возвращаемых из функций, которые возвращают по значению</li>
<li>никогда не используйте <code class="language-text">std::move</code> или <code class="language-text">std::forward</code> для локальных объектов, которые подходят для RVO</li>
</ul>
<h2>Avoid overloading on universal references</h2>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span> multiset<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token operator">></span> names<span class="token punctuation">;</span>

template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">add</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  names<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

std<span class="token punctuation">:</span><span class="token punctuation">:</span>string <span class="token function">nameFromIdx</span><span class="token punctuation">(</span>int idx<span class="token punctuation">)</span><span class="token punctuation">;</span>

void <span class="token function">add</span><span class="token punctuation">(</span>int idx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  names<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token function">nameFromIdx</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Здесь у нас 2 перегрузки метода <code class="language-text">add</code>. Пока мы в аргумент передаем <strong>string</strong> или <strong>int</strong>, все нормально.</p>
<p>Но если мы сделаем так:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">short nameIdx<span class="token punctuation">;</span>
<span class="token function">add</span><span class="token punctuation">(</span>nameIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// ошибка!</span></code></pre></div>
<p>получим ошибку компиляции. Дело в том, что из двух перегрузок компилятор выбирает ту, которая принимает универсальную ссылку, так как там есть прямой матч типа на T, а в случае int-перегрузки матч непрямой, нужно еще приводить <strong>short</strong> к <strong>int</strong>. Далее, когда перегрузка с универсальной ссылкой пытается сдедлать <code class="language-text">names.emplace(std::foward&lt;short&gt;(name))</code>, получается ошибка, так как <strong>short</strong> не может быть добавлен в сет строк.</p>
<p>Функции, принимающие универсальные ссылки - самые жадные функции в C++, они подсовывают свои перегрузки как точные матчи для почти любых типов аргументов.</p>
<p>Особенно неприятно становится, когда у нас есть конструктор, принимающий универсальную ссылку. Компилятор автоматически генерирует кострукторы перемещения и копирования, а затем при попытке копирования объекта попытается использовать перегрузку с универсальной ссылкой, потому что она самая жадная, и выдаст ошибку компиляции:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Person</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
  explicit <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span>
    <span class="token punctuation">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  explicit <span class="token function">Person</span><span class="token punctuation">(</span>int idx<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">Person</span><span class="token punctuation">(</span>const Person<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// compiler-generated</span>

  <span class="token function">Person</span><span class="token punctuation">(</span>Person<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// compiler-generated</span>
<span class="token punctuation">}</span>

Person <span class="token function">p</span><span class="token punctuation">(</span><span class="token string">"Nancy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

auto <span class="token function">cloneOfP</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// ОШИБКА</span></code></pre></div>
<p>Вдвойне неприятно, потому что здесь мы даже не можем избавиться от перегрузок переименованием, ведь у конструкторов нельзя менять имена.</p>
<p>Здесь может помочь использование <code class="language-text">const</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">const Person <span class="token function">p</span><span class="token punctuation">(</span><span class="token string">"Nancy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

auto <span class="token function">cloneOfP</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// компилится</span></code></pre></div>
<p>Такой вариант сработал, потому что здесь сработал прямой матч типа <code class="language-text">const Person&amp;</code> на сгенерированный конструктор копирования и такой матч сильнее, чем матч универсальной ссылки.</p>
<h2>Familiarize yourself with alternatives to overloading on universal references</h2>
<p>Тут очень много текста, поэтому просто приведы примеры кода для решения проблем, описанных в предыдущем пункте</p>
<h3>Using tag dispatch</h3>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">add</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> name<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">addImpl</span><span class="token punctuation">(</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>is_integral<span class="token operator">&lt;</span>typename std<span class="token punctuation">:</span><span class="token punctuation">:</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>type<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">addImpl</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> name<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>false_type<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
  names<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

void <span class="token function">addImpl</span><span class="token punctuation">(</span>int idx<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>true_type<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
  <span class="token function">add</span><span class="token punctuation">(</span><span class="token function">nameFromIdx</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<h3>Constraining templates that take universal references</h3>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Person</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  template<span class="token operator">&lt;</span>
    typename T<span class="token punctuation">,</span>
    typename <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>enable_if_t<span class="token operator">&lt;</span>
      <span class="token operator">!</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>is_base_of<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>decay_t<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>value
<span class="token operator">&amp;&amp;</span>
      <span class="token operator">!</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>is_integral<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>value
    <span class="token operator">></span> 
  <span class="token operator">></span>
  explicit <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span>
  <span class="token punctuation">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> 
  <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

  explicit <span class="token function">Person</span><span class="token punctuation">(</span>int idx<span class="token punctuation">)</span> 
  <span class="token punctuation">:</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token function">nameFromIdx</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span> 
  <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

private<span class="token punctuation">:</span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>string name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<h3>Trade-off</h3>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Person</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  template<span class="token operator">&lt;</span>
    typename T<span class="token punctuation">,</span>
    typename <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>enable_if_t<span class="token operator">&lt;</span>
      <span class="token operator">!</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>is_base_of<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>decay_t<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>value
      <span class="token operator">&amp;&amp;</span>
      <span class="token operator">!</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>is_integral<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>value
    <span class="token operator">></span> 
  <span class="token operator">></span>
  explicit <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span>
  <span class="token punctuation">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// assert that a std::string can be created from a T object</span>
    <span class="token function">static_assert</span><span class="token punctuation">(</span>
      std<span class="token punctuation">:</span><span class="token punctuation">:</span>is_constructible<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token punctuation">,</span> T<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>value<span class="token punctuation">,</span>
      <span class="token string">"Parameter n can't be used to construct a std::string"</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 
  <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<h2>Understand reference collapsing</h2>
<p>При использовании универсальных ссылок в шаблное выводитмый тип T содержит в себе информацию, была ли передана ссылка на lvalue или rvalue. Например, если есть такое определение шаблона:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">func</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>тип T будет выведен как:</p>
<ul>
<li>lvalue reference, если в качестве аргумента передана lvalue</li>
<li>non-reference, если передана rvalue</li>
</ul>
<p>Пример для нашего шаблона <code class="language-text">func</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">Widget w<span class="token punctuation">;</span>
Widget <span class="token function">widgetFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">func</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// T => Widget&amp;</span>

<span class="token function">func</span><span class="token punctuation">(</span><span class="token function">widgetFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// T => Widget</span></code></pre></div>
<p>Благодаря этому правилу работают универсальные ссылки и <code class="language-text">std::forward</code>.</p>
<p>Пользователю нельзя делать ссылки на ссылки:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto<span class="token operator">&amp;</span> <span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span>   <span class="token comment">// ОШИБКА</span></code></pre></div>
<p>Но компилятор может, используя механизм <em>reference collapsing</em>. Благодаря этому механизму у нас есть универсальные ссылки, которые по сути есть схлопнутые rvalue reference на другую ссылку. Например, в следующем примере lvalue передается в шаблон функции, принимающий rvalue:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">func</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

auto w <span class="token operator">=</span> <span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">func</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Для T выводится тип <code class="language-text">Widget&amp;</code>, а значит конкретная функция имеет вид:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">void <span class="token function">func</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Видим тут ссылку на ссылку и компилятор ничего не имеет против.</p>
<p>Дело в том, что если ссылка на ссылку появляется в разрешенном контексте (напр. при конкретизации шаблона), то ссылки "схлопываются" в одну ссылку по следующему правилу:</p>
<p>  Если любая из ссылок ссылается на lvalue, то результат становится ссылкой на lvalue. Иначе, если обе ссылки на rvalue, то результат становится ссылкой на rvalue.</p>
<ul>
<li>&#x26; + &#x26; = &#x26;</li>
<li>&#x26; + &#x26;&#x26; = &#x26;</li>
<li>&#x26;&#x26; + &#x26; = &#x26;</li>
<li>&#x26;&#x26; + &#x26;&#x26; = &#x26;&#x26;</li>
</ul>
<p>В примере выше у нас получается rvalue reference на lvalue reference, что схлопывается в lvalue reference. Если бы на вход поступила rvalue reference, то результат схлопывания был бы тоже rvalue reference. Именно так и работает универсальная ссылка.</p>
<p>Схлопывание ссылок разрешено в 4 контекстах:</p>
<ul>
<li>конкретизация шаблона</li>
<li>генерация типов для auto (<code class="language-text">auto&amp;&amp; w1 = w;</code> выводит lvalue)</li>
<li>генерация и использование <code class="language-text">typedef</code> и алиасов (<code class="language-text">typedef T&amp;&amp; Ref</code>)</li>
<li>использование <code class="language-text">decltype</code></li>
</ul>
<h2>Assume that move operations are not present, not cheap, and not used</h2>
<p>Многие типы стандартной библиотеки были переипсаны в C++11, чтобы поддержать семантику перемещения. Однако многие остались пока без этой поддержки.</p>
<p>Среди тех, которые поддерживают перемещение, некоторые типы перемещают медленно просто потому что семантика типа не позволяет сделать это иначе. Например, <code class="language-text">std::array</code> хранит все элементы в себе, поэтому для него перемещение, хоть и работает быстрее копирования, все равно требует линейного перемещения всех своих объектов. Для остальных контейнеров, как, например, <code class="language-text">std::vector</code>, перемещение заключается в перемещении указателя на начало массива в куче, поэтому выполняется за константное время.</p>
<p><code class="language-text">std::string</code>, в свою очередь, поддерживает перемещение за константное время, но оно не всегда становится от этого сильно быстрее линейного копирования. Дело в том, что многие реализации используют <em>small string optimization (SSO)</em>. Благодаря этой оптимизации "маленькие" (не более 15 символов) строки хранятся в буфере внутри объекта <code class="language-text">std::string</code>а динамически аллоцируемая память не используется. Перемещение таких "маленьких" строк работает не быстрее, чем копирование.</p>
<p>А еще бывает так, что даже при корректной и производительной реализации перемещения, компилятор все равно выбирает копирование, потому что реализация перемещения не помечена как <code class="language-text">noexcept</code>. Так бывает, например, в контейнерах, когда компилятор хочет убедиться, что не возникнет ситуации, когда при перемещении i-го элемента выбросится исключение и у нас получится 2 объекта в неконсистентном состоянии.</p>
<h2>Avoid default capture modes</h2>
<p>Захват по ссылке может привести к висячим ссылкам, если время жизни замыкания превышает время жизни переменной, ссылка на которую используется в лямбде. Когда мы такие ссылки провисываем в списке захвата вручную, то за их лайфтаймом легче уследить.</p>
<p>Казалось бы, эту проблему может решить захват по значению. Но если мы захватываем по значению указатель, никто не мешает коду вне лямбды освободить память, на которую ссылается этот указатель, и мы опять получаем висячую ссылку.</p>
<p>Вообще, надо понимать, что при использовании дефолтного захвата по значению, захватываются только локальные переменные, аргументы функции и указатель <code class="language-text">this</code>. </p>
<p>Статические объекты могут быть использованы внутри лямбды, но они не захватываются. То есть захват по значению для них не работает в том смысле, что не делается копия значения, как пользователь может ожидать при использовании <code class="language-text">[=]</code>.</p>
<p>Поля объекта тоже захватываются, но при использовании <code class="language-text">[=]</code> может сложиться ложное впечатление, что они захватились по значению, в то время как на самом деле захватился <code class="language-text">this</code> и обращение к полям объекта идет автоматически через него, то есть обращение к полям объекта опять-таки идет по ссылке.</p>
<h2>Use init capture to move objects into closures</h2>
<p>У лямбд в C++11 есть большая проблема - туда нельзя передать move-only объекты, то есть, например, <code class="language-text">std::unique_ptr</code> или <code class="language-text">std::future</code>.</p>
<p>Проблему эту позволяет решить init capture, появившаяся в C++14:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  bool <span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> const<span class="token punctuation">;</span>
  bool <span class="token function">isProcessed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> const<span class="token punctuation">;</span>
  bool <span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span> const<span class="token punctuation">;</span>
private<span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

auto pw <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

auto func <span class="token operator">=</span> <span class="token punctuation">[</span>pw <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">move</span><span class="token punctuation">(</span>pw<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> 
  <span class="token keyword">return</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>В С++11 без использования этой фичи код может быть переписан так:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">IsValAndArch</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  using DataType <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">;</span>

  explicit <span class="token function">IsValAndArch</span><span class="token punctuation">(</span>DataType<span class="token operator">&amp;&amp;</span> ptr<span class="token punctuation">)</span>
  <span class="token punctuation">:</span> <span class="token function">pw</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">move</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

     bool <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> const
     <span class="token punctuation">{</span> <span class="token keyword">return</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

private<span class="token punctuation">:</span>
  DataType pw<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
auto func <span class="token operator">=</span> <span class="token function">IsValAndArch</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Есть и другой, чуть более сложный для понимания, но требующий меньше кода, вариант:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto func <span class="token operator">=</span>
     std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">bind</span><span class="token punctuation">(</span> 
      <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>const std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span> pws<span class="token punctuation">)</span>
      <span class="token punctuation">{</span> 
        <span class="token keyword">return</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      std<span class="token punctuation">:</span><span class="token punctuation">:</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<h2>Use decltype on auto&#x26;&#x26; parameters to std::forward them</h2>
<p>В C++14 появились джененрик лямбды, у которых в списке параметров можно использовать тип <code class="language-text">auto</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>auto x<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>Сгенерированный класс замыкания выглядит так:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">SomeCompilerGeneratedClassName</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
  auto <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>T x<span class="token punctuation">)</span> const
  <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>Но ва этой лямбде есть недостаток - она плохо работает со ссылками на rvalue, а именно не форвардит их.</p>
<p>Исправленный вариант:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>auto<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span>
         <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span><span class="token function">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>Если нужна лямбда, принимающая множество параметров, можем применить вариадичный шаблон:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>auto<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span><span class="token function">decltype</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<h2>Prefer lambdas to std::bind</h2>
<ul>
<li>Лямбды намного более читабельны. </li>
<li>Лямбды могут инлайниться, бинды - нет.</li>
<li>У биндов неочевидная семантика копирования аргументов - при создании бинда аргументы копируются по значению, а при использовании результата аргументы передаются по функции. И это из кода нигде не понятно, это можно только запомнить.</li>
</ul>
<p>В С++11 без использования бинда не обойтись, когда:</p>
<ul>
<li>хотим передать аргументы в замыкание перемещением</li>
<li>дженерик лямбда</li>
</ul>
<p>Дженерик лямбда через бинд реализуется так:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">PolyWidget</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
  void <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>const T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

PolyWidget pw<span class="token punctuation">;</span>

auto boundPW <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">bind</span><span class="token punctuation">(</span>pw<span class="token punctuation">,</span> _1<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">boundPW</span><span class="token punctuation">(</span><span class="token number">1930</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">boundPW</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">boundPW</span><span class="token punctuation">(</span><span class="token string">"Rosebud"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>В С++14 лямбды поддерживают оба этих пункта, поэтому там смысла использовать бинд нет вообще никогда.</p>
<h2>Prefer task-based programming to thread-based</h2>
<p>Thread-based:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>thread <span class="token function">t</span><span class="token punctuation">(</span>doAsyncWork<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Task-based:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto fut <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">async</span><span class="token punctuation">(</span>doAsyncWork<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Основные различия:</p>
<ul>
<li>таска возвращает значение, в котором клиент может быть заинтересован. Из потока получить значение не так просто</li>
<li>если функция стреляет исключение, то в случае таски оно будет выстрелено при попытке взять значение, а в случае потока оно крэшнет весь процесс</li>
<li>если превышен максимально возможный лимит потоков в системе, конструктор <code class="language-text">std::thread</code> выбросит <code class="language-text">std::system_error</code>. Таски же могут быть запущены в текущем потоке, если потоков в системе слишком много. Для GUI-потоков можно передавать специальную политику запуска <code class="language-text">std::launch::async</code>, чтобы гарантировать, что таска точно будет запущена в отдельном потоке</li>
<li>таски имеют больше информации о загруженности системы, чтобы проводить более эффективную балансировку нагрузки</li>
</ul>
<p>Использование тредов оправдано, когда:</p>
<ul>
<li>нужен доступ к низкоуровневым свойствам тредов, например, приоритету</li>
<li>нужно вручную затюнить использование тредов в приложении</li>
<li>нужно реализовать механизмы мульти-трединга, отсутствующие в C++ concurrency API, например, тред-пулы</li>
</ul>
<h2>Specify std::launch::async if asynchronicity is essential</h2>
<p>Таски обычно создаются так:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto fut <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">async</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
auto fut2 <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>launch<span class="token punctuation">:</span><span class="token punctuation">:</span>async<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Во втором варианте вторым аргументом передается политика запуска.</p>
<p>Есть 2 стандартных политики запуска:</p>
<ul>
<li><code class="language-text">std::launch::async</code> - функция должна быть обязательно запущена асинхронно, т.е. на другом потоке</li>
<li><code class="language-text">std::launch::deferred</code> - функция будет запущено только когда для футуры будет вызван <code class="language-text">get</code> или <code class="language-text">wait</code>. Если не будет вызван, то функция никогда не запустится.</li>
</ul>
<p>Дефолтная политки запуска при этом - объединение этих двух: <code class="language-text">std::launch::async | std::launch::deferred</code>. Она значит, что функция может быть запущена как синхронно, так и асинхронно, в зависимости от текущей нагрузки.</p>
<p>У дефолтной политики есть и свои недостатки:</p>
<ul>
<li>невозможно предсказать, будет ли функция выполняться одновременно с текущим потоком, создающим таск</li>
<li>невозможно предсказать, будет ли функция выполняться на другом потоке при вызове <code class="language-text">get</code> или <code class="language-text">wait</code></li>
<li>невозможно предсказать, будет ли функция выполнена вообще, потому что может быть непросто гарантировать, что <code class="language-text">get/wait</code> будут точно вызываться во всех ветях исполнения</li>
<li>плохо работает с thread_local переменными, потому что невозможно предсказать, переменные чьего потока будут использоваться</li>
<li>использование функций <code class="language-text">wait_for</code> и <code class="language-text">wait_until</code> может сломаться, потому что если использовать их на таске, вызванном с политикой <code class="language-text">std::launch::deferred</code>, то они будут всегда возвращать <code class="language-text">std::launch::deferred</code> и никогда - <code class="language-text">std::future_status::ready</code></li>
</ul>
<p>Все эти баги сложно отследить, потому что они будут проявляться только под большой нагрузкой. Вдобавок к этому, нет никакой возможности узнать, отложен ли таск. Приходится пользоваться таким вот костылем:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto fut <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">async</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span><span class="token punctuation">(</span>fut<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span><span class="token number">0</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>future_status<span class="token punctuation">:</span><span class="token punctuation">:</span>deferred<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  auto res <span class="token operator">=</span> fut<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>fut<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span><span class="token number">100</span>ms<span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>future_status<span class="token punctuation">:</span><span class="token punctuation">:</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>
  auto res <span class="token operator">=</span> fut<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre></div>
<h2>Make std::threads unjoinable on all paths</h2>
<p>К unjoinable-тредам относятся:</p>
<ul>
<li><code class="language-text">std::thread</code> с дефолтным конструктором, то есть без указанной функции</li>
<li><code class="language-text">std::thread</code>, из которого "перестили"</li>
<li>приджойненные треды</li>
<li>задетаченные треды</li>
</ul>
<h2>Be aware of varying thread handle destructor behavior</h2>
<p>И <code class="language-text">std::thread</code> и футуры могут считаться хэндлами системных потоков. Но они очень сильно различаются по поведению деструкторов.</p>
<p>Деструктор потока вызывает <code class="language-text">terminate()</code> если тред не заджойнен.</p>
<p>Деструктор футуры иногда как будто бы делает <code class="language-text">join</code>, иногда <code class="language-text">detach</code>, а иногда ни то, ни другое. Но он точно никогда не вызывает завершение программы.</p>
<p>Напомним, что футура - это один конец канала общения клиента потока и функтора, работающего в другом потоке.  Фуктор, используя объект <code class="language-text">std::promise</code>, пишет результат вычисления в канал, а клиент читает этот результат с помощью футуры.</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/36a5dc06450d824be93bef9715fbfada/b12db/future.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 11.670020120724347%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAhElEQVQI122OuwrCMABF+/+/4ODk4Org4qAUtCIiakEKiTWS+EIFYx5LCsfiKA6Xc4Yz3OzyeJFvJfPqSCX2GK1pmoaU0ne/7r1Ht40xJ5Q6IGrFbKeYbATXpyWT5kZ3OKU3WlBWAve2+BCIMRL+0DmHtRYp2xNFwXJd0h+v6Axy6vOdD+3gkuI9JN2FAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Future"
        title="Future"
        src="/hows-that-again/static/36a5dc06450d824be93bef9715fbfada/dbb61/future.png"
        srcset="/hows-that-again/static/36a5dc06450d824be93bef9715fbfada/19bd1/future.png 163w,
/hows-that-again/static/36a5dc06450d824be93bef9715fbfada/d3bcb/future.png 325w,
/hows-that-again/static/36a5dc06450d824be93bef9715fbfada/dbb61/future.png 650w,
/hows-that-again/static/36a5dc06450d824be93bef9715fbfada/6b691/future.png 975w,
/hows-that-again/static/36a5dc06450d824be93bef9715fbfada/b12db/future.png 994w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Однако на самом деле все чуть сложнее. Что если функтор вызывается раньше, чем клиент вызовет <code class="language-text">get()</code> у футуры? Результат нужно где-то хранить. В промисе - нельзя, потому что функтор завершается и вместе с ним может завершиться промис. В футуре - тоже нельзя, так как из <code class="language-text">std::future</code> может быть сделано <code class="language-text">std::shared_future</code> и тогда результат придется копировать несколько раз. А если результат не-копируем, то придется как-то заранее знать, какая из <code class="language-text">std::shared_future</code> умрет последней и хранить в ней.</p>
<p>Поэтому результат операции хранится снаруже футуры и промиса, в месте под названием <em>shared state</em>:</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/8043f9d0a79929ae236e55cd8c292804/d418b/future-shared-state.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 16.839916839916842%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAwUlEQVQI11WOy26CUBRF+d5O/ZdOOlCnTT+g1fjoIzUxFRQfKJdLCYnGgS1GIb4udwnoQE/2npycs/Y2tE4BnUlnuvh2/qMI150hpWS33xc7pdTdDVdGzjI+BoJqrctL28Q0LcIwLB63mw2Hkyaw36k/PvBVLuENO2yTHUK4CM/Dskys/oDn1g+Vty6ftsAY/S5o9KZ0xj5xnBTpuU/HY96b9XxG//UJp1klWgaorEyaKlarPxzHQfo+3yNZMCbBgjNN6Nwl0Re31wAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Future with shared state"
        title="Future with shared state"
        src="/hows-that-again/static/8043f9d0a79929ae236e55cd8c292804/dbb61/future-shared-state.png"
        srcset="/hows-that-again/static/8043f9d0a79929ae236e55cd8c292804/19bd1/future-shared-state.png 163w,
/hows-that-again/static/8043f9d0a79929ae236e55cd8c292804/d3bcb/future-shared-state.png 325w,
/hows-that-again/static/8043f9d0a79929ae236e55cd8c292804/dbb61/future-shared-state.png 650w,
/hows-that-again/static/8043f9d0a79929ae236e55cd8c292804/d418b/future-shared-state.png 962w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Вот это вот разделяемое состояние определяет поведение деструктора футуры:</p>
<ul>
<li>деструктор последней футуры, ссылающеся на разделяемое состояние для не-отложенной (<code class="language-text">std::launch::async</code>) таски, запущенной через <code class="language-text">std::async</code> блочится, пока таска, связанная с футурой не завершится. Для <code class="language-text">std::future</code> это условие выполняется всегда, для <code class="language-text">std::shared_future</code> - только для последней.</li>
<li>деструкторы остальных футур просто уничтожают футуры и ничего не ждут</li>
</ul>
<p>Для обычных <code class="language-text">std::future</code> можно говорить, что если они запущены с <code class="language-text">std::launch::async</code>, то их деструкторы будут блочиться.</p>
<p>Имея объект футуры, невозможно определить, заблочится ли она в деструкторе.</p>
<h2>Consider void futures for one-shot event communication</h2>
<p>Когда одному потоку надо дождаться некоего события во втором потоке, есть такие опции:</p>
<ul>
<li><code class="language-text">std::condition_variable</code></li>
</ul>
<p>Thread 1:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>condition_varaible cv<span class="token punctuation">;</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>mutex m<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
cv<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Thread 2:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token punctuation">{</span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_lock<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>mutex<span class="token operator">></span> <span class="token function">lk</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Недостатки:</p>
<ol>
<li>если тред 1 занотифаит прежде чем тред 2 начал ждать, то тред 2 зависнет.</li>
<li><code class="language-text">wait</code> в треде 2 подвержен ложным пробуждениям (spurious wakeups). Решается передачей предиката в <code class="language-text">wait</code>. Но не всегда есть возможность в предикате сообщить треду 2, что произошло нужное событие в треде 1.</li>
<li>Мьютекс используется не по назначению (его назначение - синхронизировать доступ к переменным, а не передавать события)</li>
</ol>
<hr>
<ul>
<li>разделяемый <code class="language-text">std::atomic&lt;bool&gt;</code></li>
</ul>
<p>Thread 1:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>atomic<span class="token operator">&lt;</span>bool<span class="token operator">></span> <span class="token function">flag</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre></div>
<p>Thread 2:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre></div>
<p>Недостатки:</p>
<ol>
<li>жрет процессорное время</li>
<li>жрет ресурсы для контекст-свитча</li>
</ol>
<hr>
<ul>
<li>не-атомарный флаг, но под мютексом</li>
</ul>
<p>Thread 1:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>condition_variable cv<span class="token punctuation">;</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>mutex m<span class="token punctuation">;</span>

bool <span class="token function">flag</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">{</span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>lock_guard<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>mutex<span class="token operator">></span> <span class="token function">g</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
cv<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Thread 2:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">{</span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_lock<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>mutex<span class="token operator">></span> <span class="token function">lk</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">return</span> flag<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre></div>
<p>Недостатки:</p>
<ul>
<li>сложный код, фактически передаем информацию о наступлении события дважды - через <code class="language-text">cv</code> и через <code class="language-text">flag</code>  </li>
<li>все еще нужно проверять flag в <code class="language-text">wait</code></li>
</ul>
<hr>
<ul>
<li>футура, возвращающая void!</li>
</ul>
<p>Thread 1:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>promise<span class="token operator">&lt;</span>void<span class="token operator">></span> p<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Thread 2:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Не требует мутексов, работает если <code class="language-text">set_value()</code> вызван раньше, чем <code class="language-text">wait()</code> и не подвержен ложным пробуждениям.</p>
<p>Недостатки:</p>
<ul>
<li>динамически аллоцируемое <strong>shared state</strong> между промисом и футурой</li>
<li>промис может быть выставлен только единожды, то есть этот механизм годится только для одноразовых сообщений. Это главное отличие от механизмов, построенных на использовании condvar и флагов.</li>
</ul>
<p>Типичный пример использования техники:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>promise<span class="token operator">&lt;</span>void<span class="token operator">></span> p<span class="token punctuation">;</span>

void <span class="token function">react</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

void <span class="token function">detect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">{</span>
    p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">react</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Если использовать здесь <code class="language-text">std::shared_future</code>, то подписчиков на событие может быть несколько:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>promise<span class="token operator">&lt;</span>void<span class="token operator">></span> p<span class="token punctuation">;</span>

void <span class="token function">react</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

void <span class="token function">detect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  auto sf<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">share</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>thread<span class="token operator">></span> vt<span class="token punctuation">;</span>

  <span class="token keyword">for</span><span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadsToRun<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vt<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">[</span>sf<span class="token punctuation">]</span><span class="token punctuation">{</span> 
      sf<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">react</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// запускаем все ожидающие потоки</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span>auto<span class="token operator">&amp;</span> t<span class="token punctuation">:</span> vt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<h2>Use std::atomic for concurrency, volatile for special memory</h2>
<p>Операции над <code class="language-text">std::atomic</code> производятся, как будто бы они были защищены мютексом, но при этом используют специальные машинные инструкции, которые эффективнее мютексов.</p>
<p>А еще <code class="language-text">std::atomic</code> нагладывает ограничения на изменение порядка инструкций, а именно: <strong>ни одна команда, предшествующая записи вstd::atomic не может быть расположена после нее</strong>.</p>
<p><code class="language-text">volatile</code> не делает ничего из этого, поэтому оно не подходит для параллельного программирования.</p>
<p>Так для чего же оно нужно? А нужно оно, чтобы сказать компиляторам, что они работают с памятью, которая ведет себя "ненормально".</p>
<p>Под "нормальной" памятью мы понимаем такую память, для которой если мы записали значение по некоторому адресу, то он останется неизменным, пока что-нибудь его не перепишет.</p>
<p>То есть если есть такой код:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">int x<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
auto y <span class="token operator">=</span> x<span class="token punctuation">;</span>
y <span class="token operator">=</span> x<span class="token punctuation">;</span>

x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></code></pre></div>
<p>компилятор может сделать вывод, что между двумя присвоениями значение <code class="language-text">x</code> не меняется, а значит первое присвоение в каждой паре можно безопасно удалить:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">int x<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
auto y <span class="token operator">=</span> x<span class="token punctuation">;</span>
x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></code></pre></div>
<p>Но применительно к ключевому слову <code class="language-text">volatile</code> мы говорим о "ненормальной", или "специальной" памяти. Наиболее часто используемая "специальная" память используется при <code class="language-text">memory mapped I/O</code>. В такой памяти адреса общаются напрямую с периферийными устройствами, то есть сенсорами, дисплейями, принтерами, сетевыми портами и т.д.</p>
<p>В этой ситуации если видим такой код:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto y <span class="token operator">=</span> x<span class="token punctuation">;</span>
y <span class="token operator">=</span> x<span class="token punctuation">;</span></code></pre></div>
<p>нельзя удалить второе присвоение, потому что, например, сенсор, к которому привязано хначение x мог изменить показания</p>
<p>Или вот такой код:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></code></pre></div>
<p>Его возможно тоже нельзя менять, если, например, запись в x издает определенную радиокоманду.</p>
<p>Ключевое слово <code class="language-text">volatile</code> говорит компилятору, что здесь мы работаем с именно такой "специальной" памятью. Это приказ компилятору "не проводи никаких оптимизаций на этой памяти".</p>
<p>При его использовании: </p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">volatile int x<span class="token punctuation">;</span>

auto y <span class="token operator">=</span> x<span class="token punctuation">;</span>
y <span class="token operator">=</span> x<span class="token punctuation">;</span>
x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></code></pre></div>
<p>никакие строчки кода компилятором удалены не будут.</p>
<p>Теперь должно быть понятно, почему <code class="language-text">std::atomic</code> нельзя использовать для работы со "специальной" памятью, ведь он <strong>не запрещает</strong> удалять лишние, с точки зрения компилятора, строчки. </p>
<p>Ну и не лишним будет добавить, что приведенный выше код для <code class="language-text">std::atomic</code> вообще не скомпилится, потому что операции копирования для <code class="language-text">std::atomic</code> удалены. Это сделано потому что атомарное копирование обычно не поддерживается железом. Перемещение тоже не поддерживается.</p>
<p>Если нужно скопировать значение <code class="language-text">x</code> в <code class="language-text">y</code>, то нужно делать так:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>atomic<span class="token operator">&lt;</span>int<span class="token operator">></span> <span class="token function">y</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// или так</span>
y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Но между чтением и записью, естественно, никакой атомарности не сохраняется.</p>
<p>Компилятор мог бы оптимизировать этот код:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">register <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>atomic<span class="token operator">&lt;</span>int<span class="token operator">></span> <span class="token function">y</span><span class="token punctuation">(</span>register<span class="token punctuation">)</span><span class="token punctuation">;</span>
y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>register<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>и если бы мы работали со специальной память, такая оптимизация была бы неприемлема. Это еще один пример, почему <code class="language-text">std::atomic</code> и <code class="language-text">volatile</code> не взаимозаменяемы:</p>
<ul>
<li><code class="language-text">std::atomic</code> - для данных, доступ к которым осуществляется из нескольких тредов без использования мютексов. Он нужен для написания параллельного кода.</li>
<li><code class="language-text">volatile</code> - для памяти, у которой чтения и записи не должны быть оптимизированы. Это нужно для работы со специальной памятью.</li>
</ul>
<h2>Consider pass by value for copyable parameters that are cheap to move and always copied</h2>
<p>Пусть у нас есть такой вот код:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  void <span class="token function">addName</span><span class="token punctuation">(</span>const std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token operator">&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  void <span class="token function">addName</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token punctuation">}</span>

private<span class="token punctuation">:</span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token operator">></span> names<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>С точки зрения эффективности тут все хорошо: lvalue передаются по ссылки и копируются, rvalue тоже передаются по ссылке, но перемещаются. Но есть проблема - это 2 функции вместо одной.</p>
<p>Можем попробовать переписать с использованием универсальной ссылки:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
  void <span class="token function">addName</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>Здесь меньше кода, но так как это шаблон, то в объектном коде использующей библиотеки все равно будет 2 функции. На самом деле даже больше - по 2 на <code class="language-text">std::string</code> и каждый тип, приводимый к <code class="language-text">std::string</code>. </p>
<p>Кроме того, есть типы, которые не могут быть переданы как универсальная ссылка.</p>
<p>Выход простой - передаем копию и не паримся:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
  void <span class="token function">addName</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>string newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Почему это работает? Дело в том, что компилятор C++11 стал достаточно умен, чтобы в случае, когда аргументом передается rvalue, передавать его не копированием, а перемещением. Тогда в случае передачи lvalue у нас получается копирование и перемещение, а в случае rvalue - два перемещения. По сравнению с перегрузками и универсальными ссылками - это <strong>на одно перемещение больше в обоих случаях</strong>.</p>
<p>То есть такой вариант все-таки чуть менее эффективен. Именно поэтому в заголовке пункта стоит уточнение, что тип должен быть <strong>дешев для перемещения</strong>.</p>
<p>Там еще есть уточнение про копируемые типы. Дело в том ,что если тип не копируем, то в варианте с перегрузками не нужна первая перегрузка. Тогда достаточно одной функции и первый вариант не имеет недостатков.</p>
<p>И последнее уточнение - применять эту технику стоит лишь для аргументов, которые в теле функции <strong>всегда</strong> копируются. Иначе перемещение копирования в заголовок может быть лишним оверхедом для тех случаев, когда значение потом не используется и получается, что копировали зря. В таком случае передача ссылки подошла бы лучше.</p>
<h2>Consider emplacement instead of insertion</h2>
<p>У <code class="language-text">std::vector</code> есть такая перегрузка специально для rvalue:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">void <span class="token function">push_back</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Рассмотрим такой код, использующий ее:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token operator">></span> vs<span class="token punctuation">;</span>
vs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"xyzzy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Как ни странно, этот невинный код приводит аж к 2 конструкциям типа <code class="language-text">string</code>: </p>
<ul>
<li>первый раз конструктор вызывается, чтобы привести литерал типа <code class="language-text">const char[6]</code> к типу <code class="language-text">std::string</code>, получим временное значение <code class="language-text">temp</code></li>
<li>второй раз вызывается внутри метода <code class="language-text">push_back</code>, чтобы скопировать значение из ссылки rvalue на <code class="language-text">temp</code>.</li>
</ul>
<p>Не очень-то эффективно 2 раза вызывать конструктор. Хотелось бы обойтись лишь одним. Поэтому был введен специальный метод - <code class="language-text">emplace_back()</code>.</p>
<p>Он форвардит свои аргументы в <code class="language-text">std::vector</code>, чтобы внутри него.с этими аргументами вызвать конструктор <code class="language-text">std::string</code>, достигая того же эффекта, что и <code class="language-text">push_back()</code> без использования временных переменных.</p>
<p>Пример:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">vs<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token string">"xyzzy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
vs<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// создаст std::string из 50 символов x</span></code></pre></div>
<p>Метод <code class="language-text">emplace_back</code> доступен для всех стандартных контейнеров, у которых есть <code class="language-text">push_back</code>. </p>
<p>Если передать в <code class="language-text">emplace_back</code> не <code class="language-text">char[]</code>, а сразу <code class="language-text">std::string</code>, то он будет вести себя аналогично <code class="language-text">push_back</code>, так как в этом случае <code class="language-text">push_back</code> создает лишь один объект. То есть по идее он может во всех ситуациях заменить <code class="language-text">push_back</code>. Но это только по идее.</p>
<p>В действительности, бывают ситуации, когда <code class="language-text">push_back</code> работает быстрее. Эти ситуации зависят от многих факторов - от типа аргумента, типа контейнера, позиции в контейнере, куда вставляется элемент, возможности выстреливания исключения из операции копирования, а для контейнеров, в которых запрещены дубликаты - от того, есть ли уже такое значение в контейнере. ТАк что единственный способ узнать наверняка - побенчмаркать.</p>
<p>Но есть эвристические проверки, которые помогут определить, когда <code class="language-text">emplace_back</code> сработает быстрее, чем <code class="language-text">push_back</code>. Если все эти проверки проходят, то это так:</p>
<ul>
<li>добавляемое значение конструктится, а не присваивается. Это зависит от реализации метода добавления, но обычно конструктится, когда, мы добавляем новое значение в контейнер, а присваивается - когда заменяем старое. Если присваивается, то придется создавать временный объект, из которого будет осуществлено перемещение, а значит <code class="language-text">emplace_back</code> теряет свои достоинства</li>
<li>тип передаваемого аргумента отличается от типа элементов контейнера</li>
<li>контейнер не будет, или очень редко будет отвергать новое значение как дубликат. Это важно, потому что когда значение отвергнуто, мы в <code class="language-text">emplace_back</code> уже создали объект и получается, что создали зря</li>
</ul></div></div></div></div></div></div></div><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym");ym(56098288,"init",{"clickmap":true,"trackLinks":true,"accurateTrackBounce":true,"webvisor":true,"trackHash":true});</script><noscript><div><img src="https://mc.yandex.ru/watch/56098288" style="position:absolute;left:-9999px" alt=""/></div></noscript><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/blog/books/effective-modern-cpp";window.webpackCompilationHash="ae79f2442b648799db22";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-c14483461df837b8e0ee.js"],"component---src-templates-blog-template-js":["/component---src-templates-blog-template-js-e63d8ebd92abd897e273.js"],"component---src-pages-404-js":["/component---src-pages-404-js-54ff81d98f14a7da0346.js"],"component---src-pages-index-jsx":["/component---src-pages-index-jsx-e26f636638509b66d07b.js"],"component---src-pages-page-2-js":["/component---src-pages-page-2-js-e56f5911a753d0d06680.js"]};/*]]>*/</script><script src="/hows-that-again/component---src-templates-blog-template-js-e63d8ebd92abd897e273.js" async=""></script><script src="/hows-that-again/commons-313b70b8b727bdc3ecf8.js" async=""></script><script src="/hows-that-again/app-c14483461df837b8e0ee.js" async=""></script><script src="/hows-that-again/webpack-runtime-307e2eaa7f3c16e7ad2c.js" async=""></script></body></html>