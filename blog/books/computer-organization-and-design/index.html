<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/hows-that-again/commons.8860d49cbcb6ddba17d1.css">html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:112.5%/1.45em georgia,serif;box-sizing:border-box;overflow-y:scroll}*,:after,:before{box-sizing:inherit}body{color:rgba(0,0,0,.8);font-family:georgia,serif;font-weight:400;word-wrap:break-word;-webkit-font-kerning:normal;font-kerning:normal;-ms-font-feature-settings:"kern","liga","clig","calt";font-feature-settings:"kern","liga","clig","calt"}img{max-width:100%;padding:0;margin:0 0 1.45rem}h1{font-size:2.25rem}h1,h2{padding:0;margin:0 0 1.45rem;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h2{font-size:1.62671rem}h3{font-size:1.38316rem}h3,h4{padding:0;margin:0 0 1.45rem;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h4{font-size:1rem}h5{font-size:.85028rem}h5,h6{padding:0;margin:0 0 1.45rem;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h6{font-size:.78405rem}hgroup{padding:0;margin:0 0 1.45rem}ol,ul{padding:0;margin:0 0 1.45rem 1.45rem;list-style-position:outside;list-style-image:none}dd,dl,figure,p{padding:0;margin:0 0 1.45rem}pre{margin:0 0 1.45rem;font-size:.85rem;line-height:1.42;background:rgba(0,0,0,.04);border-radius:3px;overflow:auto;word-wrap:normal;padding:1.45rem}table{font-size:1rem;line-height:1.45rem;border-collapse:collapse;width:100%}fieldset,table{padding:0;margin:0 0 1.45rem}blockquote{padding:0;margin:0 1.45rem 1.45rem}form,iframe,noscript{padding:0;margin:0 0 1.45rem}hr{padding:0;margin:0 0 calc(1.45rem - 1px);background:rgba(0,0,0,.2);border:none;height:1px}address{padding:0;margin:0 0 1.45rem}b,dt,strong,th{font-weight:700}li{margin-bottom:.725rem}ol li,ul li{padding-left:0}li>ol,li>ul{margin-left:1.45rem;margin-bottom:.725rem;margin-top:.725rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,abbr[title],acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}abbr[title]{text-decoration:none}td,th,thead{text-align:left}td,th{border-bottom:1px solid rgba(0,0,0,.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding:.725rem .96667rem calc(.725rem - 1px)}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:SFMono-Regular,Consolas,Roboto Mono,Droid Sans Mono,Liberation Mono,Menlo,Courier,monospace;padding:.2em 0}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{letter-spacing:-.2em;content:" "}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}@media only screen and (max-width:480px){html{font-size:100%}}code[class*=language-],pre[class*=language-]{color:#657b83;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-]::-moz-selection,code[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection{background:#073642}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{background:#073642}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-],pre[class*=language-]{background-color:#fdf6e3}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#93a1a1}.token.punctuation{color:#586e75}.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#268bd2}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string,.token.url{color:#2aa198}.token.entity{color:#657b83;background:#eee8d5}.token.atrule,.token.attr-value,.token.keyword{color:#859900}.token.class-name,.token.function{color:#b58900}.token.important,.token.regex,.token.variable{color:#cb4b16}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}</style><meta name="generator" content="Gatsby 2.15.1"/><title data-react-helmet="true">How&#x27;s that again?</title><meta data-react-helmet="true" name="description" content="Sample"/><meta data-react-helmet="true" name="keywords" content="sample, something"/><style type="text/css">.gatsby-resp-image-image{width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;color:transparent;}</style><link as="script" rel="preload" href="/hows-that-again/webpack-runtime-6740470ac5418527fb73.js"/><link as="script" rel="preload" href="/hows-that-again/app-3dcf91bf32bdecf8876c.js"/><link as="script" rel="preload" href="/hows-that-again/commons-4f66cda7900e280efdae.js"/><link as="script" rel="preload" href="/hows-that-again/component---src-templates-blog-template-js-e63d8ebd92abd897e273.js"/><link as="fetch" rel="preload" href="/hows-that-again/page-data/blog/books/computer-organization-and-design/page-data.json" crossorigin="anonymous"/></head><body><noscript id="gatsby-noscript">This app works best with JavaScript enabled.</noscript><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group" id="gatsby-focus-wrapper"><div><div style="background:rebeccapurple;margin-bottom:1.45rem"><div style="margin:0 auto;max-width:960px;padding:1.45rem 1.0875rem;display:flex;justify-content:space-between"><h1 style="margin:0"><a style="color:white;text-decoration:none" href="/hows-that-again/">How&#x27;s that again?</a></h1><span style="margin:auto 0"><form style="margin-bottom:0" method="get" action="https://encrypted.google.com/search"><input type="hidden" name="as_sitesearch" value="y-gagar1n.github.io/hows-that-again"/><input type="text" name="as_q"/><input type="submit" style="margin-left:5px" value="Search"/></form></span></div></div><div style="margin:0 auto;max-width:960px;padding:0px 1.0875rem 1.45rem;padding-top:0"><div class="blog-post-container"><div class="blog-post"><div class="blog-post-content"><p>Источники: </p>
<ul>
<li><a href="https://www.amazon.com/Computer-Organization-Design-MIPS-Architecture/dp/0124077269">Computer Organization and Design MIPS Edition</a></li>
<li><a href="https://habr.com/post/179647/">Логическая организация кэш-памяти процессора</a></li>
<li><a href="https://habr.com/post/183834/">Кэш в многопроцессорных системах. Когерентность кэша. Протокол MESI</a></li>
</ul>
<h1>I/O</h1>
<h2>LCD</h2>
<p>Состоит из двух фильтров с перпендикулярной поляризацией, а между ними - стержнеобразные молекулы (кристаллы) в жидкости. Эти молекулы формируют закручивающуюся спираль, которая изгибает свет, проходящий через дисплей.</p>
<p>Когда напряжения нет, то кристалы, примыкающие к горизонтальному фильтру, повернуты горизонтально, а к вертикальному - вертикально. Когда через эти кристалы проходит свет, то он "изгибается" и меняет свою поскость поляризации с горизонтальной на вертикальную, в результате чего проходит через оба фильтра без потерь (не считая половины неполяризованного света, поглощенного первым фильтром, ну то есть вертикально поляризованный свет не смог пройти через горизонтальный фильтр).</p>
<p>Если же к кристаллам приложено напряжение, молекулы стремятся выстроиться в направлении электрического поля, что искажает их винтовую структуру. Свет уже ко второму фильтру приходит не совсем вертикально поляризованный, а отклоненный на сколько-то градусов, поэтому степень прозрачности понижмается. Варьируя напряжение, можно управлять степенью прозрачности.</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 640px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/aae383dbf961d65ff8a971793d38b6e6/e49a9/lcd-display.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 80%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAB7BAAAewQHDaVRTAAAC9UlEQVQ4y21Uy05aURTlA4w/4ES/wYGJA9M6sA79BYcmfoBjY+LAgYlp0pI0oRQTa2x5KMUiYPEB2pAUBeQlLzHFoCjv9+Wu7n24IDbuZOece+8+6+zHWlclyzLYeK1Wq8IrlQoajQZqtVrfB+M6nc6rz+wqufsWEgEEr67g9/kQCYfF/vLyEj56vr6+FofYMpkM/H4/whQTCoXEN46JRqOo1+sEqAT+b016Xy6XRRCvnDFbu91Gs9lEq9WCJEliLRQKYuVLVRwkXVxA0mhQpJuSsRgyHg/uKQMOrDEoldyR2qhSK2KUEWcVCYfgpwqOnU4Ui8V++QKwaTQir1Lhhjy6uIijpSXszs7Cabfjni4o5nK4y9fhj93BcR6CwfILZtsJTCYzNjbeo1QqvQSUUinkh4aQJsDU3BzcKyuwvHsHm2UfAW8Y/mAS7nAWDm8GO3Y/tgxWbP84hf6nGx8+6UQLXgDK1KfS2JgATExP43R5GXtv3kKj/ox9qwdeHwHGnmDx3EJrcmNzxwzd9wNotnaxtf2tP7DulJXxV2ZmkCHA5Pi4yHB3agpfP6pxdPgbZ54QDi7SsFKGevsfOJwuOE/OYDTt4vj4qA/WBaSpsdUWFgRgbHQUZ6urMExMwPpFi9ubFHJ/M4gmbhAIx9FotomnZdxns3C5XIIybD0uqmQaN1tjfR1ZArwfHoZbq4Vxfh6HajVKNaJNsSBiqoLwdQVAJgpJfZr1Ku3zUH54QH5kBDUCvbVYYNjbg0OvB4dJzDFFEUwR5iVTilU1yNHnoShlN3Q6FAkQNhuCNHkzgXaIvEzgQXt8fEQkEkE8HkcwGMQDJfNiKMKVTKuTk5DX1sQ+6PXiKZ8XKmBn1bCue6pg58tYPb1J96csK1m0z8/R2NxEq9socYBBuDRWSIyInkgkhI5Zz4FAQOi4V7ZqsKG9LBsEUqDMuF+sghwpJUtT7TmX3HnlH/DcQ6XsQdDee/6VJZNJpKin6XRa7HltK33vt0w5/w8GdHxC1SCFPwAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="LCD Display"
        title="LCD Display"
        src="/hows-that-again/static/aae383dbf961d65ff8a971793d38b6e6/e49a9/lcd-display.png"
        srcset="/hows-that-again/static/aae383dbf961d65ff8a971793d38b6e6/19bd1/lcd-display.png 163w,
/hows-that-again/static/aae383dbf961d65ff8a971793d38b6e6/d3bcb/lcd-display.png 325w,
/hows-that-again/static/aae383dbf961d65ff8a971793d38b6e6/e49a9/lcd-display.png 640w"
        sizes="(max-width: 640px) 100vw, 640px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Раньше использовалась <strong>пассивная матрица</strong>. Это значит, что для управления экраном NxM пикселей использовались N+M линий адресации, то есть N - для выбора строки и M - для выбора столбца. На выбранные строки подавалось напряжение, пиксель на пересечении загорался и должен был хранить свое состояние до следующей активации. Таким образом, при смене кадра последовательно изменялись все пиксели экрана. Из-за большой емкости ячеек напряжение на них меняется медленно, а значит и кадры тоже медленно меняются.</p>
<p>В настоящее время большинство ЖК-дисплеев используют <strong>активную матрицу</strong> на тонкопленочных транзисторах (thin film transistors / TFT). Раньше широко применялись матрицы на тонкопленочных диодах (TFD), но сейчас таких почти нет. В схеме активной матрицы с каждой точкой изображения последовательно включена собственная тройка транзисторов, управляющих цветами R, G, B. Все пиксели изменяются параллельно.</p>
<p>На уровне железа поддержка графики состоит в основном из <strong>фреймбуфера</strong>, в котором хранится битовая карта. Изображение, которое нужно отобразить на экране, сохраняется в фреймбуфере. Если у нас 24-битный цвет, то для каждого пикселя во фреймбуфере сохраняется 24 бита.</p>
<h2>Тачскрин</h2>
<p>На данный момент в большинстве тачскринов используются емкостностные экраны.</p>
<h3>Поверхностно-емкостной экран</h3>
<p>Экран покрывается прозрачным проводящим материалом, а по углам экрана располагаются 4 электрона, подающие на этот слой небольшое напряжение. Когда человек прикасается к экрану, возникает утечка точка. Чем ближе палец к электроду, тем меньше сопротивление экрана, а значит больше сила тока. Ток регистрируется датчиками в углах и передается на контроллер, вычисляющий координаты точки касания.</p>
<p>Не умеет в мультитач.</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 360px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/8a8976025f3c35e3345bc3b0ba9815b6/8f8c6/touch-screen-capacitive.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 105.83333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsSAAALEgHS3X78AAAEMElEQVQ4y62VbUxbVRiA773QwspHO9gKjhFgczHRTexM5tQY/eFvk8X4AxNNYP7QIG5LRtzUZWabc4o4MxhmG0FWPtpuZdpv7uSr0malA6W0sCItUOnnSoGW0tJbbl/vLZcELEZNPMnT2557znPe9773nCLIesulKED+p4ZRPEmRR5FOkcZc/w1pm9jSaBmHgk/BpcimyPkHsjeNpzPcsSGjbzzFCMsQFOX/h+zouShD7kbnToqXKfJRDDvIyc56RgKAvnBWjh2p+hLNe+V9au2C5AyE+fyLEGPI2eikR/GY77ztwlBPx7BKySJWIVpEX7qkRZDX6zZuHaDYzTyy/YwYQTNydybDPXriysF3u2wXqvD4m+X1nkNIxUzWdgsAlYGguoGFsjIEjLSU4jAFOynkFZfRDxY5bYfDV8x+S8vUkq7LnVA3W6LippHIpcvacOVbwsCr/POeQgSRbq4oh71ebRYT5XrK3L2lSWG1hRBcdSYGWn73aRTukGo0BvLJVVBZgiQ+uUTeU88S0s+Ho7eq+sNnjilix/Yc7ziCsA+kP8FjYwiKZacIaywxQd0fpE7oB41w0osrnUG5MQwS2yqIfXHoDJAgHgyD5pqTNHw7B/pKtdWAXrUeouem5RdxU4QfjROCrxxrumZfAhfNg0JlsY2MOP1DlihIZqKJO75YotMcTkhb/SD/bsLbe+q3JT1XAeX0XFZByfbCrx2krslD4sLHoO72x37WT0zZ9K5F5XQcJO5VUuyIQYfWE9J1j9scJ8djA7y7q0lhOn8bYQ0tpFJudCfwZi+JSwOg1MwTMs2UWzW6ELnnJEDiIaBN/8g2JHEsPThlJfu54vA2wqJ14YemCBXh2mCDi8SvexJ4+2NSfT8ISn0oIeuZ8f9kj4PIHgjdMTr9UnkQ5KcfEYNZ4sizKUJe8b7kj1onPFfvggdNPui+7lq73+GL94h8CSW+QMqMDkePqrfbaJya/TEAIBxaJmVnrYQ2UxRJiRDh5O2md0jGa+caX/xkyNl70Tz/yw3TnFU9ZnOptOrpscG2+WG91DFg6DP0j1nVdl+ge5aK9vIU0Z8uWlkvymYhHSU7N49+QdlHq+tzSloX9n/Ra/p0dFgeICeEELW0gdE0aPqVANnkckxN1Wl2xuvruekERaZ4ZaPKuX97hISM35+Im1vtSw9vQWRCBOC6CzD+DfQNSH/oC8J5g2u5y2Rz4DfHF/U5naHn6TlsfvHWc0DwdCm9pbKKSvbxVsy358DbDjOaz1yu3otzHrx24GHL2+26jwt30WPrDCvcHieUn7zd915GxQV6L3PSeQWZW4RsVlohfVgqbtRmBrVnRuzS43WN72RwdOd4O7YeDKkZ7W2dTe1E0eR/Cg/Ahinq3ihLOWGIa6i+vQb5wAWI3B5DlOYFrMEcxXYxK7Dy9ySvfwIMLx/HYE6D9wAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Touch Screen Capacitive"
        title="Touch Screen Capacitive"
        src="/hows-that-again/static/8a8976025f3c35e3345bc3b0ba9815b6/8f8c6/touch-screen-capacitive.png"
        srcset="/hows-that-again/static/8a8976025f3c35e3345bc3b0ba9815b6/19bd1/touch-screen-capacitive.png 163w,
/hows-that-again/static/8a8976025f3c35e3345bc3b0ba9815b6/d3bcb/touch-screen-capacitive.png 325w,
/hows-that-again/static/8a8976025f3c35e3345bc3b0ba9815b6/8f8c6/touch-screen-capacitive.png 360w"
        sizes="(max-width: 360px) 100vw, 360px"
        loading="lazy"
      />
  </a>
    </span></p>
<h3>Проекционно-емкостной экран</h3>
<p>На внутренней стороне экрана нанесена сетка электродов. Электрод вместе с телом человека образует конденсатор; электроника измеряет ёмкость этого конденсатора (подаёт импульс тока и измеряет напряжение).</p>
<p>Такие экраны применяются в айфонах. </p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 260px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/cc5558188d9f4b11eb174792794c2e7a/75624/touch-screen-capacitive2.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 138.46153846153845%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAAAsSAAALEgHS3X78AAAERElEQVRIx63We1BUVRwH8O9ydxbBAaWgl2HJFEMCUQ0sgoMgL+X9fiwPQV4K8hgRGZRddgVZEUFAAkWH2CXlkULMgA9CMgIpnMwZK4d3OQ2GjTMYpJmlv057t9cfNe3WnTlzZ/fe+czvd87vd84F9LniDuL/u+Ir+XuEfDnqv3wCqqUV6CNTpDY+DcPlq/QBBTxYIkb9rISBQThLm5BcVwCRUd1/AOW/grFQLwXgXfLCthNxMDIN1GP+DmhBmROOTEVAveiOzsfOKOh2g3JMqDsYXsyDATtfQ80NL3T87MBSfhnh0vUsZbHuoG8WD25MsUXFVUcoPrABkRncErzBCfVY/nWRPOgSvQZhe8Sw9QhGRtPr7P80CEUVf3mX4ww09xeft0CYrxip0Z7ITtyMgrQg5CUHojA7EXAM5kGnECsWZSA80yJx/JaYTUUGS1mheXbppFxwpVvJzY02cTR7mqPbfX+MeTbunOceTXZwMx91cF19nZqJFzoFvYEt1eFQf7ce75An9l6QwNLOCuea9+hX4C+4uApkA7Es3VREyotQdjmOLZSJ5lm/qnj1xVZp+IBaKnlPVZx2sVWWM9SuKBzpLC0e6SwrGetWyi+0SEvbjpaWj5xTHfrk/FtS+9CkVKgfhAoSKnchMF+G/DOZMDLJ1oALn6qyWGpEN7uJ5nuJvj1LLF1+zGvHXA/dv9FOd66dIvqqi2SlBcPIGY4wDNutgM/2UlaX+9gcHtaANNMRQ7OdRNPt39N02w80depHmjr5E02qH9F482MabyIabySaaSCaOkKLQ9K54OR4Gco+i+WiZEXwyy1B/MFiBtby4PXqaLp1jGiihuiLKqJrFfRgbD/dG1U8XPyweOl2/66Fm705X092ZQ5cakosaYgyM8dzG9yFb87EQXIgl4EyFPSkwniFRAN+3rHN7mrr1torLUmFQ8fi0/uqIyNb5f6e0q3ODn7rLFf7OD5rZiKC4Z/XROSZtBGFfels7pIgUeawAg9CQuUyVuTd/3phiQgtJ4pEmh+bs12xQ52J49/4YJCckNvmAxPztdoX+9k4w90bLhJebk4Wvn80keupijFoLPI3kKdvEDRLAwSDDXGo2OEBhO3lC1uitEdMWTo8klNZdGLWKfEw4PjWk/jawmrVyt8jWSb6h03DP48H/fLWsgi94RobgvzT1rDzCmNgue4F7Rqrbb1Qa+wftUbdhCVLz4IVdRDrZaXuoFMID9p7v8S6wwbtD63ZBvsqizYAT1ra6A76bOdBt/hXUHXdFa1LzmxPdEfJYARS6o11B39bFL9cB9RO+LMdexOL0J9FmA3jlVv0OAIqtEeAlB0B0xK03A1FLwNT6gthaFyjO5hYxW+aUfucGZiAloUQBvoxcDcDD+sOJhzSggoXBiZBdTcc3RSMrJadrPUy9AGhBU0Z+AxUi+Z4+74Fyj9+Sv+vh4TKv330C/JOwhVjRybuAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Touch Screen Capacitive2"
        title="Touch Screen Capacitive2"
        src="/hows-that-again/static/cc5558188d9f4b11eb174792794c2e7a/75624/touch-screen-capacitive2.png"
        srcset="/hows-that-again/static/cc5558188d9f4b11eb174792794c2e7a/19bd1/touch-screen-capacitive2.png 163w,
/hows-that-again/static/cc5558188d9f4b11eb174792794c2e7a/75624/touch-screen-capacitive2.png 260w"
        sizes="(max-width: 260px) 100vw, 260px"
        loading="lazy"
      />
  </a>
    </span></p>
<h1>Память</h1>
<table>
<thead>
<tr>
<th>Тип памяти</th>
<th>Время доступа</th>
</tr>
</thead>
<tbody>
<tr>
<td>DRAM</td>
<td>50-150 наносекуд</td>
</tr>
<tr>
<td>Магнитный диск</td>
<td>5-20 милисекунд</td>
</tr>
<tr>
<td>Флэш-память</td>
<td>5-50 микросекунд</td>
</tr>
</tbody>
</table>
<h2>Производство процессоров и памяти</h2>
<ol>
<li>Из расплавленного кремния на специальном оборудовании выращивают монокристалл цилиндрической формы</li>
<li>Получившийся слиток охлаждают и режут на «блины», поверхность которых тщательно выравнивают и полируют до зеркального блеска</li>
<li>Затем в «чистых комнатах» полупроводниковых заводов на кремниевых пластинах методами фотолитографии и травления создаются интегральные схемы</li>
<li>После повторной очистки пластин, специалисты лаборатории под микроскопом производят выборочное тестирование процессоров – если все «ОК», то готовые пластины разрезают на отдельные процессоры, которые позже заключают в корпуса</li>
</ol>
<p>Подробности <a href="https://habr.com/company/intel/blog/110234/">здесь</a></p>
<h1>Инструкции MIPS</h1>
<p><strong>Слово</strong> - единица доступа к памяти компьютера. Совпадает с размером регистра. В 32-битной архитектуре слово = 32 бита, регистр = 32 бита и к памяти мы можем обращаться шагами по 32 бита или 4 байта. Чем больше регистров, тем дольше будет такт, потому что расстояние до регистров будет больше и сигналы будут его дольше проходить. Помимо этого, чем больше регистров, тем больше бит занимает инструкция в памяти.</p>
<p>Разница между переменными и регистрами в том, что количество регистров ограничено, и некоторые инструкции могут работать только с данными, лежащими в определенных регистрах. Поэтому перед выполнением этих инструкций нжуно выполнить операцию <strong>load</strong>, которая загружает значение из памяти в регистр. Команда <strong>store</strong> - наоборот, сохраняет значение из регистра в переменную в памяти.</p>
<p>В архитектуре MIPS 32 32-битных регистра. Регистры в MIPS обозначаются знаком доллара и 2-буквенным обозначением, например: $s0, $s1 - регистры общего назначения. $t0, $t1 - временные регистры.</p>
<h2>Команды перемещения данных</h2>
<p><strong>Команда загрузки в регистр состоит из</strong>:</p>
<ul>
<li>название операции</li>
<li>регистр, в который загружаем</li>
<li>константа, обозначающая <strong>сдвиг</strong>, измеряемый в <em>байтах</em>. Это обязательно должна быть костанта. Если сдвиг определяется динамически, то нужно предварительно записать сдвиг в какой-нибудь регистр, затем этот регистр подать как адрес в памяти, а сдвиг указать равный 0.</li>
<li>регистр, обозначающий адрес в памяти, называемый <strong>базовый регистр</strong></li>
</ul>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">g = h + A[8] =&gt; 

	lw $t0, 32($s3) 
	add $s1, $s2, $t0</code></pre></div>
<ul>
<li><code class="language-text">lw</code> = load word</li>
<li><code class="language-text">$t0</code> = регистр, куда попадет значение</li>
<li><code class="language-text">32</code> = сдвиг. Нас интересует 8-й элемент массива, то есть 8-е слово. Каждое слово состоит из 4 байт, значит нас интересует 32-й байт. </li>
<li><code class="language-text">$s3</code> = адрес начала массива <code class="language-text">A</code> в памяти</li>
<li><code class="language-text">$s2</code> = ассоциирован с <code class="language-text">h</code></li>
<li><code class="language-text">$s1</code> = результат сложения, ассоциирован с <code class="language-text">g</code> </li>
</ul>
<p>Из-за выравнивания памяти адреса всех слов должны быть кратны 4.</p>
<p><strong>Пример обращения с динамическим сдвигом</strong>:</p>
<p>$s0 = i
$a0 = A</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">g = A[i] =&gt;

	sll $t0 $s0 2   # сдвигаем на 2, то есть умножаем на 4, чтобы из кол-ва слов получить кол-во байт
	add $t1 $a0 $t0 # t1 = a0 + t0, то есть узнаем адрес в памяти элемента A[i]
	lw $t2 0($t1)   # t2 = A[i]</code></pre></div>
<p>Компьютеры делятся на те, которые используют адрес самого левого (старшего) байта в слове в качестве адреса слова (<em>big-endian</em>) и на те, которые используют адрес правого (младшего) байта (<em>little-endian</em>). MIPS относится к <em>big-endian</em> архитектурам.</p>
<p><strong>Команда выгрузки из регистра в память</strong> называется <strong>store</strong> и имеет аналогичный с командой <strong>load</strong> синтаксис: название операции <em>sw</em>, сохраняемый регистр, сдвиг и базовый регистр.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">A[12] = h + A[8] =&gt;

	lw $t0, 32($s3)
	add $t0, $s2, $t0
	sw $t0, 48($s3)</code></pre></div>
<h2>Константы</h2>
<p>Команда <code class="language-text">add</code> принимает в качестве операндов регистры. Если нам нужно что-то сложить с константой, то пришлось бы сначала записать константу в регистр, что неэффективно. Для решения проблемы есть специальная команда <code class="language-text">addi</code>, что означает <em>add immediate</em>. Так как константы могут быть отрицательными, то нет надобности в команде <code class="language-text">subi</code>.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">addi $s3, $s3, 4    # $s3 = $s3 + 4</code></pre></div>
<p>Для константы 0 даже есть специальный регистр <code class="language-text">$zero</code>.</p>
<h2>Знаковые числа</h2>
<p>В большинстве систем сейчас используется техника представления знаковых чисел под назваием <strong>two's complement</strong>, или <em>второе дополнение</em>. Второе дополнение числа определяется как величина, полученная вычитанием числа из наибольшей степени двух.</p>
<p>В знаковых числах старший бит означает знак. Если он равен 0, то в остальных разрядах записаноположительное число.
Если 1, значит число отрицательное. Предществующие 1 в этом случае выполняют роль предшествующих 0 в положительных числах, то есть все подряд идущие 1 слева становятся незначимыми, значимая только самая правая в ряду подряд идущих единиц. При этом самый старбишй бит - всегда НЕ значимый. Если после него идет 0, то первым значащим битом становится этот ноль. </p>
<p>Разница 2^(количество значимых бит справа) - число, закодированное в этих битах = абсолют нашего искомого отрицательного числа.</p>
<p>Пример:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">1111 1111 1111 1111 1111 1111 1111 1101 = -3

 1111 1111 1111 1111 1111 1111 1111 1 101 = -3
|                                    |   |
------------------------------------- ----
              ^                        ^
              |- не значимые           |- значимые 101 = 5

Количество значимых бит = 3

2^3 - 5 = 3

Искомое число = -3</code></pre></div>
<p>Другой пример, когда у нас после знака сразу идет 0:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">1010 = -6
         1           010 = -6
|                   |   |
-------------------------
 ^                    ^
 |- не значимый бит   |- значимый 010 = 2

Количество значимых бит = 3

2 ^ 3 - 2 = 6

Искомое число = -6</code></pre></div>
<p>Иначе говоря, число со знаком может быть представлено как:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">(x[31] * -2^31) + (x[30] * 2^30) + (x[29] * 2^29) + ... + (x[1] * 2^1) + (x[0] * 2^0)</code></pre></div>
<p>То есть в случае <code class="language-text">signed</code> числа знаковый бит умножается на -2^31, а в случае <code class="language-text">unsigned</code> - на 2^31.</p>
<p>Другой способ преобразования - инвертировать число и прибавить 1, получаем абсолют. То есть в нашем случае это будет <code class="language-text">10 = 2</code>, прибавляем 1 - получаем 3.</p>
<p>Неиспользуемая ныне техника <strong>one's complement</strong> получает отрицательное число как <code class="language-text">2^n - x - 1</code>. Все отрицательные числа получаются из положительных установкой знакового бита в 1 и инвертацией всех остальных позиций. Сейчас техника не используется, так как требует больше шагов для арифметических операций (в two's complement отрицательное число равняется <code class="language-text">2^n - x</code>).</p>
<h2>Представление инструкции в машинном коде</h2>
<p>Регистры $t0-$t7 имеют номера 8-15, а $s0-$s7 - 16-23.</p>
<p>Для примера возьмем инструкцию сложения:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">add $t0, $s1, $s2</code></pre></div>
<p>Она представляется в памяти в следующем виде:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">0 17 18 8 0 32</code></pre></div>
<p>Где:</p>
<p>0 - первая часть идентификатора команды <code class="language-text">add</code>
17 - <code class="language-text">$s1</code>
18 - <code class="language-text">$s2</code>
8 - <code class="language-text">$t0</code>
0 - не используется в этой команде
32 - вторая часть идентифкатора команды <code class="language-text">add</code>.</p>
<p>В бинарном виде команда имеет вид:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">000000 10001 10010 01000 00000 100000</code></pre></div>
<p>1 и 6 части имеют по 6 бит, 2-5 по 5. Итого каждая инструкция занимает 32 бита, то есть сколько же, сколько занимает слово в этой архитектуре.</p>
<p>Каждое из полей команды имеет свое название:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">|   op  |   rs  |   rt  |   rd  | shamt | funct |
| 6 бит | 5 бит | 5 бит | 5 бит | 5 бит | 6 бит |</code></pre></div>
<ul>
<li><em>op</em>: 6 бит, <em>opcode</em>, определяет операцию и формат инструкции</li>
<li><em>rs</em>: 5 бит, первый входной регистр</li>
<li><em>rt</em>: 5 бит, второй входной регистр</li>
<li><em>rd</em>: 5 бит, регистр назначения</li>
<li><em>shamt</em>: 5 бит, сдвиг</li>
<li><em>funct</em>: 6 бит, <em>function code</em>, определяет конкретный варинт операции, указанной в поле <em>op</em>.</li>
</ul>
<p>Этот формат называется <em>R-type</em> или <em>R-format</em>, от слова register.</p>
<p>Есть еще другой формат - <em>I-type</em> / <em>I-format</em>, который используется для операций с константами и операций сохранения/загрузки данных. Дело в том, что при использовании R-формата размер константы ограничен 5 битами, а значит может принимать значения от 0 до 32. Это очень мало для константы и особенно для адресации внутри массива в случае команд <em>load/store</em>. </p>
<p>I-формат:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">|   op  |   rs  |   rt  | constant or address |
| 6 бит | 5 бит | 5 бит | 16 бит              |</code></pre></div>
<p>При этом в этом формате регистр <code class="language-text">rt</code> означает регистр назначения.</p>
<p>Еще есть самый простой формат - <em>J-type</em>, используемый для инструкции <code class="language-text">j</code>:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">|   op  | address |
| 6 бит | 26 бит  |</code></pre></div>
<h2>Условия</h2>
<p><code class="language-text">beq reg1 reg2 L1</code> - если значение регистра 1 = значению регистра 2, то перейти к метке L1</p>
<p><code class="language-text">bne reg1 reg2 L1</code> - если значение регистра 1 != значению регистра 2, то перейти к метке L1</p>
<p><code class="language-text">slt reg1 reg2 reg3</code> - set on less than, если reg2 &#x3C; reg3, то reg1 = 1, иначе 0</p>
<p><code class="language-text">slti reg1 reg2 10</code> - set on less than immediate, если reg2 &#x3C; 10, то reg1 = 1, иначе 0</p>
<p>Есть еще <code class="language-text">sltu - set on less than unsinged</code> и <code class="language-text">sltiu - set on less than immediate unsgined</code>. </p>
<h3>Быстрая проверка на выход за границы цикла</h3>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">sltu $t0 $s1 $t2  # $t0=0 if $s1 &gt;= length or $s1&lt;0
beg $t0 $zero IndexOutOfBounds  # if bad, goto Error</code></pre></div>
<h2>Цикл</h2>
<p>Допустим, мы хотим преобразовать следующий код в ассемблер:</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span>save<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> k<span class="token punctuation">)</span>
	i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre></div>
<p>Пускай переменные у нас лежат в следующих регистрах:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">i = $s3
k = $s5
save = $s6</code></pre></div>
<p>Тогда код на ассемблере будет таким:</p>
<div class="gatsby-highlight" data-language="asm"><pre class="language-asm"><code class="language-asm">While: 
	sll $t1 $s3 2  # умножаем i на 4 путем сдвига влево на 2 знака, чтобы из количества слов получить количество байт
	add $t1 $t1 $s6 # получаем адрес save[i]
	lw $t0 0($t1) # загружаем в регистр значение save[i]
	beq $t0 $s5 Exit # if(save[i] != k) break;
	addi $s3 $s3 1 # i += 1
	j While # возвращаемся в начало 
Exit:</code></pre></div>
<h2>Вызов процедуры</h2>
<p>Для вызова процедуры, нужно сделать следующее:</p>
<ol>
<li>Положить параметры в место, откуда процедура сможет их получить</li>
<li>Передать контроль процедуре</li>
<li>Получить ресурсы, необходимые процедуре</li>
<li>Выполнить процедуру</li>
<li>Положить результат в место, откуда вызывающая программа сможет его получить</li>
<li>Вернуть контроль точке вызова процедуры</li>
</ol>
<p>В MIPS для вызова процедур служат следующие регистры:</p>
<ul>
<li><em>$a0-$a3</em>: 4 регистра, куда можно положить параметры</li>
<li><em>$v0-$v1</em>: 2 регистра, куда можно положить результат</li>
<li><em>$ra</em>: return address, то есть регистр, куда кладется адресс точки вызова перед вызовом процедуры</li>
</ul>
<p>Если нужно передать больше 4 параметров, то все дополнительные параметры кладутся на стек сразу над <code class="language-text">$fp</code>.</p>
<p>Для вызова есть специальная инструкция <code class="language-text">jal (jump-and-link)</code> - она кладет адрес следующей инструкции в регистр <code class="language-text">$ra</code>, после чего вызывает процедуру. </p>
<p>Синтаксис прост:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">jal ProcedureAddress</code></pre></div>
<p>Процедура возвращается вызовом <code class="language-text">jr $ra</code>.</p>
<p>Адрес текущей выполняемой инструкции почти всегда называется <em>program counter</em> или <em>PC</em>. Команда jal просто сохраняет в регистр $ra значение PC + 4.</p>
<h2>Стек</h2>
<p>Когда регистров не хватает, на помощь приходит <strong>стек</strong>. Например, после вызова процедуры нужно подчистить все следы и вернуть все используемые процедурой регистры к тем значениям, которые были <em>до</em> вызова процедуры. А для этого их нужно где-то хранить. Вот на стеке они и хранятся. Также в нем хранятся локальные массивы и структуры.</p>
<p>Для работы со стеком используется <em>stack pointer</em>, указывающий на адрес последнего сохраненного в стек значения. При сохранении или извлечении каждого значения, стэк пойнтер изменяется на 1 слово. Обратиться к нему можно по регистру <code class="language-text">$sp</code>.</p>
<p>Стек растет от высших адресов к низшим. Это означает, что для пуша на стек нужно вычитать 1 слово из значения стэк пойнтера. А увеличение стэк пойнтера уменьшает стэк, выдавливая из него значения.</p>
<p>Пример процедуры:</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">leaf_example</span><span class="token punctuation">(</span><span class="token keyword">int</span> g<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> f<span class="token punctuation">;</span>
	f <span class="token operator">=</span> <span class="token punctuation">(</span>g <span class="token operator">+</span> h<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> f<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>g,h,i,j = $a0,$a1,$a2,$a3</p>
<p>f = $s0</p>
<p>Скомпилированная процедура будет выглядеть так:</p>
<div class="gatsby-highlight" data-language="asm"><pre class="language-asm"><code class="language-asm">leaf_example:
	addi $sp, $sp, -12  # выделяем в стеке место для 3 локальных переменных
	sw $t1, 8($sp)
	sw $t0, 4($sp)
	sw $s0, 0($sp) # бэкапим на стек значение регистров, которые будем использовать в теле функции

	add $t0, $a0, $a1
	add $t1, $a2, $a3
	sub $s0, $t0, $t1 # делаем наши арифметические операции
	add $v0, $s0, $zero # возвращаем результат

	lw $s0, 0($sp)
	lw $t0, 4($sp)
	lw $t1, 8($sp) # ресторим из стека значение регистров
	addi $sp, $sp, 12 # уменьшаем стек на 3 элемента

	jr $ra   # возвращаемся к точке вызова</code></pre></div>
<p>Теперь посмотрим, как выглядит рекурсия:</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token keyword">int</span> fact <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token punctuation">(</span> n <span class="token operator">*</span> <span class="token function">fact</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<div class="gatsby-highlight" data-language="asm"><pre class="language-asm"><code class="language-asm">fact:
	addi $sp $sp -8
	sw $ra 4($sp)
	sw $a0 0($sp) # бэкапим аргументы и адрес возврата, чтобы восстановить их после вызова другой процедуры внутри этой

	slti $t0 $a0 1
	beq $t0 $zero L1 # if n &gt; 1 goto L1

	addi $v0 $zero 1 # else return 1
	addi $sp $sp 8 # уничтожаем забекапленные значения, так как внутренний вызов не пригодился
	jr $ra # возвращаемся к точке вызова

L1: 
	addi $a0 $a0 -1 
	jal fact   # fact(n-1)
	lw $a0 0($sp) # восстанавливаем из стека значение регистров после внутреннего вызова
	lw $ra 4($sp)
	addi $sp $sp 8

	mul $v0 $a0 $v0 # return n * fact(n-1)
	jr $ra</code></pre></div>
<p>Рассмотрим, какие регистры нужно обязательно сохранять перед вызовом процедуры и ресторить после возврата из нее, а какие необязательно</p>
<table>
<thead>
<tr>
<th>Сохранять</th>
<th>Можно не сохранять</th>
</tr>
</thead>
<tbody>
<tr>
<td>$s0-$s7</td>
<td>$t0-$t9</td>
</tr>
<tr>
<td>$sp</td>
<td>$a0-$a3</td>
</tr>
<tr>
<td>$ra</td>
<td>$v0-$v1</td>
</tr>
<tr>
<td>Стэк над $sp</td>
<td>Стэк под $sp</td>
</tr>
</tbody>
</table>
<h3>Выделение места на стеке</h3>
<p>Сегмент стека, содержащий сохраненные процедурой регистры и ее локальные переменные, называется <em>фрейм процедуры</em>.</p>
<p>Для обозначения начала фрейма используется регистр <code class="language-text">$fp</code> - frame pointer, указывающий на адрес первого слова фрейма процедуры. Stack pointer может измениться во время процедуры, а frame pointer - нет.</p>
<p>На рисунке изображен стек до, во время и после вызова процедуры:</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/a9983574e0824c051ede6965c590ffcf/1478c/procedure-frame.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 48.64864864864865%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABt0lEQVQoz3WR7WsTQRDG8/9/LRZRAxX0g4i0CpX6UikVDLXUIkhTm6vExiTNpXdeNnu5fb3Hmal3RKgDD7e3M/Obl+1Mp1PMZjNY7xFrINS1KJLqVlg7ky8E8Yd1xVtfR+slbgqFw+sK71KPD6TXE4OrpQVh4Cx/IWc2hhV5htFihbczj32Kf58GHFB+aR06q1JjTsC9cYXticerqcezK4NBvkJ0FqqyMMQyEfLV1mNOE/3INV6MHV5OnOTt/qqgDQG5oiFyqg0yW4vSKkjXC6Wkcvd0hK0vQ3RPhtgZKhQlJVcGc6qS2XibUzpYR0AZI0b4djSZC56cbHvnY2wcfMWjT33c//gNT04usaQug7PtGmQh9Aa+AQbu0th2U95z1xY1FdofZnhwNCDgGR72vuN5/1rWwLttHo7NEcytA+1ah/zvpMMah2OF7ucEj48TbB1fYifJsDRegPX/gHxpjPkHqLWWuzc/F9joJdjsXeBeb4Cn/RSKRnbku7PDsiwlmSHtPiiI7xXdj8qA898GFwXLIlnQq9NK4t/4Bsj5rE6e55inKYqiaAOaIAGrAncZF2ymauLZ/gDUEfxlzmyBFQAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Procedure frame"
        title="Procedure frame"
        src="/hows-that-again/static/a9983574e0824c051ede6965c590ffcf/dbb61/procedure-frame.png"
        srcset="/hows-that-again/static/a9983574e0824c051ede6965c590ffcf/19bd1/procedure-frame.png 163w,
/hows-that-again/static/a9983574e0824c051ede6965c590ffcf/d3bcb/procedure-frame.png 325w,
/hows-that-again/static/a9983574e0824c051ede6965c590ffcf/dbb61/procedure-frame.png 650w,
/hows-that-again/static/a9983574e0824c051ede6965c590ffcf/1478c/procedure-frame.png 666w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>На следующей схеме - распределение данных в памяти для архитектуры MIPS</p>
<p><a href="mips-memory-allocation.png">!MIPS Memory allocation</a></p>
<p>Указанные адреса не являются частью архитектуры, а просто соглашение на уровне приложений. </p>
<p>Вершина стека инициализируется самым старшим адресом доступной памяти, то есть <code class="language-text">$sp = 7fff fffc</code>. Оттуда стек будет расти вниз.</p>
<p>Затем идет сегмент динамической памяти, или <em>куча</em>. Она растет вверх, навстречу стеку. Это память, выделяемая командами <code class="language-text">malloc</code> и <code class="language-text">new</code>. Здесь всякие массивы, структуры.</p>
<p>Затем сегмент статической памяти, который начинается с адреса <code class="language-text">1000 0000</code>. Здесь хранятся константы и другие статические переменные.</p>
<p>Затем сегмент Text, содержащий машинный код исполняемой программы.</p>
<p><code class="language-text">$gp</code> указывает на середину сегмента статической памяти и с его помощью, указывая положительный или отрицательный сдвиг, можно обратиться к любому адресу статического сегмента.</p>
<p>И в конце сегмент зарезервированной памяти.</p>
<h3>Tail call optimization</h3>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> acc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token function">sum</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> acc<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token keyword">return</span> acc<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p> Преобразуется в:</p>
<p> $a0 = n
$a1 = acc</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">sum:
	slti $t0 $a0 1                 # if n &lt;= 0
	bne $t0 $zero sum_exit         # goto sum_exit if n &lt;= 0
	add $a1 $a1 $a0 			   # acc += n
	addi $a0 $a0 -1				   # n -= 1
	j sum
sum_exit:
	add $v0 $a1 $zero			   # return acc
	jr $ra</code></pre></div>
<h2>Манипуляции со строками</h2>
<p>Для работы со строками есть инструкции <code class="language-text">lb</code> и <code class="language-text">sb</code>, которые загружают из памяти 1 байт и сохраняют его в младший байт регистра - и наоборот. В этом случае адрес памяти необязательно должен быть кратным 4.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">lb $t0 0($sp)   # read byte from source
sb $t0 0($gp)	# write byte to destination</code></pre></div>
<p>А для чтения юникодных символов есть инструкции <code class="language-text">lh</code> и <code class="language-text">sh</code> (load half/store half), которые читают по 2 байта из памяти и сохраняют в младшие 2 байта регистра - и наоборот. Адрес должен быть кратен 2.</p>
<p>В <strong>С</strong> строка ограничена символом с кодом 0 справа.</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">strcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> x<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> y<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>

	i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">)</span>
		i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>$a0 = x
$a1 = y
i = $t0</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">strcpy:
	add $t0 $zero $zero
loop:
	add $t1 $t0 $a1 
	lbu $t2 0($t1)		# $t2 = y[i]

	add $t3 $t0 $a0
	sb $t2 0($t3) 		# x[i] = y[i]

	beq $t2 $zero exit
	add1 $t0 $t0 1
	j loop

exit:	
	jr $ra</code></pre></div>
<p>Так как вложенных вызовов процедур нет, то нам удалось обойти только временными регистрами <code class="language-text">$t</code>. Если есть вложенные вызовы, то перед вызовом:</p>
<ol>
<li>если есть значение, которое полностью используется до вызова и не будет использоваться после вызова, то оно пишется во временный регистр</li>
<li>остальные значения пишутся в сохраняемые регистры <code class="language-text">$s</code>, бэкапятся перед вызовом процедуры и ресторятся после вызова (либо в начал и в конце процедуры, зависит от соглашения вызова).</li>
</ol>
<h2>Работа с большими константами</h2>
<p>Если нужно работать с константой, которая не влезает в 16 бит, на этот случай есть команда <code class="language-text">lui</code> - <code class="language-text">load upper intermediate</code>. Она загружает старшие 16 бит в регистр, позволяя затем указать младшие 16 бит, используя инструкцию <code class="language-text">ori</code>.</p>
<p>Пример:</p>
<p>допустим, хотим в регистр <code class="language-text">$s0</code> загрузить значение <code class="language-text">0000 0000 0011 1101 0000 1001 0000 0000</code></p>
<p>Сначала загружаем старшие 16 бит, которые составляют число 61:</p>
<p><code class="language-text">lui $s0 61</code></p>
<p>После этого в <code class="language-text">$s0</code> лежит значение: <code class="language-text">0000 0000 0011 1101 0000 0000 0000 0000</code></p>
<p>Затем через OR соединяем с младшими 16 битами (которые составляют 2304) и результат кладем в тот же регистр:</p>
<p><code class="language-text">ori $s0 $s0 2304</code></p>
<p>Готово!</p>
<h2>Работа с большими адресами</h2>
<p>Если используем команду <code class="language-text">j</code>, то там используется формат J-type, который выделяет 26 бит на адрес слова. Этого достаточно для адресации в пределах 256 MB.</p>
<p>Если же используются бранч-команды, типа <code class="language-text">beq</code> или <code class="language-text">bne</code>, то там на адрес остается всего лишь 16 бит. Но этого достаточно, так как такие команды используются обычно, чтобы перейти к какой-то близлежащей инструкции в коде. Используя в качестве базового адреса <code class="language-text">$pc</code> мы можем перейти на команду, отстоящую на +-2^15 от текущей. К тому же адресация идет по словам, а не по байтам, так что эти числа можно умножить еще на 4. В результате получаем относительную адресацию в пределах +-128 КБ.</p>
<p>Ну а если не хватает, то мы всегда можем воспользоваться следующим хаком:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">	beq $s0 $s1 L1</code></pre></div>
<p>преобразуем в:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">	bne $s0 $s1 L2
	j L1
L2:</code></pre></div>
<h2>Синхронизация потоков</h2>
<p>Для реализации атомарных операций есть две специальных инструкции:</p>
<ul>
<li><code class="language-text">ll</code>: load linked. Аналогична обычной загрузке, но обозначает начало атомарной операции</li>
<li><code class="language-text">sc</code>: store conditional. Сохраняет регистр в указанный адрес в памяти, но только <em>если</em> значение указанного адреса памяти было изменено между этой инструкцией и инструкцией <code class="language-text">ll</code>, прочитавшей значение из этого же адреса. При этом случае успеха он меняет значение этого регистра в 1, а в случае неудачи - 0.</li>
</ul>
<p>Таким образом, потокобезопасная замена значения, лежащего в <code class="language-text">$s1</code> будет выглядеть так:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">again:
	addi $t0 $zero 1
	ll $t1 0($s1)
	sc $t0 0($s1)
	beq $t0 $zero again
	add $s4 $zero $t1</code></pre></div>
<p>В этом коде мы прочитали значение по адресу <code class="language-text">$s1</code> и записали туда новое значение из регистра <code class="language-text">$t0</code>.	</p>
<p>На основании конструкции <em>load linked/store conditional</em> могут быть построены другие примитивы синхронизации, такие как <em>atomic compare</em>, <em>swap</em> или <em>atomic fetch-and-increment</em>.</p>
<h2>Системные вызовы</h2>
<p>Реализация системных вызовов зависит от ОС и архитектуры процессора, рассмотрим, как реализованы сисколлы в x86_64 на линуксе:</p>
<ol>
<li>Номер системного вызова кладется в регистр RAX</li>
<li>Аргументы вызова кладутся в регистры RDI, RSI, RDX...</li>
<li>Выполняется инструкция ассемблера SYSCALL. Эта инструкция переводит процессор на кольцо защиты 0 и выполняет код, на который ссылается регистр <code class="language-text">MSR_LSTAR</code>, а он ссылается на функцию <code class="language-text">system_call</code>. Эта функция пушит регистры в стек ядра и берет из таблицы <code class="language-text">sys_call_table</code> адрес функции, в строке с номером, соответствующим номеру системного вызова, лежащему в RAX. </li>
</ol>
<h2>Компиляция программы</h2>
<h3>Компилятор</h3>
<h4>Фронтенд</h4>
<p>На вход фронтенду компилятора поступает код программы, а на выходе - некая промежуточная форма, не зависящая от архитектуры. Фронтенд - единственный этап процесса компиляции, который зависит от языка.</p>
<p>Шаги фронтенда:</p>
<ol>
<li><strong>Сканирование</strong> - читает символы и создает поток <em>токенов</em>. <strong>Токены</strong> - это атомарные единицы языка, например: зарезервированные слова, имена, операторы, знаки пунктуации. В коде <code class="language-text">while (save[i] == k) i += 1;</code> токенами будут: while, (, save, [, i, ], ==, k, ), i, +=, 1, ;.</li>
<li><strong>Парсинг</strong> - берет поток токенов, проверяет синтаксис и строит <strong>AST - abstract syntax tree</strong>. Это дерево, в котором представлена ситнактическая структура программы.</li>
<li><strong>Семантический анализ</strong> - берет AST и проверяет программу на семантическую корректность. Обычно на этом этапе проверяется, что переменные и типы правильно объявлены, типы операторов и объектов совпадают. В процессе составляется таблица символов, в которую заносятся все именованные объекты - классы, функции, переменные.</li>
<li><strong>Генерация промежуточного представления</strong> - берет AST со 2 шага, таблицу символов с 3 шага и генерирует текст программы на языке промежуточного представления. Это что-то вроде байткода или MSIL. Обычно этот язык представляет собой подобие MIPS, но с бесконечным количеством виртуальных регистров.</li>
</ol>
<p>После фронтенда идет шаг высокоуровневых оптимизаций</p>
<p>Потом глобальные оптимизации - оптимизации, которые влияют на несколько блоков кода</p>
<p>И наконец генерация машинного кода</p>
<h3>Ассемблер</h3>
<p>На выходе из ассемблера получается object file - комбинация инструкций на машинном языке, данных и информации, необходимой для загрузки инструкций в память. Для создания бинарной версии, ассемблер поддерживает <em>таблицу символов</em>, в которой записаны соответствия меток и их адресов в памяти.</p>
<p>В объектном файле на UNIX обычно содержатся 6 блоков:</p>
<ul>
<li><strong>object file header</strong>: описывает размер и расположение остальных блоков</li>
<li><strong>text segment</strong>: содержит код на машинном языке</li>
<li><strong>static data segment</strong>: содержит статические данные, которые никогда не меняются</li>
<li><strong>relocation information</strong>: содержит адреса инструкций, в которых происходит обращение по абсолютному адресу. Блок нужен, чтобы можно было изменить адреса, когда мы линкуем модуль с другими модулями и стартовый адрес нашей памяти изменяется</li>
<li><strong>symbol table</strong>: содержит незарезолвленные метки, то есть внешние ссылки</li>
<li><strong>debugging information</strong>: инфа о том, как были скомпилированы модули, чтобы дебаггер мог сассоциировать машинные инструкции со строками исходного кода</li>
</ul>
<h3>Линкер</h3>
<p>Берет независимо собранные программы на ассемблере и "линкует" их вместе.</p>
<p>Работает в 3 шага:</p>
<ol>
<li>Помещает код и данные в память</li>
<li>Определяет новые адреса для данных и меток инструкций</li>
<li>Патчит внутренние и внешние ссылки</li>
</ol>
<p>Для 2 и 3 шага линкер использует <em>relocation information</em> и <em>symbol table</em> каждого объектного модуля, чтобы зарезолвить ссылки на внешние процедуры. </p>
<p>В 3 шаге линкер просто проходит по всему коду, отыскивает ссылки и заменяет адреса в них новыми адресами. Польза линкера в том, что патчить код ораздо проще и быстрее, чем перекомпилировать его заново.</p>
<p>На выходе линкера получается <em>исполняемый файл</em>. Обычно он имеет тот же формат, что и объектный файл, только теперь в нем нет незарезолвленнхы ссылок.</p>
<p>Далее мы видим пример того, как линкер линкует 2 модуля в один:</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 602px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/7b9bf997acd4b668105e42b9a323eb97/f0a9a/linker-before.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 116.77740863787376%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsSAAALEgHS3X78AAAC+0lEQVQ4y32V63LiMAyFef8HLD+WW0ICCeROrkCr1Sfbmc5su8wIR4otHUlHzmaeZ6mqSrYfW9nvdrL7s5O2aeTxeMgwDDKOo3vue9ORCVvXyTiMMk2T6ay823CAh7ZtpUN04zROFiQ6RXJJUymLQu73uwXb7/fS1LXcbzepdeVcEPQNCN/vt3z/fX5+SqMotx8fhhrnsyJIzokkSSLLskittl5RB0CsgNmQTlVWtpHoyflskcqilNPxKKkirKvaAhxVPxwOVhKCkDZOg5DhivDr60ter5ehQydaUzdrKmVZyuVylTS72TO2UOcghpBUns+npcGK4Ljz0dnIYVYQteoEENj6b41aUw6GPM8VwcWKzUtQtN3DBJsrfCeVptur05vaKIOlq7rLSJsy9IPVCWdZltkzK5vPcSzZ9WrO6HIcxZJqrXlum9bt0ZpjZw8lMNoQhTQWlcAnDoCS4tNRGoEOhUCDnSYU2rCsqAwlTi1lHJICnCO9wEvK4NC41EAHGwiKQ8jeK6C6H43caw1BGSZi9DoH8nshhVKqUFRGZnVOYA7yTMpd5wYCAOiWMgro8iy3AzgG1aidn+bFdVnRPFWHFSAMXf6H2Ch4jqLIUqIRvMAhOmkHLp5OJ2sC9PmVh/Dvpx9ODvuDBai0GaCJNSi6lURtOB78lLBaU8LIQBWisxKZjm63WznqqFV+bskC3che/YLQFN1sMw0ViKo2nm++y1Al10CxBoyS1MpgjbKmdP6m6lxTfrpt0Algw69rqBcH6rZbx/G/oxemhOjWeS5ZvRd7FSjjuqnUUifLMq/zPfthQMwhf5f0YrRJvZAeBM8ylzJSqBAUG/W1UugKAIQA3E4biBxqZXVTRzYdWhdoc/WzTB25K1O7wUtLH3uieqR2gK2zDHWATE1Y0Y17zLFGDvUKnwL2gM4ma3JlGf24ull+9O760mgg7D2nMpCrk/DR4kYCISAIFmgTmmM1HL0BVEF4abeydrRlbv0H6eEpYtdZ+EhpsOab/AUbJddrfXgOSAAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Before link"
        title="Before link"
        src="/hows-that-again/static/7b9bf997acd4b668105e42b9a323eb97/f0a9a/linker-before.png"
        srcset="/hows-that-again/static/7b9bf997acd4b668105e42b9a323eb97/19bd1/linker-before.png 163w,
/hows-that-again/static/7b9bf997acd4b668105e42b9a323eb97/d3bcb/linker-before.png 325w,
/hows-that-again/static/7b9bf997acd4b668105e42b9a323eb97/f0a9a/linker-before.png 602w"
        sizes="(max-width: 602px) 100vw, 602px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Здесь мы видим 2 модуля. До прохода линкера <code class="language-text">$gp</code> указывает на начало сегмента данных.</p>
<p>Процедура А в строчке 0 ссылается на строчку 0 в сегменте данных, где у нас лежит переменная Х.</p>
<p>В строчке по адресу 4 мы ссылаемся на адрес 0, но в <em>relocation information</em> мы видим, что строчка 4 зависит от процедуры B, а значит это адрес 0 не в нашем модуле, а в модуле B.</p>
<p>Процедура B в строчке 0 ссылается на строчку 0 в сегменте данных, где у нас лежит переменная Y.</p>
<p>В строчке по адресу 4 мы ссылаемся на адрес 0, но в <em>relocation information</em> мы видим, что строчка 4 зависит от процедуры A, а значит это адрес 0 не в нашем модуле, а в модуле A.</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 573px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/397533e645af420b876ec0a66fede5ed/65025/linker-after.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 60.90750436300174%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAABq0lEQVQoz2VT2XLDIAz0/39eOpk0id2ZpEl8gA0Y4yMvqlax3HT6IAMyWu0ukKVhoJQSfRUFfR4OdDwe6cCjaRrJhxBkRIzjSH3fS2AeYyTUj2mkgecYMxQMnGxtK9F1HVlrBch7T945qqqK8vNZ8shhz8SA9/udvq/fW+PIjTJlAFCwQnHbtsLAO089/0fhx27HDX8bTdNE18uF8tNJmKIe4waIhWkMlY+HFI5rV4A/OJfnuTQDGJg2dUW3sqaiNFQzkaauX4D4zPMsHZdloefzKWsEukIyQK2xokCkcU0InlxMZNJCNo6yNw2JMnRUoyXCa0SRW/2EZw2DYRRwzuFfx5YYDsdNkUOdMAQzZaWBHKxAQ0iFFSpLDoYBbD/QrZ+pcb0owf5MJaixEnH4Ixed5TDWtajitYPHrKhjYFUogDhR0L7wqRV8H3GqyAVcGzAsS9rv9yzTbaeM/2gKkImZqU3bPVSWcf0Bg/XOwZ+qrMRHeIe83D3e2/kge/8Bqsz3QOHrhI2w1MNQvwLkAhxMV+syeTJMX5/X+zOLq3fKAHOEPj1VpnPU/QCeCpGBn3BmawAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="After link"
        title="After link"
        src="/hows-that-again/static/397533e645af420b876ec0a66fede5ed/65025/linker-after.png"
        srcset="/hows-that-again/static/397533e645af420b876ec0a66fede5ed/19bd1/linker-after.png 163w,
/hows-that-again/static/397533e645af420b876ec0a66fede5ed/d3bcb/linker-after.png 325w,
/hows-that-again/static/397533e645af420b876ec0a66fede5ed/65025/linker-after.png 573w"
        sizes="(max-width: 573px) 100vw, 573px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Мы видели ранее, что после линка сегмент текста начинается по адресу <code class="language-text">0х40 0000</code>, а сегмент данных - по <code class="language-text">0х1000 0000</code>. Текст процедуры А располагается по первому адресу, а ее данные - по второму. Заголовок процедуры А говорит, что ее текст занимает <code class="language-text">0х100</code> байт, а данные - <code class="language-text">0х20</code> байт, поэтому текст процедуры B располагается сразу после А по адресу <code class="language-text">0х40 0100</code>, а ее данные - по <code class="language-text">0х1000 0020</code>.</p>
<p>Шаг 1 закончен. Теперь линкер обновляет адреса в инструкциях. Он проходит по каждой строчке в сегменте <em>relocation information</em> и патчит соответствующие инструкции. Чтобы определить используемый формат, он читает поле <em>instruction type</em>.</p>
<p>В нашем случае используется 2 типа команд:</p>
<ol>
<li><code class="language-text">jal</code>. C ними все просто, потому что они используют абсолютные адреса. <code class="language-text">jal</code> по адресу <code class="language-text">0х40 0004</code> должен обращаться к 0 строчке процедуры B. B у нас лежит по <code class="language-text">0x40 0100</code>, значит и целевой адрес такой же. Аналогично <code class="language-text">jal</code> по адресу <code class="language-text">0x40 0104</code> преобразуется в <code class="language-text">0х40 0000</code>.</li>
<li><code class="language-text">lw</code> и <code class="language-text">sw</code> посложнее, потому что они используют относительные смещения от <code class="language-text">$gp</code>. Как мы видели ранее, <code class="language-text">$gp</code> инициализируется значением <code class="language-text">0х1000 8000</code>. В строчке <code class="language-text">0х40 0000</code> нам нужно обратиться к переменной Х, то есть бывшей 0 строке сегмента данных процедуры А. 0 строка данных А теперь получила адрес <code class="language-text">0х1000 0000</code>. Значит ее относительный адрес относительно <code class="language-text">$gp</code> будет <code class="language-text">0х-8000</code>. Аналогично в строчке <code class="language-text">0х40 0100</code> относительный адрес меняется на <code class="language-text">0х8020</code>.</li>
</ol>
<h3>Загрузчик</h3>
<p>Кладет программу в память, чтобы она могла выполниться.</p>
<p>Для этого выполняет следующие шаги:</p>
<ol>
<li>Читает заголовок программы в память, чтобы определить размер сегментов кода и данных</li>
<li>Выделяет адресное пространство, достаточное чтобы вместить текст и данные</li>
<li>Копирует инструкции и данные из исполняемого файла в память</li>
<li>Копирует параметры главной программы на стек</li>
<li>Инициализирует регистры и устанавливает stack pointer</li>
<li>Переходит к процедуре запуска, которая копирует параметры в регистры аргументов и вызывает главный метод программы</li>
</ol>
<h3>Динамически загружаемые библиотеки</h3>
<p>Поблемы вышеописанного способа линковки:</p>
<ol>
<li>Все библиотеки становятся часть исполняемого файла, новая версия библиотеки означает перелинковку.</li>
<li>При старте в память загружаются все функции всех модулей даже если эти функции не запускаются</li>
</ol>
<p>Эти проблемы решают динамически связываемые библиотеки (DLL). В таком способе линковки библиотеки не линкуются и не связываются, пока программа не запущена. </p>
<p>Для этого:</p>
<ol>
<li>Объектный файл динамически загружаемой библиотеки содержит дополнительную информацию о расположении процедур внутри нее</li>
<li>При старте загрузчика запускается динамический линкер, который использует эту информацию для связывания библиотек и обновления всех внешних ссылок</li>
</ol>
<p>Недостаток первоначальной версии был в том, что в память все равно загружались все функции программы, а не только те, которые будут использоваться. Поэтому в следующей версии каждая функция линкуется индивидуально только <strong>после</strong> того, как она была вызвана.</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/4bf2dd0b6774c85dc85860cdac175646/16abd/lazy-procedure-linkage.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 117.87234042553192%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAABYlAAAWJQFJUiTwAAADnklEQVQ4y41V2W4bRxDU//+LH4IgQBB/QJ6SGLYESRQpcknufc/O3kelupekJcOJPcBghrPN2u7qmto7cCzLgrIsdbZti67rdMpepjyXIfs0TWGt1ef9ZTZNg2EYNOYOKyK22y3c8xnLPOtDDeC+rmtM06RheZ7j6fFRz2aeFbZG2/cYOAX0BtiN0/r2osDCwIcwx2/7BB0DJRMBnBnXcF8xOwEa+g6/bCM8RIWCS5wCTqwm6UZ4RYVzVqAZZ+yTAp+8BLYf0UnJ8wQzLohsy2c5Ytug7AbcE+xY1hjH8T1gwwyrqlIOZbzEBT462S1QMmiZouxLqYIvwDTg932KbVopTe8AS2ZSGoPCVCgIXHCflQZRWcHy97KQSwZGVa1nIWdQrDGn3Gj8O0CvGbBxTtidXaT8U1k3uhqu0lGmAMsMnTjF82aDKEkVoGYjbNPcuv4VsB7wutvBc130bERMrtqu104bU2mJFQH3YYKTc9Cs06ZHUrcaIx2WziugdC+oe2SUxDQwyFj8+pog5JoK+ZfOW9IW5CV114Itxp9ujr+CQmNycq+VXDNM2eW8XjuXNx0ss5NVwCvyI8Ju+GaRi/CWkw7LjCSrgDGGGff9peR+JtndBM/z4AWhlmoplapptZSVQ96kYUbST6pZUUXNaYd1P88zrjfubiBg0I4IfA9xHCuHb4cIXm6MoT6rccb/DQUkHiJ2We6kXKGqyLGLMvwdUpNsRsvzVdgr6PWP35s3Dg11mJHYlPxU5OX+5OOPzQlekqG+lvwN4H8NAi7w2wlPBwcvJ+qQUjCtNGZtzpVD8/OAwJkl7+g2zn6vMkmTBEWeIcuy1UUuHP40oGG3drstnp6f8cz5st3hn89f4LPz4jjvOVx+zGFNwJpa0vLGHg9ujA+Prl6t9uY27PK0/LjLEhNRNl6aw+dNkNtwCCJs/EjPtClY1L5Sir1l05rLi96u4kyaoegwbAd17A3nka4t4pYKxFjlNog9iTm49MstzUEq0TJ5LqvcZ9XrW3OQBjiHA47Ho67DReCrsFeD9U2N0PcRBIEaSRAnGjPP3zi2XKHaVmqyGAd8cjx8ePKUw+v3Qwy2kStpyvUDZY3yfO+vVtZ9zXBBTCvyWU5I00wqq6VtwhQBjVTdRXTIlwbMUHiWT4CY7CHO8MpPQknTEHPQpgj6mel7LOV4OuNMqURRBJdnYRjeOiifzz3Fv3c4SYnEua6HMzkXDxCqJOZfDtk85znLY0YAAAAASUVORK5CYII='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Lazy Procedure Linkage"
        title="Lazy Procedure Linkage"
        src="/hows-that-again/static/4bf2dd0b6774c85dc85860cdac175646/dbb61/lazy-procedure-linkage.png"
        srcset="/hows-that-again/static/4bf2dd0b6774c85dc85860cdac175646/19bd1/lazy-procedure-linkage.png 163w,
/hows-that-again/static/4bf2dd0b6774c85dc85860cdac175646/d3bcb/lazy-procedure-linkage.png 325w,
/hows-that-again/static/4bf2dd0b6774c85dc85860cdac175646/dbb61/lazy-procedure-linkage.png 650w,
/hows-that-again/static/4bf2dd0b6774c85dc85860cdac175646/16abd/lazy-procedure-linkage.png 940w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Когда вызывается функция библиотеки, то: происходит переход по адресу, лежащему в некой переменной (первый прямоугольник). Эта переменная лежит в области данных (второй прямоугольник) и при первом вызове указывает на заглушку (третий). Заглушка загружает в регистр идентификатор функции и переходит в динамический загрузчик (четвертый). Загрузчик по идентификатору определяет, где лежит эта функция, динамически ее линкует, загружает и вызывает. А вместе с этим он переписывает переменную из 2-го прямоугольника так, чтобы она указывала сразу на адрес загруженной в память реальной функции. Таким образом при последующих вызовах мы попадаем сразу в функцию, правда через адрес, лежащий в переменной. Но количество инструкций остается тем же, просто вместо <code class="language-text">j</code> используется <code class="language-text">jr</code>.</p>
<h1>Архитектура ARMv7 (32-bit)</h1>
<p>Для ARMv8 мануал <a href="https://www.element14.com/community/servlet/JiveServlet/previewBody/41836-102-1-229511/ARM.Reference_Manual.pdf">здесь</a></p>
<p>Основное отличие от MIPS: меньше регистров, больше схем адресации</p>
<table>
<thead>
<tr>
<th></th>
<th>ARM</th>
<th>MIPS</th>
</tr>
</thead>
<tbody>
<tr>
<td>Размер инструкции</td>
<td>32</td>
<td>32</td>
</tr>
<tr>
<td>Адресное пространство</td>
<td>32-битное</td>
<td>32-битное</td>
</tr>
<tr>
<td>Выравнивание данных</td>
<td>Есть</td>
<td>Есть</td>
</tr>
<tr>
<td>Схем адресации</td>
<td>9</td>
<td>3</td>
</tr>
<tr>
<td>Регистры</td>
<td>15 х 32 бит</td>
<td>31 х 32 бит</td>
</tr>
</tbody>
</table>
<p>Сравнение инструкций:</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/9de5d07b55cdf8c16e41d063247d091f/840a7/arm-mips-instructions.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 88.95612708018155%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsSAAALEgHS3X78AAAC7ElEQVQ4y2VUy27TUBDN77FGLFARiC1ijZBgx+8gEGwroaJCARUB6iNpXo5feTmOHb/i2E1ymDOx01Iije6945kzZ87cm8Zbt8C94wgPv8d4cBLjyWmKx6cZXl8s8aqy579SHPxI8Ej8z35neHme4b7EPv2Z4UB8b1q55Cd4cZahYYRLfBom+DrJcDLNcdj38OHcwjcnwLE5wxfLx8koxqExw7s/Bo4GPr65IY7cGB8vLLw/G+CoO8RnN1J/Y1sWALaof2WygNtrI5yOEfse0sAH1iWKOMTENJDOZyjTWHwFpvZAzh42eQYUOa7F31itVijXa6w3W4UNwhAXl5dwHBfebIbRaAx/Pke4WKDXNzCZeojiGPmqgGlaEuMjzTJky1z9jaIocPsXCmBTAD3P030gYFEUwfd9uI6jvoWAJ0kCy7JgGAbG47GewyDYMcykQp7nIPhcAGwJpJ++2h8JCBO5V598t20bk8lEz4wnqAISmSxioTyTNsmORXimMXAmPgJwX8eSMdlqXBTvGN5tmQHdble0G2EsNnRdBSfIdDpVJsvlUlm58o1AdSdJXDFcy1C2292kmdhpt9HpdFQfVicAtRsNh7rP0kxXMqSPBXmOJVcZbjabf4bSarbQ7/UUuNZItZWWmZhK21ztaijUl2eSaSi6mF4fAfdFQ06ZwdxTAsYEog8LUAoadXaEoSNFGMcYxv7fcqWhOTDR6/aUcSF3jivZpGmqyTTqm1RstWW9hwJ4u2VWuWq10BUNW80m2ldX++o9kaEeSD0Utn8zlArw+vp6D8rETrsjDAfaFlmQHduy5GUwiVrRqCm/cRi0oL42pErRuUYVQ7ZMZmVZqrGQdevCc6WWbJn7/cW+2zIrss1+vw9P3u0iXEiRSC+2ZZq7ohUj27J3RKKdb//07gKS4UAGwASd6nAkbzqQiTqYy5uunyOnzDfO/Q1DOVBDTprA9RVZCDBZMZnfOAxq6su/C/fMYRHua1kY+xeMAUfzmC0qQQAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="ARM vs MIPS instructions"
        title="ARM vs MIPS instructions"
        src="/hows-that-again/static/9de5d07b55cdf8c16e41d063247d091f/dbb61/arm-mips-instructions.png"
        srcset="/hows-that-again/static/9de5d07b55cdf8c16e41d063247d091f/19bd1/arm-mips-instructions.png 163w,
/hows-that-again/static/9de5d07b55cdf8c16e41d063247d091f/d3bcb/arm-mips-instructions.png 325w,
/hows-that-again/static/9de5d07b55cdf8c16e41d063247d091f/dbb61/arm-mips-instructions.png 650w,
/hows-that-again/static/9de5d07b55cdf8c16e41d063247d091f/840a7/arm-mips-instructions.png 661w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Обратите внимание, в ARM нет инструкции для деления!</p>
<p>Сравнение схем адресации:</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/84d2c264d56a99cd9c89bb235a399edc/bbf8d/arm-mips-addressing-modes.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 43.730886850152906%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABuElEQVQoz21QTU/VUBDtP2RlYgLEpb9BNgZ/iUu3xohCgiEav0h0gYj09cFre19LX3ltb+9HP4HjzDU1MbI4OTPnzpyZud7GJ42tY4Od0wa7Py2enlo8OTHY/qrx4LPCFvGjY41N4mdn1uWMbdIeflFOe/xNY+Ojwom8gff8e4gXP5Z4dZ7iw5XF+9TgiLAvDN4Ijb2wxutFhbcUH0Z/mPO9ULr3d6QdCIWXlxKZ6eDl4RxlEiOLLtErCXQWt40GGH3jcGcVcNNj1LXju4by1gC3pBmKh5b6DMauhXf26xxRLOD7MwTBHLMgwFW2QiyWWOU5pFJYFyWUMbher6G0QVFWKCsJbax7q5V2edOSYRiGyKkxjmMIQrJcoiwKdF2Hvu9hrYUiU45VXTtdk4GhAdM7a5wzexfzC2RZhoiMoyhyCGjLaxoyDMM/hvU9hpPRX0Pf9yGEwJxMwsUCwWzmDBcUcxGblGUJS3FBm7NWVRWklE6TFGutXd7yybwZn5smCdI0RULMRTyNCyZTzmtqYuaNDZlMm3EdmzrDfLUCg6eO44iBzuBTuJjRNM1/5/E3sM4a81THX/QbQb2bWuvr9mIAAAAASUVORK5CYII='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="ARM vs MIPS addressing modes"
        title="ARM vs MIPS addressing modes"
        src="/hows-that-again/static/84d2c264d56a99cd9c89bb235a399edc/dbb61/arm-mips-addressing-modes.png"
        srcset="/hows-that-again/static/84d2c264d56a99cd9c89bb235a399edc/19bd1/arm-mips-addressing-modes.png 163w,
/hows-that-again/static/84d2c264d56a99cd9c89bb235a399edc/d3bcb/arm-mips-addressing-modes.png 325w,
/hows-that-again/static/84d2c264d56a99cd9c89bb235a399edc/dbb61/arm-mips-addressing-modes.png 650w,
/hows-that-again/static/84d2c264d56a99cd9c89bb235a399edc/bbf8d/arm-mips-addressing-modes.png 654w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p><strong>Следующий блок относится только к ARMv7 и более ранним моделям. В ARMv8 от условно-выполняемых инструкций отказались</strong></p>
<hr>
<p>Еще одно важное отличие: для выполнения условий условных переходов в MIPS используется содержимое регистров. В ARM же используется 4 условных бита (<strong>condition codes</strong>), которые хранятся в <em>program status word</em>: negative, zero, carry, overflow. Эти биты могут быть изменены любой инструкцией, но выставлять их необязательно.</p>
<p>Например, CMP (Compare) вычитает один операнд из другого и выставляет условные биты соответственно результату вычитания. CMN (Compare negative) <em>складывает</em> операнды и так же выставляет условные биты соответственно результату. TST делает операндам логическое И и выставляет все условные биты кроме overflow, а TEQ делает им OR и так же выставляет все биты кроме overflow.</p>
<p>Необычная особенность ARM заключается в том, что каждая инструкция может быть выполнена или не выполнена в зависимости от состояния условных битов. Каждая инструкция начинается с 4-битового поля, которое определяет, будет ли инструкция превращена в nop. Засчет этого можно сэкономить время и место, когда нужно, например, перепрыгнуть через одну инструкцию - теперь не нужно вставлять дополнительное условие и инструкцию j для этого.</p>
<hr>
<p>Сравнение форматов инструкций: </p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/48d4b0c986436b5e980dca30f60cc6a2/a700e/arm-mips-instruction-formats.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 81.47590361445783%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsSAAALEgHS3X78AAACeElEQVQ4y22UaU+iQRCE3///T9wvum7iB3WjJoInyimigNwIyn0qaG0/vU7CHpN0BnqG7qrqGiJtrPV6rcVioVKxqNubG2UyGd3f3+vu7s73l5cX9V5fNRqNVC6XPZ/P5/2s2WhqOp0qokC/39dwONTq/V3L5VJZK3R9daWry0slEgmlkklls1kNBwN1Oh2NreDT05OfJ29vfa9Vq14n+vj48EKge3t703QyVTwW0/edHf08PFS/19N8PtdsNtOgP9BkMrHCQ0cDAxodHR3p29aWEtfXijYpf35+igYUgBY/Jsd6t6awgUEI7pGjGff5/kfB1Wrlh3nT5iwed7o3FtDPpNPqdrumYU8Do96o11W3qBh1otls+rlriNCL+cLRgKRoQ0HsXC6nQqGgUqnkP4Lmq92lYM+kaLfbalmhVqvlnzmLAk0WNMbjsWu4s72tw4MDvxQojYYjNRoNpQ1twSabTqWVtIE9PDz4xGu12u+CIcICNWgoRLO1ScHOnTA8mLBvBrn/agiCk+NjxU5PPaBdq9bcKqAomwTkKpWKR9Uswxm0ozAtFijo0jWvdZ6fXXTCNfsaBuZmx3O4gEAmwo0NKuAGa5BEwx+7u64hBeazuecuLy58YOj1+PjoPoQNGuIMzB397UE0onvbJsdAaEKAIPgwoOF1EaBkaMj1j4bQRw865+wVgAL9KN7tdN1rzyYH0wZ9CPL9nj096NIlTBE0CI6ReaepVMpN27QCHvYZXas2DM9/RWgQhUGwwls+PzvX3t6eDvb3/a3yz4K5Q5BDN/RkR09A1PHhJmX/ozDaUII2SHgRiM2PyBVt90JWgBcSJs49tPwFTGumq8H0V00AAAAASUVORK5CYII='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="ARM vs MIPS instruction formats"
        title="ARM vs MIPS instruction formats"
        src="/hows-that-again/static/48d4b0c986436b5e980dca30f60cc6a2/dbb61/arm-mips-instruction-formats.png"
        srcset="/hows-that-again/static/48d4b0c986436b5e980dca30f60cc6a2/19bd1/arm-mips-instruction-formats.png 163w,
/hows-that-again/static/48d4b0c986436b5e980dca30f60cc6a2/d3bcb/arm-mips-instruction-formats.png 325w,
/hows-that-again/static/48d4b0c986436b5e980dca30f60cc6a2/dbb61/arm-mips-instruction-formats.png 650w,
/hows-that-again/static/48d4b0c986436b5e980dca30f60cc6a2/a700e/arm-mips-instruction-formats.png 664w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Еще в ARM есть сохранение и загрузка групп регистров. </p>
<h1>Архитектура x86</h1>
<p>Архитектура поддерживает следующие комбинации оперендов в инструкциях:</p>
<ul>
<li>регистр-регистр</li>
<li>регистр-константа</li>
<li>регистр-память</li>
<li>память-регистр</li>
<li>память-константа</li>
</ul>
<p>Не поддерживается только комбинация память-память. В это время, в ARM и MIPS большинством инструкций не поддерживается адрес памяти в качестве одного из операндов.</p>
<p>Все регистры, начинающиеся с Е, являются расширениями 16-битных регистров до 32-битных. Большинство инструкций имеют только 2 операнда, это значит что один из операндов часто является и входным и выходным.</p>
<p>Среди используемых методов адресации есть:</p>
<ul>
<li><em>based mode with 8- or 32-bit displacement</em> - адрес равен содержимое регистра плюс сдвиг на 8 или 32 бита</li>
<li><em>base plus scaled index</em> - адрес равен содержимому регистра плюс 2^scale * index, где scale = 0, 1, 2 или 3. Этот режим нужен, чтобы избежать умножения на 4 при адресации по байтам. scale = 1 используется для 16-битных слов, 2 для 32-битных, 3 - для 64-битных. 0 означает, что не скейлим.</li>
<li><em>base plus scaled index with 8- or 32-bit displacement</em> - комбинация первых двух режимов</li>
</ul>
<p>Каждая инструкция в 80386 может занимать от 1 до 15 байт. Обычно опкоды включают указание, используется ли 8-битный или 16-битный операнд. Некоторые опкоды включают в себя указание метода адресации и регистра. Другие инструкции включают дополнительный байт опкода, называемый <strong>постбайт</strong> содержащий метод адресации и регистр. Режим адресации <em>base plus scaled index</em> использует еще и второй постбайт.</p>
<h1>Архитектура ARMv8 (64-bit)</h1>
<p>Первая архитектура ARM, поддерживающая 64-битное адресное пространство.</p>
<p>По сравнению с ARMv7 отброшены почти все необычные возможности, которых не было в MIPS:</p>
<ul>
<li>нет условного выполнения инструкций</li>
<li>под константы выделено простое 12-битное поле, а не функция, производящая константу, как было в v7</li>
<li>нет загрузки и сохранения групп регистров</li>
<li>PC больше не регистр</li>
</ul>
<p>Добавлены новые возможности, которые наоборот оказались полезными в MIPS:</p>
<ul>
<li>добавлены регистры общего назначения, теперь их тоже 32. Один из регистров привязан к константе 0</li>
<li>режимы адресации работают для всех размеров слов</li>
<li>добавлена инструкция деления</li>
<li>добавлены эквиваленты команд BEQ и BNE</li>
</ul>
<p>В целом, главное сходство между ARMv7 и ARMv8 это имя.</p>
<h1>Арифметика в компьютерах</h1>
<h2>Сложение и вычитание</h2>
<p>При вычитании мы можем либо вычитать, либо складывать с отрицательным числом, полученным по методу <em>two's complement</em>. При переполнении в 32-й бит знака попадает перенос из сложения битов на 31-й позиции и знак меняется. Если складывать A и B, а N - количество доступных бит для представления числа (включая знакомый), то результат сложения при переполнении будет равен <code class="language-text">A + B - 2^N</code>.</p>
<p>Пример: </p>
<p>допустим, у нас есть только 4 бита и мы складываем 5 и 5:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">  0101
+ 0101
  ----
  1010 == -6

  N = 4
  Результат равен 5 + 5 - 2^4 = -6</code></pre></div>
<p>Для <code class="language-text">unsigned</code> операций MIPS НЕ выбрасывает исключения (прерывания) при переполнении, потому что чаще всего беззнаковые операции выполняются для адресной арифметики и там переполнение может быть не важно. Для <code class="language-text">signed</code> операций исключения выбрасываются.</p>
<p>При исключении/прерывании адрес инструкции записывается в регистр и происходит переход на инструкцию обработчика этого прерывания. Адрес инструкции сохраняется, чтобы после обработки исключения программа могла продолжить выполнение. В MIPS есть регистр EPC (exception program counter), в который записывается адрес этой инструкции. Инструкция <em>mfc0</em> используется для загрузки этого значения из EPC в регистр общего нзаначения, после чего можно сделать джамп на соответствующую инструкцию. Причем по соглашению значение EPC пишется в специальные регистры $k0 или $k1, так как если писать в другой регистр общего назначения, то по возвращению в функцию, из которой было выброшено исключение, никто не будет восстанавливать значение этого регистра, и оно будет потеряно.</p>
<h2>Умножение</h2>
<p>Рассмотри первую версию множителя.</p>
<p>В качестве примера умножим 8 на 9 столбиком:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">      1 0 0 0
    X 1 0 0 1
    ---------
      1 0 0 1
    0 0 0 0
  0 0 0 0
1 0 0 1
-------------
1 0 0 1 0 0 0</code></pre></div>
<p>Мы видим, что первый операнд (множимое) на каждом i-м шаге сдвигается на одну позицию влево и в зависимости от значения i-го бита множителя либо идет в сумму, либо нет. То есть на каждом шаге:</p>
<ol>
<li>если младший бит множителя = 1, то множимое суммируется с текущим результатов</li>
<li>множимое сдвигается на 1 позицию влево</li>
<li>множитель сдвигается на 1 позицию вправо</li>
</ol>
<p>Эти 3 шага повторяются 32 раза - по количеству бит в операндах. Если бы каждый шаг занимал один такт, то любое умножение занимало бы 96 тактов. Однако операция может быть ускорена засчет распараллеливания - операции сдвига и сложения выполняются одновременно, засчет этого мы получаем 34 такта.</p>
<p>Этот алгоритм может быть реализован в виде следующей схемы:</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 591px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/48f0f1083ad066c8d468d19034217370/a615a/multiplication-hardware.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 53.299492385786806%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABdUlEQVQoz5WT63KCQAxGef/3syozgoiAotxF8Uaak3YZdfqnmUHZ9cvJl+zqjeMoPMQwDFLXtXRdJ7vdTsIgkLIobN21nVyvV9M5/V/hvS6appHb7SbP59OAgQKL4/EX2Nre/X6foK9m3J7HB5V5yrKUpm6k1WSeLMtkG28lDEODR+vIHH+6fAV7OEqTRE6nkyasrW0cImCd5/nkiuj7/g306dgDgBtaSgBre7ROm8DSNJXL5WKJFO+1MO9VVZlr3/dNPzmk1bqqJ9FRZxZFkcEQxnFsroC6UbBu9TcObblY6ndo+lE7MyAgAiiQZLu1vfP5/HaCdMOcH4+HjShNUvmazVSfTF0ZsNBBN3pd2OTaLOZzORwOJmAPdwSQTEfgHDMmdG7muLdDyfe5JTsXFMAdQkZA2+gYBSe+2WzEX/qWBwQ4RShoDkly7gDTQrBa/VwbbX+/31shigBAy7u7boMCgdopM7edJjIbwFxkICS6f8Z/4huw307qz6lMjwAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Multiplication hardware"
        title="Multiplication hardware"
        src="/hows-that-again/static/48f0f1083ad066c8d468d19034217370/a615a/multiplication-hardware.png"
        srcset="/hows-that-again/static/48f0f1083ad066c8d468d19034217370/19bd1/multiplication-hardware.png 163w,
/hows-that-again/static/48f0f1083ad066c8d468d19034217370/d3bcb/multiplication-hardware.png 325w,
/hows-that-again/static/48f0f1083ad066c8d468d19034217370/a615a/multiplication-hardware.png 591w"
        sizes="(max-width: 591px) 100vw, 591px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Обычно эту схему усложняют за счет того, что в блоке Product мы можем хранить одновременно множитель (в правой половине) и результат (в левой половине). ЭТо возможно благодаря тому, что на каждом шаге у нас множитель уменьшается на 1 знак, а результат - увеличивается.</p>
<p>Если нам нужно умножить знаковые числа, то мы сначала запоминаем их знаки, обрубаем их, перемножаем два 31-битных числа, а затем выставляем отрицательный знак если оригинальные знаки различались.</p>
<p>В новых множителях схема гораздо сложнее. К каждому биту множителя подсоединяется свой 32-битный сумматор, которому на вход подается выход предыдущего сумматора и результат AND над множимым и соответствующим битом множителя. Причем все сумматору соединяются не последовательно, а в виде бинарного дерева, чтобы уменьшить количество операций. В результате мы ждем не 32 последовательных сложения, а только 5.</p>
<p><img src="fast-multiplication-hardware.png" alt="Fast multiplication hardware"></p>
<p>(рисунок немного неверный, так как на каждом следующем слое должно быть больше бит для хранения результата сложения. На втором слое - 34, на третьем - 36 и т.д.)</p>
<p>В MIPS есть специальные регистры для хранения результата умножения 32-битных регистров, называемые Hi и Lo, и инструкции mfhi/mflo, означающие move from hi, move from lo.</p>
<p>Например, при умножении $s2 на $s3:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">mult $s2, $s3 # верхний бит результата окажется в Hi, нижний бит - в Lo
mfhi $s0 	  # перемещаем верхний бит в s0
mflo $s1	  # перемещаем нижний бит в s1</code></pre></div>
<h2>Деление</h2>
<p>Пример деления столбиком, делим 1001010  (делимое) на 1000 (делитель):</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"> 1001010 | 1000 &lt;- делитель
-1000 	 |------
-----	 | 1001	&lt;- результат
	1
	10
	101
	1010
   -1000
   -----
   	  10   &lt;- остаток</code></pre></div>
<ol>
<li>Берем максимум знаков слева делимого, чтобы было больше делителя, в нашем случае это 4 знака и 1001. </li>
<li>Делим полученное число на делитель, то есть 1001/1000</li>
<li>Результат деления пишем в результат - 1</li>
<li>Остаток от деления (1) пишем под вычитанием, приписываем один знак от делимого - 0.</li>
<li>Если полученное число (10) меньше делителя, то в результат пишем 0 и приписываем еще один знак делимого. Так до тех пор, пока не сможем разделить полученное число на делитель. В нашем случае мы не смогли разделить 10 и 101 на 1000, поэтому в результат попало два нуля, а вот 1010 уже смогли, поэтому после двух нулей стоит 1.</li>
</ol>
<p>Итого, алгоритмически деление может быть осуществлено следующим образом:</p>
<ol>
<li>32-битный делитель представляем как 64-битное число, у которого делитель записан в левой половине, а правая заполнена нулями</li>
<li>В остаток вначале операции записывается делимое</li>
<li>
<p>Затем в цикле повторяем 33 раза:</p>
<ol>
<li>Вычитаем делитель из остатка, пишем результат в остаток</li>
<li>Если остаток >= 0, сдвигаем частное влево на 1 позицию, выставляем правый бит в 1. Иначе - обратно прибавляем делитель к остатку, после чего сдвигаем частное влево на 1 позицию, выставляем правый бит в 0</li>
<li>делитель сдвигаем вправо на 1 позицию</li>
</ol>
</li>
</ol>
<p>Таким образом, в шагах 3.1-3.2 мы определяем, является ли текущий остаток большим, чем делитель и если да, то пишем в результат 1 и вычитаем делитель из остатка, а если нет, то пишем 0 и оставляем остаток нертронутым.</p>
<p>Такое деление называется <em><a href="https://en.wikipedia.org/wiki/Division_algorithm#Restoring_division">восстанавливающее (restoring)</a></em>. Есть еще <em><a href="https://en.wikipedia.org/wiki/Division_algorithm#Non-restoring_division">невосстанавливающее (nonrestoring)</a></em> - оно более быстрое. В нем на 2 шаге не происходит восстановления остатка, а вместо этого прибавляет делитель к сдвинутому остатку на следующем шаге, так как <code class="language-text">(r + d) * 2 - d = 2r + 2d - d = 2r + d</code>.</p>
<p>На картинке изображен пример деления 7 (00000111) на 2 (0010) этим алгоритмом:</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/d167f9259082337ce37e314e9f9a6794/bbf8d/division-example.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 57.645259938837924%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAACdklEQVQoz1WSzYvTUBTF+2cKA4K4cSOIuBhEcOlC/D9cCIIzzMKFji5GpI79mLZpkibvJXlNXl6T5rvTVPR481JGXBzeDe9y8jv3vsGLWYOX8wYPrxvc/7HDybDB00mD02mDe99KnHwv8WBY4fnNDq/tFk9GNR6Pd3hltnj0s8Ez6n1j73FK92dhi8EXpnAVbPF+wvB2aOLdyMFXL8WVyPBZlLgUBT7xFJeOxMXY0ncfpgxnIwvnMw8f7QjnkxUuFj5WSYkB8AfAb6RhAOUzZJFAJkMUSuI2S9EWW606z8ACgUNVQHIH7nKOhPpVVsBQBcI0x21dYbBvD9i3LTj3YBhLWJYNx2VIkhRJmiLdZtiSVLqF4XDkeQ4r3GDqx2ByAxFT7fhw1xHKigxbMtvv92TI4axW+uSMYy0EYimhlNKSpIXr0Y8S2NQ3Xxjgrgs3TjFep7CjBEVRYHAgw87U8zyYyyVWNpkyRlRbZFmmmwqiSjQhQ0Xf1jrGjRfBI8L1kZCtJaqq7glbHZmTma3NGCkIAkRRhDiOoUhSbYjQ7wmp745QJphqwk1PqA0pckdomaaO3dXdrPIs788j4cJ2NaEpYkx4CF8qBCrBtbuGE6qe8HA4oFNHZpkWHIc2SPKIWNIMy7JESlRRrGCwQNcWEc7mC53KFRHGpgOb+/8Iu6X4RGVblib0j4Sd2W6302e3dcvl/80wiBMISbRk6PoCdX0k/EViNI+lsdRz7BfD9Qy7hdwRcqHrJSWZ3Mx0KicIMTRo6yvWE3YEt6QuXuD7EPR4JRlV9KZKaujua6qzvICIYqpL+GmB1YYeeF5iu1FglEoEvu79C/HEbDzBQnEMAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Division example"
        title="Division example"
        src="/hows-that-again/static/d167f9259082337ce37e314e9f9a6794/dbb61/division-example.png"
        srcset="/hows-that-again/static/d167f9259082337ce37e314e9f9a6794/19bd1/division-example.png 163w,
/hows-that-again/static/d167f9259082337ce37e314e9f9a6794/d3bcb/division-example.png 325w,
/hows-that-again/static/d167f9259082337ce37e314e9f9a6794/dbb61/division-example.png 650w,
/hows-that-again/static/d167f9259082337ce37e314e9f9a6794/bbf8d/division-example.png 654w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>На следующей картинке изображена первая версия делителя:</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 540px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/39ac247a99f16a60eb7972d4f2158160/22492/division-hardware.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 59.074074074074076%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAABlklEQVQoz3WSh46DQAxE+f8PhDQplITeUkhCms/Pp0VcdEEyC7v27HjG3vv9Fp7H4yHjOMr9fpfL5SJlWcr5fJ72n8+nkOvy3fr5eLwAqatKTqeTgaRpKosgkLqube94PErbtlPRN7AJEBaHvpfX62Xfl2EwEJgmcSyxxma9lrZpLMeBzsPtebColF2R58bucDgYEAC+70uWZcaOM+J2u/3LzIF6JDQKuksS24ABEsRRJNfr9U8RuQ6wbVrTedBu5vp6sAEMZr22XRal6dbUjbEEdG4WgOTu93s930hRFHJSeaaWeZHcaVskRWEoubbfd52BAnLVsAu73gAb1XI4D7JaLs28QKVxHnhOZMwgEYdhxf/8MeMUlPYgQLuBH0ie5XYh+rLvIThA3BAqu+ViYcm4jGFOx0ELcDyJE5Pkc3TQ0gAxhFsJ3AacAnRDW2QgERlS/V6vVr9TodrBiovdrFrLGAFLZwosozCS3W5nenLBqLrBlHM6QFeKP+fQxqbS9igimLntdmtr13YGQiswcSug3+aQ+AF0CJvvm5RuswAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Division hardware"
        title="Division hardware"
        src="/hows-that-again/static/39ac247a99f16a60eb7972d4f2158160/22492/division-hardware.png"
        srcset="/hows-that-again/static/39ac247a99f16a60eb7972d4f2158160/19bd1/division-hardware.png 163w,
/hows-that-again/static/39ac247a99f16a60eb7972d4f2158160/d3bcb/division-hardware.png 325w,
/hows-that-again/static/39ac247a99f16a60eb7972d4f2158160/22492/division-hardware.png 540w"
        sizes="(max-width: 540px) 100vw, 540px"
        loading="lazy"
      />
  </a>
    </span></p>
<ul>
<li>Divisor - делитель</li>
<li>Quotient - частное</li>
<li>Remainder - остаток</li>
</ul>
<p>В новых делителях используется более сложная схема. Использовать тот же подход, что и в сложном делении мы не можем, так как на каждом шаге нужно знать результат сравнения делителя с остатком. Но есть техники, позволяющие производить более 1 знака частного за шаг. Техника <em>SRT division</em> пытается <strong>предугадать</strong> несколько бит частного, используя поиск по таблице по верхним битам делимого и остатка. В последующих шагах алгоритм может исправить предсказания, если они оказались неверными. Обычно считается по 4 бита частного за раз, используя 4 бита делимого и 6 бит остатка в качестве ключа поиска по таблице.</p>
<p>В MIPS для деления используются те же регистры Hi/Lo и операции mfhi/mflo, что и при умножении:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">div $s2, $s3  # остаток окажется в Hi, частное - в Lo
mfhi $s0 	  # перемещаем остаток в s0
mflo $s1	  # перемещаем частное в s1</code></pre></div>
<h2>Плавающая точка</h2>
<p><strong>Научная нотация записи</strong> чисел имеет один знак слева от запятой, например: <code class="language-text">1.2 * 10^9</code>. Есть еще <strong>нормализованная научная запись</strong>, в которой слева от запятой должен быть только один знак и он должен быть ненулевым. Например, <code class="language-text">0.1 * 10^-8</code> и <code class="language-text">10.0 * 10^-10</code> не являются нормализованными научными записями, а <code class="language-text">1.0 * 10^-9</code> - является.</p>
<p>Двоичные числа так же могут быть представлены в научной нотации: <code class="language-text">1.0 * 2^-1</code>. Степень двойки означает, на сколько знаков вправо нужно сдвинуть число в двоичной записи. В данном случае 0.5 будет представлено как 0.1 в двоичной записи.</p>
<p>Числа с плавающей запятой имеют форму <code class="language-text">1.xxxxxxxxx * 2^yyyy</code></p>
<p>В компьютере числа с плавающей точкой представлены в виде двух частей - мантиссы и экспоненты. Увеличение мантиссы увеличивает точность, увеличение экспоненты увеличивает представимый интервал. </p>
<p>Мантисса всегда имеет значение от 0 до 1 - это <code class="language-text">1.xxxxxxxxx</code>.</p>
<p>Экспонента - это <code class="language-text">yyyy</code>.</p>
<p>В MIPS числа с плавающей точкой представлены следующим образом:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">| знак (1 бит) | экспонента (8 бит) | мантисса (23 бита) |</code></pre></div>
<p>Значение = <code class="language-text">-1^S * M * 2^E</code>, где S - знак, M - мантисса, E - экспонента.</p>
<p>Переполнение возникает, когда не хватает знаков для экспоненты. Однако может быть еще и <em>опустошение / underflow</em>, когда нам нужно представить настолько маленькое число, что знаков в экспоненте не хватает. Тогда используются типы с удвоенной точностью, имеющие больше бит для экспоненты.</p>
<p>В MIPS число с удвоенной точностью занимает 64 бита, из них 11 - экспонента, а 52 - мантисса.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">| знак (1 бит) | экспонента (11 бит) | мантисса (52 бита) |</code></pre></div>
<p>Чтобы использовать больше бит, спецификация IEEE 754 предполагает, что 1 слева от запятой в нормализованном представлении числа всегда есть и поэтому она в мантиссе не указывается.</p>
<p>Тогда числа имеют значение: <code class="language-text">-1^S * (1 + M) * 2^E</code>, где мантисса - число от 0 до 1. При этом в мантиссе биты используются "слева-направо". То есть, если пронумеровать биты мантиссы слева направо как s1, s2, s3, то значение будет равно:</p>
<p><code class="language-text">-1^S * (1 + (s1 * 2^-1) + (s2 * 2^-2) + (s3 * 2^-3) + (s4 * 2^-4) + ...) * 2^E</code></p>
<p>Помимо этого, чтобы меньшие числа имели меньшее значение, было решено, что наименьшая экспонента (-127) должна иметь значение 0000..00, а наибольшая (128) - 1111..11. Поэтому для записи экспоненты применяется т.н. <code class="language-text">biased notation</code>, где к реальному значению экспоненты прибавляется некий сдвиг. В числах с одинарной точностью сдвиг равен -127. Таким образом, экспонента -1 становится равна <code class="language-text">-1 + 127 = 126 = 0111 1110</code>, а экспонента 1 становится <code class="language-text">1 + 127 = 128 = 1000 0000</code>.</p>
<p>В числах с двойной точностью сдвиг равен 1023.</p>
<p>Таким образом, значение, представленное числов с плавающей точкой, равно:</p>
<p><code class="language-text">-1^S * (1 + M) * 2^(E - bias)</code></p>
<p>или, если писать полностью:</p>
<p><code class="language-text">-1^S * (1 + (s1 * 2^-1) + (s2 * 2^-2) + (s3 * 2^-3) + (s4 * 2^-4) + ...) * 2^(E - bias)</code>, где s1,s2,s3 - биты мантиссы, перечисленные слева направо.</p>
<p>Пример:</p>
<p>преобразуем число в десятичную запись:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">110000001010000000...

знак = 1
мантисса = 10000001
экспонента = 010000000...

Для начала определим знак, значение 1 - значит отрицательный

Мантисса представлена как 129, нужно отнять 127, получаем 2.

В экспоненте мы видим 01000..., что значит 0*2^-1 + 1*2^-2 + 0*2^-3 + ... = 0.25

Итого получаем: -1 * (1 + 0.25) * 2^2 = -5.0</code></pre></div>
<p>Обратный пример:</p>
<p>преобразуем -0.75 в число с плавающей точкой:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">-0.75 = -3 * 2^-2 = -1,5 * 2^-1

Знак = 1
Мантисса = 1.5, для представления отбрасываем 1, остается 0.5 = 1 * 2^-1 = 100000...0 в двоичном представлении
Экспонента = -1, для представления нужно прибавить 127, получаем 126 = 0111 1110 в двоичном представлении

Итого, получаем:

1 0111 1110 1000000000...0</code></pre></div>
<p>Хороший источник по чтению и записи чисел с плавающей точкой: <a href="http://cstl-csm.semo.edu/xzhang/Class%20Folder/CS280/Workbook_HTML/FLOATING_tut.htm">http://cstl-csm.semo.edu/xzhang/Class%20Folder/CS280/Workbook_HTML/FLOATING_tut.htm</a></p>
<p>Еще одна инструкция по переводу из бинарного вида в десятичную дробь: <a href="http://sandbox.mc.edu/~bennet/cs110/flt/ftod.html">http://sandbox.mc.edu/~bennet/cs110/flt/ftod.html</a></p>
<h3>Инструкции MIPS по работе с плавающей точкой</h3>
<ul>
<li>add.s, add.d - сложение single- и double-precision чисел</li>
<li>sub.s, sub.d</li>
<li>mul.s, mul.d</li>
<li>div.s, div.d</li>
<li>c.x.s, c.x.d - сравнение чисел, где x может быть eq, neq, lt, le, gt, ge</li>
<li>bclt, bclf - команды перехода</li>
<li>lwcl, swcl - загрузить/сохранить регистр с плавающей точкой</li>
</ul>
<p>Для операция с плавающей точкой выделены специальные регистры - $f0, $f1, $f2, ...</p>
<h2>Subword parallelism</h2>
<p>Если мы оперируем типами, размер которых меньше машинного слова, то в одном регистре может быть несколько значений такого типа. Инструкции, поддерживающие <em>subword parallelism</em>, таким образом, параллельно обрабатывают несколько таких значений, лежащих в одном регистре.</p>
<p>В процессоры ARM такие операции были добавлены расширением ARM NEON.</p>
<h2>Streaming SIMD Extension (SSE)</h2>
<p>SSE и MMX (MultiMedia eXtension) - это расширения к x86, реализующие <strong>subword parallelism</strong>.</p>
<h1>Процессор</h1>
<p>Далее будет представлен вариант реализации процессора, который поддерживает следующие команды MIPS:</p>
<ul>
<li>инструкции работы с памятью: lw, sw</li>
<li>арифметико-логические инструкции: add, sub, and, or, slt</li>
<li>инструкции ветвления: beq, j</li>
</ul>
<p>Не поддерживаются: сдвиг, умножение, деление, операции с плавающей точкой и т.д.</p>
<p>В общем виде каждая из инструкций может быть декомпозирована на следующие шаги:</p>
<ol>
<li>Читаем из памяти инструкцию по адресу, содержащемуся в регистре PC</li>
<li>Парсим инструкцию</li>
<li>Читаем 1 или 2 регистра в зависимости от инструкции</li>
</ol>
<p>Дальнейшие действия зависят от инструкции, но сильно похожи. Для всех инструкций, кроме <code class="language-text">j</code>, нужно обратиться к ALU, подав на вход либо значение 2 регистров, либо значение 1 регистра и константу. </p>
<p>Затем, если у нас инструкция работы с памятью, то нужно обратиться к памяти (для записи или чтения) по полученному из ALU адресу. Если арифметико-логическая инструкция, то нужно результат работы ALU записать в какой-то регистр. А если инструкция ветвления, то нужно изменить значение регистра PC в зависимости от результата сравнения. Если же это не инструкция ветвления, то значение PC должно быть увеличено на 4.</p>
<p>Таким образом, получаем следующую высоко-уровневую схему реализации MIPS:</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/e7122415dbdd4ccd91e1a77ca6b1d16a/9fa2c/mips-implementation1.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 55.227882037533504%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABbElEQVQoz4WT627CMAyF8/4vN/4xMYlVQK/0Ru+lgOfPI9OY2GbJxEkcn+Nj6k6nk/R9L33X2ToMg3T3uCgKi3HylmUR7Ha7yW/mBn3ojcRpmqRrW4ursrRCnOHn8/n/gv2PgnjTNFJVlbGkSF3Vtr9cLg95z9wKXq/Xr3bHcZQoiqRUdrCq61qSOP6T1QPDUYvwcJ5nWZQNjNhTuNF2YduqBDixB/XajsP4eXbX3vFDIgwRnYK0ho5JkkgUhjLcWwcIECukRRkkb4yMrsji0CdLU0P5LjiIpU65LMqHCdu/AnYKiByAcAeJLMvE8Wi73UqsuuV5bkwBQMe3zUbSJJUgCOR1vbYzmAIeKnM6ILfVDjH2DrokkLx6WUnwHtgliOHhYJ5qIkyww35vEnHvWa8VLNXCDNIxYS7QBcq04fXKj7n60VaYc7bb7UyrWWPa98NC00ndPRs9IGhJEuz91+O/GD8EYliRD2Mm/gG/aFOaQzDUIgAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="MIPS implementation 1"
        title="MIPS implementation 1"
        src="/hows-that-again/static/e7122415dbdd4ccd91e1a77ca6b1d16a/dbb61/mips-implementation1.png"
        srcset="/hows-that-again/static/e7122415dbdd4ccd91e1a77ca6b1d16a/19bd1/mips-implementation1.png 163w,
/hows-that-again/static/e7122415dbdd4ccd91e1a77ca6b1d16a/d3bcb/mips-implementation1.png 325w,
/hows-that-again/static/e7122415dbdd4ccd91e1a77ca6b1d16a/dbb61/mips-implementation1.png 650w,
/hows-that-again/static/e7122415dbdd4ccd91e1a77ca6b1d16a/9fa2c/mips-implementation1.png 746w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>На этой схеме для понятности опущены мультиплексоры и контроллеры, занимающиеся выбором линий в зависимости от инструкций. Полная схема выглядит так:</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/771daf35826589796876b9cc3302c490/6bcd1/mips-implementation2.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 74.18630751964085%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACPklEQVQ4y4VUiZKiMBT0//9wpxTHAQTlhlwQQk+/oFOus1WbqjYhR79+l4dt2/COOQCWcI9ZYNbtB5rITUDJA/uyL+sD3sayLKiaBto6wkIbC8P1SkNPyON+2eDD/u2JQChPQmsMHB9aYp5nKKVQ3e9xb9sCthDiWeC8jy3+urB78zqiQq11vLyuayQchiGSDn0POZM9Q6OB5zIkHAJRKErdIzRiYIwKaf11OOfQd10kE+KG7steJJsX1P1IVwOGeYVZKMI/sAY0MwnFNe99VCHx69o2koihnirHcdwdpXvOGjQMx2w0em32MDmBg6WA1q27QiETNaJEEBNTVehEqdKRVHAbDdJeI+smFFzbbXff02CjHUrjcRAiueys+3FbYiqJKYsiqn/uDSTvJqpTBvXEZC4evfM4Dw7nZsRZkVBUpGkaFYm6ieQt3T6eEpRliSzLkGcppBqsFU8mxrjFR1rgXtWoOyZv9jG2yURCIRGFxfWK0/EY11JfSXrFNc9Q1w0mqjd8lJP8RiOWbyrlYjJuxRXpOaFqjdPEGD67Q5ReLpeYXclidq9R5DmausZNz0joUpKcUbd9jLkkSKrB0m3tFox2xqcOvzsFUvkknHjJUpkSdSSYxBCT5Vh7rHbWLStjGtEZh6/RoSPhRQjf+1iGvJE2YrtCsZ6vTOdtBirWWc20Si8rYuIdtfCb9ai5TtRD4V+Ej1ku1GyBO/GpV/wZV3wwRsdfCJHoSMtf/3L5tT8lOUvY/wSeBsN/8A0udI2qn1RYKgAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="MIPS implementation 2"
        title="MIPS implementation 2"
        src="/hows-that-again/static/771daf35826589796876b9cc3302c490/dbb61/mips-implementation2.png"
        srcset="/hows-that-again/static/771daf35826589796876b9cc3302c490/19bd1/mips-implementation2.png 163w,
/hows-that-again/static/771daf35826589796876b9cc3302c490/d3bcb/mips-implementation2.png 325w,
/hows-that-again/static/771daf35826589796876b9cc3302c490/dbb61/mips-implementation2.png 650w,
/hows-that-again/static/771daf35826589796876b9cc3302c490/6bcd1/mips-implementation2.png 891w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Здесь верхний мультиплексор определяет, нужно ли брать PC = PC + 4 или PC = адрес джампа. Ему на вход поступает AND результата сравнения от ALU и бита, определяющего, является ли инструкция инструкцией ветвления. Второй сверху мультиплексор выбирает, в зависимости от инструкции, писать в регистр результат работы ALU или значение, полученное из памяти. Ну и третий - в зависимости от инструкции определяет, подавать вторым операндом в ALU значение регистра, или константу сдвига, полученную из инструкции.</p>
<p>Теперь разберем итеративный процесс построения потока данных (<strong>datapath</strong>).</p>
<p>Для начала нам понадобится блок, который читает инструкции и инкрементирует PC:</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 373px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/0d959ba9046c42f9819d8351546ace90/f9f05/datapath-pc.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 78.28418230563003%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsSAAALEgHS3X78AAABu0lEQVQ4y5WUa2+CUAyG+f8/bDPz23RxUadDIt4VwQuo2PWpHgeiydakObf27dsLePv9XlarlayjtURR9C/FJ15f/Na6LpdL8QDb7XZyPB7lcDjI6XSSPM9tfaa8Z1km8/lcNpuNnNQ313vAPaIA5gQDY6yPD1XZJEki4XBodmmaShzH5ku2HnRh5mS5WNgDUY8P1GVBYIAR7jkDXgHkjMNfBJBwGEq/35fZbCbT6fQCWEw5Wv2ez+dzRZ2wBxDb9NpYiHjUhQfqQHPcwzNJ1M6YheGtdqw0CfEwgCURt9utOMaAo9SpqKQFAPu5pmldvhIAw4uU0Xg0MgPYDrV74/FYRno3U2fAMbRxuToCyF2WZqUSGEM643/70mm3DSwIAvF9Xz5bLanVahIMglI9b4D5uXJvDNmQmq2asjuTSnE0St29uys2y3OFBoSU+QoAKRrx1u/1bEQGyp6G0DzqWWR3A6Q+NIT0LcAdIPskTixVFDD3eVYAi45OYNrtdOWj2ZTGe0OajUZp+B8FLKV8P7iwZfJfX16l/laXr263PIsFwIcp30eyGdM/yUKVlVot9Bs31fNkMql02MkPLPnatoQAcBIAAAAASUVORK5CYII='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Datapath PC portion"
        title="Datapath PC portion"
        src="/hows-that-again/static/0d959ba9046c42f9819d8351546ace90/f9f05/datapath-pc.png"
        srcset="/hows-that-again/static/0d959ba9046c42f9819d8351546ace90/19bd1/datapath-pc.png 163w,
/hows-that-again/static/0d959ba9046c42f9819d8351546ace90/d3bcb/datapath-pc.png 325w,
/hows-that-again/static/0d959ba9046c42f9819d8351546ace90/f9f05/datapath-pc.png 373w"
        sizes="(max-width: 373px) 100vw, 373px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Дальше - блок бранчинга:</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 632px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/463d74a56e02fc1b5a38593837f88ff9/f84ea/datapath-branching.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 71.99367088607596%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAABnklEQVQ4y31Ui26DMAzk/3+vk1omQaEtHZUolEcICQ/P542IImikCEjs8905waPFmKbJPY0xMruuo05rebZtS9ZaUkrJ3jiOtM73tgAR2DQNla8XFUVBzyyjPM8p4yfW67oWwLqqpJDmgn3fS663ZDXPvYHEYRgE8PF4SBG8+74v7w5wC2RZAIzLsqSvw4GiKBKQwbIlukXkvuSKJVziWBKWUuAZJuTDR90ZyhRLZpW5GckME9D+ABtOBkhyu1GapvTN9OHNPJIkEVZgCHAUKnk/bQwV2lJuWcGClAc5QFaNEtAwCKn6T4ZfYPni5syA6DIK2k5TzWuQjXh4iHgnGcDYiKNYAMIgEOPnZuhWOxYAz7IngxRixc/9TtH5LFa5LgMdgQACwDyul6usoQjkAgBxYGr4e93QN0CYHoYhGUjrB1nDeQMAGgYVkI017G2dCAcohjOzUrV0LjtKlaWKJYAR2IDd3tFaXgoHaLkqbgG+re2FLVjJcWHDsbd1Adbn+E0ykqUBPAFyPB7JP52cZ0sme8P7FDT/HNZ3/dP4BV2PRCQX4kUvAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Datapath branching portion"
        title="Datapath branching portion"
        src="/hows-that-again/static/463d74a56e02fc1b5a38593837f88ff9/f84ea/datapath-branching.png"
        srcset="/hows-that-again/static/463d74a56e02fc1b5a38593837f88ff9/19bd1/datapath-branching.png 163w,
/hows-that-again/static/463d74a56e02fc1b5a38593837f88ff9/d3bcb/datapath-branching.png 325w,
/hows-that-again/static/463d74a56e02fc1b5a38593837f88ff9/f84ea/datapath-branching.png 632w"
        sizes="(max-width: 632px) 100vw, 632px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Здесь синим обозначены управляющие сигналы</p>
<ul>
<li><strong>RegWrite</strong> - сигнал блока регистров, который подается, когда данные, поданные на вход <em>Write data</em> нужно записать в регистр <em>Write register</em>. Для чтения такого управляющего сигнала нет, поэтому значения регистров <em>Read register 1</em> и <em>Read register 2</em> <strong>всегда</strong> подаются на исходящие пины <em>Read data 1</em> и <em>Read data 2</em>.</li>
<li><strong>ALU operation</strong> - 4-битовый сигнал, определяющий операцию, которую должен выполнить АЛУ. В данном случае это будет операция сравнения. Управляющий сигнал здесь нужен потому что этот АЛУ будет использован для разных операций в разных инструкциях. А вот для сумматора на этой схеме используется другой АЛУ, у которого всегда будет проводиться операция сложения, поэтому ему управляющий сигнал не нужен. Дублирование АЛУ обусловлено тем, что в конце концов наш процессор должен выполнять инструкцию за один такт, а значит ни один элемент не может быть использован больше 1 раза.</li>
</ul>
<p>Блок <em>Sign-extend</em> нужен, чтобы преобразовать знаковый 16-битный сдвиг в знаковый 32-битный, который можно подать на сумматор.</p>
<p>Далее - блок выполнения инструкций работы с памятью и инструкций R-типа:</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/d8f4f198e08050058d98942bf5bd393a/9dbfb/datapath-memory-r-type.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 48.86685552407932%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABlklEQVQoz5VSa2+DMAzs//9924dpGh2FAuX9SEISAjdfUKt9mrRIBidOzuezL8dxYF1XZLcb2raFtRbGGCzLgufa9wO9DRg24GEP+OM8D/Lfon8eCBQu+77Hx9fkirquY6DvupjAOwcryaZpwrg6jEpDuw3Oe1jn0WiHTHnMksjtJ+glTVOURYmiKEC/aZrIeJIk+WTQrx5aKUnSoioLdG0T9wSdJVHTD8gFtLX7CbhKeWSU5zmyLMM4jvKwRPKVoBtGfKc3jMMAJexyiRf3e0yqtcYg5634ZZ7BqFOiCzVkIJcS3WpeulHHScBLYc4k27aBdwnEP5f3W9yzsk5IRUBqOAlgcq+QtDMmY+MlWv2oMc9zlIDGhlFnyuPE//z4ECJp9Bl/AZJBkI2Wls3aSHkqXiIo49FCiMz6vsf39YpGJqLqBtyqBk7YE/B4lky6Rh4rYXMXLd/f3lBV1Wt0niX+9kPYZZQ2VGuAlflhLyJDfogeQogHTkaFzLx08T/L/AZUwoRaEYis2CSesfS/bFmedr7n+gHjAAPrxGQeUQAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Datapath for memory instructions and R-type instructions"
        title="Datapath for memory instructions and R-type instructions"
        src="/hows-that-again/static/d8f4f198e08050058d98942bf5bd393a/dbb61/datapath-memory-r-type.png"
        srcset="/hows-that-again/static/d8f4f198e08050058d98942bf5bd393a/19bd1/datapath-memory-r-type.png 163w,
/hows-that-again/static/d8f4f198e08050058d98942bf5bd393a/d3bcb/datapath-memory-r-type.png 325w,
/hows-that-again/static/d8f4f198e08050058d98942bf5bd393a/dbb61/datapath-memory-r-type.png 650w,
/hows-that-again/static/d8f4f198e08050058d98942bf5bd393a/9dbfb/datapath-memory-r-type.png 706w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Управляющие сигналы:</p>
<ul>
<li><strong>ALUSrc</strong> - определяем, подавать ли вторым операндом в АЛУ значение регистра (для арифметико-логических операций) или константу сдвига (для операций памяти)</li>
<li><strong>MemWrite, MemRead</strong> - если сигналы активированы, то происходит запись либо чтение в память. В отличие от блока регистров, здесь чтение должно происходить по сигналу, так как попытка чтения из невалидного адреса может привести к проблемам</li>
<li><strong>MemToReg</strong> - определяет, что нужно писать в регистр - результат работы АЛУ, или значение, прочитанное из памяти</li>
</ul>
<p>На схедующей схеме эти 3 блока объединены в общую схему процессора. Этот процессор может выполнять основные инструкции (чтение/запись слова, сложение/вычитание/сравнение и условные переходы) за один такт. Джампы пока не поддерживаются.</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/7b9bb95bf075dbe5a9c60d19c35ba267/840a7/datapath-combined.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 67.32223903177005%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAAB6UlEQVQ4y21T23ajMAzk//9u+9a0SUMukJiLbTD3hKlGCVm6W50zx2Ds0Wgkoq7rME0TuHrv0bYt5vmO+/0vmqZRhBBQ1zWGvkfoBqS5RSV3GPM8KyISkIwXedhcjb6vYa3VlaS2LPVcK8+n41He7U9CHhyGAb1kdc5hHEf8FjxHolIIj0JkjNEEt9vtRciIGimD+DeomFbwAhF/fWHz/q5neyGf5fsj5p8KizzH5XLB+XTS7FSbSXaWw2eqKPIMphnguhFlO6CQIvJhxnSfMQr6+/wijlhmkiSKxfzD4YDt51aVOedxFnIXWpS+krWBq2qxSGyShCb0SOsepSSpJ1FImbzIblFpHMeK/T7GbrdDKomoNhfzvRDlmdHSk/NZPa280+dT7uClgmjxLE1SvP15Q5qmSnA+xLrPJsX7PT42G1yvV20Oq9KmyIRQDIl3n5+oK/9QSLAJXGn4QQg/EoOqn7QxRVGo+lAHLHN7EeWBVYkAfiuKUmc4Wtr9Gg/ZtKLADTdkrtKuctbapxoqZrO2pwQ7U8IIUZ5lOvTcj9YtX+aNisa+QyrebKRUqqCqdRRVwNUHeGkSh5wJ+Qe9PFwIeZGZFv8yyb4e3nXydfAe7fqPkF4663Qm7RPlE/aXvce+RS7zzOq+AYfV6oQkKfh1AAAAAElFTkSuQmCC'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Datapath combined"
        title="Datapath combined"
        src="/hows-that-again/static/7b9bb95bf075dbe5a9c60d19c35ba267/dbb61/datapath-combined.png"
        srcset="/hows-that-again/static/7b9bb95bf075dbe5a9c60d19c35ba267/19bd1/datapath-combined.png 163w,
/hows-that-again/static/7b9bb95bf075dbe5a9c60d19c35ba267/d3bcb/datapath-combined.png 325w,
/hows-that-again/static/7b9bb95bf075dbe5a9c60d19c35ba267/dbb61/datapath-combined.png 650w,
/hows-that-again/static/7b9bb95bf075dbe5a9c60d19c35ba267/840a7/datapath-combined.png 661w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Здесь добавлен один мультиплексор, управляемый сигналом:</p>
<ul>
<li><strong>PCSrc</strong> - определяет, использовать ли для PC следующую инструкцию или перепрыгивать на адрес, указанный в инструкции условного перехода</li>
</ul>
<p>Итак, у нас готов <strong>datapath</strong>, теперь попробуем реализовать его внутренние элементы.</p>
<p>Наша реализация будет поддерживать следующие команды: lw, sw, beq, add, sub, and, or, slt.</p>
<p>Вспомним, какие у нас используются форматы инструкций:</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 617px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/211a92ffee7974633687bc226729170a/0794e/instruction-formats.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 37.27714748784441%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABC0lEQVQozz1Ri46EIAzk/79wL2a9rHt7gi9UUPCBvU5zSDJS2+kwFDVPE02M8zzJOUdaa+r7XlDXNQ3DQI0xZBiWY9TbtqW+66h8PsloQx3H1etF4ziSyiIdk7Ztk6J3Xg4A4bouijHKoVjg4x9rnmdKKQm895JTaEQT1rquLOakiKbjOCiGcMeo7/suCJxflkV2GEEOPAX7P++3nAahoij4GlocVVUlTeD8fj4iCEAE3K/Hg0ZrRSjXFOzmRN4hggbEuAEAh3nPMW6WznTnoKXgJM8CAnaw8u8YeBgIW3YBYH7icA3C+S5LycOxjIu5Cp+maW7rLccgxxBFEPOBEF77+J9fBup5vjn3B2a9GyFSZ46sAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Instruction formats"
        title="Instruction formats"
        src="/hows-that-again/static/211a92ffee7974633687bc226729170a/0794e/instruction-formats.png"
        srcset="/hows-that-again/static/211a92ffee7974633687bc226729170a/19bd1/instruction-formats.png 163w,
/hows-that-again/static/211a92ffee7974633687bc226729170a/d3bcb/instruction-formats.png 325w,
/hows-that-again/static/211a92ffee7974633687bc226729170a/0794e/instruction-formats.png 617w"
        sizes="(max-width: 617px) 100vw, 617px"
        loading="lazy"
      />
  </a>
    </span></p>
<p><strong>а</strong>. арифметические инструкции, <code class="language-text">rs</code> и <code class="language-text">rt</code> - источники, <code class="language-text">rd</code> - регистр, куда кладем результат. <code class="language-text">shamt</code> не используем, а операция АЛУ задается совокупностью полей <code class="language-text">op</code> (31:26) и <code class="language-text">funct</code>.</p>
<p><strong>b</strong>. Операции с памятью. <code class="language-text">rs</code> - регистр, в котором записан сдвиг, который будет добавлен к адресу памяти. <code class="language-text">rt</code> - регистр, из которого читаем или в который пишем данные.</p>
<p><strong>c</strong>. Операции бранчинга. <code class="language-text">rs</code> и <code class="language-text">rt</code> - сравниваемые регистры. <code class="language-text">address</code> - адрес перехода при равенстве этих регистров.</p>
<p>В операциях a и b различается поле, в котором записан регистр, куда нужно писать данные, поэтому перед записью в регистр нам понадобится еще один мультиплексор.</p>
<p>Добавим вышеописанную информацию о полях и новый мультиплексор на нашу схему:</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/5ea329797dccb6d6df273b2e3ebee85b/04c1a/mips-implementation3.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 61.474269819193324%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAAB5UlEQVQoz2VT53KjMBjk/d/u8sczcYnpGEwvonpvVw6OL6cZIRBi2/fhdF0HYwx6rn3fYxxH+/x7av+fyb26N4irFo9tg8bj8YCjw+u6YhgGlEWBiYc3HtDe+6r3Im/b1q7LsqDtevhR/D/g+K0gTVNUVYVpmn6UcS7TiLZpeD9a4Px+R8azeZ4j8P0X2AtwnucXwO8h7m593tdVDdd1UZYlkjhGR7XrMr8BAk5D5qqsLLNsSJ0sdbQj+2lZI24NBpLlWUagyArYycz2BOPV7jnKzSPr+XRCwXsxe54Hn1Zk6XI+o8zviMKQRRjQmskSKTezbMjMCrNuaOli3mhZocuqwo7CCNfrFXVdIwxCHD8/7XNRlIijCG58Q1xUSG8JThRwp+L8TtW3FFHNDlkJuGd1uVzw8ecDvufbwJMkweFwwPXraqsvgtPxaJWqcHIiEYaFkrMzyVVA5+kfNhdZUS9qdMwmKhokVBZxxgQQaNfUaOhAYFIdk8C1rhrr1NkrtA/lJnVpSjt5YdUFQUCwgNUtkLYDMkYgNV+uZ2NQu+0FfSncV71QT65cBabWCPyAWeW2F+OahRlGe3biJxkv6irVQt857z33rtTaJlhISzcqVk5qpxtbyMwLNgII5KE/iVPqBPgXFW+a+BmiSLQAAAAASUVORK5CYII='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="MIPS implementation 3"
        title="MIPS implementation 3"
        src="/hows-that-again/static/5ea329797dccb6d6df273b2e3ebee85b/dbb61/mips-implementation3.png"
        srcset="/hows-that-again/static/5ea329797dccb6d6df273b2e3ebee85b/19bd1/mips-implementation3.png 163w,
/hows-that-again/static/5ea329797dccb6d6df273b2e3ebee85b/d3bcb/mips-implementation3.png 325w,
/hows-that-again/static/5ea329797dccb6d6df273b2e3ebee85b/dbb61/mips-implementation3.png 650w,
/hows-that-again/static/5ea329797dccb6d6df273b2e3ebee85b/04c1a/mips-implementation3.png 719w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Новые управляющие сигналы:</p>
<ul>
<li><strong>ALUOp</strong> - 2-битовый управляющий сигнал, который переводит АЛУ в один из трех режимов - сложение, вычитание, или использование инструкции, указанной в поле <code class="language-text">funct</code>.</li>
<li><strong>RegDst</strong> - определяет, брать регистр назначения из <code class="language-text">rt</code> или <code class="language-text">rd</code>.</li>
</ul>
<p>Итак, у нас есть 9 управляющих сигналов (для <code class="language-text">ALUOp</code> используются два). Все, кроме <code class="language-text">PCSrc</code> могут быть установлены в заисимости от <code class="language-text">opcode</code>. Для определения <code class="language-text">PCSrc</code> нужно еще знать результат сравнения регистров.</p>
<p>В результате наш контроллер принимает на вход 6 бит <code class="language-text">opcode</code> и имеет 9 выходов. На рисунке изображена наша схема с добавлением контроллера:</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/b80f11d0941cd35ba57f3e7c7b4e4f67/a8200/datapath-with-controller.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 77.42857142857143%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACi0lEQVQ4y2VT2ZKbQAz0/39L3vIXyUuyteuyd2ExBgPmGIZruOm0hjjl2lClmgGJltRqHfq+xzRN6LoOZVnaO7YN27paW+Xk+zAMaJrGxjV1bePk3yRJYIyBPBJ3kI8SPI4j7nSWukLXD2hNb038I/1t29ofB8ZprZFnGeqqQhgEmOf5f8BWsvPeLcCw7ib3mrHLZuPRs7qrf4HKc0RRhLRQqM2wO7EH/QOUNudtB3pkm9cNPlF/FDPKacP1nuPkh0iqFsW44dZvUGRo/Ru7PFe4LDMEK8oKRGGIMIpxqwyO9Yrv0Yjf5Yy47lExSBE8H1dcmUzxfJjm98ODP6lQAMvW2PLlLq16ZsO3cMKxmnHKW7Rsw9AamoB0PO3QGFwLoBAs1gvh84IkVzuf5KvuenxmGmdlUJkRH3ljeYVNRuBlN0ksgJUAZmmKi3eB8/4OXTc4uR78C833oZTCp+NAF5lVgHMvUNTtnnzZKzXzioX8kVIOkIDSrvCoqcFrGMH1A3Rtg5hT9DwPLgEzSiSOE5yjDGXT2UROGCNO+c7uYvKt+V2PCw5Svoj3+PaGXy+vcAgo1QiI637ifDpbSoIgxM+TC891UVYNbkwoWpSCsiyH+/GBgAM9CKFiUmU/jEgZ3DBTM61IdW3Bb5x6QHvxQnS6RNpy2v2IhKDiF3oEPKWcLODzo4rCOmUN5V5QxHHM9oTDhL5+gVONaLhNSXSjvBImu5GmFoqDOzxE/ACWSmVn5SwIWHEVL+QyzwuEuoWjB/hm34ttWzmclVJaUQ8TFFVxeK7ua7UiHVGBtKVYcaD5biZuk4XDc/SyLNz5J8AH2Ndq0/sdKUHzLMXxluEtIg2qtKoon0y66TqDP9rzf7i2saMEAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Datapath with controller"
        title="Datapath with controller"
        src="/hows-that-again/static/b80f11d0941cd35ba57f3e7c7b4e4f67/dbb61/datapath-with-controller.png"
        srcset="/hows-that-again/static/b80f11d0941cd35ba57f3e7c7b4e4f67/19bd1/datapath-with-controller.png 163w,
/hows-that-again/static/b80f11d0941cd35ba57f3e7c7b4e4f67/d3bcb/datapath-with-controller.png 325w,
/hows-that-again/static/b80f11d0941cd35ba57f3e7c7b4e4f67/dbb61/datapath-with-controller.png 650w,
/hows-that-again/static/b80f11d0941cd35ba57f3e7c7b4e4f67/a8200/datapath-with-controller.png 700w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>На этой таблице видим таблицу истинности для контроллера:</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/e72a78bf2d710d890e40834473eeed94/8d35d/controller-truth-table.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 19.006211180124225%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsSAAALEgHS3X78AAAA0UlEQVQY00WMu27CQBBF/Y9pSKBzHQlFaRBBFEhRgBT5rMQIkG34BQrbOzt+rZs4l9nBCsXR2bkzd4OHH4fxzmGya9Wep8gh3Du8JB3Cg8NU7HmOO7ym3f/dWDqjqNXuY3S7D96+L1jsc6xixja1WBwJ68RidiB8DPNGvE5kFj5TwlKy95hkZ7E5Mebekn+dGUFvM6AmoDL4Kwt5G32rGwtI9mtzIdO9t88U31MMes7RSxZwVaNqWhjLSkF2gEFcIjd0R3Jvv9fboUNc6R9l3eAKiMEZDIOX1IwAAAAASUVORK5CYII='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Controller truth table"
        title="Controller truth table"
        src="/hows-that-again/static/e72a78bf2d710d890e40834473eeed94/dbb61/controller-truth-table.png"
        srcset="/hows-that-again/static/e72a78bf2d710d890e40834473eeed94/19bd1/controller-truth-table.png 163w,
/hows-that-again/static/e72a78bf2d710d890e40834473eeed94/d3bcb/controller-truth-table.png 325w,
/hows-that-again/static/e72a78bf2d710d890e40834473eeed94/dbb61/controller-truth-table.png 650w,
/hows-that-again/static/e72a78bf2d710d890e40834473eeed94/8d35d/controller-truth-table.png 805w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Пример работы процессора для операции <code class="language-text">add $t1, $t2, $t3</code>. Жирным выделены активные соединения и элементы. Вся операция выполняется за 1 такт.</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/aed65898b2520049af5d224a83f396eb/60142/datapath-add-example.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 75.87168758716875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACfElEQVQ4y2VTy5KbMBD0//9NbvmDXHJLtmyvN2SxwbxsQCAQCIlOj7C3ditUtSXr0TM9Pdr1fY9xHNF1XRinaYIx5j/I+hMfa8QwDPDeQ751XbGTDWttIBTIXA4454ht9H7FyItyWYIaQs41TYPb7fY/oUSVw1VZQjPjeZ5D9JnrT4gSIZE9mcu9W1WiLIoPsi+EnVKY7ALtAOM3dMuGLT4w6h6aKiYpUa+hxgl2cY/dNfx+EJIelmvGSSQPS7kT5y/K4VfrMFiPvOlQdgPU7FBMKy7jioFnLEsyE/5zhp61ko0kL5GlCc7XHMVg8eO+4NvVYq8sinFBZYFy8sjMBsUs6nlFy1ESCIRSlyBppuTZhrkIoVr8VCu+Fw7x4HDu55DJzIvKbmSShMjVyxrU7eq6ZnFvdJE1GUYU9waD1gEt/5/yO/J+Qq0NLto+yrURTeK+26T2DBAIq6pCFEU4xzFuTYvDW4TkckGSJCiKHH9Or6jLAnGa4aIMHdaYqEIvJHhACLXf6r+TPhuYSdvUOJzeECdXZteHdjgeDojPZ7Rtg3cSHq8VFHsvyQq8ndPQk5pKpI3qftgIRYGYctzv8Xt/RETCglmneYHD6wnx+ztLUuEv11+iGGVOs2oVAkpDS2+qtsWRZ0X+7tmQAkNzOjNDKkUjcW8VpCR5dkVS3pCSyNuZbjsoeVns3YYetETNcg3WbRkKmXwSsWLkPMvCq5HMRJJcFElJZxCx8y90XJ6i4nrVdmi6ngYa6M+En0m39+shHSD17VQbMk9bkho6+nwc/GYqEUVqNOHVfMnwOT6/Vgyg21ma4sKGj2uaNcxYWDf7gMzdsoS2897hH9kZhYbQYOEeAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Datapath add example"
        title="Datapath add example"
        src="/hows-that-again/static/aed65898b2520049af5d224a83f396eb/dbb61/datapath-add-example.png"
        srcset="/hows-that-again/static/aed65898b2520049af5d224a83f396eb/19bd1/datapath-add-example.png 163w,
/hows-that-again/static/aed65898b2520049af5d224a83f396eb/d3bcb/datapath-add-example.png 325w,
/hows-that-again/static/aed65898b2520049af5d224a83f396eb/dbb61/datapath-add-example.png 650w,
/hows-that-again/static/aed65898b2520049af5d224a83f396eb/60142/datapath-add-example.png 717w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>А здесь - пример для инструкции <code class="language-text">lw $t1, offset($t2)</code>:</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/5df023df91dbd0267df49a1df77f6a3a/ad34c/datapath-lw-example.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 76.33802816901408%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACfUlEQVQ4y2VUi27bMAzM/3/NsO8YsALb+liaLnFsJ35bliVLft2OctJ2mAFGNE0eeSSVndYa1lp0XRdO5xyGYfhPxP4uw4ePMQbTNEGedV2xE+M4jgFQRHT5sCxLkHlewvvAZBIsSUXET6kOeZ7/DyhZxUk+aoJ670N2T3sQ7yBMXNA9dN+HBG3TIE3Td7B/ADul4MYJ/QwMyyaaesfk8xpiAogWPzl1j86S+rhVR8jw+w5IeIy0DRItOqk66k/djO8NE00LLq3GldK4CblbcbYr9LRiWlZ4yvK5wmWeMbKq+JrjmiaI0iuuvce3ZsbXdMSTmlDYCfUIVH5BRgqJXaAYVPO9YTV2vgFKXwIllq/dppMtiI8HteBLMuJVT4i0D1ULCwFSBHGhHyvMdANs6hpVVcEa9sRYZFUDw6aLtL3Fy6VErAZUZgiA6zYBstnABEioSkuMAMpkD4cDTscjykbh5fAHyfmMOI5RM5HoXV3hlFwQtRa9TJgsBEj65pZtJGS/VSg7JPvVqRZ7gh3jFJZBsg5vTJTnRViptKzxljdhG6607aMEDdemLMsgNaduWOVO0GUoz4+PePjxE0lB+uxrw8Dnl9/Y7/fodUd7jV+HYxhYQSZZloXeSzGyj6/0a7lGu/tCypQtr1RDo4xF9lBaULAllyTBkVM/JBkWPyDntA19hX4cRfTJwuK31n8Ahl7zqpVFjjy7oioK6kW4PRIUXXi2BGCmyMxbH1ldpTSU0GUCNYwb5c+gI1dHqGx3VYXM59MJVWdQGI+TYVJ/uzp8uILgjkORmfU3wPtzB70/Ahb+hUit7HrkvUPteAGmObRonrdTmDn2fWIRfwHdG4Wt4TfBGQAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Datapath load example"
        title="Datapath load example"
        src="/hows-that-again/static/5df023df91dbd0267df49a1df77f6a3a/dbb61/datapath-lw-example.png"
        srcset="/hows-that-again/static/5df023df91dbd0267df49a1df77f6a3a/19bd1/datapath-lw-example.png 163w,
/hows-that-again/static/5df023df91dbd0267df49a1df77f6a3a/d3bcb/datapath-lw-example.png 325w,
/hows-that-again/static/5df023df91dbd0267df49a1df77f6a3a/dbb61/datapath-lw-example.png 650w,
/hows-that-again/static/5df023df91dbd0267df49a1df77f6a3a/ad34c/datapath-lw-example.png 710w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>И напоследок - пример для инструкции бранчинга <code class="language-text">beq $t1, $t2, offset</code>:</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/910d3d795400851d1203009c545579e9/28569/datapath-beq-example.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 78.22349570200574%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsSAAALEgHS3X78AAACoUlEQVQ4y11U2W7bMBDU//9KH/sTBfrSFEXSJnFsWT50UhdJidQxnaWjIA6BBUlxOTu7O1TU9z3GYYC1Ntjwvh7e95+/j+MYfGWW/WZyvq4rZETyYZomtG0LAfdcy+GyLLTbLPt5nqF5bo2F1jqAeu9R1zXaprkHFBOnLMvQ0sEFBvbGZrAf53LZOQelVDBhdjwcwlqGgAZAcWroPBBITyuGGcEszcz4GHJBggrw5XxGlqZQbc8M53tAoS+pTUzRLO+XaY7r67DgTzuBcdB3HR4fnwKgcR7VOKPyuBsfgPM8BZCCEVVZoCgrVNoitiu+Xxx+qhmHxiId1xDkQnvTC1LONSMrWseokYBJyguLLgxT1cCyXm3Xo7IOO7Pi24mA9YynykCNbKBf0fgFGcEaLyVaWZ41fI+ks8aYQHf0ExRZyZASeAa4mgk/SoeSqb0qw0u3mvA+DBm55WZSP9lH6fWKt90OxzhGpw1e4gSnJMGZRZfuvfIso0+R53hJK3SDw8SM1nUJzCSonSgxBpCGRiKHsiyRs3vXNMO/fYyyKAJgyi7u9/vQzSwv8PdSoOw0NJuTdRZlb+GoRTs6ZuepCAKGVFlHYfjr4Td2x1NgoHV/A2Ig0dvlmuLhNcYxOaGqKlzSnLMK4hZS8jByNjIAyiuQ1M+XK5KyQS+FH33oeE62wngDTI4xWpamMmymvDLelYDyitIsR7Q9mW1oNsjx+XmKdaTWRFaBKUEPRR0a17oZuWGKTF2pOjA2zMjzLNoUvpmIVtgKK0XHivV9eX5GfEwQk32iJzx2S5DISu1K/URePTNqB38D3EC/DqmtSErSEQUUxqET/Y33vuv2sj4z/MpURvgLNS0a/k06pndQGvt2hCKjefJ8EB6eDfTeheYIgf+pOdJOvQ1roQAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Datapath branching example"
        title="Datapath branching example"
        src="/hows-that-again/static/910d3d795400851d1203009c545579e9/dbb61/datapath-beq-example.png"
        srcset="/hows-that-again/static/910d3d795400851d1203009c545579e9/19bd1/datapath-beq-example.png 163w,
/hows-that-again/static/910d3d795400851d1203009c545579e9/d3bcb/datapath-beq-example.png 325w,
/hows-that-again/static/910d3d795400851d1203009c545579e9/dbb61/datapath-beq-example.png 650w,
/hows-that-again/static/910d3d795400851d1203009c545579e9/28569/datapath-beq-example.png 698w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<h2>Почему однотактовые реализации больше не используются</h2>
<p>Наша реализация выполняет всю инструкцию за 1 такт. Тем не менее, такие реализации на данный момент не используются потому что тогда длина такта будет одинакова для всех возможных инструкций, а значит - будет равна длине самой медленной инструкции. Это наверняка будет инструкция загрузки из памяти, так как она последовательно задействует целых 5 элементов: блок инструкций, блок регистров, АЛУ, блок памяти и опять блок регистров, но уже для записи.</p>
<p>Такая реализация может быть приемлема для архитектур с небольшим количеством простых инструкций, так как тогда расхождение между самой быстрой и самой медленной поерацией не очень велико, однако если бы мы добавили операции с плавающей точкой, то такой вариант работал бы совсем плохо.</p>
<h2>Проектирование набора инструкций для пайплайнинга</h2>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/eaee3245f1b2deee1886e48e24f4d489/b4fb4/mips-pipeline.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 37.79385171790235%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABE0lEQVQoz32RiY6CQAxA+f9f4w8UVgHlPkUuOeq8ZtmoMTtJ02mnx2vHchxH6rqWbdtkWRZ5PB5yu91Ut20r0zT9afzjOH7V5K7rKpZt25LnuSRJIsMwqKTm3nWdpGkq9/v9TVM8iiItEsexamzygLBiYxCIs+97FTrN86wBu0CCj0n+O1ZVVYJcr1e5XC5yOBykaRopikIJIIPe8zxtCiGHwt/EIjgzhBRD2Knv+3I8HnUVURiqnynwn89ntT8L73cLEhIhhIblQwIpvtPpJGVZSm2moDnCe2ga8ZnE78V0ZMajG4XZEYcPybJMC0LMWxAESriT/riuuEaw3wg/l/q6dAii309jnzSBjIlebT5xz30C3AxjPnDAMQAAAAAASUVORK5CYII='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="MIPS pipeline"
        title="MIPS pipeline"
        src="/hows-that-again/static/eaee3245f1b2deee1886e48e24f4d489/dbb61/mips-pipeline.png"
        srcset="/hows-that-again/static/eaee3245f1b2deee1886e48e24f4d489/19bd1/mips-pipeline.png 163w,
/hows-that-again/static/eaee3245f1b2deee1886e48e24f4d489/d3bcb/mips-pipeline.png 325w,
/hows-that-again/static/eaee3245f1b2deee1886e48e24f4d489/dbb61/mips-pipeline.png 650w,
/hows-that-again/static/eaee3245f1b2deee1886e48e24f4d489/6b691/mips-pipeline.png 975w,
/hows-that-again/static/eaee3245f1b2deee1886e48e24f4d489/b4fb4/mips-pipeline.png 1106w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>В MIPS инструкции были спроектированы для пайплайна, этому способствуют следующие свойства:</p>
<ol>
<li>Все инструкции имеют одинаковую длину. </li>
<li>Поле регистра-источника всегда находится в одном и том же месте. Благодаря этому, пока первый шаг определяет тип инструкции, второй шаг может уже начать читать значение регистра. Если бы это свойство не соблюдалось, пришлось бы разбить шаг 2 на 2 шага.</li>
<li>Адреса памяти используются только для операций чтения и записи. Благодаря этому мы можем на 4 шаге вычислять адрес памяти и обращаться по этому адресу на шаге 5. Если бы мы могли бы совершать арифметические действия над данными из памяти, то после 4 шага пришлось бы вставить еще один АЛУ.</li>
<li>Все операнды выровнены в памяти.</li>
</ol>
<h2>Риски пайплайна</h2>
<p>Риски - это ситуации, в которых следующая инструкция не может быть выполнена в следующем такте. Есть 3 разных типа:</p>
<h3>Структурные риски</h3>
<p>Возникают когда аппаратная часть не поддерживает запрашиваемую комбинацию инструкций, которую мы хотим выполнить в одном такте. В MIPS таких рисков нет, так как набор инструкций был тщательно спроектирован для пайплайнинга. Например, если инструкции и данные хранятся в одной памяти, то 1 и 4 шаг нашего пайплайна не может быть выполнен одновременно, так как и там и там происходит чтение из одной памяти.</p>
<h3>Риски данных</h3>
<p>Возникает когда данные, необходимые для выполнения шага, еще не доступны</p>
<p>Пример:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">add $s0 $t0 $t1
sub $t2 $s0 $t3</code></pre></div>
<p>Здесь вторая инструкция ожидает результата выполнения первой. Если не вмешаться, то пайплайн не сработает. Первая инструкция пишет результат только на 5-м шаге, значит второй инструкции придется 3 такта ждать впустую. </p>
<p>Компилятор может переупорядочивать местами команды чтобы избежать этого, но это помогает не всегда.</p>
<p>Типичное решение - не ждать полного выполнения 1-й инструкции, а сразу подать во 2-ю результат сложения, минуя память.</p>
<p>Однако такое решение помогает не всегда. Если бы первой инструкцией была <code class="language-text">lw</code>, результат был бы доступен только после 4 шага, что уже слишком поздно. Тогда все равно пришлось бы ждать 1 такт впустую и только после него подать выход с 4 шага 1-й инструкции на 3-й шаг 2-й.</p>
<h3>Риски управления</h3>
<p>Возникает, когда прочитана не та инструкция, которая нужна. Например, в инструкциях ветвления адрес следующей инструкции выясняется только на последнем шаге, а следующая инструкция к этому момент уже прочитала неверный адрес.</p>
<p>Одно из решений - остановить пайплайн сразу, как только прочитали инструкция бранчинга до тех пор, пока не станет известен следующий адрес.</p>
<p>Но обычно используется <em>branch prediction</em>: попытаться предсказать, какой бранч будет выбран и начать загружать его. Если окажется, что выбран не он, то загрузку этого отбрасываем и считаем заново правильный.</p>
<p>Очень популярный подход для предсказания бранчей - для каждого бранча помнить, был ли он в прошлый раз выбран или нет, и предсказывать что в следующий раз будет так же. Это хорошо работает для циклов.</p>
<p>Еще один вариант решения - <em>отложенное выполнение</em>: переупорядочить инструкции так, чтобы пока не станет известен адрес бранча для перехода, выполнялись другие инструкции, не зависящие от этого.</p>
<h2>Pipelined datapath</h2>
<p>На схеме изображена наша однотактовая схема процессора, на которой выделены шаги пайплайна:</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/41f47af6c90e30f3960019492f4073df/332aa/pipelined-datapath.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 70.27379400260756%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAAB6klEQVQ4y3VTiXKrMAzk/z+ynUnK0RAwhy/AoLcrcJPO9HnQYIO8Wq3XxXEcwrFtm0zTpMF5CEGqspKmaSTGKM45Kb++ZBxH8d7LYIzmLsuiueMwaF4hf4yUkrDQvu/65prBNYMF88jf8ih82qW3QQYXxCC6yWr4bZeIPMYcVwnp0HlATFg7/PfpLJYLsHhhlySz87qYZysj2mjbp7aiyYiI+UoZ0FKWBxsuwF3zfgDdmsSHM5E6zPMMwFZ1oiYMa63+67pOzDgpQ3Zgt5ccfwJSXAK8a8KxrqseDotZHM4Chgmbj0vDXy07VHmaUYwZEEZBGc46ZUWm7eMhA+YTTnhF+xsKJICw0DsBBVxQxlgvZd1IjYi0ADZ+g9H9fle7sNVsF8pB+3TPTsHImgRy22qb480efd/L58eHgtd1rayqqpLb7SZPHBb1JFuyG9AVc2YcZPNoBc1KcVxaqP8AbFGxA2g7zgrOIjRxWZYKtIAVpenBmuwWAOueYVJbFbn3d+CwrNLPTjezXQKzrZybbxSDUpAh2UXY6Afw/U3A0UcJ3kmDlowyfd2OdPlQbwpvEP79AswjA9LENG3EkjfE0lrpNDLXvDnnXIS2s8smDut1/w8gfaV3VKU4C+xIxvNaXxLxpmxbOuXCt387kUPuh4dhEQAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Pipelined datapath"
        title="Pipelined datapath"
        src="/hows-that-again/static/41f47af6c90e30f3960019492f4073df/dbb61/pipelined-datapath.png"
        srcset="/hows-that-again/static/41f47af6c90e30f3960019492f4073df/19bd1/pipelined-datapath.png 163w,
/hows-that-again/static/41f47af6c90e30f3960019492f4073df/d3bcb/pipelined-datapath.png 325w,
/hows-that-again/static/41f47af6c90e30f3960019492f4073df/dbb61/pipelined-datapath.png 650w,
/hows-that-again/static/41f47af6c90e30f3960019492f4073df/332aa/pipelined-datapath.png 767w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Данные всегда идут слева направо, кроме 2 исключений:</p>
<ul>
<li>write-back, где данные из памяти идут в регистр</li>
<li>выбор следующего значения PC</li>
</ul>
<p>Но эти исключения не мешают выполнению текущей инструкции - они влияют только на последующие инструкции в пайплайне.</p>
<p>При этом первое исключение может привести к рискам данных, а второе - к рискам управления.</p>
<p>Чтобы каждый из шагов выполнялся в отдельном такте, между ними нужно поместить специальные пайплайн-регистры, которые будут хранить результат выполнения предыдущего шага для передачи его в следующий. При этом, если из шага выходит несколько значений, то и регистр должен быть достаточно большим, чтобы все их вместить.</p>
<p>Например, на следующей схеме регистр <code class="language-text">IF/ID</code> должен быть 64-битным, чтобы вместить 2 выхода из шага <code class="language-text">IF</code>. Остальные регистры содержат 128, 97 и 64 бита соответственно.</p>
<p>Чтение из таких регистров производится в начале такта, а запись - в конце, поэтому конфликта не происходит. </p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/32f40166d3a680afb61cb90a2be93144/d5c82/pipelined-datapath2.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 47.19800747198008%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABqElEQVQozz1Si27bMAz0///WhmZJt3XAugHdmraZE8eWZEuW/JBsyTdKdkKAEEHQd8ejMykljDEpu+3t+z6lcw7OWlhKTX271eM4QimVZmJ47zFQL0bWqjYVcbDrOoydwVl1eJPr8LIscLPHM9PwVMcIlL8YEY82TkA7j5+lWgGjohtg27YYjMZRaPzm1J+npDJ++Pm9wrWqwCiV1ni8KJh+SIDKBTxVJtVZXddJWQT2PiTws7b4I4e7Qk/CDnkNUTewtNpEKz5VGnNYFetpwY9qFZY1TYNrUYAxBk3MbujxITvsjxfwa5GIKi6w/yegiTgCSrJpTwRR4UJbMD3ge7lal4WwqprnmQbJaN0mwN3rGfn7WyJhpOzTscD5UkBwDi4EHsgC0cgkIOcSX04cSnBk2GKaJso5MV6Mw9dTCaPk3cOoMAKOw4CRersTQ1FWCZDpHrsPhrapkUWPlu1624OcPPyWc/ofZnBSVDKOw1nCumklp6sf6ChR4TT2KKRJR/LOroA382816yxeOXkS/F3hC49HCIl1puO9CIOwbddNAX/rjsBH/AeN/rKBuZCMTQAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Pipelined datapath 2"
        title="Pipelined datapath 2"
        src="/hows-that-again/static/32f40166d3a680afb61cb90a2be93144/dbb61/pipelined-datapath2.png"
        srcset="/hows-that-again/static/32f40166d3a680afb61cb90a2be93144/19bd1/pipelined-datapath2.png 163w,
/hows-that-again/static/32f40166d3a680afb61cb90a2be93144/d3bcb/pipelined-datapath2.png 325w,
/hows-that-again/static/32f40166d3a680afb61cb90a2be93144/dbb61/pipelined-datapath2.png 650w,
/hows-that-again/static/32f40166d3a680afb61cb90a2be93144/d5c82/pipelined-datapath2.png 803w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<h2>Forwarding unit</h2>
<p>Форвардинг - направление результата работы АЛУ на текущей инструкции сразу на вход АЛУ следующей, чтобы следующая не дожидалась пока текущая завершится и запишет свой результат в регистр.</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 630px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/88573e5fa0145476d231895dfb49207d/b2a12/pipeline-forwarding.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 128.41269841269843%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAAsSAAALEgHS3X78AAADG0lEQVRIx22Vi27iQAxF+f/P27YrdVVUnnlDHpCQAMHrY+I0UEaykpl47lzb15OZTMb1epXdbieXy8Xmt9vNjMFaEidSleWDfxLHtsf9ZyyeTiezrutkl2Uj4PNhaZrKoarGzYw0SaTIix/AMAjNmVEUhRyPR6l0Ewcwr+t6BOXAKXsGfufz+Qew1BCiMJRYqR8Oh5EpA8f9fm+gvHMY1jTNCMS8bdsfQGdSFqUAzmY2wIRnQkj6nXc2x1Fkfn4gJLq2G6OYkVBCxggVB0Br3Qy7kwJNQ+Z7vs/l78eHZJpvjyDUKPeKNWMCG88PTPq+t3cPh29Egm+mhcnSOxAF8v1hEMhms7kDTitpDhoK+QDIzQGRCaDMkVA5GGmB/QgIAIDNUIBXw+XFd5if9SDAiIRBdA8MAWXRZfQK8Pkw/H0NrBmFqAc5QNkr2g5splYOOvVvsIQh+3gfQw40ocE2MC16QTgV83eefIO9zV+s8Zw9h+Wifh5WJGUxbUvWXAWjDq266uSnbLX0hAMDnj4AWi6X1us+YMcaGhw7hZxxgrcRKeC5Wq3ke/4ll6613Dmb81MEVpRu0ssRrTQkO8/zoW87iaJYtqmK99xLqYVjI5LicJidB63eizTpZRwJk8LQzy7YOEklbW8SKKGDAuFDRRF2rl3CoNoA/uplv0hdAqTh3+enbNcrabqLReAyKTQKbP71Zb3PHidhwgZgVP7w5ORPBUyiUNK8tBuHUEkHRWHOlcc7lyv+i+9vK9CvXjYmakG2l/DUS971VnFOr4/3Xvbryw/hG5cFqfjVy8yhn2k+E81h1PYPGi0nFwK3zf0uLUxWkHkAxPhvvL+/y1JDyOJICq3yrb+aVpuhOJv1xjpru91a+LQue62Xp4DIgZySv7c/b3a/baqTRGVtlunF6sL3a+2o/hSH3J+aFwwZ5GI+n0uuCgh3uaybXtYqtbg8SKTyWq/XynBrDB3sPOR55neZA/oV5j+tQ1XKvjrK7lDfJaVVRXd+aThTogPL/nqLxcLyQrtVw4/K/y930MqMNTbxn2kGOw3GHlLxH1Va3ctF5fktAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Pipeline forwarding"
        title="Pipeline forwarding"
        src="/hows-that-again/static/88573e5fa0145476d231895dfb49207d/b2a12/pipeline-forwarding.png"
        srcset="/hows-that-again/static/88573e5fa0145476d231895dfb49207d/19bd1/pipeline-forwarding.png 163w,
/hows-that-again/static/88573e5fa0145476d231895dfb49207d/d3bcb/pipeline-forwarding.png 325w,
/hows-that-again/static/88573e5fa0145476d231895dfb49207d/b2a12/pipeline-forwarding.png 630w"
        sizes="(max-width: 630px) 100vw, 630px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Здесь наверху - обычная схема, снизу - схема с добавленной функциональностью форвардинга. </p>
<p><code class="language-text">Forwarding unit</code> - смотрит, совпадает ли регистр, куда пишется результат АЛУ на текущей инструкции (<code class="language-text">EX/MEM.RegisterRd</code>) с регистром, откуда берется операнд для АЛУ на следующей (<code class="language-text">ID/EX.RegisterRs</code>) и если да, то активирует контрольную линию <code class="language-text">ForwardA</code>, которая верхнему мультиплексору говорит брать то значение, которое приходит из регистра <code class="language-text">EX/MEM</code>. </p>
<p>Аналогично обрабатываются 3 других случая:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">if (EX/MEM.RegWrite
and (EX/MEM.RegisterRd ≠ 0)
and (EX/MEM.RegisterRd = ID/EX.RegisterRs)) ForwardA = 10

if (EX/MEM.RegWrite
and (EX/MEM.RegisterRd ≠ 0)
and (EX/MEM.RegisterRd = ID/EX.RegisterRt)) ForwardB = 10

if (MEM/WB.RegWrite
and (MEM/WB.RegisterRd ≠ 0)
and ( MEM/WB.RegisterRd = ID/EX.RegisterRs)) ForwardA = 01

if (MEM/WB.RegWrite
and (MEM/WB.RegisterRd ≠ 0)
and (MEM/WB.RegisterRd = ID/EX.RegisterRt)) ForwardB = 01</code></pre></div>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 611px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/83946b40ecb23879a33ce4a1db031e52/f21ab/forwarding-controls.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 31.914893617021278%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABaUlEQVQY0y2PzW7aUBCF/WJdVUlVddldWnVdqZH6InmmJiRIVWkIcE3xz7WxsWOD/42NwVl9vThZfDozZ+6MztVurCPfJgeunw58+dNypfj+1PH5d8vl/Z6L+4bLh3bQT+OGH7OOn/OOr2rn/ajhg5p9HLe8u2sGXxNuwFiYzJ0NE7lhrNuYUcrUi7nVJaN/LndKfwmb0VLy13CYWi4Pwhq8yTpmFmYs4hIrqdCiYIM0ViRxRJnusJY60canqyvkaolnmYRrB19aRP4aR/WelPiO5NlzByLfo9xtObUNWlGUlFVFvd+TFwWFou978rzA933CMKRS86qqqepX6jeKshy071/ojkeatkVzXZfp4yNnDYOA+WxGoDTPMizTxDSMASEExspgqevoQlf1CrFYYKo3vucRxzHd4YCWpRlb1ZRv6Z5VokwdO9fnQ1J9z7ZtoihSqXOSJGG33XLeS5OUNFUor1RpT6cT/wGuw6m1IBDRnAAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Forwarding controls"
        title="Forwarding controls"
        src="/hows-that-again/static/83946b40ecb23879a33ce4a1db031e52/f21ab/forwarding-controls.png"
        srcset="/hows-that-again/static/83946b40ecb23879a33ce4a1db031e52/19bd1/forwarding-controls.png 163w,
/hows-that-again/static/83946b40ecb23879a33ce4a1db031e52/d3bcb/forwarding-controls.png 325w,
/hows-that-again/static/83946b40ecb23879a33ce4a1db031e52/f21ab/forwarding-controls.png 611w"
        sizes="(max-width: 611px) 100vw, 611px"
        loading="lazy"
      />
  </a>
    </span></p>
<h2>Static Multiple Issue</h2>
<p>Компилятор упаковывает несколько разных инструкций в одну длинную инструкцию. За счет дублирования блоков процессор выполняет несколько инструкций за один такт.</p>
<h2>Dynamic Multiple Issue</h2>
<p>Тоже самое, что и Static, но инструкции объединяются не компилятором, а самим процессором во время выполнения. Так же такой подход называется <strong>суперскалярным</strong>.</p>
<p>Дублируются обычно блоки АЛУ и блоки регистров. Такой подход используется во всех современных архитектурах.</p>
<h2>Реальные архитектуры процессоров</h2>
<h3>ARM Cortex-A8</h3>
<p>Использует пайплайн из 14 шагов. Суперскаляр с 2 иструкциями за такт. Инструкции не перемешиваются, а выполняются ровно в том порядке, в котором приходят. Пайплайн состоит из 3 секций: получение инструкции, декодирование и выполнение. </p>
<p>На схеме ибозражен пайплайн процессора ARM A8:</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 577px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/edf06e328c5ffc6600fd7e0c8f4d9475/e8146/a8-pipeline.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 43.327556325823224%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABfElEQVQoz3VRaW+CQBDl//8sm9gPFsohh1wKRlFRDqUCXtN5U7FJk5JMZnbZfdcqx+OR2nNLdV3T5XKhqiyprioqikKq5Kp43XUdNU0j/Xw+yzwU1sC53++k0J/ver1S4Ps0n88pjiIKgkCIHo+HABeHg3QhYvKS6/DcO51OpAAdIH3XU9u2wpbnuajDIczYh4IkSSiOY+lz7ovFQnoUhrTZbKSU9XpNWZYJC+xADQjQh8Ia7Ljos/qIlQNYQNkJ3KxWK7KnU1KQlz+bEYABCgvIAnW73V4zSPVPnRzbkfMzzyOPCwSmYYhq13FIcV2XDF0nTdOEAUoQ9H6/l8eBZQDvdjuyLEvAkGvIlbBlqJ3yPvLGfwWy30Yj8hgYh6AQOeLVGwZHjrAMBzoTm4ZJ6odKqqpKBFD8Ph7LfYOVKrjwMZkIwBcrQ/hDdn3fv2YoxSXbtsWRZZpiN2RQTdV+Fd6fOQ15/fcBHK+43W5pk/28aM4xoC/TpfQ0TekbFOKfzXPITU0AAAAASUVORK5CYII='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="ARM A8 Pipeline"
        title="ARM A8 Pipeline"
        src="/hows-that-again/static/edf06e328c5ffc6600fd7e0c8f4d9475/e8146/a8-pipeline.png"
        srcset="/hows-that-again/static/edf06e328c5ffc6600fd7e0c8f4d9475/19bd1/a8-pipeline.png 163w,
/hows-that-again/static/edf06e328c5ffc6600fd7e0c8f4d9475/d3bcb/a8-pipeline.png 325w,
/hows-that-again/static/edf06e328c5ffc6600fd7e0c8f4d9475/e8146/a8-pipeline.png 577w"
        sizes="(max-width: 577px) 100vw, 577px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Первые 3 шага получают 2 инструкции за такт и поддерживают очередь из 12 заранее прочитанных инструкций. Для этого используется 2-уровневый бранч-предиктор, состощий из:</p>
<ul>
<li><strong>BTB: Branch target buffer</strong> на 512 записей, содержащий адреса используемых бранчей</li>
<li><strong>GHB: Global history buffer</strong> на 4096 записей, содержащий историю переходов по бранчам</li>
<li><strong>RS: Return stack</strong> на 8 записей, предскаывающий будущие возвраты из бранчей</li>
</ul>
<p>Если предсказание бранча ошиблось, то пайплайн очищается и мы получаем штраф на 13 тактов.</p>
<p>Затем блок из 5 шагов определяет, есть ли зависимости между инструкциями и в какой пайплайн последней секции нужно подать инструкцию.</p>
<p>Последние 6 шагов предоставляют один пайплайн для инструкций сохранения/загрузки и 2 пайплайна для арифметических операций.</p>
<h3>Intel Core i7 920</h3>
<p>Архитектура x86. Предоставляет сложный подход к пайплайнингу, использует 14-шаговый пайплайн,  мультискалярность, спекуляции, перемешивание инструкций. </p>
<p>Из-за очень сложного набора инструкций x86, Intel сначала преобразует их в так называемые <em>микрооперации</em>, похожие на операции, используемые в MIPS. Затем эти микрооперации используются сложным, спекуляционным пайплайном с динамическим расписанием, который может выполнять до 6 микроопераций за такт.</p>
<p><img src="core-i8-pipeline.png" alt="Core i8 Pipeline"></p>
<p>Внутренняя организация процессора называется его <strong>микроархитектурой</strong>.</p>
<p>Каждая инструкция x86 проходит через 7 этапов:</p>
<ol>
<li><strong>Instruction fetch</strong> - используется многоуровненый <em>branch target buffer</em> для достижения баланса между скоростью и точностью предсказаний. Ошибочное предсказание влечет штраф на 15 тактов. В результате получаем пакет инструкций длиной 16 байт.</li>
<li><strong>Predecode</strong> - полученные 16 байт кладутся в <em>predecode instruction buffer</em> и на этом этапе преобразуются в индивидуальные инструкции x86. Это нетривиальный шаг, так как инструкции x86 имеют длину от 1 до 15 байт. Полученные инструкции кладутся в 18-элементную очередь инструкций.</li>
<li><strong>Micro-op decode</strong> - инструкции x86 транслируются в <em>микрооперации</em>. 3 из 4 декодеров работают с инструкциями, которые напрямую транслируются в 1 микрооперацию. Декодер для сложных инструкций транслирует инструкцию в последовательность микроопераций. Он производит до 4 микроопераций за такт и продолжает работать в следующих тактах, пока не сгенерирует всю нужную последовательность. Микрооперации помещаются в 28-элементный буфер микроопераций.</li>
<li><strong>Loop stream detection</strong> - если есть последовательность инструкций (меньше чем 28 штук или 256 байт в длину), которые образуют петлю, то на этом этапе они обнаруживаются и дальше микрооперации будут подаваться напрямую из буфера микроопераций, чтобы не выполнять впустую шаги 1-3</li>
<li><strong>Perform the basic instruction issue</strong> - регистр ищется в таблице регистров, переименовывается, выделяется место в <em>reorder buffer entry</em>, из <em>reorder buffer</em> и регистров получаются нужные значения прежде чем микрооперации отправятся в <em>reservation stations</em></li>
<li><strong>Reservation</strong> - 6 функциональных блоков поддерживают 36-элементную станцию резервации. На этом этапе микрооперации распределяются между ними. В каждый из блоков можно назначить до 6 микроопераций за такт.</li>
<li>Функциональные блоки выполняют микрооперации, результаты посылаются обратно на станцию резервации и в <em>register retirement unit</em>, откуда они запишутся в регистры, как только станет известно, что инструкция больше не спекулятивна. После этого инструкция в <em>reorder buffer</em> помечается как выполненная</li>
<li>Когда одна или несколько инструкций сверху <em>reorder buffer</em> помечаются как выполненные, ожидающие записи в <em>register retirement unit</em> выполняются, а инструкции удаляются из буфера.</li>
</ol>
<h2>Кэши процессора</h2>
<p>Кэши создаются основе статической памяти RAM или SRAM.</p>
<p>Кэш L1 - свой у каждого ядра. Самый быстрый и самый мелкий. Обычно процессоры имеют два кэша L1 - для инструкций и для данных.</p>
<p>Кэш L2 - разделятся между всеми ядрами и через него ядра могут обмениваться информацией. Некоторые процессоры дублируют данные из L1 в L2. Этот кеш медленнее, но больше, чем L1.</p>
<p>Кэш L3 - тоже разделяется между всеми ядрами, но использует более медленный и дешевый SRAM, чем L2, засчет чего размер L3 может быть сильно больше L2.</p>
<p>Процессор спроектирован так, что самые важные значения кладутся в более быстрый L2, а менее важные - в медленный L3.</p>
<p>При попытке чтения из кэша процессор сначала ищет его в L1, потом в L2, потом в L3, L4 и, когда кеши кончаются - в память.</p>
<p>Логически кэш-память представляет собой набор кэш-линий. Каждая кэш-линия хранит блок данных и дополнительную информацию. Под размером кэш-линии понимают размер блока данных. В архитектуре x86 размер кэш-линии составляет 64 байта. </p>
<p>Суть кэширования состоит в разбиении RAM на кэш-линии и отображении их на кэш-линии кэш-памяти. Возможно несколько вариантов такого отображения.</p>
<h3>Inclusive vs Exclusive</h3>
<p><strong>(В этом разделе под верхними уровнями подразумеваются более быстрые уровни, то есть L1 - выше, чем L2)</strong></p>
<p>Если все блоки верхнего уровня кэша присутствуют в блоке нижнего уровня, тогда нижний называется <strong>инклюзивным</strong>. Такие кэши используются в процессорах Intel.</p>
<p>Если же в нижнем уровне только те блоки, которых нет в верхнем - то он <strong>эксклюзивный</strong>. Такие кэши используются в процессорах AMD.</p>
<p>При чтении из инклюзивного кэша:</p>
<ul>
<li>если блок Х найден в L1, то читаем оттуда</li>
<li>если не найден в L1, но найден в L2, тогда копируем его в L1. </li>
<li>если же не найден ни L1 ни на L2, но найден в L3, то копируем его в L2 и L1. </li>
</ul>
<p>При переполнении одного из уровней <strong>удаляем</strong> один из старых блоков и шлет уровню <strong>выше</strong> команду удаления этого блока, чтобы не нарушить свойство инклюзивности.</p>
<p>При чтении из эксклюзивного кэша:</p>
<ul>
<li>если блок Х найден в L1, то читаем оттуда</li>
<li>если не найден в L1, то найден в L2, тогда <strong>перемещаем</strong> его из L2 в L1. </li>
<li>если не найден ни на одном из уровней, то берем из памяти и кладем в L1. </li>
</ul>
<p>При переполнении одного из уровней <strong>перемещаем</strong> один из старых блоков на уровень <strong>ниже</strong>, чтобы не нарушить свойство эксклюзивности.</p>
<p>Таким образом, низжие уровни кэша получают блоки только когда они вытесняются высшими уровнями, что делает низжие уровни эксклюзивных кэшей <strong>виктимными кэшами</strong>.</p>
<h3>Виды отображения</h3>
<h4>Direct Mapping</h4>
<p>RAM делится на сегменты, причем размер каждого сегмента равен размеру кэша, а каждый сегмент делится на блоки, причем размер каждого блока равен размеру кэш-линии.</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/6dee6c84c45b72969524a7339f66296c/8000e/cpu-cache-direct-mapping.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 82.72604588394063%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMBBf/EABUBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAHsVlo2CSwirC5//8QAGhAAAQUBAAAAAAAAAAAAAAAAAQIQETFCMv/aAAgBAQABBQIdy2yqCK0qxX//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAVEQEBAAAAAAAAAAAAAAAAAAAQQf/aAAgBAgEBPwEh/8QAFRABAQAAAAAAAAAAAAAAAAAAIEH/2gAIAQEABj8Cgh//xAAdEAADAAICAwAAAAAAAAAAAAAAAREhMVFhcaGx/9oACAEBAAE/IUVTLzkarkTorVk62Oh7saoxH4mg/9oADAMBAAIAAwAAABDYAMD/xAAWEQEBAQAAAAAAAAAAAAAAAAABEDH/2gAIAQMBAT8QYbP/xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAgEBPxAjH//EAB4QAQACAgEFAAAAAAAAAAAAAAEAESExEGFxgZGh/9oACAEBAAE/EMmCzq3pEacuhDNl+SNGnZxByTS9DEQq0vE393jfAT//2Q=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Direct Mapping"
        title="Direct Mapping"
        src="/hows-that-again/static/6dee6c84c45b72969524a7339f66296c/a111b/cpu-cache-direct-mapping.jpg"
        srcset="/hows-that-again/static/6dee6c84c45b72969524a7339f66296c/aca85/cpu-cache-direct-mapping.jpg 163w,
/hows-that-again/static/6dee6c84c45b72969524a7339f66296c/0954f/cpu-cache-direct-mapping.jpg 325w,
/hows-that-again/static/6dee6c84c45b72969524a7339f66296c/a111b/cpu-cache-direct-mapping.jpg 650w,
/hows-that-again/static/6dee6c84c45b72969524a7339f66296c/8000e/cpu-cache-direct-mapping.jpg 741w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Адрес каждого байта представляет собой сумму порядкового номера сегмента, порядкового номера кэш-линии внутри сегмента и порядкового номера байта внутри кэш-линии. </p>
<p>Тэг кэш-линии хранит порядковый номер сегмента, то есть старшую часть адреса первого байта в данной кэш-линии.</p>
<p>Этапы поиска:</p>
<ol>
<li>извлекается средняя часть адреса, определяющая номер линии в кэше</li>
<li>тэг кэш-линии сравнивается со старшей частью адреса, то есть с номером сегмента</li>
<li>если совпадает, то внутри этой кэш-линии ищем байт с адресом, совпадающим с младшей частью искомого адреса.</li>
</ol>
<p>Этот вариант очень подвержен конфликтам, когда две строки соревнуются за одну ячейку, поочередно вытесняя друг друга из кэша.</p>
<h4>Fully associative mapping</h4>
<p>RAM делится на блоки, размер которых равен размеру кэш-линий. Каждый блок RAM может сохраняться в любой кэш-линии кэша.</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/420ac154242ce109ed755b623b915d0e/ab70f/cpu-cache-fully-associative-mapping.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 88.62019914651495%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAASABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7WuQ2VFYJbhP/8QAHBAAAQMFAAAAAAAAAAAAAAAAAQACQhARITFB/9oACAEBAAEFApUmXWQyOuCGv//EABURAQEAAAAAAAAAAAAAAAAAABAB/9oACAEDAQE/ASH/xAAVEQEBAAAAAAAAAAAAAAAAAAAQAf/aAAgBAgEBPwEp/8QAFRABAQAAAAAAAAAAAAAAAAAAIDH/2gAIAQEABj8CEP8A/8QAGxABAAICAwAAAAAAAAAAAAAAAQARIUEQgcH/2gAIAQEAAT8hSre8t6ERUW7jyJUQ1gKWExE//9oADAMBAAIAAwAAABDQDwP/xAAXEQADAQAAAAAAAAAAAAAAAAAAATEQ/9oACAEDAQE/EModP//EABcRAAMBAAAAAAAAAAAAAAAAAAABMRD/2gAIAQIBAT8QyBQ//8QAHRABAAICAgMAAAAAAAAAAAAAAQARITFBURBhkf/aAAgBAQABPxDUihPb55xEQszi9QcUdpKihYPF3FFQuM1EpTXJACADon//2Q=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Fully Associative Mapping"
        title="Fully Associative Mapping"
        src="/hows-that-again/static/420ac154242ce109ed755b623b915d0e/a111b/cpu-cache-fully-associative-mapping.jpg"
        srcset="/hows-that-again/static/420ac154242ce109ed755b623b915d0e/aca85/cpu-cache-fully-associative-mapping.jpg 163w,
/hows-that-again/static/420ac154242ce109ed755b623b915d0e/0954f/cpu-cache-fully-associative-mapping.jpg 325w,
/hows-that-again/static/420ac154242ce109ed755b623b915d0e/a111b/cpu-cache-fully-associative-mapping.jpg 650w,
/hows-that-again/static/420ac154242ce109ed755b623b915d0e/ab70f/cpu-cache-fully-associative-mapping.jpg 703w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Адрес каждого байта представляет собой сумму порядкового номера кэш-линии и порядкового номера байта внутри кэш-линии. Адреса байт различаются только старшими частями, поэтому в тэге каждой кэш-линии хранится старшая часть, то есть порядковый номер кэш-линии(блока) в RAM.</p>
<p>Этапы поиска:</p>
<ol>
<li>тэги всех кэш-линий сравниваются со старшей частью адреса одновременно</li>
<li>если было совпадение по одному из тэгов, то внутри этой кэш-линии ищем байт с адресом, совпадающим с младшей частью искомого адреса</li>
</ol>
<p>Этот вариант имеет гораздо меньше конфликтов, но сложен и дорог в реализации.</p>
<h4>Set associative mapping</h4>
<p>Когда говорят об N-ассоциативном кэше, то имеется в виду этот тип отображения с N каналами.</p>
<p>RAM делится так же, как и в прямом отображеии, а сам кэш состоит из k каналов, использующих прямое отображение. Кэш-линии, имеющие одинаковые номера во всех каналах, образуют <strong>сет</strong>.</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/5b0d916a6d1b2d80f8a658a58676d1c4/a296c/cpu-cache-set-associative-mapping-set.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 31%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAMF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB2QNAn//EABgQAAIDAAAAAAAAAAAAAAAAAAABAjFB/9oACAEBAAEFAmmZGv/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABgQAAIDAAAAAAAAAAAAAAAAAAABEBEh/9oACAEBAAY/AnpUf//EABoQAQACAwEAAAAAAAAAAAAAAAEAETFBYXH/2gAIAQEAAT8hArbsBzN+wJRn/9oADAMBAAIAAwAAABALz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABkQAQEAAwEAAAAAAAAAAAAAAAERACGxMf/aAAgBAQABPxBcKXI9YlG10133KsrXdXuf/9k='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Set Associative Mapping (Set)"
        title="Set Associative Mapping (Set)"
        src="/hows-that-again/static/5b0d916a6d1b2d80f8a658a58676d1c4/a111b/cpu-cache-set-associative-mapping-set.jpg"
        srcset="/hows-that-again/static/5b0d916a6d1b2d80f8a658a58676d1c4/aca85/cpu-cache-set-associative-mapping-set.jpg 163w,
/hows-that-again/static/5b0d916a6d1b2d80f8a658a58676d1c4/0954f/cpu-cache-set-associative-mapping-set.jpg 325w,
/hows-that-again/static/5b0d916a6d1b2d80f8a658a58676d1c4/a111b/cpu-cache-set-associative-mapping-set.jpg 650w,
/hows-that-again/static/5b0d916a6d1b2d80f8a658a58676d1c4/a296c/cpu-cache-set-associative-mapping-set.jpg 800w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/4f85224c39f0c2674ca2b73e58b550a6/a296c/cpu-cache-set-associative-mapping.jpg"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 51.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIBBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHtVSDVf//EABcQAQEBAQAAAAAAAAAAAAAAAAEAESD/2gAIAQEAAQUChId4/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFRABAQAAAAAAAAAAAAAAAAAAASD/2gAIAQEABj8Ca//EABkQAQEAAwEAAAAAAAAAAAAAAAEAETFRIf/aAAgBAQABPyEQ96zaRAMkhywctX//2gAMAwEAAgADAAAAEGzP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxABAAMBAAMAAAAAAAAAAAAAAQARITFhcZH/2gAIAQEAAT8QvwTFlhswvk1RXqWKpT3IBoPkAFAB4n//2Q=='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Set Associative Mapping"
        title="Set Associative Mapping"
        src="/hows-that-again/static/4f85224c39f0c2674ca2b73e58b550a6/a111b/cpu-cache-set-associative-mapping.jpg"
        srcset="/hows-that-again/static/4f85224c39f0c2674ca2b73e58b550a6/aca85/cpu-cache-set-associative-mapping.jpg 163w,
/hows-that-again/static/4f85224c39f0c2674ca2b73e58b550a6/0954f/cpu-cache-set-associative-mapping.jpg 325w,
/hows-that-again/static/4f85224c39f0c2674ca2b73e58b550a6/a111b/cpu-cache-set-associative-mapping.jpg 650w,
/hows-that-again/static/4f85224c39f0c2674ca2b73e58b550a6/a296c/cpu-cache-set-associative-mapping.jpg 800w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Структура адреса и тэга такая же, как и в прямом отображении, но алгоритм поиска отличается:</p>
<ol>
<li>извлекается средняя часть адреса, определяющая номер сэта в кеше</li>
<li>тэги всех кэш-линий данного сета сравниваются со старшей частью одновременно</li>
<li>если было совпадение по одному из тэгов, то внутри этой кэш-линии ищем байт с адресом, совпадающим с младшей частью искомого адреса</li>
</ol>
<p>Таким образом, количество каналов кэша определяет количество одновременно сравниваемых тэгов.</p>
<p>Этот вариант является общепринятым компромиссом между сложностью реализации и эффективностью.</p>
<h3>Категории промахов</h3>
<ul>
<li><strong>Промах по чтению из кэша инструкций</strong>. Обычно дает очень большую задержку, поскольку процессор не может продолжать исполнение программы (по крайней мере, текущего потока исполнения) и вынужден простаивать в ожидании загрузки инструкции из памяти.</li>
<li><strong>Промах по чтению из кэша данных.</strong> Обычно дает меньшую задержку, поскольку инструкции, не зависящие от запрошенных данных, могут продолжать исполняться, пока запрос обрабатывается в основной памяти. После получения данных из памяти можно продолжать исполнение зависимых инструкций.</li>
<li><strong>Промах по записи в кэш данных</strong>. Обычно дает наименьшую задержку, поскольку запись может быть поставлена в очередь и последующие инструкции практически не ограничены в своих возможностях. Процессор может продолжать свою работу, кроме случаев промаха по записи с полностью заполненной очередью.</li>
</ul>
<h3>Согласованность кэшей</h3>
<p>Кэш L1 - свой у каждого ядра. То есть у нас в несколько разных кэшей копируются одни и те же данные из памяти. Так как они используются на чтение и запись разными потоками, то теоретически могут рассинхронизироваться и значение какого-то адреса в одном кэше может не совпадать со значением этого же адреса в другом.</p>
<p>На практике аппаратные кэши в современных процессорах всегда синхронизируются. Это значит, что если два разных потока в любом месте системы читают данные с одного и того же адреса памяти, то они никогда не должны <em>одновременно</em> считывать разные значения.</p>
<p>Наиболее распространенный протокол для обеспечения согласованности между кэшами известен как протокол MESI. </p>
<h4>MESI</h4>
<p>Каждая строка данных в кэше помечена одним из следующих состояний:</p>
<ol>
<li><strong>М</strong>odified - данные модифицированы и отличаются от основной памяти. Являются источником истины, а все остальные источники устарели.</li>
<li><strong>E</strong>xclusive - данные не модифицированы и синхронизированы с основной памятью. Ни в одном другом кэше того же уровня нет этих данных.</li>
<li><strong>S</strong>hared - данные не модифицированы и синхронизированы с общей памятью. В других кэшах того же уровня (возможно) есть те же данные</li>
<li><strong>I</strong>nvalid - данные устарели и не должны использоваться</li>
</ol>
<p>Применяя и обновляя эти состояния, можно добиться согласованности кэша.</p>
<p>Рассмотрим несколько примеров для процессора с четырьмя ядрами, у каждого из которых собственный кэш L1, а также глобальный кэш L2 на кристалле.</p>
<h5>Запись в память</h5>
<p>Предположим, что поток на core-1 хочет записать в память по адресу 0xabcd. Ниже приведены некоторые возможные последовательности событий.</p>
<h6>Попадание в кэш</h6>
<p>В L1-1 есть данные в состоянии E или M.
L1-1 производит запись. Всё готово.
Ни в одном другом кэше нет данных, так что немедленная запись будет безопасной.
Состояние строки кэша изменяется на M, поскольку она теперь изменена.</p>
<h6>Промах локального кэша, попадание одноуровневого кэша</h6>
<p>В L1-1 есть данные в состоянии S.
Это значит, что в другом одноуровневом кэше могут быть эти данные.
Та же последовательность применяется, если в L1-1 вообще нет этих данных.
L1-1 отправляет Request-For-Ownership в кэш L2.
L2 смотрит по своему каталогу и видит, что в L1-2 сейчас есть эти данные в состоянии S.
L2 отправляет snoop-invalidate в L1-2.
L1-2 помечает данные как недействительные (I).
L1-2 отправляет запрос Ack в L2.
L2 отправляет Ack вместе с последними данными в L1-1.
L2 проверяет, что в L1-1 эти данные хранятся в состоянии E.
В L1-1 теперь последние данные, а также разрешение войти в состояние E.
L1-1 осуществляет запись и изменяет состояние этих данных на M.</p>
<h5>Чтение памяти</h5>
<p>Теперь предположим, что поток на core-2 хочет считать с адреса 0xabcd. Ниже приведены некоторые возможные последовательности событий.</p>
<h6>Попадание кэша</h6>
<p>L1-2 имеет данные в состоянии S, E или M.
L1-2 считывает данные и возвращает в поток. Готово.</p>
<h6>Промах локального кэша, промах кэша верхнего уровня</h6>
<p>L1-2 имеет данные в состоянии I (недействительное), то есть не может их использовать.
L1-2 отправляет запрос Request-for-Share в кэш L2.
В L2 тоже нет данных. Он считывает данные из памяти.
L2 возвращает данные из памяти.
L2 отправляет данные в L1-2 с разрешением войти в состояние S.
L2 проверяет, что в L1-2 эти данные хранятся в состоянии S.
L1-2 получает данные, сохраняет их в кэше и отправляет в поток.</p>
<h6>Промах локального кэша, попадание кэша верхнего уровня</h6>
<p>В L1-2 есть данные в состоянии I.
L1-2 отправляет запрос Request-for-S в кэш L2.
L2 видит, что в L1-1 данные в состоянии S.
L2 отправляет Ack в L1-2, вместе с данными и разрешением войти в состояние S.
L1-2 получает данные, сохраняет их в кэше и отправляет в поток.</p>
<h6>Промах локального кэша, попадание одноуровневого кэша</h6>
<p>В L1-2 есть данные в состоянии I.
L1-2 отправляет запрос Request-for-S в кэш L2.
L2 видит, что в L1-1 данные в состоянии E (или M).
L2 отправляет snoop-share в L1-1
L1-1 понижает состояние до S.
L1-1 отправляет Ack в L2 вместе с модифицированными данными, если это применимо.
L2 отправляет Ack в L1-2 вместе с данными и разрешением войти в состояние S.
L1-2 получает данные, сохраняет их в кэше и отправляет в поток.</p>
<h1>Дисковая память</h1>
<p>Магнитный жесткий диск состоит из набора металлических пластин, которые вертятся на шпинделе со скоростью 5400-15000 оборотов в минуту. Пластины покрыты с обоих сторон магнитным записываемым материалом, похожим на материал, которым покрываются аудио- или видеокассеты. Чтобы читать и писать информацию на диск, над каждой поверхностью размещается перемещаемая ручка, содержащая на конце маленькую электромагнитную спираль, называемую <em>головкой чтения/записи</em>.</p>
<p>Каждая поверхность пластин радлелена на концентрические окружности, называемые "треками". На каждой десятки тысяч таких треков. Каждый трек делится ена сектора, содержащие информацию: на каждом треке тысячи секторов. В секторе обычно от 512 до 4096 байт. На пластине записаны последовательно: номер сектора, пустой промежуток, кусок данных, включающий код коррекции, пустой промежуток, следующий кусок данных с кодом коррекции, и так далее.</p>
<p>Головки дисков соединены и двигаются вместе, так что каждая головка находится над одним и тем же треком. Словом <strong>цилиндр</strong> обозначаются все треки под всеми головками.</p>
<p>Чтобы обратиться к данным, нужно пройти 3 шага:</p>
<ol>
<li>Позиционируем головку над нужным треком. Эта операция называется <strong>seek</strong>.</li>
<li>Дождаться, пока нужный сектор попадет под головку. Это время называется <strong>rotational latency</strong> или <strong>rotational delay</strong>. </li>
<li>Передать блок данных. Время передачи зависит от размера сектора, скорости вращения и плотности записи.</li>
</ol>
<p>Большинство контроллеров дисков имеют встроенный кэш, который сохраняет все сектора, которые через него проходят.</p></div></div></div></div></div></div></div><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym");ym(56098288,"init",{"clickmap":true,"trackLinks":true,"accurateTrackBounce":true,"webvisor":true,"trackHash":true});</script><noscript><div><img src="https://mc.yandex.ru/watch/56098288" style="position:absolute;left:-9999px" alt=""/></div></noscript><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/blog/books/computer-organization-and-design";window.webpackCompilationHash="b5e245c03e282d84e836";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-3dcf91bf32bdecf8876c.js"],"component---src-templates-blog-template-js":["/component---src-templates-blog-template-js-e63d8ebd92abd897e273.js"],"component---src-pages-404-js":["/component---src-pages-404-js-54ff81d98f14a7da0346.js"],"component---src-pages-index-jsx":["/component---src-pages-index-jsx-e7d38443bba19f46db0c.js"],"component---src-pages-page-2-js":["/component---src-pages-page-2-js-e56f5911a753d0d06680.js"]};/*]]>*/</script><script src="/hows-that-again/component---src-templates-blog-template-js-e63d8ebd92abd897e273.js" async=""></script><script src="/hows-that-again/commons-4f66cda7900e280efdae.js" async=""></script><script src="/hows-that-again/app-3dcf91bf32bdecf8876c.js" async=""></script><script src="/hows-that-again/webpack-runtime-6740470ac5418527fb73.js" async=""></script></body></html>