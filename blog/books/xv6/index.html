<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="preload" href="/hows-that-again/component---src-layouts-index-js-6ed608cdf879d3b0dfb1.js" as="script"/><link rel="preload" href="/hows-that-again/component---src-templates-blog-template-js-40956da8f886eafeb36f.js" as="script"/><link rel="preload" href="/hows-that-again/path---blog-books-xv-6-9023bac90e984ef3e566.js" as="script"/><link rel="preload" href="/hows-that-again/app-f5de8f78c377ac2d1842.js" as="script"/><link rel="preload" href="/hows-that-again/commons-afb5782224ac01f1fa03.js" as="script"/><title data-react-helmet="true">How&#x27;s that again?</title><meta data-react-helmet="true" name="description" content="Sample"/><meta data-react-helmet="true" name="keywords" content="sample, something"/><style id="gatsby-inlined-css">html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:112.5%/1.45em georgia,serif;box-sizing:border-box;overflow-y:scroll}*,:after,:before{box-sizing:inherit}body{color:rgba(0,0,0,.8);font-family:georgia,serif;font-weight:400;word-wrap:break-word;-webkit-font-kerning:normal;font-kerning:normal;-ms-font-feature-settings:"kern","liga","clig","calt";-webkit-font-feature-settings:"kern","liga","clig","calt";font-feature-settings:"kern","liga","clig","calt","kern"}img{max-width:100%;margin:0 0 1.45rem;padding:0}h1{font-size:2.25rem}h1,h2{margin:0 0 1.45rem;padding:0;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h2{font-size:1.62671rem}h3{font-size:1.38316rem}h3,h4{margin:0 0 1.45rem;padding:0;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h4{font-size:1rem}h5{font-size:.85028rem}h5,h6{margin:0 0 1.45rem;padding:0;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h6{font-size:.78405rem}hgroup{margin:0 0 1.45rem;padding:0}ol,ul{margin:0 0 1.45rem 1.45rem;padding:0;list-style-position:outside;list-style-image:none}dd,dl,figure,p{margin:0 0 1.45rem;padding:0}pre{padding:0;font-size:.85rem;line-height:1.42;background:rgba(0,0,0,.04);border-radius:3px;overflow:auto;word-wrap:normal;padding:1.45rem}pre,table{margin:0 0 1.45rem}table{padding:0;font-size:1rem;line-height:1.45rem;border-collapse:collapse;width:100%}fieldset{margin:0 0 1.45rem;padding:0}blockquote{margin:0 1.45rem 1.45rem;padding:0}form,iframe,noscript{margin:0 0 1.45rem;padding:0}hr{margin:0 0 calc(1.45rem - 1px);padding:0;background:rgba(0,0,0,.2);border:none;height:1px}address{margin:0 0 1.45rem;padding:0}b,dt,strong,th{font-weight:700}li{margin-bottom:.725rem}ol li,ul li{padding-left:0}li>ol,li>ul{margin-left:1.45rem;margin-bottom:.725rem;margin-top:.725rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,abbr[title],acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}abbr[title]{text-decoration:none}td,th,thead{text-align:left}td,th{border-bottom:1px solid rgba(0,0,0,.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding:.725rem .96667rem calc(.725rem - 1px)}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:SFMono-Regular,Consolas,Roboto Mono,Droid Sans Mono,Liberation Mono,Menlo,Courier,monospace;padding:0;padding-top:.2em;padding-bottom:.2em}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{letter-spacing:-.2em;content:" "}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}@media only screen and (max-width:480px){html{font-size:100%}}</style></head><body><div id="___gatsby"><div data-reactroot="" data-reactid="1" data-react-checksum="1511498183"><!-- react-empty: 2 --><div style="background:rebeccapurple;margin-bottom:1.45rem;" data-reactid="3"><div style="margin:0 auto;max-width:960px;padding:1.45rem 1.0875rem;" data-reactid="4"><h1 style="margin:0;" data-reactid="5"><a style="color:white;text-decoration:none;" href="/hows-that-again/" data-reactid="6">How&#x27;s that again?</a></h1></div></div><div style="margin:0 auto;max-width:960px;padding:0px 1.0875rem 1.45rem;padding-top:0;" data-reactid="7"><div class="blog-post-container" data-reactid="8"><div class="blog-post" data-reactid="9"><div class="blog-post-content" data-reactid="10"><p><a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">Комментарии к исходному коду</a>
<a href="https://github.com/YehudaShapira/xv6-explained/blob/master/Explanations.md">Еще комментарии</a></p>
<p><a href="https://pdos.csail.mit.edu/6.828/2018/xv6/xv6-rev11.pdf">Исходный код</a></p>
<h1>xv6</h1>
<p>Важное замечание для начала: во всех ассемблерах UNIX, включая используемый здесь, команда mov имеет следующий синтаксис: <code>MOV src dest</code>.</p>
<p>То есть <code>mov $a $b</code> означает, что значение регистра a будет присвоено регистру b.</p>
<h2>Основные понятия</h2>
<h3>Процесс</h3>
<p>Память любого процесса состоит из 3 частей: инструкции, данные, стек.</p>
<h3>fork</h3>
<p>Создает новый процесс (child process), содержимое памяти которого идентично содержимому памяти вызывающего процесса (parent process). Но это не одна и та же память, это копия. Так как память у процессов одинаковая, значит одинаковые и инструкции, значит в обоих процессах выполнение продолжается со следующей инструкции. Только в child process функция fork возвращает 0, а в родительском - pid созданного процесса.</p>
<pre><code class="language-c">int pid = fork();
if(pid > 0){
    printf("parent: child=%d\n", pid);
    pid = wait();
    printf("child %d is done\n", pid);
} else if(pid == 0){
    printf("child: exiting\n");
    exit();
} else {
    printf("fork error\n");
}
</code></pre>
<p><code>exit</code> - запускает процедуру выхода из процесса и освобождает ресурсы (память, открытые файлы)</p>
<p><code>wait</code> - ожидает завершения дочернего процесса и возвращает его pid.</p>
<p>В приведенном примере на экран будет выдано:</p>
<pre><code>parent: child=1234
child: exiting
child 1234 is done
</code></pre>
<h3>exec</h3>
<p>Принимает в качестве аргумента путь к исполняемому файлу и заменяет память вызывающего процесса на память, загруженную из этого файла. Файл должен быть в специальном формате (ELF), в котором указано начало секции инструкций, начало секции данных, с какой инструкции начать выполнение и т.д. Если вызов exec совершен удачно, то выполнение продолжится с той инструкции, которая указана первой к исполнению в загруженном файле.</p>
<p>Пример:</p>
<pre><code class="language-c">char *argv[3];
argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");
</code></pre>
<p>Здесь исполняемая программа заменяется программой <code>/bin/echo</code>, которая получает в качестве списка аргументов <code>echo hello</code>.</p>
<h3>sh</h3>
<p>Шелл использует <code>fork</code> и <code>exec</code> для исполнения программ. В общем структура выполнения выглядит так:</p>
<pre><code class="language-c">int
main(void)
{
  static char buf[100];

  while(getcmd(buf, sizeof(buf)) >= 0){
    if(fork1() == 0)
      runcmd(parsecmd(buf));
    wait();
  }
  exit();
}

void
runcmd(struct cmd *cmd)
{
  struct execcmd *ecmd;

  switch(cmd->type){  
    ...
  case EXEC:
    ecmd = (struct execcmd*)cmd;
    exec(ecmd->argv[0], ecmd->argv);
    printf(2, "exec %s failed\n", ecmd->argv[0]);
    break;
    ...
  }
  exit();
}
</code></pre>
<ul>
<li><code>main</code> - делает дочерний процесс, в нем парсит команду, подает на выполнение</li>
<li><code>runcmd</code> - делает <code>exec</code>, заменяя текущий процесс (тот, который был создан форком в <code>main</code>) на исполняемый файл, указанный в команде</li>
</ul>
<p>После завершения дочернего процесса исполнение продолжается на инструкции, следующей за <code>wait()</code>.</p>
<h3>Дескрипторы файлов</h3>
<p>У каждого процесса свой набор дескрипторов файлов, начинающийся с 0. По соглашению, 0 - дескриптор стандартного ввода/stdin, 1 - стандартного вывода/stdout, 2 - дескриптор канала ошибок/stderr.</p>
<p>При открытии файла он всегда получает наименьший из неиспользуемых в текущем процессе дексрипторов.</p>
<p>Вот так, например, выглядит <code>cat</code>:</p>
<pre><code class="language-c">char buf[512];

void
cat(int fd)
{
  int n;

  while((n = read(fd, buf, sizeof(buf))) > 0) { // читаем из указанного дескриптора
    if (write(1, buf, n) != n) {  // пишем в 1, то есть stdout
      printf(1, "cat: write error\n");
      exit();
    }
  }

  // error handling
  if(n &#x3C; 0){
    printf(1, "cat: read error\n");
    exit();
  }
}

int
main(int argc, char *argv[])
{
  int fd, i;

  if(argc &#x3C;= 1){ // если аргументов не указано, то читаем из 0, то есть stdin
    cat(0);
    exit();
  }

  for(i = 1; i &#x3C; argc; i++){ // если аргументы есть, то открываем файлы по этим путям и читаем из дескрипторов этих файлов
    if((fd = open(argv[i], 0)) &#x3C; 0){
      printf(1, "cat: cannot open %s\n", argv[i]);
      exit();
    }
    cat(fd);
    close(fd);
  }
  exit();
}
</code></pre>
<h4>Перенаправление I/O</h4>
<p><code>exec</code> заменяет содержимое памяти вызывающего процесса, но при этом <strong>оставляет неизменной его таблицу дескрипторов</strong>. Это позволяет реализовать перенаправление I/O. Вот, что происходит при вызове <code>cat &#x3C; input.txt</code>:</p>
<pre><code class="language-c">char *argv[2];
argv[0] = "cat";
argv[1] = 0;
if(fork() == 0) {
    close(0);
    open("input.txt", O_RDONLY);
    exec("cat", argv);
}
</code></pre>
<p>Здесь используется правило "При открытии файла он всегда получает наименьший из неиспользуемых в текущем процессе дексрипторов". Когда вызывается <code>close(0)</code>, дескриптор 0 (stdin) освобождается, а значит следующая инструкция <code>open</code> назначит открытому файлу <code>input.txt</code> дексриптор 0. Затем вызывается программа <code>cat</code>, которая при вызове без аргументов читает содержимое из дескриптора 0.</p>
<p>В коде шелла этот кусок выглядит так:</p>
<pre><code class="language-c">void
runcmd(struct cmd *cmd)
{
  struct redircmd *rcmd;

    switch(cmd->type){
  ...

  case REDIR:
    rcmd = (struct redircmd*)cmd;
    close(rcmd->fd);
    if(open(rcmd->file, rcmd->mode) &#x3C; 0){
      printf(2, "open %s failed\n", rcmd->file);
      exit();
    }
    runcmd(rcmd->cmd);
    break;
    ...
  }
  exit();
}

...

struct cmd*
parseredirs(struct cmd *cmd, char **ps, char *es)
{
  int tok;
  char *q, *eq;

  while(peek(ps, es, "&#x3C;>")){
    tok = gettoken(ps, es, 0, 0);
    switch(tok){
    case '&#x3C;':
      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
      break;
    case '>':
      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
      break;
    case '+':  // >>
      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
      break;
    }
  }
  return cmd;
}
</code></pre>
<p><code>rcmd</code> при парсинге получит <code>fd</code>, равный 0, при использовании <code>&#x3C;</code> и равный 1 при использовании <code>></code>. В ветке <code>REDIR</code> мы закрыли дексриптор, на который будем перенаправлять ввод или вывод, открыли нужный файл и вызвали <code>runcmd</code>, внутри которого будет использован <code>exec</code>.</p>
<h4>Использование дескрипторов в fork</h4>
<p>При форке таблица дескрипторов копируется, а сдвиги - шарятся между процессами. То есть следующий пример:</p>
<pre><code class="language-c">if(fork() == 0) {
    write(1, "hello ", 6);
    exit();
} else {
    wait();
    write(1, "world\n", 6);
}
</code></pre>
<p>Выведет на экран <code>hello world</code>. </p>
<p>Благодаря этому мы можем писать: <code>(echo hello; echo world)>output.txt</code>. (хотя пока непонятно, почему тут должен вызываться fork, а не exec).</p>
<h4>dup</h4>
<p>Копирует дескриптор, после чего оба дескриптора шарят сдвиг.</p>
<p>То есть:</p>
<pre><code class="language-c">fd = dup(1);
write(1, "hello ", 6);
write(fd, "world\n", 6);
</code></pre>
<p>тоже выведет <code>hello world</code>.</p>
<p>Таким образом, два дексриптора файла шарят между собой сдвиг только в том случае, если они были получены из одного и того же дескриптора вызовами <code>fork</code> и <code>dup</code>. Во всех остальных случаях сдвиги не шарятся.</p>
<p><code>dup</code> позволяет писать такие команды:</p>
<pre><code class="language-shell">ls existing-file non-existing-file > tmp1 2>&#x26;1
</code></pre>
<p>Здесь <code>2>&#x26;1</code> как раз копирует дексриптор 1 в дескриптор 2, чтобы все ошибки выводились в stdout.</p>
<h3>pipes</h3>
<p>Вызов <code>pipe</code> принимает массив из двух элементов и записывает в него 2 дексриптора: первый - для чтения и второй - для записи. Все, что будет записано в дексриптор для записи, можно будет прочитать из дескриптора для чтения.</p>
<p>Пример использования <code>pipe</code>:</p>
<pre><code class="language-c">int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;

pipe(p);
if(fork() == 0) {
    close(0);
    dup(p[0]);
    close(p[0]);
    close(p[1]);
    exec("/bin/wc", argv);
} else {
    close(p[0]);
    write(p[1], "hello world\n", 12);
    close(p[1]);
}
</code></pre>
<p>Здесь дочерний процесс закрывает <code>stdin</code>, дублирует дескриптор чтения из пайпа в дескриптор 0, закрывает дескриптор чтения и записи и запускает <code>wc</code>, который будет принимать ввод от дескриптора 0, то есть будет читать из пайпа.</p>
<p>Родительский процесс пишет в дескриптор записи и закрывает оба дескриптора пайпа.</p>
<p>Приблизительно так же выглядит и ветка <code>PIPE</code> в <code>runcmd</code>, только она создает 2 дочерних процесса:</p>
<pre><code class="language-c">void
runcmd(struct cmd *cmd)
{
   struct pipecmd *pcmd;
 
  switch(cmd->type){
    ...
  case PIPE:
    pcmd = (struct pipecmd*)cmd;
    if(pipe(p) &#x3C; 0)
      panic("pipe");
    if(fork1() == 0){
      close(1);
      dup(p[1]);
      close(p[0]);
      close(p[1]);
      runcmd(pcmd->left);
    }
    if(fork1() == 0){
      close(0);
      dup(p[0]);
      close(p[0]);
      close(p[1]);
      runcmd(pcmd->right);
    }
    close(p[0]);
    close(p[1]);
    wait();
    wait();
    break;
    ...
  }
  exit();
}
</code></pre>
<p>В шелле пайпы используются при выполнении команд вида <code>grep fork sh.c | wc -l</code>.</p>
<p>Преимущества пайпов перед временными файлами:</p>
<ul>
<li>автоматическое очищение</li>
<li>можно передавать очень длинные потоки данных, не беспокоясь, что на диске кончится место</li>
<li>возможно параллельное выполнение левой и правой команды</li>
<li>для межпроцессного общения блокирующая модель записи и чтения пайпов удобнее, чем неблокирующая модель файлов</li>
</ul>
<h3>Файловая система</h3>
<p><code>fstat</code> - возвращает информацию о файле, на который указывает дескрриптор</p>
<p>У файла может быть несколько имен, или "линков". Сам файл называется <code>inode</code>. Линки создаются командой <code>link</code>, например:</p>
<pre><code class="language-c">open("a", O_CREATE|O_WRONLY);
link("a", "b");
</code></pre>
<p>После этого <code>a</code> и <code>b</code> ссылаются на один и тот же <code>inode</code> и запись/чтение в <code>a</code> равносильно записи/чтению в <code>b</code>.</p>
<p>Каждый айнод идентифицируется своим <code>inode number</code>. Его можно получить вызовом <code>fstat</code>.</p>
<p>Линки удаляются командой <code>unlink</code>. Айнод и место на диске очищаются только когда количество линков уменьшится до 0 и не останется дескрипторов, ссылающихся на него.</p>
<h2>Организация операционной системы</h2>
<h3>Загрузчик</h3>
<p>Загрузчик состоит из 2 частей: <code>bootasm.s</code>, написанный на ассемблере и <code>bootmain.c</code>, написанный на С.</p>
<p>Когда компьютер стартует, он выполняет программу BIOS, которая записана в энергонезависимой памяти материнской платы. BIOS подготавливает аппаратное обеспечение к работе и передает управление коду, записанному в загрузочный сектор, т.е. первый 512-байтовый сектор загрузочного диска. В этом секторе содержится загрузчик: инструкции по загрузке ядра в память. BIOS загружает содержимое загрузочного сектора в адрес <code>0x7c00</code> и переходит на этот адрес. Начинается исполнение файла <code>bootasm.s</code>.</p>
<p>Первая инструкция загрузчика - <code>cli</code>, которая отключает прерывания. BIOS возможно установил какие-то свои обработчики прерываний, чтобы инициализировать устройства, но мы уже покинули BIOS, поэтому они нам больше не нужны. Когда операционная система загрузится, она включит прерывания обратно.</p>
<p>Затем загрузчик должен перевести процессор из реального режима работы в защищенный.</p>
<p>После этого загрузчик переходит в <code>bootmain.c</code>.</p>
<p>Задача <code>bootmain.c</code> - загрузить и запустить ядро. Ядро должно быть в формате ELF. <code>bootmain</code> загружает первые 4096 байт из бинарника ELF и кладет их копию по адресу <code>0x10000</code>. Затем он проверяет, что это действительно ELF путем проверки магического числа в заголовке файла. Затем он проходит по всем сегментам файла, загружает их в память и переходит в точку входа в ядро, а именно <code>0x10000c</code>.</p>
<h3>Старт ядра</h3>
<p>Когда загрузчик передает управления в ядро, первая выполняемая инструкция - это <code>entry:</code> в файле <code>entry.s</code>. Первое, что делает ядро - это настраивает аппаратный пэйджинг. Добавляется маппинг виртуальных адресов, начинающихся с <code>0x80000000</code> на физические, начинающиеся с <code>0x0</code>:</p>
<pre><code class="language-asm">  movl    $(V2P_WO(entrypgdir)), %eax
  movl    %eax, %cr3
</code></pre>
<p><code>V2P_WO</code>(virtual to physical) - это макрос, который отнимает от "высокого" адреса <code>entrypgdir</code> константу <code>0x80000000</code>. Это нужно, потому что у нас еще не работает маппинг виртуальных адресов, но ядро слинковано с их использованием.</p>
<p>Таблица страниц entrypgdir описана в main.c:</p>
<pre><code class="language-c">__attribute__((__aligned__(PGSIZE)))
pde_t entrypgdir[NPDENTRIES] = {
  // Map VA's [0, 4MB) to PA's [0, 4MB)
  [0] = (0) | PTE_P | PTE_W | PTE_PS,
  // Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)
  [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
};
</code></pre>
<p>Затем ядро включает аппаратный пейджинг:</p>
<pre><code>  orl     $(CR0_PG|CR0_WP), %eax
  movl    %eax, %cr0
</code></pre>
<p>Ну и наконец мы переходим в <code>main.c</code>:</p>
<pre><code class="language-asm">  # Set up the stack pointer.
  movl $(stack + KSTACKSIZE), %esp

  # Jump to main(), and switch to executing at
  # high addresses. The indirect call is needed because
  # the assembler produces a PC-relative instruction
  # for a direct jump.
  mov $main, %eax
  jmp *%eax
</code></pre>
<h3>Создание первого процесса</h3>
<p>Процесс описывается следующей структурой:</p>
<pre><code class="language-c">// Per-process state
struct proc {
  uint sz;                     // Size of process memory (bytes)
  pde_t* pgdir;                // Page table
  char *kstack;                // Bottom of kernel stack for this process
  enum procstate state;        // Process state
  int pid;                     // Process ID
  struct proc *parent;         // Parent process
  struct trapframe *tf;        // Trap frame for current syscall
  struct context *context;     // swtch() here to run process
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory
  char name[16];               // Process name (debugging)
};

struct context {
  uint edi;
  uint esi;
  uint ebx;
  uint ebp;
  uint eip;
};
</code></pre>
<p><code>main</code> инициализирует кучу устройств и подсистем:</p>
<pre><code class="language-c">// Bootstrap processor starts running C code here.
// Allocate a real stack and switch to it, first
// doing some setup required for memory allocator to work.
int
main(void)
{
  kinit1(end, P2V(4*1024*1024)); // phys page allocator
  kvmalloc();      // kernel page table
  mpinit();        // detect other processors
  lapicinit();     // interrupt controller
  seginit();       // segment descriptors
  picinit();       // disable pic
  ioapicinit();    // another interrupt controller
  consoleinit();   // console hardware
  uartinit();      // serial port
  pinit();         // process table
  tvinit();        // trap vectors
  binit();         // buffer cache
  fileinit();      // file table
  ideinit();       // disk 
  startothers();   // start other processors
  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
  userinit();      // first user process
  mpmain();        // finish this processor's setup
}
</code></pre>
<p>Первый процесс создается вызовом <code>userinit()</code>, который вызывает <code>allocproc()</code>. Задача <code>allocproc()</code> - аллоцировать структуру типа <code>proc</code> в системной таблице процессов и инициализировать части состояния процесса, чтобы он мог запуститься. <code>allocproc()</code> запускается для каждого нового процесса, а <code>userinit()</code> - только для первого.</p>
<pre><code class="language-c">// Look in the process table for an UNUSED proc.
// If found, change state to EMBRYO and initialize
// state required to run in the kernel.
// Otherwise return 0.
static struct proc*
allocproc(void)
{
  struct proc *p;
  char *sp;

  acquire(&#x26;ptable.lock);

  for(p = ptable.proc; p &#x3C; &#x26;ptable.proc[NPROC]; p++)
    if(p->state == UNUSED)
      goto found;

  release(&#x26;ptable.lock);
  return 0;

found:
  p->state = EMBRYO;
  p->pid = nextpid++;

  release(&#x26;ptable.lock);

  // Allocate kernel stack.
  if((p->kstack = kalloc()) == 0){
    p->state = UNUSED;
    return 0;
  }
  sp = p->kstack + KSTACKSIZE;

  // Leave room for trap frame.
  sp -= sizeof *p->tf;
  p->tf = (struct trapframe*)sp;

  // Set up new context to start executing at forkret,
  // which returns to trapret.
  sp -= 4;
  *(uint*)sp = (uint)trapret;

  sp -= sizeof *p->context;
  p->context = (struct context*)sp;
  memset(p->context, 0, sizeof *p->context);
  p->context->eip = (uint)forkret;

  return p;
}
</code></pre>
<ul>
<li>регистр EIP в x86 означает Extended Instruction Pointer</li>
</ul>
<p>Allocproc:</p>
<ol>
<li>ищет в таблице процессов слот с состоянием UNUSED</li>
<li>когда находит, устанавливает ему состояние EMBRYO и дает процессу уникальный pid.</li>
<li>затем пытается выделить в памяти 4096 байт для ядерного стека процесса. Если не получается, то выставляет состояние обратно в UNUSED и возвращает 0.</li>
<li>если получилось, то поля структуры proc инициализируются адресами в стеке для trap frame, trapret, context. В результате полученный ядерный стек выглядит так:</li>
</ol>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/d05989cf0b10a4cc4b2d7a61cf6fb487/f7060/new-kernel-stack.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block;  max-width: 325px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 105.23076923076921%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsSAAALEgHS3X78AAACPElEQVQ4y5VVia7iMAzk/38NCR4rbomr9L6gB6XlmvX4vfLYcm6kyGlCJvZ4bFr4GZfLRe3pdITnuYjCEI7rwfN9eK4Lx3FQlhWyLENVVTgcDnqHlt/H41Hvtx4BmuYaYeDDth0FWq8NWKaJNM3Q+/pCFEWIZY7HY8SbjeynCIJAQa+At6CvRlEUCriJY/T7fSQCVhQ7+BJJWZb3HtI+mufzWc834pFlWQoaBCFiAebatm0NvfXKmxrs9sEkSbDdbtXDTqeDPN9hv98jFM4/AmwCE4yXmRyu8zzXyZAV8FmIt/N28HIggEmyhWGskAow9zzPe+9hPdI0wXKx1EwOBgPNvCVKaLfbcD1feb1yuFqtsFjM5TVDyV7MuTZhyutr04L5s0dL/obDoUgqwHQ6xZ9eTx8oir3uKaAromX8tNSU73vqCYUdRbHyxfVWwBgaAfm7MAzQ7XZVNrvd7pdD/OeoLzMhhrFWUTNBVw4/TcZtUsgh9UfeyB/BuffQw98SPEnIofI6XyywXK7Um9lsho0AxHLWEw7TjDoslKaXgKyMLEs1EcqjVAO9G41G+s0SZPjce8vhq5rmJdZsc5DHf2r5k5r+1mSq3jUHI3kI+K4Ms4wh5nAdG9PJBOPJFJX0xKcePvOy7ja8WAhnBGVPDEWrPKfnCtgMqWkfyYbd5b4803sPm2Bl+V1SFC0rqKwOor9Is1orofacWlRA6o0AtM1WxabgCFdzqeWlaDEII+3S7DYUdj31L0Eswf8C0/9bMV1u3ygAAAAASUVORK5CYII='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="New kernel stack"
        title=""
        src="/hows-that-again/static/d05989cf0b10a4cc4b2d7a61cf6fb487/f7060/new-kernel-stack.png"
        srcset="/hows-that-again/static/d05989cf0b10a4cc4b2d7a61cf6fb487/c5e8e/new-kernel-stack.png 163w,
/hows-that-again/static/d05989cf0b10a4cc4b2d7a61cf6fb487/f7060/new-kernel-stack.png 325w"
        sizes="(max-width: 325px) 100vw, 325px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p>После заполнения стэка в <code>p->context->eip</code> будет адрес функции <code>forkret</code>, а над контекстом, там, где обычно пишется адрес возврата - будет адрес функции <code>trapret</code>. Созданный поток начинает выполнение со значениями регистров, скопированными из <code>p->context</code>, поэтому при старте потока в регистре EIP будет адрес <code>forkret</code> и начнет выполняться она. После выполнения будет возврат из функции, а значит переход к инструкции, которая располагается сразу над <code>p->context</code>, то есть <code>trapret</code>. <code>trapret</code> восстанавливает значение регистров из значений, сохраненных наверху стэка и прыгает внутрь процесса.</p>
<p>Такая сложная конструкция нужна, потому что этот же код используется и для форков. А <code>trapret</code> нужен потому что переход из юзерспейса в ядро происходит через исключения, или, как они называются в x86, трэпы. При трэпе выстреливается прерывание, побирается соответствующий обработчик прерывания, а этот обработчик сохраняет в стэк все значения регистров и вызывает функцию<code>trap()</code>.</p>
<p>После создания процесса, ему указывается программа для выполнения, и в случае userinit это программа <code>initcode.s</code>. Но чтобы ее запустить, нужно выделить память, чтобы хранить в ней эту программу, скопировать туда программу, и создать таблицу страниц для этого процесса:</p>
<pre><code class="language-c">void
userinit(void)
{
  struct proc *p;
  extern char _binary_initcode_start[], _binary_initcode_size[];

  p = allocproc();
  
  initproc = p;
  if((p->pgdir = setupkvm()) == 0)
    panic("userinit: out of memory?");
  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
  p->sz = PGSIZE;
  memset(p->tf, 0, sizeof(*p->tf));
  p->tf->cs = (SEG_UCODE &#x3C;&#x3C; 3) | DPL_USER;
  p->tf->ds = (SEG_UDATA &#x3C;&#x3C; 3) | DPL_USER;
  p->tf->es = p->tf->ds;
  p->tf->ss = p->tf->ds;
  p->tf->eflags = FL_IF;
  p->tf->esp = PGSIZE;
  p->tf->eip = 0;  // beginning of initcode.S

  safestrcpy(p->name, "initcode", sizeof(p->name));
  p->cwd = namei("/");

  // this assignment to p->state lets other cores
  // run this process. the acquire forces the above
  // writes to be visible, and the lock is also needed
  // because the assignment might not be atomic.
  acquire(&#x26;ptable.lock);

  p->state = RUNNABLE;

  release(&#x26;ptable.lock);
}
</code></pre>
<p>Процедура <code>setupkvm</code> создает таблицу страниц для нашего процесса. </p>
<p><code>inituvm</code> загружает по 0-му адресу выделенной процессу памяти содержимое скомпилированной процедуры <code>initcode</code>, константы <code>_binary_initcode_start</code> и <code>_binary_initcode_size</code> прописываются в процессе билда ядра и обозначают начало и размер эмбеженной в ядро функции <code>initcode</code>.</p>
<p>Затем <code>userinit</code> заполняет трэпфрейм, записывая в регистры сегментов селектор сегмента <code>SEG_UCODE</code> и <code>SEG_UDATA</code> с уровнем привилегий <code>DPL_USER</code>, не позволяющим работать в режиме ядра. Указатель стека %esp выставляется в самый большой виртуальный адрес, доступный процессу, а указатель инструкций выставляется в самый маленький, то есть 0. <code>p->name</code> выставляется в основном для отладки, <code>p->cwd</code> выставляет рабочую папку. </p>
<p>Когда заполнили все поля процесса, он ставится в очередь на выполнение путем установки поля <code>state</code> в <code>RUNNABLE</code>.</p>
<h3>Запуск первого процесса</h3>
<p>Итак, первый процесс готов к запуску, а мы выходим из <code>userinit</code> обратно в <code>main</code> и следующая строчка вызывает <code>mpmain()</code>, который вызывает <code>scheduler()</code>.</p>
<p><code>scheduler()</code> находится в <code>proc.c</code>, вот его код:</p>
<pre><code class="language-c">void
scheduler(void)
{
  struct proc *p;
  struct cpu *c = mycpu();
  c->proc = 0;
  
  for(;;){
    // Enable interrupts on this processor.
    sti();

    // Loop over process table looking for process to run.
    acquire(&#x26;ptable.lock);
    for(p = ptable.proc; p &#x3C; &#x26;ptable.proc[NPROC]; p++){
      if(p->state != RUNNABLE)
        continue;

      // Switch to chosen process.  It is the process's job
      // to release ptable.lock and then reacquire it
      // before jumping back to us.
      c->proc = p;
      switchuvm(p);
      p->state = RUNNING;

      swtch(&#x26;(c->scheduler), p->context);
      switchkvm();

      // Process is done running for now.
      // It should have changed its p->state before coming back.
      c->proc = 0;
    }
    release(&#x26;ptable.lock);

  }
}
</code></pre>
<p>Шедулер проходит по всем процессам в <code>ptable</code> и ищет первый, у которого state равен <code>RUNNABLE</code>. Когда такой процесс найден, он записывается в переменную <code>proc</code> для процессора текущего треда, после чего вызывается <code>switchuvm(p)</code>, которая дает железу команду начать использовать таблицу страниц этого процесса (kvm означает kernel virtual memory, uvm означает user virtual memory).</p>
<p>Затем шедулер устанавливает state в RUNNING и вызывает <code>swtch</code>, чтобы переключиться на выбранный поток.</p>
<p>После переключения, поток начинает выполнять <code>forkret</code>, потому что <code>allocproc</code> записал ее адрес в <code>p->context->eip</code>. <code>forkret</code> что-то там инициализирует и возвращается. Затем, по заветам <code>allocproc</code>, выполняется <code>trapret</code>. Он восстанавливает регистры <code>gs</code>, <code>fs</code>, <code>es</code> и <code>ds</code> из стека (<code>swtch</code> делает то же самое, но для общих регистров). В данном случае они туда попали в процедуре <code>allocproc</code>, который пытался новому потоку создать такой стек, как будто он был создан ранее и мы на него переключились в процессе нормального context switch. В обычных ситуациях происходит настоящий context switch и эти регистры в стек попадают в процедуре <code>alltraps</code> (см. ниже).</p>
<pre><code class="language-asm">  # Return falls through to trapret...
.globl trapret
trapret:
  popal
  popl %gs
  popl %fs
  popl %es
  popl %ds
  addl $0x8, %esp  # trapno and errcode
  iret
</code></pre>
<p>Инструкция <code>iret</code> извлекает регистры <code>cs</code>, <code>eip</code>, <code>flags</code>, <code>esp</code> и <code>ss</code>. Следующей выполняется инструкция, адрес которой записан в <code>$eip</code>. В случае <code>initproc</code> это адрес 0, а <code>$esp</code> получает адрес 4096 (верх страницы, чтобы стек мог расти вниз). Это уже виртуальные адреса.</p>
<h3>Первый системный вызов: exec</h3>
<p>Первое, что делает <code>initcode.S</code> - это вызывает <code>exec</code>:</p>
<pre><code class="language-asm"># exec(init, argv)
.globl start
start:
  pushl $argv
  pushl $init
  pushl $0  // where caller pc would be
  movl $SYS_exec, %eax
  int $T_SYSCALL

# char init[] = "/init\0";
init:
  .string "/init\0"

# char *argv[] = { init, 0 };
.p2align 2
argv:
  .long init
  .long 0
</code></pre>
<p>Ну точнее она сначала кладет в стек аргументы командной строки (<code>$argv</code> = [init, 0]), адрес вызываемой программы (<code>$init</code> = "/init"), адрес возврата (0), а потом кладет в <code>$eax</code> номер системного вызова <code>exec</code> и выполняет инструкцию <code>int $T_SYSCALL</code> - это просьба выстрелить прерывание с номером, соответствующим системному вызову. Если все пройдет хорошо, то в результате в этом же процессе будет вызвана программа <code>/init</code>, заменив память процесса памятью этой программы.</p>
<p><code>/init</code> создаст дескриптор консоли, откроет дескрипторы 0, 1, 2, запустит шелл и будет в цикле принимать команды.</p>
<h2>Context switch</h2>
<p>Переключение контекста состоит из 3 шагов:</p>
<ol>
<li>Активация прерывания по таймеру</li>
<li>Вызов шедулера</li>
<li>Переключение контекста</li>
</ol>
<p>Рассмотрим шаги по отдельности:</p>
<h3>Активация прерывания по таймеру</h3>
<p>При билде скрипт <code>vectors.pl</code> генерирует обработчики для 256 прерываний, каждый из обработчиков выглядит приблизительно так:</p>
<pre><code class="language-asm">vector 32:
  pushl $0 //error code
  pushl $32 //vector number of timer interrupt
  jmp alltraps
</code></pre>
<p>Здесь мы видим обработчик прерывания с номером 32. Он пишет в стек 0 и 32 в качестве аргументов вызова и вызывает процедуру <code>alltraps</code>.</p>
<p>Эта процедура описана в файле <code>trapasm.S</code>, вот ее код:</p>
<pre><code class="language-asm">.globl alltraps
alltraps:
  # Build trap frame.
  pushl %ds #data segment register
  pushl %es #extra segment register
  pushl %fs #general segment register
  pushl %gs #general segment register
  pushal    #all local registers (push EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI)
  
  # Set up data segments.
  movw $(SEG_KDATA&#x3C;&#x3C;3), %ax
  movw %ax, %ds
  movw %ax, %es

  # Call trap(tf), where tf=%esp
  pushl %esp
  call trap
  addl $4, %esp

  # Return falls through to trapret...
.globl trapret
trapret:
  popal
  popl %gs
  popl %fs
  popl %es
  popl %ds
  addl $0x8, %esp  # trapno and errcode
  iret
</code></pre>
<p>Итак, процедура <code>alltraps</code> сохранила на стеке значение регистров. Регистр esp мы не трогали, но каждый пуш уменьшает его значение, поэтому сейчас он указывает на низ фрейма. а над ним - сохраненные нами регистры и сегменты. Передавая значение регистра esp внутрь процедуры <code>trap</code>, мы, таким образом, передаем внутрь ее структуру <code>tf</code> типа <code>trapframe</code>. Вот код структуры:</p>
<pre><code class="language-c">struct trapframe {
  // registers as pushed by pusha
  uint edi;
  uint esi;
  uint ebp;
  uint oesp;      // useless &#x26; ignored
  uint ebx;
  uint edx;
  uint ecx;
  uint eax;

  // rest of trap frame
  ushort gs;
  ushort padding1;
  ushort fs;
  ushort padding2;
  ushort es;
  ushort padding3;
  ushort ds;
  ushort padding4;
  uint trapno;

  // below here defined by x86 hardware
  uint err;
  uint eip;
  ushort cs;
  ushort padding5;
  uint eflags;

  // below here only when crossing rings, such as from user to kernel
  uint esp;
  ushort ss;
  ushort padding6;
};
</code></pre>
<p>В процедуре <code>alltraps</code> у этой структуры мы заполняем только верхние поля от <code>edi</code> до <code>padding4</code>. Поля <code>trapno</code> и <code>err</code> были ранее заполнены обработчиком прерывания <code>vector 32</code>. Оставшиеся поля составляют kernel stack и записываются аппаратным обеспечением.</p>
<p>Итак, перед вызовом <code>trap</code> стэк имеет следующий вид:</p>
<pre><code>err
trapno
padding4
ds
padding3
es
padding2
fs
padding1
gs
eax
ecx
edx
ebx
oesp
ebp
esi
edi &#x3C;--- $esp
</code></pre>
<p>Переход в <code>alltraps</code> осуществлялся командой <code>JMP</code>, поэтому адрес возврата нигде не записан (для вызова процедуры с возможностью возврата используется <code>CALL</code>, который автоматически пишет адрес следующей инструкции в стэк. Вызовы функций изнутри C всегда осуществляются через <code>CALL</code>, поэтому стэк трапфрейма составляется на ассемблере).</p>
<p>Далее, в <code>trap.c (109)</code> видим, что произошло прерывание по таймеру и вызываем процедуру <code>yield()</code> для запуска шедурера:</p>
<pre><code class="language-c">if(myproc() &#x26;&#x26; myproc()->state == RUNNING &#x26;&#x26;
   tf->trapno == T_IRQ0+IRQ_TIMER)
yield();
</code></pre>
<h3>Вызов шедулера</h3>
<p>Посмотрим, что делает <code>yield()</code>:</p>
<pre><code class="language-c">// Give up the CPU for one scheduling round.
void
yield(void)
{
  acquire(&#x26;ptable.lock);
  proc->state = RUNNABLE;
  sched();
  release(&#x26;ptable.lock);
}
</code></pre>
<p>Здесь ничего особенного, смотрим что там в <code>sched()</code>:</p>
<pre><code class="language-c">// Enter scheduler.  Must hold only ptable.lock
// and have changed proc->state.
void
sched(void)
{
  int intena;

  // If we aren't holding the ptable lock, panic
  if(!holding(&#x26;ptable.lock))
    panic("sched ptable.lock");

  // If we aren't 1 pushcli level deep, panic
  if(cpu->ncli != 1)
    panic("sched locks");

  // If the current process is in the running state, panic
  if(proc->state == RUNNING)
    panic("sched running");

  // If the processor can be interrupted, panic
  if(readeflags()&#x26;FL_IF)
    panic("sched interruptible");

  intena = cpu->intena;
  swtch(&#x26;proc->context, cpu->scheduler);
  cpu->intena = intena;
}
</code></pre>
<p>Здесь у нас в основном проверки, что мы действительно можем сделать переключение контекста и сохранение поля <code>intena</code> (interruptions enabled), неизвестно зачем.</p>
<p>В конце вызывается непосредственно процедура переключения контекста, в которую передается контекст текущего процесса и контекст щедулера, то есть контекст, на который мы будем переключаться (предполагаю, что где-то в другом месте шедулер выбирает процесс, на который переключаемся и подставляет его контекст).</p>
<h3>Переключение контекста</h3>
<p>Вот код <code>swtch.S</code>:</p>
<pre><code class="language-asm"># Context switch
#
#   void swtch(struct context **old, struct context *new);
#
# Save current register context in old
# and then load register context from new.

.globl swtch
swtch:
  movl 4(%esp), %eax
  movl 8(%esp), %edx # сохраняем *new в %edx, **old в %eax

  # Save old callee-save registers
  pushl %ebp
  pushl %ebx
  pushl %esi
  pushl %edi

  # Switch stacks
  movl %esp, (%eax)
  movl %edx, %esp   # пишем значение %edx, то есть *new в %esp

  # Load new callee-save registers
  popl %edi
  popl %esi
  popl %ebx
  popl %ebp
  ret
</code></pre>
<p>Здесь общий смысл такой:</p>
<ol>
<li>мы сохраняем значение регистров на стеке</li>
<li>перемещаем указатель стека <code>esp</code> на тот, который указан в новом контексте</li>
<li>теперь мы работаем со стеком нового контекста, в котором запушены его значения регистров. Нам осталось только сделать <code>pop</code> для всех регистров и продолжить выполнение.</li>
</ol>
<h2>Организация страничной памяти</h2>
<p>Каждому процессу доступны 4 ГБ виртуальной памяти, из которых верхние 2 ГБ всегда занимает адресное пространство ядра, а нижние 2 выделены под нужды процесса. Начало области виртуального адресного пространства ядра обозначается константой <code>KERNBASE</code>.</p>
<h3>Создание адресного пространства ядра</h3>
<p>Процедура <code>main</code> вызывает <code>kvmalloc</code>, который создает и переключается на страницу памяти, описывающую маппинги страниц выше <code>KERNBASE</code>, необходимых для работы ядра:</p>
<pre><code class="language-c">// Allocate one page table for the machine for the kernel address
// space for scheduler processes.
void
kvmalloc(void)
{
  kpgdir = setupkvm();
  switchkvm();
}
</code></pre>
<p>Основная работа происходит в <code>setupkvm</code>:</p>
<pre><code class="language-c">// Set up kernel part of a page table.
pde_t*
setupkvm(void)
{
  pde_t *pgdir;
  struct kmap *k;

  if((pgdir = (pde_t*)kalloc()) == 0)
    return 0;
  memset(pgdir, 0, PGSIZE);
  if (P2V(PHYSTOP) > (void*)DEVSPACE)
    panic("PHYSTOP too high");
  for(k = kmap; k &#x3C; &#x26;kmap[NELEM(kmap)]; k++)
    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
                (uint)k->phys_start, k->perm) &#x3C; 0) {
      freevm(pgdir);
      return 0;
    }
  return pgdir;
}
</code></pre>
<p>Сначала <code>kalloc</code> находит и выделяет 1 физическую страницу памяти для ядра:</p>
<pre><code class="language-c">// Allocate one 4096-byte page of physical memory.
// Returns a pointer that the kernel can use.
// Returns 0 if the memory cannot be allocated.
char*
kalloc(void)
{
  struct run *r;

  if(kmem.use_lock)
    acquire(&#x26;kmem.lock);
  r = kmem.freelist;
  if(r)
    kmem.freelist = r->next;
  if(kmem.use_lock)
    release(&#x26;kmem.lock);
  return (char*)r;
}
</code></pre>
<p>Как видим, <code>kalloc</code> выделяет страницы по очереди, начиная с первой.</p>
<p>Затем <code>setupkvm</code> зануляет полученную страницу: <code>memset(pgdir, 0, PGSIZE);</code>.</p>
<p>Затем проходит по перенаправлениям, описанным в массиве <code>kmap</code>:</p>
<pre><code class="language-c">static struct kmap {
  void *virt;
  uint phys_start;
  uint phys_end;
  int perm;
} kmap[] = {
 { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space
 { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata
 { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory
 { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices
};
</code></pre>
<p>И для каждого перенаправления создает запись в странице таблиц памяти:</p>
<pre><code class="language-c">for(k = kmap; k &#x3C; &#x26;kmap[NELEM(kmap)]; k++)
    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
                (uint)k->phys_start, k->perm) &#x3C; 0) {
      freevm(pgdir);
      return 0;
    }
</code></pre>
<p>Вот как выглядит <code>mappages</code>:</p>
<pre><code class="language-c">// Create PTEs for virtual addresses starting at va that refer to
// physical addresses starting at pa. va and size might not
// be page-aligned.
static int
mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
{
  char *a, *last;
  pte_t *pte;

  a = (char*)PGROUNDDOWN((uint)va);
  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
  for(;;){
    if((pte = walkpgdir(pgdir, a, 1)) == 0)
      return -1;
    if(*pte &#x26; PTE_P)
      panic("remap");
    *pte = pa | perm | PTE_P;
    if(a == last)
      break;
    a += PGSIZE;
    pa += PGSIZE;
  }
  return 0;
}
</code></pre>
<p>Он проходит по каждой странице (<code>a</code> - текущий виртуальный адрес, <code>pa</code> - текущий физический, в каждой итерации к ним прибавляется <code>PGSIZE</code>, то есть размер страницы).</p>
<p>Процедура <code>walkpgdir</code> здесь ищет нужную запись в таблице страниц:</p>
<pre><code class="language-c">// Return the address of the PTE in page table pgdir
// that corresponds to virtual address va.  If alloc!=0,
// create any required page table pages.
static pte_t *
walkpgdir(pde_t *pgdir, const void *va, int alloc)
{
  pde_t *pde;
  pte_t *pgtab;

  pde = &#x26;pgdir[PDX(va)];
  if(*pde &#x26; PTE_P){
    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
  } else {
    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
      return 0;
    // Make sure all those PTE_P bits are zero.
    memset(pgtab, 0, PGSIZE);
    // The permissions here are overly generous, but they can
    // be further restricted by the permissions in the page table
    // entries, if necessary.
    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
  }
  return &#x26;pgtab[PTX(va)];
}
</code></pre>
<p>Для адресации используется 2-уровневое дерево, первый уровень называется PD (page directory), в нем ищется запись по индексу, соотв-му первым 10 битам виртуального адреса. полученная запись называется PDE (page directory entry) и она обозначает адрес используемой в этом процессе таблицы страниц. Следующие 10 бит виртуального адреса обозначают индекс в таблице страниц процесса, по которому лежит PTE (page table entry). В каждом PTE записан PPN (physical page number) и несколько флагов, регулирующие доступ к этой физической странице. Для получения необходимой строки внутри страницы используются последние 12 бит виртуального адреса.</p>
<p>Сначала <code>walkpgdir</code> использует верхние 10 бит (макрос PDX) виртуального адреса <code>va</code>, чтобы получить PDE. Если PDE не найден, значит таблица страниц для этого процесса еще не инициализирована, и если параметр <code>alloc</code> выставлен, то мы выделяем для нее память через <code>kalloc</code>, зануляем память и сохраняем ее адрес в <code>pgdir</code>. Затем получаем в таблице страниц строчку по индексу, состоящему из вторых 10 бит адреса (макрос PTX) и возвращаем ссылку на нее.</p>
<p>Вернувшись в <code>mappages</code>, пишем текущий физический адрес в полученную <code>PTE</code>:</p>
<pre><code class="language-c">*pte = pa | perm | PTE_P;
</code></pre>
<h3>Аллокация физической памяти для ядра</h3>
<p>Аллокатор физической памяти использует <strong>free list</strong> (список освобождения), чтобы отслеживать страницы физической памяти, доступные для аллокации. Это связанный список страниц, в котором каждая аллокация памяти удаляет страницу, а каждое освобождение памяти - добавляет. Каждый элемент списка имеет тип <code>run</code>:</p>
<pre><code class="language-c">struct run {
  struct run *next;
};
</code></pre>
<p>Каждая структура <code>run</code> хранится в начале свободной страницы памяти, потому что в ней все равно больше нечего хранить, она же свободная.</p>
<p>Доступ к free list защищается спинлоком:</p>
<pre><code class="language-c">struct {
  struct spinlock lock;
  int use_lock;
  struct run *freelist;
} kmem;
</code></pre>
<p>Для инициализации аллокатора процедура <code>main</code> вызывает процедуры <code>kinit1</code> в начале и <code>kinit2</code> в конце. Это нужно потому что нам нужно аллоцировать немножко памяти, чтобы мы могли поднять все остальное (в том числе таблицу страниц), а уже после этого мы можем использовать нормальный стандартный большой аллокатор. Поэтому <code>kinit1</code> инициализирует аллокатор на 4 МБ, не использующий локов, а <code>kinit2</code> инициализирует полномощный аллокатор:</p>
<pre><code class="language-c">int
main(void)
{
  kinit1(end, P2V(4*1024*1024)); // phys page allocator
  ...
  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
  ...  
}

// Initialization happens in two phases.
// 1. main() calls kinit1() while still using entrypgdir to place just
// the pages mapped by entrypgdir on free list.
// 2. main() calls kinit2() with the rest of the physical pages
// after installing a full page table that maps them on all cores.
void
kinit1(void *vstart, void *vend)
{
  initlock(&#x26;kmem.lock, "kmem");
  kmem.use_lock = 0;
  freerange(vstart, vend);
}

void
kinit2(void *vstart, void *vend)
{
  freerange(vstart, vend);
  kmem.use_lock = 1;
}
</code></pre>
<p><code>freerange</code> заносит страницы из указанного ренджа по одной во free list и выставляет каждый байт в них в 1, это нужно чтобы код, который попытается прочесть эту память после ее освобождения, не наткнулся на старые данные и выдал ошибку как можно быстрее.</p>
<h2>Пользовательское пространство</h2>
<p>На схеме изображено содержимое памяти для процесса:</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/165bd8d61bd499051f28e2b358bf2ad9/bdbe7/memory-layout-main.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 57.80089153046062%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAABoElEQVQoz4VTa4+CMBDk//+uM/G+mJgIiAEMLwV5ig9EwbnOnjXRu8s1aVq2u9OZ2WI4joNtmiLPc5xOJ5zPZxyPR/R9j//G/X7/ETP0Zr/f43q9StLlchFwjnEccbvd0KlY13UYhkFy/pqGvoXMxnGQPQEIyrUsS2w3GyyXS5lplkmM57+NF8BOzd1uJ0zJhkV1XSOJY5iWBdpDawj4raiXGlpERWT/lEwAytMMmcSELN3CdV34vo/VaoUgDJEkCTzPw3w+h6NYF0WBXBGh74YwU2DaQ+55cDgcBDyKQiwWCwG1bQumaarVxkbZkCn5740x6E+sJK3Xa1lZQAZkqAE/p1NY1gPMsoVtqJgyn8zKshIrGkXqKZmMmMRkAvKbFhRFDk/FJpMPzGYzUdI0tch3XU98dZX8IAhE+rMpNJVyq6oSyWRIC3Q8jiK5jOeMUXKhWJEZG9kqAi/PhoyYyEkwektggjGHxU3TSC4v0g3889mwmF2lJCbrd6i7zQv00+CZ/pNeH/bjT2nbFr5qChmwSMvSbAjAVe8Jpom8d/kLO2GZD/ds8UwAAAAASUVORK5CYII='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="Memory layout"
        title=""
        src="/hows-that-again/static/165bd8d61bd499051f28e2b358bf2ad9/10273/memory-layout-main.png"
        srcset="/hows-that-again/static/165bd8d61bd499051f28e2b358bf2ad9/9b14a/memory-layout-main.png 163w,
/hows-that-again/static/165bd8d61bd499051f28e2b358bf2ad9/94962/memory-layout-main.png 325w,
/hows-that-again/static/165bd8d61bd499051f28e2b358bf2ad9/10273/memory-layout-main.png 650w,
/hows-that-again/static/165bd8d61bd499051f28e2b358bf2ad9/bdbe7/memory-layout-main.png 673w"
        sizes="(max-width: 650px) 100vw, 650px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p>Каждый пользовательский процесс стартует с адреса 0. Внизу пространства располагаются текст программы, ее данные и стек. Здесь <strong>важное различие</strong> относительно схемы памяти в илнуксе.</p>
<p>В xv6 стек располагается под кучей. <strong>В линуксе - стек наверху и растет вниз, куча внизу и растет вверх</strong>.</p>
<p>Стек занимает одну страницу и на схеме показан с содержимым после вызова <code>exec</code>. Сначала идут аргументы командной строки <code>argv</code>, представляющие ссылки на строки, затем аргумент <code>args</code> и адрес возврата. Чтобы стек не смог вырасти больше одной страницы, под ним располагается <strong>guard page</strong>. Эта страница не замаплена, поэтому когда стек попытается ее аллоцировать, будет сгенерировано исключение. Реальные ОС позволяют выделить больше пространства для стека, и он располагается на нескольких страницах.</p>
<p><code>sbrk</code> - это системный вызов для увеличения или уменьшения памяти процесса. Реализуется функцией <code>growproc</code>. Если аргумент положительный, то аллоцируется 1 или несколько страниц и мапятся наверх пользовательского пространства. Если отрицательный - размапливаются 1 или несколько страниц пользовательского пространства и освобождаются соответствующие им физические страницы.</p>
<pre><code class="language-c">// Grow current process's memory by n bytes.
// Return 0 on success, -1 on failure.
int
growproc(int n)
{
  uint sz;
  struct proc *curproc = myproc();

  sz = curproc->sz;
  if(n > 0){
    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
      return -1;
  } else if(n &#x3C; 0){
    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
      return -1;
  }
  curproc->sz = sz;
  switchuvm(curproc);
  return 0;
}
</code></pre>
<p>Для выделения области памяти в пользовательском пространстве используется <code>allocuvm</code>:</p>
<pre><code class="language-c">// Allocate page tables and physical memory to grow process from oldsz to
// newsz, which need not be page aligned.  Returns new size or 0 on error.
int
allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
{
  char *mem;
  uint a;

  if(newsz >= KERNBASE)
    return 0;
  if(newsz &#x3C; oldsz)
    return oldsz;

  a = PGROUNDUP(oldsz);
  for(; a &#x3C; newsz; a += PGSIZE){
    mem = kalloc();
    if(mem == 0){
      cprintf("allocuvm out of memory\n");
      deallocuvm(pgdir, newsz, oldsz);
      return 0;
    }
    memset(mem, 0, PGSIZE);
    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) &#x3C; 0){
      cprintf("allocuvm out of memory (2)\n");
      deallocuvm(pgdir, newsz, oldsz);
      kfree(mem);
      return 0;
    }
  }
  return newsz;
}
</code></pre>
<p>Как видим, она проходит по одной странице от нижней до верхней границы ренджа, выделяет им виртуальную память, зануляет ее и пишет маппинг в таблицу страниц.</p>
<p>Похожим образом работает и деаалоцирование пользовательской памяти:</p>
<pre><code class="language-c">// Deallocate user pages to bring the process size from oldsz to
// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
// need to be less than oldsz.  oldsz can be larger than the actual
// process size.  Returns the new process size.
int
deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
{
  pte_t *pte;
  uint a, pa;

  if(newsz >= oldsz)
    return oldsz;

  a = PGROUNDUP(newsz);
  for(; a  &#x3C; oldsz; a += PGSIZE){
    pte = walkpgdir(pgdir, (char*)a, 0);
    if(!pte)
      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
    else if((*pte &#x26; PTE_P) != 0){
      pa = PTE_ADDR(*pte);
      if(pa == 0)
        panic("kfree");
      char *v = P2V(pa);
      kfree(v);
      *pte = 0;
    }
  }
  return newsz;
}
</code></pre>
<h3>exec</h3>
<pre><code class="language-c">int
exec(char *path, char **argv)
{
  # ------------------------------------------
  # сначала загружаем образ программы в память
  # ------------------------------------------

  ...
  if((ip = namei(path)) == 0){   # ищет и возвращает inode по адресу path
    end_op();
    cprintf("exec: fail\n");
    return -1;
  }
  ilock(ip);        # лочит полученный inode

  // Check ELF header
  if(readi(ip, (char*)&#x26;elf, 0, sizeof(elf)) != sizeof(elf))     # читает заголовок ELF-файла из inode в структуру &#x26;elf (которая имеет тип elfhdr)
    goto bad;
  if(elf.magic != ELF_MAGIC)                                    # проверяет, что это действительно ELF-файл
    goto bad;

  if((pgdir = setupkvm()) == 0)                                 # аллоцирует новую таблицу страниц для этого процесса
    goto bad;

  // Load program into memory.
  for(i=0, off=elf.phoff; i&#x3C;elf.phnum; i++, off+=sizeof(ph)){   # проходим по всем program headers ELF-файла, в каждом из которых описано расположение какого-либо сегмента памяти
    if(readi(ip, (char*)&#x26;ph, off, sizeof(ph)) != sizeof(ph))    # читает с диска program header
      goto bad;
    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)    # выделяем в виртуальной памяти кусок под сегмент
      goto bad;
    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) &#x3C; 0)  # загружаем постранично сегмент в память
      goto bad;
  }
  iunlockput(ip);       # разлочивает inode

  # --------------------------------------------
  # теперь будем создавать пользовательский стек
  # --------------------------------------------

  // Allocate two pages at the next page boundary.
  // Make the first inaccessible.  Use the second as the user stack.
  sz = PGROUNDUP(sz);
  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0) # аллоцируем 2 страницы над сегментами
    goto bad;
  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));          # первую страницу удаляем из таблицы страниц, это будет наша guard page
  sp = sz;

  // Push argument strings, prepare rest of stack in ustack.
  for(argc = 0; argv[argc]; argc++) {
    sp = (sp - (strlen(argv[argc]) + 1)) &#x26; ~3;
    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) &#x3C; 0)
      goto bad;
    ustack[3+argc] = sp;
  }
  ustack[3+argc] = 0;

  ustack[0] = 0xffffffff;  // fake return PC
  ustack[1] = argc;
  ustack[2] = sp - (argc+1)*4;  // argv pointer

  sp -= (3+argc+1) * 4;
  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) &#x3C; 0)      # записываем стек в память
    goto bad;

  # -----------------------------------
  # теперь переключаемся на новый имедж
  # -----------------------------------

  // Commit to the user image.
  oldpgdir = curproc->pgdir;
  curproc->pgdir = pgdir;   # устанавливаем процессу созданную нами таблицу страниц
  curproc->sz = sz;
  curproc->tf->eip = elf.entry;  # следующей выполняемой инструкцией будет точка входа в загруженный образ
  curproc->tf->esp = sp;        # устанавливаем указатель стека на созданный нами стек
  switchuvm(curproc);       # переключаемся на использование образа нового процесса
  freevm(oldpgdir);         # удаляем старую таблицу страниц
  return 0;
}
</code></pre>
<p>В результате всех этих манипуляций <code>exec</code> загружает сегменты программы по тем адресам, которые указаны в ELF-файле. Эти адреса вполне могут указывать на область памяти ядра, поэтому <code>exec</code> опасен. Внутри кода <code>exec</code> есть некоторые дополнительные проверки для этого, которые здесь были опущены.</p>
<p>В настоящих операционных системах есть еще пейджинг неиспользуемых страниц на диск, copy-on-write, разделяемая память, лениво-аллоцируемые страницы и автоматически расширяемые стеки. В xv6 этого всего нет.</p>
<h2>Трэпы/исключения, прерывания и драйвера</h2>
<p>Управление от пользовательской программы в ядро передается в 3 случаях:</p>
<ol>
<li>Системный вызов</li>
<li>Исключение (официальная терминология xv6 использует термин trap)</li>
<li>Прерывание (разделение времени среди процессов осуществляется по прерыванию таймера)</li>
</ol>
<p>Все прерывания обрабатываются ядром, потому что обычно только у него есть необходимые привилегии.</p>
<p>Все 3 случая на самом деле реализуются через прерывания: для системного вызова генерируется прерывание инструкцией int, для исключений тоже.</p>
<p>При каждом переходе в ядро ОС сохраняет значения регистров, готовится к выполнению кода в ядре, выбирает точку входа в ядро, получает информация о произошедшем событии. Общий алгоритм работы при прерывании такой:</p>
<ul>
<li>прерывание приостанавливает нормальную работу процессора</li>
<li>процессор сохраняет значения регистров, чтобы можно было потом к ним вернуться</li>
<li>процессор запускает новую последовательность инструкций, называемую <em>обработчик прерываний</em></li>
</ul>
<h3>Защита X86</h3>
<p>У процессоров x86 есть 4 уровня защиты, именуемые от 0 (самый привилегированный) до 3 (наименее привилегированный). На практике, большинство ОС используют только 0 и 3, которые называются <em>режим ядра</em> и  <em>пользовательский режим</em>, соответственно. Текущий уровень привилегий хранится в регистре <code>%cs</code>.</p>
<p>Обработчики прерываний определены в IDT (interrupt descriptor table). IDT содержит 256 строк, в каждой из которых есть <code>%cs</code> и <code>%eip</code> для обработки прерывания.</p>
<p>Для выполнения системного вызова на x86, программа выполняет инструкцию <code>int n</code>, где <code>n</code> - индекс обработчика в IDT. Инструкция <code>int n</code> делает следующее:</p>
<ol>
<li>Получает n-ю запись из IDT</li>
<li>Берет CPL (current privilege level) из регистра %cs, проверяет, что CPL &#x3C;= DPL, где DPL = descriptor privilege level, хранящийся в полученной из IDT строке. Благодаря этому пользовательские программы (CPL=3) не могут дергать обработчики уровня ядра (DPL=0).</li>
<li>Сохраняет значения <code>%esp</code> и <code>%ss</code> (stack segment) во внутренних регистрах CPU, но только если уровень привилегий нужного сегмента &#x3C; CPL</li>
<li>Загружает <code>%ss</code> и <code>%esp</code> из дескриптора сегмента таска (?)</li>
<li>Пушит <code>%ss</code>, <code>%esp</code>, <code>%eflags</code>, <code>%cs</code>, <code>%eip</code>.</li>
<li>Очищает бит IF в <code>%eflags</code>, но только в случае прерывания</li>
<li>Выставляет <code>%cs</code> и <code>%eip</code> в значения, полученные из дескриптора.</li>
</ol>
<h3>Реализация системного вызова</h3>
<p>Выше я уже описывал, как заполняется файл <code>vectors.S</code>, но не было описано, как он используется. Так вот, при старте процедура <code>main()</code> вызывает <code>tvinit()</code>. Вот ее код:</p>
<pre><code class="language-c">void
tvinit(void)
{
  int i;

  for(i = 0; i &#x3C; 256; i++)
    SETGATE(idt[i], 0, SEG_KCODE&#x3C;&#x3C;3, vectors[i], 0);
  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE&#x3C;&#x3C;3, vectors[T_SYSCALL], DPL_USER);

  initlock(&#x26;tickslock, "time");
}

// Set up a normal interrupt/trap gate descriptor.
// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.
//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone
// - sel: Code segment selector for interrupt/trap handler
// - off: Offset in code segment for interrupt/trap handler
// - dpl: Descriptor Privilege Level -
//        the privilege level required for software to invoke
//        this interrupt/trap gate explicitly using an int instruction.
#define SETGATE(gate, istrap, sel, off, d)                \
{                                                         \
  (gate).off_15_0 = (uint)(off) &#x26; 0xffff;                \
  (gate).cs = (sel);                                      \
  (gate).args = 0;                                        \
  (gate).rsv1 = 0;                                        \
  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
  (gate).s = 0;                                           \
  (gate).dpl = (d);                                       \
  (gate).p = 1;                                           \
  (gate).off_31_16 = (uint)(off) >> 16;                  \
}
</code></pre>
<p>Видим, что цикл проходит по всем элементам <code>vectors</code> и для каждого создает запись в массиве <code>idt</code>, потом отдельно добавляет запись, предназначенную для обработки системных вызовов под номером 64.</p>
<p>У обычных обработчиков вторым параметром передается 0, что делает их обработчиками прерываний, а у системного вызова - 1, что делает его исключением или трэпом. Так же ему выставляется <code>DPL = DPL_USER</code>, а обработчикам прерываний - <code>DPL = 0</code>. xv6 зарещает пользовательскому коду вызывать любые другие прерывания, кроме 64, если они попытаются, то получат <code>general protection exception</code>.</p>
<p>Первая часть обработки системного вызова описана в разделе <strong>Context switch</strong>. Для системного вызова там актуально все, что до вызова <code>trap(tf)</code>. Там в этой процедуре пошли по ветви, соответствующей прерыванию таймера. Здесь пойдем по ветке, соответствующей <code>T_SYSCALL</code>:</p>
<pre><code class="language-c">void
trap(struct trapframe *tf)
{
  if(tf->trapno == T_SYSCALL){
    ...
    myproc()->tf = tf;
    syscall();
    ...
    return;
  }
  ...
}
</code></pre>
<p>Шлавное, что здесь происходит - вызывается <code>syscall()</code>. Посмотрим на него:</p>
<pre><code class="language-c">void
syscall(void)
{
  int num;
  struct proc *curproc = myproc();

  num = curproc->tf->eax;
  if(num > 0 &#x26;&#x26; num &#x3C; NELEM(syscalls) &#x26;&#x26; syscalls[num]) {
    curproc->tf->eax = syscalls[num]();
  } else {
    cprintf("%d %s: unknown sys call %d\n",
            curproc->pid, curproc->name, num);
    curproc->tf->eax = -1;
  }
}
</code></pre>
<p>Он сохраняет номер вызова из регистра <code>eax</code> в переменную <code>num</code>, получает по этому индексу функцию из массива <code>syscalls</code>, выполняет ее и кладет результат в регистр <code>eax</code>.</p>
<p>Массив <code>syscalls</code> выглядит так:</p>
<pre><code class="language-c">static int (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
[SYS_exit]    sys_exit,
[SYS_wait]    sys_wait,
[SYS_pipe]    sys_pipe,
[SYS_read]    sys_read,
[SYS_kill]    sys_kill,
[SYS_exec]    sys_exec,
[SYS_fstat]   sys_fstat,
[SYS_chdir]   sys_chdir,
[SYS_dup]     sys_dup,
[SYS_getpid]  sys_getpid,
[SYS_sbrk]    sys_sbrk,
[SYS_sleep]   sys_sleep,
[SYS_uptime]  sys_uptime,
[SYS_open]    sys_open,
[SYS_write]   sys_write,
[SYS_mknod]   sys_mknod,
[SYS_unlink]  sys_unlink,
[SYS_link]    sys_link,
[SYS_mkdir]   sys_mkdir,
[SYS_close]   sys_close,
};
</code></pre>
<p>Для получения своих аргументов системные функции используют функции <code>argint</code>, <code>argptr</code>, <code>argstr</code> и <code>argfd</code>. Они принимают первым аргументов <code>n</code> и возвращают n-й аргумент как число, указатель, строку или файловый дескриптор. n-й аргумент лежит по адресу <code>%esp+4+4*n</code> (адрес возврата лежит  %esp, а первый аргумент лежит в %esp+4).</p>
<p>Системные функции лежат в syspoc.c и sysfile.c и в основном являются оболочками - читают аргументы со стека, используя функции <code>arg*</code> и вызывают с этими аргументами реальные реализации.</p>
<h3>Реализация прерываний</h3>
<p>Раньше у материнских плат был programmable interrupt controller (PIC), который занимался обслуживанием прерываний. Но потом появились системы с несколькими процессорами и пришлось каждому делать свой, интегрированный APIC (advanced PIC). Теперь для работы с прерываниями на уровне ОС используется 2 API: работающий с прерываниями системы I/O (ioapic.c) и работающий с локальными APIC, интегрированными в каждый процессор (lapic.c).</p>
<p><code>ioapic.c</code> предоставляет функцию <code>ioapicenable</code>, которая позволяет различным устройствам ввода-вывода включать отдельные прерывания и указывать, на каком процессоре они должны быть обработаны:</p>
<pre><code class="language-c">void
ioapicenable(int irq, int cpunum)
{
  // Mark interrupt edge-triggered, active high,
  // enabled, and routed to the given cpunum,
  // which happens to be that cpu's APIC ID.
  ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
  ioapicwrite(REG_TABLE+2*irq+1, cpunum &#x3C;&#x3C; 24);
}
</code></pre>
<p>Например, при старте консоль направляет прерывания клавиатуры на процессор 0:</p>
<pre><code class="language-c">void
consoleinit(void)
{
  ...
  ioapicenable(IRQ_KBD, 0);
}
</code></pre>
<p>А прерывания от дисков отправляются на последний процессор:</p>
<pre><code class="language-c">void
ideinit(void)
{
  ...
  ioapicenable(IRQ_IDE, ncpu - 1);
  ...
}
</code></pre>
<p><code>lapic.c</code> инициализирует все свои прерывания сам, в <code>lapicinit</code>. Там же инициализируется и прерывание для таймера, которое потом обрабатывается в <code>trap.c</code>.</p>
<h3>Драйвера</h3>
<p>Драйвера указывают устройствам, какие операции выполнять и какие прерывания генерировать, когда закончат, а так же реагируют на эти прерывания.</p>
<p>Рассмотрим реализацию драйвера диска.</p>
<p>Диск хранит данные как последовательность 512-байтных <em>блоков</em>, или <em>секторов</em>. Операционная система использует свои блоки, размер которых обычно кратен размеру сектора. В xv6 блок тоже 512 байт. В памяти блок представлен структурой <code>buf</code>:</p>
<pre><code class="language-c">struct buf {
  int flags;            # B_VALID если данные прочитали, B_DIRTY если они изменились и нужно их записать
  uint dev;             # номер устройства
  uint blockno;         # номер сектора
  struct sleeplock lock;
  uint refcnt;
  struct buf *prev; // LRU cache list
  struct buf *next;
  struct buf *qnext; // disk queue
  uchar data[BSIZE];    # копия данных сектора в памяти
};
</code></pre>
<p>При загрузке ОС инициализирует драйвер диска вызовом <code>ideinit</code> из <code>main</code>:</p>
<pre><code class="language-c">void
ideinit(void)
{
  int i;

  initlock(&#x26;idelock, "ide");
  ioapicenable(IRQ_IDE, ncpu - 1);  # включает прерывание диска
  idewait(0);                       # ждет, пока диск будет готов к принятию команд

  // Check if disk 1 is present
  outb(0x1f6, 0xe0 | (1&#x3C;&#x3C;4));       # проверяет доступен ли еще один диск - диск 1. Для этого пишет в порт 0x1f6, чтобы выбрать этот диск
  for(i=0; i&#x3C;1000; i++){            # затем в течение 1000 попыток пытается прочесть статус с порта 0x1f7. Если получается - считаем, что диск есть.
    if(inb(0x1f7) != 0){
      havedisk1 = 1;
      break;
    }
  }

  // Switch back to disk 0.
  outb(0x1f6, 0xe0 | (0&#x3C;&#x3C;4));       # выбираем обратно диск 0
}
</code></pre>
<p><code>idewait</code> работает так: материнка выставляет статус диска в I/O порту <code>0x1f7</code>, а <code>idewait</code> в цикле читает этот статус и ждет, пока бит IDE<em>BSY не будет снят, а IDE</em>DRDY не выставлен:</p>
<p>(I/O порт - это такая отдельная память в процессоре, через которую он работает с устройствами ввода-вывода)</p>
<pre><code class="language-c">// Wait for IDE disk to become ready.
static int
idewait(int checkerr)
{
  int r;

  while(((r = inb(0x1f7)) &#x26; (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
    ;
  if(checkerr &#x26;&#x26; (r &#x26; (IDE_DF|IDE_ERR)) != 0)
    return -1;
  return 0;
}
</code></pre>
<p>После <code>ideinit</code> диск никто не трогает, пока кэш буфера не решит, что пора выполнить <code>iderw</code>, который вызывает <code>idestart</code>, который в зависимости от флагов синхронизирует содержимое буфера с содержимым сектора:</p>
<pre><code class="language-c">// Sync buf with disk.
// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
// Else if B_VALID is not set, read buf from disk, set B_VALID.
void
iderw(struct buf *b)
{
  struct buf **pp;

  if(!holdingsleep(&#x26;b->lock))
    panic("iderw: buf not locked");
  if((b->flags &#x26; (B_VALID|B_DIRTY)) == B_VALID)
    panic("iderw: nothing to do");
  if(b->dev != 0 &#x26;&#x26; !havedisk1)
    panic("iderw: ide disk 1 not present");

  acquire(&#x26;idelock);  //DOC:acquire-lock

  // Append b to idequeue.
  b->qnext = 0;
  for(pp=&#x26;idequeue; *pp; pp=&#x26;(*pp)->qnext)  // записываем наш буфер в очередь запросов к диску. idequeue указывает на буфер, который сейчас читается или пишется на диск.
    ;
  *pp = b;

  // Start disk if necessary.
  if(idequeue == b)                     // если подошла очередь нашего блока, то сразу его обрабатываем. Иначе - ему придется подождать, пока не сработают прерывания завершения операции для всех блоков перед ним.
    idestart(b);

  // Wait for request to finish.
  while((b->flags &#x26; (B_VALID|B_DIRTY)) != B_VALID){
    sleep(b, &#x26;idelock);
  }


  release(&#x26;idelock);
}

// Start the request for b.  Caller must hold idelock.
static void
idestart(struct buf *b)
{
  if(b == 0)
    panic("idestart");
  if(b->blockno >= FSSIZE)
    panic("incorrect blockno");
  int sector_per_block =  BSIZE/SECTOR_SIZE;
  int sector = b->blockno * sector_per_block;
  int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
  int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;

  if (sector_per_block > 7) panic("idestart");

  idewait(0);
  outb(0x3f6, 0);  // generate interrupt
  outb(0x1f2, sector_per_block);  // number of sectors
  outb(0x1f3, sector &#x26; 0xff);
  outb(0x1f4, (sector >> 8) &#x26; 0xff);
  outb(0x1f5, (sector >> 16) &#x26; 0xff);
  outb(0x1f6, 0xe0 | ((b->dev&#x26;1)&#x3C;&#x3C;4) | ((sector>>24)&#x26;0x0f));
  if(b->flags &#x26; B_DIRTY){
    outb(0x1f7, write_cmd);
    outsl(0x1f0, b->data, BSIZE/4);
  } else {
    outb(0x1f7, read_cmd);
  }
}
</code></pre>
<p>Делает он это тоже через порты ввода-вывода. Чтение/запись происходят асинхронно, то есть например при чтении мы даем команду и отправляется делать другие вещи, а обработчик прерываний ловит прерывание конца чтения и записывает в буфер данные. При записи мы сразу пишем данные в порт, а в обработчике прерывания только лишь продвигаем очередь к следующему блоку. Вот как это выглядит:</p>
<pre><code class="language-c">void
trap(struct trapframe *tf)
{
  ...
  case T_IRQ0 + IRQ_IDE:
    ideintr();                  # регистрируем вызов нашего обработчика
    lapiceoi();
    break;
  ...  
}

// Interrupt handler.
void
ideintr(void)
{
  struct buf *b;

  // First queued buffer is the active request.
  acquire(&#x26;idelock);

  if((b = idequeue) == 0){  # читаем текущий буфер в b
    release(&#x26;idelock);
    return;
  }
  idequeue = b->qnext;      # продвигаем очередь к следующему буферу

  // Read data if needed.
  if(!(b->flags &#x26; B_DIRTY) &#x26;&#x26; idewait(1) >= 0)  # если флаг b не выставлен, значит у нас не запись, значит - чтение
    insl(0x1f0, b->data, BSIZE/4);              # подаем на ассемблер команду прочесть данные с порта ввода-вывода 0x1f0 в буфер b->data

  // Wake process waiting for this buf.
  b->flags |= B_VALID;
  b->flags &#x26;= ~B_DIRTY;
  wakeup(b);

  if(idequeue != 0)         # запускаем обработку следующео буфера в очереди
    idestart(idequeue);

  release(&#x26;idelock);
}
</code></pre>
<p>Некоторые устройства динамически переключаются между получением данных по прерываниям и поллингом, например, если устройство знает, что ей нужно совершить много однотипных операций подряд, то оно может на  переключиться на поллинг. Когда пакет принят - переключается обратно на прерывания.</p>
<p>Некоторые драйверы настраивают APIC так, чтобы балансировать нагрузку между процессорами.</p>
<p>Когда программа читает файл, данные из него копируются дважды - сначала с диска в ядро через порты ввода-вывода, потом из ядра в программу командой <code>read</code>. Если после этого мы шлем данные по сети, то они копируются еще два раза - в ядро командой <code>write</code> и в сетевое устройство через порты ввода-вывода. Поэтому часто, чтобы избежать этих лишних операций, операционные системы используют специальные функции для избежания копий данных, чтобы данные шли сразу в адресное пространство процесса.</p>
<h2>Потоковая синхронизация</h2>
<h3>Локи</h3>
<p>В xv6 есть 2 типа локов: спин-локи и слип-локи. Начнем со спинлоков.</p>
<h4>Спинлоки</h4>
<p>Спинлок представлен структурой <code>spinlock</code>:</p>
<pre><code class="language-c">// Mutual exclusion lock.
struct spinlock {
  uint locked;       // Is the lock held?

  // For debugging:
  char *name;        // Name of lock.
  struct cpu *cpu;   // The cpu holding the lock.
  uint pcs[10];      // The call stack (an array of program counters)
                     // that locked the lock.
};
</code></pre>
<p>Чтобы выставить лок, есть специальная инструкция x86: <code>xchg</code>, вот как она используется в нашем коде (x86.h):</p>
<pre><code class="language-c">static inline uint
xchg(volatile uint *addr, uint newval)
{
  uint result;

  // The + in "+m" denotes a read-modify-write operand.
  asm volatile("lock; xchgl %0, %1" :
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
}
</code></pre>
<p>(Кстати, в этом же файле описаны и все остальные используемые инструкции x86)</p>
<p><code>xchg</code> позволяет атомарно поменять местами содержимое адреса памяти и значение регистра. То есть если в памяти хранилось 1, а в регистре 2, то после операции в памяти будет 2, а в регистре 1.</p>
<p>Функция <code>acquire</code> использует эту инструкцию:</p>
<pre><code class="language-c">// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
acquire(struct spinlock *lk)
{
  pushcli(); // disable interrupts to avoid deadlock.

  while(xchg(&#x26;lk->locked, 1) != 0);   # пишем в память 1 и проверяем, что там был 0. если мы записали 1, а там и так был 1, значит лок захвачен другим потоком.

  // Tell the C compiler and the processor to not move loads or stores
  // past this point, to ensure that the critical section's memory
  // references happen after the lock is acquired.
  __sync_synchronize();

  lk->cpu = mycpu();
  getcallerpcs(&#x26;lk, lk->pcs);
}
</code></pre>
<p>После захвата лока <code>acquire</code> еще пишет в лок номер процессора и стек трейс для отладки в случае проблем.</p>
<p>Функция <code>release</code> работает ровно наоборот - сначала очищает отладочную информацию, потом пишет в поле <code>locked</code> значение 0:</p>
<pre><code class="language-c">// Release the lock.
void
release(struct spinlock *lk)
{
  ...
  lk->pcs[0] = 0;
  lk->cpu = 0;

  // Tell the C compiler and the processor to not move loads or stores
  // past this point, to ensure that all the stores in the critical
  // section are visible to other cores before the lock is released.
  // Both the C compiler and the hardware may re-order loads and
  // stores; __sync_synchronize() tells them both not to.
  __sync_synchronize();

  // Release the lock, equivalent to lk->locked = 0.
  // This code can't use a C assignment, since it might
  // not be atomic. A real OS would use C atomics here.
  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
  
  popcli();
}
</code></pre>
<h4>Слиплоки</h4>
<p>Проблема спин-локов в том, что они отключают прерывания, а значит между <code>acquire</code> и <code>release</code> не может произойти <code>context switch</code>. То есть если у нас какой-то долгий лок, то остальные потоки будут его ждать. Слип-локи допускают переключение контекста в критической секции.</p>
<p><strong>ПРИМЕЧАНИЕ</strong>: Те спинлоки, которые в дотнете - реализованы в юзерспейсе, поэтому там вполне может быть переключение потока между захватом и освобождением лока. А вот в ядре линукса - не может.</p>
<p>Слиплок описан следующей структурой:</p>
<pre><code class="language-c">// Long-term locks for processes
struct sleeplock {
  uint locked;       // Is the lock held?
  struct spinlock lk; // spinlock protecting this sleep lock
  
  // For debugging:
  char *name;        // Name of lock.
  int pid;           // Process holding lock
};
</code></pre>
<p>Реализация слиплока описана в <code>sleeplock.c</code>. Вот методы захвата и освобождения:</p>
<pre><code class="language-c">void
acquiresleep(struct sleeplock *lk)
{
  acquire(&#x26;lk->lk);
  while (lk->locked) {
    sleep(lk, &#x26;lk->lk);
  }
  lk->locked = 1;
  lk->pid = myproc()->pid;
  release(&#x26;lk->lk);
}

void
releasesleep(struct sleeplock *lk)
{
  acquire(&#x26;lk->lk);
  lk->locked = 0;
  lk->pid = 0;
  wakeup(lk);
  release(&#x26;lk->lk);
}
</code></pre>
<p><code>acquiresleep</code> ожидает, пока освободится <code>lk->locked</code> и выставляет его в 1. <code>releasesleep</code> сразу выставляет <code>lk->locked</code> в 0. </p>
<p>Непонятно, как работает ситуация, когда <code>acquiresleep</code> взял спинлок, крутится в <code>while</code>, а освободить <code>lk->locked</code> некому, так как <code>releasesleep</code> не может захватить этот же спинлок. Дело в том, что при <code>sleep</code> функция <code>acquiresleep</code> отпускает спинлок и дает возможность поработать другим функциям.</p>
<p>Вот как реализован <code>sleep</code>:</p>
<pre><code class="language-c">sleep(void *chan, struct spinlock *lk)
{
  struct proc *p = myproc();
  
  if(p == 0)
    panic("sleep");

  if(lk == 0)
    panic("sleep without lk");

  // Must acquire ptable.lock in order to
  // change p->state and then call sched.
  // Once we hold ptable.lock, we can be
  // guaranteed that we won't miss any wakeup
  // (wakeup runs with ptable.lock locked),
  // so it's okay to release lk.
  if(lk != &#x26;ptable.lock){  //DOC: sleeplock0
    acquire(&#x26;ptable.lock);  //DOC: sleeplock1
    release(lk);
  }
  // Go to sleep.
  p->chan = chan;
  p->state = SLEEPING;

  sched();

  // Tidy up.
  p->chan = 0;

  // Reacquire original lock.
  if(lk != &#x26;ptable.lock){  //DOC: sleeplock2
    release(&#x26;ptable.lock);
    acquire(lk);
  }
}
</code></pre>
<p>Она сначала делает <code>release(lk)</code>, потом <code>sched()</code>, отдавая управление другим потокам, а когда получит управление обратно, делает <code>acquire(lk)</code>, захватывая спинлок обратно. Таким образом, если другой поток захватит этот лок, то наш поток какое-то время не сможет вернуться из слипа.</p>
<h2>Файловая система</h2>
<p>Состоит из 7 слоев, каждый из которых исплоьзует результаты работы нижележащего:</p>
<ul>
<li>слой дескрипторов файлов - абстрагирует многие ресурсы Unix, используя интерфейс файловой системы</li>
<li>слой путей - предоставляет иерархические пути к файлам и возможность получения файла по пути путем рекурсивного поиска</li>
<li>слой директорий - предоставляет директории, каждая из которых является специальным видом ай-ноды, в которой хранится последовательность детей директории, для каждого из которых записано имя файла и i-номер</li>
<li>слой айнодов - предоставляет индивидуальные файлы, каждый из которых представлен как <em>inode</em> с уникальным i-номером и несколькими секторами, в которых содержится содержимое файла</li>
<li>слой логирования - заворачивает операции доступа от высших слоев в транзакции и обеспечивает атомарность изменений секторов</li>
<li>слой буферного кэша - кэширует сектора в памяти и синхронизирует доступ к ним</li>
<li>слой диска - читает и пишет сектора на диск через драйвер IDE</li>
</ul>
<h3>Слой буферного кэша</h3>
<p>Описан в файле <code>bio.c</code>. Основные функции:</p>
<ul>
<li><code>bread</code> - получает <code>buf</code>, содержащий копию данных сектора</li>
<li><code>brwite</code> - записывает модифицированный буффер в соответствующий ему сектор на диске.</li>
</ul>
<p>Сам кэш описывается следующей структурой:</p>
<pre><code class="language-c">struct {
  struct spinlock lock;
  struct buf buf[NBUF];  // связанный список секторов в кэше, каждый ссылается на соседние через prev/next
  
  struct buf head;
} bcache;
</code></pre>
<p>Он содержит фиксированное количество объектов структуры <code>buf</code>, каждая из которых содержит данные 1 сектора.</p>
<p>Рассмотрим функции <code>bread</code> и <code>bwrite</code>:</p>
<pre><code class="language-c">// Write b's contents to disk.  Must be locked.
void
bwrite(struct buf *b)
{
  if(!holdingsleep(&#x26;b->lock))
    panic("bwrite");
  b->flags |= B_DIRTY;
  iderw(b);
}

// Return a locked buf with the contents of the indicated block.
struct buf*
bread(uint dev, uint blockno)
{
  struct buf *b;

  b = bget(dev, blockno);
  if((b->flags &#x26; B_VALID) == 0) { // данные неактуальны
    iderw(b);                     // нужно перечитать с диска
  }
  return b;
}

// Look through buffer cache for block on device dev.
// If not found, allocate a buffer.
// In either case, return locked buffer.
static struct buf*
bget(uint dev, uint blockno)
{
  struct buf *b;

  acquire(&#x26;bcache.lock);

  for(b = bcache.head.next; b != &#x26;bcache.head; b = b->next){  // проходим по закэшированным буфам
    if(b->dev == dev &#x26;&#x26; b->blockno == blockno){   // проверяем, искомый ли это буф
      b->refcnt++;            // если да, то инкрементируем счетчик ссылок и возвращаем сектор
      release(&#x26;bcache.lock);
      acquiresleep(&#x26;b->lock);
      return b;
    }
  }

  // Если мы оказались здесь, значит в памяти искомого сектора нет
  // Нужно убрать из кэша один сектора и положить на его место прочитанный с диска
  // Убирать из кэша можно только сектор, который никем не используется и не содержт незаписанных на диск изменений. 
  // То есть у него должно быть refcnt == 0 и не стоять флаг B_DIRTY.
  for(b = bcache.head.prev; b != &#x26;bcache.head; b = b->prev){ // кэш закольцован, поэтому через head.prev мы можем обратиться к последнему элементу, это будет least recently used элемент
    if(b->refcnt == 0 &#x26;&#x26; (b->flags &#x26; B_DIRTY) == 0) {
      b->dev = dev;           // когда нашли неиспользуемый сектор в кэше, то просто перезаписываем его поля
      b->blockno = blockno;
      b->flags = 0;           // это сбросить флаг B_VALID, чтобы bread узнал, что в секторе неактуальные данные и прочитал их туда с диска
      b->refcnt = 1;
      release(&#x26;bcache.lock);
      acquiresleep(&#x26;b->lock);
      return b;
    }
  }
  panic("bget: no buffers");
}
</code></pre>
<p>После окончания работы с сектором, его нужно отпустить функцией <code>brelse</code>:</p>
<pre><code class="language-c">// Release a locked buffer.
// Move to the head of the MRU list.
void
brelse(struct buf *b)
{
  if(!holdingsleep(&#x26;b->lock))
    panic("brelse");

  releasesleep(&#x26;b->lock);

  acquire(&#x26;bcache.lock);
  b->refcnt--;
  if (b->refcnt == 0) {
    // no one is waiting for it.
    b->next->prev = b->prev;
    b->prev->next = b->next;
    b->next = bcache.head.next;
    b->prev = &#x26;bcache.head;
    bcache.head.next->prev = b;
    bcache.head.next = b;
  }
  
  release(&#x26;bcache.lock);
}
</code></pre>
<h3>Слой логирования</h3>
<p>Перед каждой операцией записи ее описание пишется в <em>лог</em> на диске. После этого на диск пишется <em>commit record</em>, означающая, что лог завершен. После осуществления записи на диск, лог и его <em>commit record</em> уничтожается.</p>
<p>После перезагрузки на старте системы, если на диске есть <em>commit record</em>, то пишем данные из соответствующего лога на диск. Если лог есть, а коммит рекорда нет - значит, операция записи еще не началась, можем проигнорировать лог. В любом случае лог в конце восстановления удаляется.</p>
<p>Лог состоит из блока заголовка и последовательности копий обновленных секторов (т.н. залогированные сектора). Блок заголовка содержит массив номеров секторов и количество залогированных секторов. Если это количество равно 0, то транзакций в логе нет, а если больше 0, то значит лог содержит закоммиченную транзакцию с указанным количеством блоков. Блог заголовка записывается при коммите и зануляется после записи на диск.</p>
<p>Использование лога в системном вызове выглядит так:</p>
<pre><code class="language-c">begin_op();
...
bp = bread(...);
bp->data[...] = ...;
log_write(bp);
...
end_op();
</code></pre>
<p><code>begin_op</code> ожидает, пока система логирования освободится и пока в логе появится достаточное количество места, после чего инкрементирует <code>log.outstanding</code>, которое означает количество одновременных системных вызовов к файловой системе, которые зарезервировали место в нашем логе. Общее зарезервированное пространство в логе = <code>log.outstanding * MAXOPBLOCKS</code>.</p>
<p><code>log_write</code> - это прокси над <code>bwrite</code>, которое пишет номер сектора в память, резервирует слот в логе на диске, и помечает буфер флагом <code>B_DIRTY</code>, чтобы слой кэша его не удалил.</p>
<p><code>end_op</code> уменьшает <code>log.outstanding</code>, если оно стало 0, значит больше никто в наш лог не пишет, можем вызывать <code>commit()</code>.</p>
<p>Коммит состоит из 4 этапов:</p>
<ol>
<li><code>write_log()</code> - копирует каждый сектор, модифицированный в кэше в соответствующий ему слот лога на диске</li>
<li><code>write_head()</code> - пишет блог заголовка лога на диск</li>
<li><code>install_trans()</code> - читает каждый блок из лога и пишет его на диск</li>
<li><code>end_op</code> пишет заголовок сектора еще раз, но уже выставив ему количество блоков в 0.</li>
</ol>
<p>Логирование описано в файле <code>log.c</code>:</p>
<pre><code class="language-c">// Contents of the header block, used for both the on-disk header block
// and to keep track in memory of logged block# before commit.
struct logheader {
  int n;
  int block[LOGSIZE];
};

struct log {
  struct spinlock lock;
  int start;
  int size;
  int outstanding; // how many FS sys calls are executing.
  int committing;  // in commit(), please wait.
  int dev;
  struct logheader lh;
};
struct log log;

// called at the start of each FS system call.
void
begin_op(void)
{
  acquire(&#x26;log.lock);
  while(1){
    if(log.committing){
      sleep(&#x26;log, &#x26;log.lock);
    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
      // this op might exhaust log space; wait for commit.
      sleep(&#x26;log, &#x26;log.lock);
    } else {
      log.outstanding += 1;
      release(&#x26;log.lock);
      break;
    }
  }
}

// Caller has modified b->data and is done with the buffer.
// Record the block number and pin in the cache with B_DIRTY.
// commit()/write_log() will do the disk write.
//
// log_write() replaces bwrite(); a typical use is:
//   bp = bread(...)
//   modify bp->data[]
//   log_write(bp)
//   brelse(bp)
void
log_write(struct buf *b)
{
  int i;

  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
    panic("too big a transaction");
  if (log.outstanding &#x3C; 1)
    panic("log_write outside of trans");

  acquire(&#x26;log.lock);
  for (i = 0; i &#x3C; log.lh.n; i++) {
    if (log.lh.block[i] == b->blockno)   // log absorbtion
      break;
  }
  log.lh.block[i] = b->blockno;
  if (i == log.lh.n)
    log.lh.n++;
  b->flags |= B_DIRTY; // prevent eviction
  release(&#x26;log.lock);
}

static void
commit()
{
  if (log.lh.n > 0) {
    write_log();     // Write modified blocks from cache to log
    write_head();    // Write header to disk -- the real commit
    install_trans(); // Now install writes to home locations
    log.lh.n = 0;
    write_head();    // Erase the transaction from the log
  }
}


// called at the end of each FS system call.
// commits if this was the last outstanding operation.
void
end_op(void)
{
  int do_commit = 0;

  acquire(&#x26;log.lock);
  log.outstanding -= 1;
  if(log.committing)
    panic("log.committing");
  if(log.outstanding == 0){
    do_commit = 1;
    log.committing = 1;
  } else {
    // begin_op() may be waiting for log space,
    // and decrementing log.outstanding has decreased
    // the amount of reserved space.
    wakeup(&#x26;log);
  }
  release(&#x26;log.lock);

  if(do_commit){
    // call commit w/o holding locks, since not allowed
    // to sleep with locks.
    commit();
    acquire(&#x26;log.lock);
    log.committing = 0;
    wakeup(&#x26;log);
    release(&#x26;log.lock);
  }
}
</code></pre>
<p>Восстановление из лога осуществляется в <code>recover_from_log</code>, который вызывается в <code>initlog</code>:</p>
<pre><code class="language-c">static void
recover_from_log(void)
{
  read_head();
  install_trans(); // if committed, copy from log to disk
  log.lh.n = 0;
  write_head(); // clear the log
}
</code></pre>
<p>Процедура читает заголовок и повторяет действия коммита.</p>
<p>Реальный пример использования из процедуры <code>filewrite</code>:</p>
<pre><code class="language-c">begin_op();
ilock(f->ip);
if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
  f->off += r;
iunlock(f->ip);
end_op();
</code></pre>
<p><code>log_write</code> вызывается внутри <code>writei</code>. Чтобы не превысить размер лога транзакции, кусок кода из примера вызывается в цикле, каждый раз сохраняя в транзакции по несколько блоков.</p>
<h4>Аллокатор блоков</h4>
<p>Файлы и папки хранятся в дисковых блоках, которые тоже должны аллоцироваться и свобождаться. Для этого есть <em>аллокатор блоков</em>, вызываемый функциями <code>balloc</code> и <code>bfree</code>:</p>
<pre><code class="language-c">// Allocate a zeroed disk block.
static uint
balloc(uint dev)
{
  int b, bi, m;
  struct buf *bp;

  bp = 0;
  for(b = 0; b &#x3C; sb.size; b += BPB){
    bp = bread(dev, BBLOCK(b, sb));
    for(bi = 0; bi &#x3C; BPB &#x26;&#x26; b + bi &#x3C; sb.size; bi++){
      m = 1 &#x3C;&#x3C; (bi % 8);
      if((bp->data[bi/8] &#x26; m) == 0){  // Is block free?
        bp->data[bi/8] |= m;  // Mark block in use.
        log_write(bp);
        brelse(bp);
        bzero(dev, b + bi);
        return b + bi;
      }
    }
    brelse(bp);
  }
  panic("balloc: out of blocks");
}

// Free a disk block.
static void
bfree(int dev, uint b)
{
  struct buf *bp;
  int bi, m;

  readsb(dev, &#x26;sb);
  bp = bread(dev, BBLOCK(b, sb));
  bi = b % BPB;
  m = 1 &#x3C;&#x3C; (bi % 8);
  if((bp->data[bi/8] &#x26; m) == 0)
    panic("freeing free block");
  bp->data[bi/8] &#x26;= ~m;
  log_write(bp);
  brelse(bp);
}
</code></pre>
<h3>Слой айнодов</h3>
<p><code>inode</code> бывают двух типов:</p>
<ul>
<li>хранящиеся на диске - содержат размер файла и список номеров его секторов данных</li>
<li>хранящиеся в памяти - содержат копию дискового айнода и дополнительную информацию, необходимую ядру</li>
</ul>
<p>Дисковые айноды лежат последовательно в области диска, называемой "блоки айнодов". Каждый айнод имеет фиксированный размер, поэтому их легко находить по номеру, такие номера называются ай-номеры.</p>
<p>Дисковые айноды описываются структурой <code>dinode</code>:</p>
<pre><code class="language-c">// On-disk inode structure
struct dinode {
  short type;           // Тип айнода: файл, директория, "специальный" файл (девайс). 0 означает, что айнод свободен.
  short major;          // Major device number (T_DEV only)
  short minor;          // Minor device number (T_DEV only)
  short nlink;          // Количество ссылок на этот айнод из директорий. Когда достигает нуля, айнод можно удалять.
  uint size;            // Размер, т.е. количество байт в содержимом файла
  uint addrs[NDIRECT+1];   // Номера секторов данных на диске, в которых записано содержимое файла
};
</code></pre>
<p>Копии активных дисковых айнодов содержатся в памяти ядра в структурах <code>inode</code>:</p>
<pre><code class="language-c">// in-memory copy of an inode
struct inode {
  uint dev;           // Device number
  uint inum;          // Inode number
  int ref;            // Количество C-указателей на этот айнод, когда достигает нуля - удаляем из памяти.
  struct sleeplock lock; // protects everything below here
  int valid;          // inode has been read from disk?

  short type;         // copy of disk inode
  short major;
  short minor;
  short nlink;
  uint size;
  uint addrs[NDIRECT+1];
};
</code></pre>
<p>Копия айнода в памяти содержится только если есть указатели, ссылающиеся на этот айнод.</p>
<p>Чтобы аллоцировать новый айнод (например, при создании файла), вызывается <code>ialloc</code>:</p>
<pre><code class="language-c">// Allocate an inode on device dev.
// Mark it as allocated by  giving it type type.
// Returns an unlocked but allocated and referenced inode.
struct inode*
ialloc(uint dev, short type)
{
  int inum;
  struct buf *bp;
  struct dinode *dip;

  for(inum = 1; inum &#x3C; sb.ninodes; inum++){
    bp = bread(dev, IBLOCK(inum, sb));
    dip = (struct dinode*)bp->data + inum%IPB;
    if(dip->type == 0){  // a free inode
      memset(dip, 0, sizeof(*dip));
      dip->type = type;
      log_write(bp);   // mark it allocated on the disk
      brelse(bp);
      return iget(dev, inum);
    }
    brelse(bp);
  }
  panic("ialloc: no inodes");
}
</code></pre>
<p><code>ialloc</code> проходит по всем айнодам на диске, ища пустой. Когда находит, помечает его как аллоцированный и возвращает его копию из памяти через <code>iget</code>.</p>
<pre><code class="language-c">// Find the inode with number inum on device dev
// and return the in-memory copy. Does not lock
// the inode and does not read it from disk.
static struct inode*
iget(uint dev, uint inum)
{
  struct inode *ip, *empty;

  acquire(&#x26;icache.lock);

  // Is the inode already cached?
  empty = 0;
  for(ip = &#x26;icache.inode[0]; ip &#x3C; &#x26;icache.inode[NINODE]; ip++){
    if(ip->ref > 0 &#x26;&#x26; ip->dev == dev &#x26;&#x26; ip->inum == inum){
      ip->ref++;
      release(&#x26;icache.lock);
      return ip;
    }
    if(empty == 0 &#x26;&#x26; ip->ref == 0)    // Remember empty slot.
      empty = ip;
  }

  // Recycle an inode cache entry.
  if(empty == 0)
    panic("iget: no inodes");

  ip = empty;
  ip->dev = dev;
  ip->inum = inum;
  ip->ref = 1;
  ip->valid = 0;
  release(&#x26;icache.lock);

  return ip;
}
</code></pre>
<p>Прежде чем читать или писать в айнод, код должен его сначала залочить:</p>
<pre><code class="language-c">// Lock the given inode.
// Reads the inode from disk if necessary.
void
ilock(struct inode *ip)
{
  struct buf *bp;
  struct dinode *dip;

  if(ip == 0 || ip->ref &#x3C; 1)
    panic("ilock");

  acquiresleep(&#x26;ip->lock);

  if(ip->valid == 0){
    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
    dip = (struct dinode*)bp->data + ip->inum%IPB;
    ip->type = dip->type;
    ip->major = dip->major;
    ip->minor = dip->minor;
    ip->nlink = dip->nlink;
    ip->size = dip->size;
    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
    brelse(bp);
    ip->valid = 1;
    if(ip->type == 0)
      panic("ilock: no type");
  }
}

// Unlock the given inode.
void
iunlock(struct inode *ip)
{
  if(ip == 0 || !holdingsleep(&#x26;ip->lock) || ip->ref &#x3C; 1)
    panic("iunlock");

  releasesleep(&#x26;ip->lock);
}
</code></pre>
<h4>Содержимое айнодов</h4>
<pre><code class="language-c">// Copy stat information from inode.
// Caller must hold ip->lock.
void
stati(struct inode *ip, struct stat *st)
{
  st->dev = ip->dev;
  st->ino = ip->inum;
  st->type = ip->type;
  st->nlink = ip->nlink;
  st->size = ip->size;
}

//PAGEBREAK!
// Read data from inode.
// Caller must hold ip->lock.
int
readi(struct inode *ip, char *dst, uint off, uint n)
{
  uint tot, m;
  struct buf *bp;

  if(ip->type == T_DEV){
    if(ip->major &#x3C; 0 || ip->major >= NDEV || !devsw[ip->major].read)
      return -1;
    return devsw[ip->major].read(ip, dst, n);
  }

  if(off > ip->size || off + n &#x3C; off)
    return -1;
  if(off + n > ip->size)
    n = ip->size - off;

  for(tot=0; tot&#x3C;n; tot+=m, off+=m, dst+=m){
    bp = bread(ip->dev, bmap(ip, off/BSIZE));
    m = min(n - tot, BSIZE - off%BSIZE);
    memmove(dst, bp->data + off%BSIZE, m);
    brelse(bp);
  }
  return n;
}

// PAGEBREAK!
// Write data to inode.
// Caller must hold ip->lock.
int
writei(struct inode *ip, char *src, uint off, uint n)
{
  uint tot, m;
  struct buf *bp;

  if(ip->type == T_DEV){
    if(ip->major &#x3C; 0 || ip->major >= NDEV || !devsw[ip->major].write)
      return -1;
    return devsw[ip->major].write(ip, src, n);
  }

  if(off > ip->size || off + n &#x3C; off)
    return -1;
  if(off + n > MAXFILE*BSIZE)
    return -1;

  for(tot=0; tot&#x3C;n; tot+=m, off+=m, src+=m){
    bp = bread(ip->dev, bmap(ip, off/BSIZE));
    m = min(n - tot, BSIZE - off%BSIZE);
    memmove(bp->data + off%BSIZE, src, m);
    log_write(bp);
    brelse(bp);
  }

  if(n > 0 &#x26;&#x26; off > ip->size){
    ip->size = off;
    iupdate(ip);
  }
  return n;
}
</code></pre>
<h3>Слой директорий</h3>
<pre><code class="language-c">// Look for a directory entry in a directory.
// If found, set *poff to byte offset of entry.
struct inode*
dirlookup(struct inode *dp, char *name, uint *poff)
{
  uint off, inum;
  struct dirent de;

  if(dp->type != T_DIR)
    panic("dirlookup not DIR");

  for(off = 0; off &#x3C; dp->size; off += sizeof(de)){
    if(readi(dp, (char*)&#x26;de, off, sizeof(de)) != sizeof(de))
      panic("dirlookup read");
    if(de.inum == 0)
      continue;
    if(namecmp(name, de.name) == 0){
      // entry matches path element
      if(poff)
        *poff = off;
      inum = de.inum;
      return iget(dp->dev, inum);
    }
  }

  return 0;
}

// Write a new directory entry (name, inum) into the directory dp.
int
dirlink(struct inode *dp, char *name, uint inum)
{
  int off;
  struct dirent de;
  struct inode *ip;

  // Check that name is not present.
  if((ip = dirlookup(dp, name, 0)) != 0){
    iput(ip);
    return -1;
  }

  // Look for an empty dirent.
  for(off = 0; off &#x3C; dp->size; off += sizeof(de)){
    if(readi(dp, (char*)&#x26;de, off, sizeof(de)) != sizeof(de))
      panic("dirlink read");
    if(de.inum == 0)
      break;
  }

  strncpy(de.name, name, DIRSIZ);
  de.inum = inum;
  if(writei(dp, (char*)&#x26;de, off, sizeof(de)) != sizeof(de))
    panic("dirlink");

  return 0;
}
</code></pre>
<h3>Слой путей</h3>
<pre><code class="language-c">// Copy the next path element from path into name.
// Return a pointer to the element following the copied one.
// The returned path has no leading slashes,
// so the caller can check *path=='\0' to see if the name is the last one.
// If no name to remove, return 0.
//
// Examples:
//   skipelem("a/bb/c", name) = "bb/c", setting name = "a"
//   skipelem("///a//bb", name) = "bb", setting name = "a"
//   skipelem("a", name) = "", setting name = "a"
//   skipelem("", name) = skipelem("////", name) = 0
//
static char*
skipelem(char *path, char *name)
{
  char *s;
  int len;

  while(*path == '/')
    path++;
  if(*path == 0)
    return 0;
  s = path;
  while(*path != '/' &#x26;&#x26; *path != 0)
    path++;
  len = path - s;
  if(len >= DIRSIZ)
    memmove(name, s, DIRSIZ);
  else {
    memmove(name, s, len);
    name[len] = 0;
  }
  while(*path == '/')
    path++;
  return path;
}

// Look up and return the inode for a path name.
// If parent != 0, return the inode for the parent and copy the final
// path element into name, which must have room for DIRSIZ bytes.
// Must be called inside a transaction since it calls iput().
static struct inode*
namex(char *path, int nameiparent, char *name)
{
  struct inode *ip, *next;

  if(*path == '/')
    ip = iget(ROOTDEV, ROOTINO);
  else
    ip = idup(myproc()->cwd);

  while((path = skipelem(path, name)) != 0){
    ilock(ip);
    if(ip->type != T_DIR){
      iunlockput(ip);
      return 0;
    }
    if(nameiparent &#x26;&#x26; *path == '\0'){
      // Stop one level early.
      iunlock(ip);
      return ip;
    }
    if((next = dirlookup(ip, name, 0)) == 0){
      iunlockput(ip);
      return 0;
    }
    iunlockput(ip);
    ip = next;
  }
  if(nameiparent){
    iput(ip);
    return 0;
  }
  return ip;
}

struct inode*
namei(char *path)
{
  char name[DIRSIZ];
  return namex(path, 0, name);
}

struct inode*
nameiparent(char *path, char *name)
{
  return namex(path, 1, name);
}
</code></pre>
<h3>Слой дескрипторов файлов</h3>
<pre><code class="language-c">// Allocate a file structure.
struct file*
filealloc(void)
{
  struct file *f;

  acquire(&#x26;ftable.lock);
  for(f = ftable.file; f &#x3C; ftable.file + NFILE; f++){
    if(f->ref == 0){
      f->ref = 1;
      release(&#x26;ftable.lock);
      return f;
    }
  }
  release(&#x26;ftable.lock);
  return 0;
}

// Close file f.  (Decrement ref count, close when reaches 0.)
void
fileclose(struct file *f)
{
  struct file ff;

  acquire(&#x26;ftable.lock);
  if(f->ref &#x3C; 1)
    panic("fileclose");
  if(--f->ref > 0){
    release(&#x26;ftable.lock);
    return;
  }
  ff = *f;
  f->ref = 0;
  f->type = FD_NONE;
  release(&#x26;ftable.lock);

  if(ff.type == FD_PIPE)
    pipeclose(ff.pipe, ff.writable);
  else if(ff.type == FD_INODE){
    begin_op();
    iput(ff.ip);
    end_op();
  }
}

// Read from file f.
int
fileread(struct file *f, char *addr, int n)
{
  int r;

  if(f->readable == 0)
    return -1;
  if(f->type == FD_PIPE)
    return piperead(f->pipe, addr, n);
  if(f->type == FD_INODE){
    ilock(f->ip);
    if((r = readi(f->ip, addr, f->off, n)) > 0)
      f->off += r;
    iunlock(f->ip);
    return r;
  }
  panic("fileread");
}

//PAGEBREAK!
// Write to file f.
int
filewrite(struct file *f, char *addr, int n)
{
  int r;

  if(f->writable == 0)
    return -1;
  if(f->type == FD_PIPE)
    return pipewrite(f->pipe, addr, n);
  if(f->type == FD_INODE){
    // write a few blocks at a time to avoid exceeding
    // the maximum log transaction size, including
    // i-node, indirect block, allocation blocks,
    // and 2 blocks of slop for non-aligned writes.
    // this really belongs lower down, since writei()
    // might be writing a device like the console.
    int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
    int i = 0;
    while(i &#x3C; n){
      int n1 = n - i;
      if(n1 > max)
        n1 = max;

      begin_op();
      ilock(f->ip);
      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
        f->off += r;
      iunlock(f->ip);
      end_op();

      if(r &#x3C; 0)
        break;
      if(r != n1)
        panic("short filewrite");
      i += r;
    }
    return i == n ? n : -1;
  }
  panic("filewrite");
}
</code></pre></div></div></div></div></div></div><script id="webpack-manifest">/*<![CDATA[*/window.webpackManifest={"231608221292675":"app-f5de8f78c377ac2d1842.js","122212659448958":"component---src-templates-blog-template-js-40956da8f886eafeb36f.js","162898551421021":"component---src-pages-404-js-4503918ea3a16cfcdb75.js","213534597649335":"component---src-pages-index-jsx-ed5f83543216989c42c9.js","218538773642512":"component---src-pages-page-2-js-65f0147ecb0dc4da2a2b.js","60335399758886":"path----312dbf55939ed237922c.js","229226591425695":"path---blog-video-microservices-what-we-learned-f5a90a189b44da7a91be.js","100364315975247":"path---blog-video-dapp-introduction-18a08af6d97c4f55c2fa.js","55495657889055":"path---blog-video-after-ddos-defense-d7f2f630e6f10d653de7.js","139359830059626":"path---blog-video-microservices-introduction-f3e72db12b0fbbb3d580.js","192092705425134":"path---blog-react-code-review-3639de61a5c8ec40c288.js","92226880614288":"path---howto-mips-gcc-0880423397eebc2bc371.js","186363950922344":"path---blog-video-kafka-under-highload-c9ba43a895234eb619dc.js","226923551111508":"path---blog-video-http-balancing-6eec4894584ee04d7a77.js","160831456888542":"path---blog-books-xv-6-9023bac90e984ef3e566.js","184279855636086":"path---blog-x-64-7781a52988fda6ca93ef.js","53213360603775":"path---blog-wget-b2276cddc4105ace9aa7.js","27547127271145":"path---blog-virtualenv-3ed97f2ead9054836cf6.js","24818581494570":"path---blog-hardware-virtual-memory-79d5b2f9932e063d2b8c.js","98763693551004":"path---blog-hardware-video-a882f7233cbbe8420a8f.js","130591662829648":"path---blog-hardware-usb-2902438d72114310e6d2.js","9365413787972":"path---blog-tmux-18af5c3ee5786bc23e5e.js","162551281273053":"path---blog-systemd-bde979ddc87b1e7c9bf1.js","186644301018450":"path---blog-sh-6171eda06ba839bbe4eb.js","73744929748382":"path---blog-sed-6a7051bbefdd9def0839.js","104991713993326":"path---blog-pip-abd64edaa0d15be853d7.js","264201604445726":"path---blog-pdb-cbd483343d11c66f1e7c.js","133853690878566":"path---blog-npm-4f38b5dbca23541666f7.js","109648760230997":"path---blog-video-microservices-patterns-playbook-789b40dcdf4d315ca285.js","159123021256651":"path---blog-kazoo-2497377bd7253a7b95a2.js","104310528048563":"path---blog-gcc-2f6622c1c0f0846a2708.js","110067976222435":"path---blog-hardware-disk-306e6d689cb622b49051.js","132138994540798":"path---blog-hardware-cpu-4cd2e518ccf742e8026f.js","55889076892030":"path---blog-books-computer-organization-and-design-b9fec2d6c985ad44539f.js","77570552653218":"path---blog-books-build-systems-da90c07c93f61b8f655a.js","131670063006948":"path---blog-webpack-9d3fd355b7a49f15c82d.js","48555064563601":"path---blog-webpack-2-613f06922b155eeb86aa.js","36163852562177":"path---blog-web-components-143a7e086a55de724af5.js","274395942926096":"path---blog-vim-5e5110444cdff57e8c62.js","207874380873722":"path---blog-typescript-288e7095a7260887c28e.js","1112656806016":"path---blog-storybook-5a29d2baa4a10d8b7a27.js","65468590155737":"path---blog-books-stackframes-a750e700629fe8105cd2.js","85756719843508":"path---blog-spring-boot-374ccfd3bfa67ded83ed.js","94230034957513":"path---blog-mvc-sessionless-state-12281ec2091582c9e1ae.js","34503133861313":"path---blog-swig-2cbe0b7c6b6e1e3d1ec3.js","9783932336651":"path---blog-ssl-d27dc0e7877818ebe753.js","30778352477470":"path---blog-sql-recursive-cte-e643e27fb3c8145e3a0a.js","218031196284409":"path---blog-sql-fizzbuzz-a19125265b020c668aaf.js","123969815895874":"path---blog-ruby-10341037f2e8234a4d30.js","254035159982288":"path---blog-riak-017c27a09cb33adc6bc9.js","204811817341229":"path---blog-redux-4fed98bde112a019015a.js","92818489627367":"path---blog-redux-2-8275ec87d46ada9ec530.js","62231134199178":"path---blog-react-1772bc9452377966cb75.js","148854442917752":"path---blog-rabbitmq-f591f04c8eff604d8f41.js","38855089869933":"path---blog-hardware-ram-11c6c8f0b951e307c6d9.js","148886276492926":"path---blog-python-2-a5296659987e03ada440.js","105666842049118":"path---blog-python-4c69d05159424d2e7402.js","269087443385385":"path---blog-postcss-fc1a38ea5a4d5f6c1159.js","256307876683203":"path---blog-oauth-58b2881d3b6fe2cf98ae.js","143217941000248":"path---blog-nodejs-a4db1ba11ab71d87a276.js","28480827339995":"path---blog-nginx-95158fa4765cbc4e89cf.js","244296159480370":"path---blog-mongodb-a0072eebb3f25201f6b5.js","250734049749304":"path---blog-maven-da6909564d3fe9fc05b3.js","189813236319561":"path---blog-linux-networking-fa7457ac2d7b179d8bdf.js","64880211853811":"path---blog-linux-debugging-2d1eabdd3caf05008f62.js","79569183618093":"path---blog-linux-api-92a99c0e0ec520076abb.js","197411268609348":"path---blog-knockout-7c4cfbd4a1c286e3ac1b.js","229750489612856":"path---blog-kafka-4e5cbf0c1f4416575a91.js","123278874046992":"path---blog-javascript-bf38942f9fb919cc14c6.js","53396112491056":"path---blog-java-1bdcc1887eeecc89a78d.js","18938219703366":"path---blog-js-event-loop-f72490c1078996bba861.js","142042848561750":"path---blog-how-would-you-implement-2673484302e1346fc8da.js","154704496480088":"path---blog-books-how-linux-works-38446ba99539e818f42a.js","76495366757855":"path---blog-gstreamer-5298189b6f670bfb7f51.js","190181808776960":"path---blog-google-test-516e9734941f59461e2c.js","130613441630911":"path---blog-gitlab-ci-9cdb9c5b7a3c03e85974.js","60149745945718":"path---blog-git-a176b80686ca6e70bf81.js","68448465120492":"path---blog-gdb-1b8ecd9ea32b86157dbe.js","191388377664321":"path---blog-flexbox-d2727e853a6da977e9a1.js","259445767305737":"path---blog-express-00cc4f3d5211bb03edae.js","267150169503670":"path---blog-docker-compose-4a43b0829173eab4e471.js","97711108842923":"path---blog-docker-9d4ff6fc5df7945b590e.js","838797986268":"path---blog-books-designing-data-intensive-applications-1eaeffd06f5df9f3bbba.js","175567745484808":"path---blog-debian-bootstrap-a4183455e2eea7aeb7ca.js","246498121182663":"path---blog-debian-9965d1c337457bf36996.js","109290739445578":"path---blog-call-conventions-4a3238dc1cc5325623ad.js","249667644861725":"path---blog-css-293623988a319b100ba5.js","257759292890660":"path---blog-web-security-2ad6831319dac386d275.js","226785351346532":"path---blog-cmake-a37c0e87876c6ccec47d.js","143229806240817":"path---blog-cpp-6478d4e4dc045e454b92.js","159223318109625":"path---blog-backstopjs-6e9ff9bcf4f8661b9ce4.js","69801897094251":"path---blog-architecture-e499ab2115654d6ed9ad.js","117626492464451":"path---blog-algorithms-e375169a15a627e27332.js","215540810942742":"path---blog-mvc-async-controllers-c3cc24f140a51a9e6bb0.js","27779406687296":"path---blog-mvc-web-farms-9cb51abf17a7815a45a8.js","146292636605172":"path---blog-mvc-web-sockets-86e449c7694174065fb9.js","279780729786774":"path---blog-mvc-modules-handlers-44f1e163873a16c2c733.js","77216212851623":"path---blog-mvc-data-tampering-3d0d565b8fbb7674f2e4.js","13218921337688":"path---blog-video-10-ways-to-get-highload-and-bigdata-2a40a94753b968a20eda.js","225240287407359":"path---blog-dotnet-9c981bcf9de4c6440961.js","44704367536930":"path---blog-dotnet-monitor-0ee8745d0cde9bdafe90.js","254022195166212":"path---404-a0e39f21c11f6a62c5ab.js","142629428675168":"path---index-5d828f7969c6a5a5be25.js","135728916539164":"path---page-2-a0e39f21c11f6a62c5ab.js","178698757827068":"path---404-html-a0e39f21c11f6a62c5ab.js","114276838955818":"component---src-layouts-index-js-6ed608cdf879d3b0dfb1.js"}/*]]>*/</script><script>/*<![CDATA[*/!function(e,t,r){function n(){for(;d[0]&&"loaded"==d[0][f];)c=d.shift(),c[o]=!i.parentNode.insertBefore(c,i)}for(var s,a,c,d=[],i=e.scripts[0],o="onreadystatechange",f="readyState";s=r.shift();)a=e.createElement(t),"async"in i?(a.async=!1,e.head.appendChild(a)):i[f]?(d.push(a),a[o]=n):e.write("<"+t+' src="'+s+'" defer></'+t+">"),a.src=s}(document,"script",["/hows-that-again/commons-afb5782224ac01f1fa03.js","/hows-that-again/app-f5de8f78c377ac2d1842.js","/hows-that-again/path---blog-books-xv-6-9023bac90e984ef3e566.js","/hows-that-again/component---src-templates-blog-template-js-40956da8f886eafeb36f.js","/hows-that-again/component---src-layouts-index-js-6ed608cdf879d3b0dfb1.js"])/*]]>*/</script></body></html>