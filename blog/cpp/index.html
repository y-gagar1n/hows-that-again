<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/hows-that-again/commons.8860d49cbcb6ddba17d1.css">html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:112.5%/1.45em georgia,serif;box-sizing:border-box;overflow-y:scroll}*,:after,:before{box-sizing:inherit}body{color:rgba(0,0,0,.8);font-family:georgia,serif;font-weight:400;word-wrap:break-word;-webkit-font-kerning:normal;font-kerning:normal;-ms-font-feature-settings:"kern","liga","clig","calt";font-feature-settings:"kern","liga","clig","calt"}img{max-width:100%;padding:0;margin:0 0 1.45rem}h1{font-size:2.25rem}h1,h2{padding:0;margin:0 0 1.45rem;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h2{font-size:1.62671rem}h3{font-size:1.38316rem}h3,h4{padding:0;margin:0 0 1.45rem;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h4{font-size:1rem}h5{font-size:.85028rem}h5,h6{padding:0;margin:0 0 1.45rem;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h6{font-size:.78405rem}hgroup{padding:0;margin:0 0 1.45rem}ol,ul{padding:0;margin:0 0 1.45rem 1.45rem;list-style-position:outside;list-style-image:none}dd,dl,figure,p{padding:0;margin:0 0 1.45rem}pre{margin:0 0 1.45rem;font-size:.85rem;line-height:1.42;background:rgba(0,0,0,.04);border-radius:3px;overflow:auto;word-wrap:normal;padding:1.45rem}table{font-size:1rem;line-height:1.45rem;border-collapse:collapse;width:100%}fieldset,table{padding:0;margin:0 0 1.45rem}blockquote{padding:0;margin:0 1.45rem 1.45rem}form,iframe,noscript{padding:0;margin:0 0 1.45rem}hr{padding:0;margin:0 0 calc(1.45rem - 1px);background:rgba(0,0,0,.2);border:none;height:1px}address{padding:0;margin:0 0 1.45rem}b,dt,strong,th{font-weight:700}li{margin-bottom:.725rem}ol li,ul li{padding-left:0}li>ol,li>ul{margin-left:1.45rem;margin-bottom:.725rem;margin-top:.725rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,abbr[title],acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}abbr[title]{text-decoration:none}td,th,thead{text-align:left}td,th{border-bottom:1px solid rgba(0,0,0,.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding:.725rem .96667rem calc(.725rem - 1px)}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:SFMono-Regular,Consolas,Roboto Mono,Droid Sans Mono,Liberation Mono,Menlo,Courier,monospace;padding:.2em 0}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{letter-spacing:-.2em;content:" "}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}@media only screen and (max-width:480px){html{font-size:100%}}code[class*=language-],pre[class*=language-]{color:#657b83;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-]::-moz-selection,code[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection{background:#073642}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{background:#073642}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-],pre[class*=language-]{background-color:#fdf6e3}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#93a1a1}.token.punctuation{color:#586e75}.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#268bd2}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string,.token.url{color:#2aa198}.token.entity{color:#657b83;background:#eee8d5}.token.atrule,.token.attr-value,.token.keyword{color:#859900}.token.class-name,.token.function{color:#b58900}.token.important,.token.regex,.token.variable{color:#cb4b16}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}</style><meta name="generator" content="Gatsby 2.15.1"/><title data-react-helmet="true">How&#x27;s that again?</title><meta data-react-helmet="true" name="description" content="Sample"/><meta data-react-helmet="true" name="keywords" content="sample, something"/><style type="text/css">.gatsby-resp-image-image{width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;color:transparent;}</style><link as="script" rel="preload" href="/hows-that-again/webpack-runtime-307e2eaa7f3c16e7ad2c.js"/><link as="script" rel="preload" href="/hows-that-again/app-c14483461df837b8e0ee.js"/><link as="script" rel="preload" href="/hows-that-again/commons-313b70b8b727bdc3ecf8.js"/><link as="script" rel="preload" href="/hows-that-again/component---src-templates-blog-template-js-e63d8ebd92abd897e273.js"/><link as="fetch" rel="preload" href="/hows-that-again/page-data/blog/cpp/page-data.json" crossorigin="anonymous"/></head><body><noscript id="gatsby-noscript">This app works best with JavaScript enabled.</noscript><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group" id="gatsby-focus-wrapper"><div><div style="background:rebeccapurple;margin-bottom:1.45rem"><div style="margin:0 auto;max-width:960px;padding:1.45rem 1.0875rem;display:flex;justify-content:space-between"><h1 style="margin:0"><a style="color:white;text-decoration:none" href="/hows-that-again/">How&#x27;s that again?</a></h1><span style="margin:auto 0"><form style="margin-bottom:0" method="get" action="https://encrypted.google.com/search"><input type="hidden" name="as_sitesearch" value="y-gagar1n.github.io/hows-that-again"/><input type="text" name="as_q"/><input type="submit" style="margin-left:5px" value="Search"/></form></span></div></div><div style="margin:0 auto;max-width:960px;padding:0px 1.0875rem 1.45rem;padding-top:0"><div class="blog-post-container"><div class="blog-post"><div class="blog-post-content"><p><a href="http://c-faq.com/decl/spiral.anderson.html">Spiral rule</a></p>
<h1>Suggestions for C++ programmers (C++11 features)</h1>
<ol>
<li>Use constructors to establish invariants (§2.4.3.2, §13.4, §17.2.1).</li>
<li>Use constructor/destructor pairs to simplify resource management (RAII; §5.2, §13.3).</li>
<li>Avoid ‘‘naked’’ new and delete (§3.2.1.2, §11.2.1).</li>
<li>Use containers and algorithms rather than built-in arrays and ad hoc code (§4.4, §4.5,
§7.4, Chapter 32).</li>
<li>Prefer standard-library facilities to locally developed code (§1.2.4).</li>
<li>Use exceptions, rather than error codes, to report errors that cannot be handled locally
(§2.4.3, §13.1).</li>
<li>Use move semantics to avoid copying large objects (§3.3.2, §17.5.2).</li>
<li>Use unique_ptr to reference objects of polymorphic type (§5.2.1).</li>
<li>Use shared_ptr to reference shared objects, that is, objects without a single owner that is
responsible for their destruction (§5.2.1).</li>
<li>Use templates to maintain static type safety (eliminate casts) and avoid unnecessary use
of class hierarchies (§27.2).</li>
</ol>
<h1>Suggestions for C Programmers</h1>
<ol>
<li>Don’t think of C++ as C with a few features added. C++ can be used that way, but only
suboptimally. To get really major advantages from C++ as compared to C, you need to
apply different design and implementation styles.</li>
<li>Don’t write C in C++; that is often seriously suboptimal for both maintenance and perfor-
mance.</li>
<li>Use the C++ standard library as a teacher of new techniques and programming styles.
Note the difference from the C standard library (e.g., = rather than strcpy() for copying
and == rather than strcmp() for comparing).</li>
<li>Macro substitution is almost never necessary in C++. Use const (§7.5), constexpr (§2.2.3,
§10.4), enum or enum class (§8.4) to define manifest constants, inline (§12.1.5) to avoid
function-calling overhead, template s (§3.4, Chapter 23) to specify families of functions
and types, and namespace s (§2.4.2, §14.3.1) to avoid name clashes.</li>
<li>Don’t declare a variable before you need it, and initialize it immediately. A declaration
can occur anywhere a statement can (§9.3), in for -statement initializers (§9.5), and in con-
ditions (§9.4.3).</li>
<li>Don’t use malloc() . The new operator (§11.2) does the same job better, and instead of
realloc() , try a vector (§3.4.2). Don’t just replace malloc() and free() with ‘‘naked’’ new and
delete (§3.2.1.2, §11.2.1).</li>
<li>Avoid void∗ , unions, and casts, except deep within the implementation of some function
or class. Their use limits the support you can get from the type system and can harm per-
formance. In most cases, a cast is an indication of a design error. If you must use an
explicit type conversion, try using one of the named casts (e.g., static_cast ; §11.5.2) for a
more precise statement of what you are trying to do.</li>
<li>Minimize the use of arrays and C-style strings. C++ standard-library string s (§4.2), array s
(§8.2.4), and vector s (§4.4.1) can often be used to write simpler and more maintainable
code compared to the traditional C style. In general, try not to build yourself what has
already been provided by the standard library.</li>
<li>Avoid pointer arithmetic except in very specialized code (such as a memory manager) and
for simple array traversal (e.g., ++p ).</li>
<li>Do not assume that something laboriously written in C style (avoiding C++ features such
as classes, templates, and exceptions) is more efficient than a shorter alternative (e.g.,
using standard-library facilities). Often (but of course not always), the opposite is true.</li>
</ol>
<h1>Suggestions for Java/C# Programmers</h1>
<ol>
<li>Don’t simply mimic Java style in C++; that is often seriously suboptimal for both main-
tainability and performance.</li>
<li>Use the C++ abstraction mechanisms (e.g., classes and templates): don’t fall back to a C
style of programming out of a false feeling of familiarity.</li>
<li>Use the C++ standard library as a teacher of new techniques and programming styles.</li>
<li>Don’t immediately invent a unique base for all of your classes (an Object class). Typi-
cally, you can do better without it for many/most classes.</li>
<li>Minimize the use of reference and pointer variables: use local and member variables
(§3.2.1.2, §5.2, §16.3.4, §17.1).</li>
<li>Remember: a variable is never implicitly a reference.</li>
<li>Think of pointers as C++’s equivalent to Java references (C++ references are more lim-
ited; there is no reseating of C++ references).</li>
<li>A function is not virtual by default. Not every class is meant for inheritance.</li>
<li>Use abstract classes as interfaces to class hierarchies; avoid "brittle base classes", that is, base classes with data members.</li>
<li>Use scoped resource management ("Resource Acquisition Is Initialization"; RAII) when-
ever possible.</li>
<li>Use a constructor to establish a class invariant (and throw an exception if it can’t).</li>
<li>If a cleanup action is needed when an object is deleted (e.g., goes out of scope), use a de-
structor for that. Don’t imitate finally (doing so is more ad hoc and in the longer run far
more work than relying on destructors).</li>
<li>Avoid "naked" <code class="language-text">new</code> and <code class="language-text">delete</code> ; instead, use containers (e.g., <code class="language-text">vector</code>, <code class="language-text">string</code>, and <code class="language-text">map</code>) and handle classes (e.g., <code class="language-text">lock</code> and <code class="language-text">unique_ptr</code> ).</li>
<li>Use freestanding functions (nonmember functions) to minimize coupling (e.g., see the
standard algorithms), and use namespaces (§2.4.2, Chapter 14) to limit the scope of free-
standing functions.</li>
<li>Don’t use exception specifications (except <code class="language-text">noexcept</code>; §13.5.1.1).</li>
<li>A C++ nested class does not have access to an object of the enclosing class.</li>
<li>C++ offers only the most minimal run-time reflection: <code class="language-text">dynamic_cast</code> and <code class="language-text">typeid</code> (Chapter
22). Rely more on compile-time facilities (e.g., compile-time polymorphism; Chapter 27,
Chapter 28).</li>
</ol>
<h1>Ключевые слова</h1>
<h2>constexpr</h2>
<p><code class="language-text">const</code> - константное выражение, которое может быть вычислено на этапе выполнения.</p>
<p><code class="language-text">constexpr</code> - константное выражение, которое должно быть вычислено на этапе компиляции. Необходимо для экономии ресурсов, а так же в некоторых синтаксических конструкциях. </p>
<ul>
<li>Переменная может быть объявлена как <code class="language-text">constexpr</code>, если она имеет <strong>литеральный тип</strong> и инициализирована. Если инициализация осуществляется через конструктор, то конструктор должен быть помечен как <code class="language-text">constexpr</code>. </li>
<li>Ссылка может быть объявлена как <code class="language-text">constexpr</code>, если объект, на который она ссылается инициализирован константным выражением и все преобразования, выполняемые при инициализации, тоже являются константными выражениями.</li>
</ul>
<h1>Указатели</h1>
<p>Проверка, указывает ли указатель на объект:</p>
<p><code class="language-text">if (p==nullptr) return 0;</code></p>
<h2>Разница между указателями и ссылками</h2>
<ol>
<li>Указатель может быть переназначен сколько угодно раз, ссылка - не может.</li>
<li>Указатель может указывать в никуда (<code class="language-text">nullptr</code>), ссылка - не может.</li>
<li>Адрес ссылки получить нельзя.</li>
<li>Нет "арифметики ссылок".</li>
<li>Можно иметь указатель на указатель на указатель и т.д. У ссылок может быть только один уровень.</li>
<li>Чтобы получить значение по ссылке, не нужно использовать символы * и ->.</li>
</ol>
<h2>Когда использовать ссылки</h2>
<ul>
<li>аргументы функций</li>
<li>возвращаемые значения функций</li>
</ul>
<h2>Когда использовать указатели</h2>
<ul>
<li>в алгоритмах</li>
<li>в структурах данных</li>
</ul>
<h1>Конструктор инициализации</h1>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">class Vector {
public:
    Vector(int s) :elem{new double[s]}, sz{s} {}
private:
    double* elem;
    int sz;
};</code></pre></div>
<p>Здесь запись <code class="language-text">Vector(int s) :elem{new double[s]}, sz{s} {}</code> означает, что при использовании этого конструктора нужно приватные поля <code class="language-text">elem</code> и <code class="language-text">sz</code> инициализировать указанными значениями.</p>
<h1>Ассершны</h1>
<p>Ассерты в рантайме осуществляются командой <code class="language-text">static_assert</code>:</p>
<p><code class="language-text">static_assert(4&lt;=sizeof(int), &quot;Integers are too small&quot;);</code></p>
<h1>RAII</h1>
<p>Формулируется так: владение ресурсом есть инварианта класса. Это означает, что захват ресурса должен производиться в конструкторе, а освобождение - в деструкторе.</p>
<p>Рантайм обеспечивает, что деструктор вызывается только, если конструктор не возбудил исключения. Поэтому если в конструкторе не удалось захватить ресурс - нужно стрелять исключение. Если в деструкторе не удалось освободить - тоже стрелять исключение.</p>
<h1>initializer_list</h1>
<p>Если мы инициализируем контейнер следующей конструкцией:</p>
<p><code class="language-text">Vector v = {1,2,3,4,5};</code></p>
<p>то у него вызывается вот такой конструктор:</p>
<p><code class="language-text">Vector(initializer_list&lt;double&gt; lst)</code></p>
<h2>Пример реализации</h2>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">#include <span class="token operator">&lt;</span>initializer_list<span class="token operator">></span>
#include <span class="token operator">&lt;</span>algorithm<span class="token operator">></span>

<span class="token function">Vector</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>initializer_list<span class="token operator">&lt;</span>double<span class="token operator">></span> lst<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">copy</span><span class="token punctuation">(</span>lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lst<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> elem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<h1>Типы и префиксы строк</h1>
<ul>
<li><strong>char</strong> - 8-битные символы, нужен для ASCII и UTF-8</li>
<li><strong>char16_t</strong> - 16-битные символы, нужен для UTF-16</li>
<li><strong>char32_t</strong> - 32-битные символы, нужен для UTF-32</li>
<li><strong>wchar_t</strong> - любые "широкие" символы (wide characters), то есть символы с размером, большим чем 8 бит. Имеет размер, достаточный для того, чтобы представить любой поддерживаемый символ Unicode.</li>
</ul>
<p>Префиксы:</p>
<table>
<thead>
<tr>
<th align="right">Префикс</th>
<th>Тип</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">"Hello"</td>
<td>const char*</td>
</tr>
<tr>
<td align="right">L"Hello"</td>
<td>const wchar_t*</td>
</tr>
<tr>
<td align="right">u8"Hello"</td>
<td>const char* / const char8_t*</td>
</tr>
<tr>
<td align="right">u"Hello"</td>
<td>const char16_t*</td>
</tr>
<tr>
<td align="right">U"Hello"</td>
<td>const char32_t*</td>
</tr>
</tbody>
</table>
<p>Пример:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main()
{
    cout &lt;&lt; &quot;\n\n Hello World! (plain) \n&quot;;
    cout &lt;&lt; u8&quot;\n Hello World! (u8) \n&quot;;
    cout &lt;&lt; u&quot;\n Hello World! (u) \n&quot;;
    cout &lt;&lt; U&quot;\n Hello World! (U) \n&quot;;
    cout &lt;&lt; L&quot;\n Hello World! (plain) \n\n&quot;;

    cout &lt;&lt; &quot;\n\n\n&quot;;
}</code></pre></div>
<p>3-5 <code class="language-text">cout</code> вернут ерунду типа <code class="language-text">0x47f0d8</code>. Так происходит из-за того, что оператор <code class="language-text">&lt;&lt;</code> для класса <code class="language-text">std::cout</code> принимает <code class="language-text">const char*</code>, но не содержит перегрузок для <code class="language-text">const char16_t*</code>, <code class="language-text">const char32_t*</code>, <code class="language-text">const wchar_t*</code>. Поэтотому он применит перегрузку для печати указателей.</p>
<p>Однако для вывода последнего есть специальный класс: <code class="language-text">std::wcout</code>.</p>
<h1>Инициализация</h1>
<p>Есть 4 синтаксических стиля инициализации объектов:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">X a1<span class="token punctuation">{</span>v<span class="token punctuation">}</span><span class="token punctuation">;</span>
X a2 <span class="token operator">=</span> <span class="token punctuation">{</span>v<span class="token punctuation">}</span><span class="token punctuation">;</span>
X a3 <span class="token operator">=</span> v<span class="token punctuation">;</span>
X <span class="token function">a4</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Самая предпочтительная - первая, через <code class="language-text">{}</code>. Она же и самая новая - появилась в C++11.</p>
<p>Ее преимущество в том, что она не допускает "сужения" типов, то есть:</p>
<ul>
<li>char приводить к int можно, наоборот - нельзя</li>
<li>float приводить к double можно, наоборот - нельзя</li>
<li>число с плавающей точкой нельзя приводить к целому</li>
<li>целое число нельзя приводить к числу с плавающей точкой</li>
</ul>
<p>Однако если используется <code class="language-text">auto</code>, то лучше использовать форму <code class="language-text">a3</code>, то есть через <code class="language-text">=</code>. Во-первых, в этом случае инициализация через <code class="language-text">{}</code> не дает никаких преимуществ, а во-вторых тип может быть определен не так, как мы хочем:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto z1 <span class="token punctuation">{</span><span class="token number">99</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// initializer_list&lt;int></span>
auto z2 <span class="token operator">=</span> <span class="token number">99</span><span class="token punctuation">;</span> <span class="token comment">// int</span></code></pre></div>
<p>Пустой список инициализации <code class="language-text">{}</code> присвоит дефолтное значение:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">int x<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 0</span>
char<span class="token operator">*</span> p <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// nullptr</span>
char buf<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// массив из тысячи нулей</span></code></pre></div>
<h1>Алиасы типов</h1>
<h2>using</h2>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">using Pchar <span class="token operator">=</span> char<span class="token operator">*</span><span class="token punctuation">;</span>
using PF <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>double<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Можно эти алиасы даже объявлять внутри типов и обращаться потом извне:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>class <span class="token class-name">T</span><span class="token operator">></span>
class <span class="token class-name">vector</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
    using value_type <span class="token operator">=</span> T<span class="token punctuation">;</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

vector<span class="token operator">&lt;</span>int<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>value_type vt<span class="token punctuation">;</span> <span class="token comment">//int</span></code></pre></div>
<h2>typedef</h2>
<p>Это более старый синтаксис, служащий в тех же целях. Но он сложнее в понимании, потому что объявляемое имя стоит там, где стояло бы имя переменной при ее объявлении. В определении не могут быть использованы шаблоны. Не рекомендуется к использованию в современном C++. </p>
<p>Примеры:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">typedef int int32_t<span class="token punctuation">;</span> <span class="token comment">// using int32_t = int;</span>
typedef short int16_t<span class="token punctuation">;</span> <span class="token comment">// using unt16_t = short;</span>
typedef <span class="token function">void</span><span class="token punctuation">(</span><span class="token operator">*</span>PtoF<span class="token punctuation">)</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span> <span class="token comment">// using PtoF = void(*)(int);</span></code></pre></div>
<p>Суффикс <code class="language-text">_t</code> в названиях типов по соглашению используется для алиасов.</p>
<h1>Константные указатели</h1>
<p>Если константным должен быть сам указатель, то вместо <code class="language-text">*</code> нужно использовать <code class="language-text">*const</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">char<span class="token operator">*</span> p<span class="token punctuation">;</span>
char s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>

const char<span class="token operator">*</span> pc <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// указатель на константу</span>
pc<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'g'</span><span class="token punctuation">;</span> <span class="token comment">// ОШИБКА</span>
pc <span class="token operator">=</span> p<span class="token punctuation">;</span>      <span class="token comment">// ok</span>

char <span class="token operator">*</span>const cp <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// константый указатель</span>
cp<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'g'</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
cp <span class="token operator">=</span> p<span class="token punctuation">;</span>      <span class="token comment">// ОШИБКА</span>

const char <span class="token operator">*</span>const cpc <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// константный указатель на константу</span>
cpc<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'g'</span><span class="token punctuation">;</span>  <span class="token comment">// ОШИБКА</span>
cpc <span class="token operator">=</span> p<span class="token punctuation">;</span>       <span class="token comment">// ok</span></code></pre></div>
<p>Если ошибиться и вместо <code class="language-text">*const</code> написать <code class="language-text">const*</code>, то это опять будет указатель на константу:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">char <span class="token operator">*</span>const cp<span class="token punctuation">;</span>  <span class="token comment">// константный указатель</span>
char const<span class="token operator">*</span> pc<span class="token punctuation">;</span>  <span class="token comment">// указатель на константу</span>
const char<span class="token operator">*</span> pc2<span class="token punctuation">;</span> <span class="token comment">// опять указатель на константу</span></code></pre></div>
<p>Удобнее читать эти определения справа налево: <code class="language-text">cp</code> это константый указатель на <code class="language-text">char</code>, а <code class="language-text">pc2</code> это указатель на <code class="language-text">char const</code>.</p>
<h1>rvalue/lvalue</h1>
<p><a href="http://thbecker.net/articles/rvalue_references/section_01.html">http://thbecker.net/articles/rvalue_references/section_01.html</a></p>
<p><strong>lvalue</strong> - объект, который занимает идентифицируемое место в памяти (например, имеет адрес)</p>
<p><strong>rvalue</strong> - все остальное. То есть это выражение, которое не представляет собой объект, занимающий идентифицируемое место в памяти.</p>
<p>lvalue можно менять, rvalue - нет.</p>
<p>lvalue может быть преобразовано в rvalue, но <strong>rvalue в lvalue преобразовано быть не может</strong>.</p>
<p>Ссылка на lvalue формируется приписыванием "&#x26;": <code class="language-text">A&amp; a_ref = a;</code>, а ссылка на rvalue - приписыванием "&#x26;&#x26;": <code class="language-text">A&amp;&amp; a_ref = a;</code>.</p>
<p>Оператор "*" принимает rvalue, а возвращает lvalue: <code class="language-text">*(p + 1) = 10</code></p>
<p>Оператор "&#x26;" - наоборот, принимает lvalue, а возвращает rvalue: <code class="language-text">int *addr = &amp;v;</code>, поэтому символ <code class="language-text">&amp;</code> еще называют "ссылкой на lvalue".</p>
<p>Неконстантной ссылке на lvalue не может быть присвоено rvalue, так как это потребовало бы невалидного преобразования rvalue в lvalue. Однако если ссылка на lvalue - константна, то можно, так как в этом случае отсутствует проблема модификации rvalue:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const std::string &amp;ref = std::string();</code></pre></div>
<p>Именно благодаря этому свойству в функции можно передавать константные ссылки на значения:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">#include <span class="token operator">&lt;</span>iostream<span class="token operator">></span>

int length <span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

int lengthConst <span class="token punctuation">(</span>const std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token string">"Hello!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// не скомпилится, потому что пытаемся передать rvalue как неконстантную ссылку</span>

  std<span class="token punctuation">:</span><span class="token punctuation">:</span>string h <span class="token operator">=</span> <span class="token string">"Hello!"</span><span class="token punctuation">;</span>
  std<span class="token operator">&lt;</span><span class="token operator">&lt;</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token function">length</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// а тут нормально скопилится, потому что передаем уже lvalue</span>

  std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token function">lengthConst</span><span class="token punctuation">(</span><span class="token string">"Hello!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// скомпилится, потому что ссылка принимается константная</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Копии rvalue обычно создаются конструктором перемещения, а копии lvalue - конструктором копирования.</p>
<p>Если у нас есть такое объявление функции:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">void <span class="token function">someFunc</span><span class="token punctuation">(</span>Widget w<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>vмы ничего не можем сказать о стоимости копирования <code class="language-text">w</code> в функцию <code class="language-text">someFunc</code>, так как не знаем, это rvalue или lvalue.</p>
<h1>Конструктор</h1>
<p>Если у класса есть конструктор, принимающий один аргумент, то этот конструктор будет вызываться при инициализации аргументов этого типа.</p>
<p>Пример:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">uri</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
    <span class="token function">uri</span><span class="token punctuation">(</span>const char<span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span> _c<span class="token punctuation">{</span>s<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
private<span class="token punctuation">:</span>
    const char<span class="token operator">*</span> _c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

uri u <span class="token operator">=</span> <span class="token string">"http://www.ya.ru"</span><span class="token punctuation">;</span>   <span class="token comment">// будет вызван конструктор</span></code></pre></div>
<h1>Копирование объектов</h1>
<p>По дефолту при присваивании происходит полное копирование всех членов объекта.</p>
<p>Например,</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token number">1</span> Vector <span class="token function">bad_copy</span><span class="token punctuation">(</span>Vector v1<span class="token punctuation">)</span> 
<span class="token number">2</span> <span class="token punctuation">{</span>
<span class="token number">3</span> 	Vector v2 <span class="token operator">=</span> v1<span class="token punctuation">;</span>
<span class="token number">4</span> 	v1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment">// v2[0] теперь тоже равен 2</span>
<span class="token number">5</span> 	v2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>   <span class="token comment">// v1[1] теперь тоже равен 3</span>
<span class="token number">6</span> 	<span class="token keyword">return</span> v2<span class="token punctuation">;</span>
<span class="token number">7</span> <span class="token punctuation">}</span></code></pre></div>
<p>В большинстве случаев это совсем не то, чего мы хотели, так как это может нарушить RAII. Простое правило - если у класса есть деструктор, то это скорее всего означает, что дефолтная семантика копирования нам не подходит.</p>
<p>Варианта решения два: <em>конструктор копирования</em> и <em>присваивание копированием</em>.</p>
<h2>Конструктор копирования</h2>
<p>Этот конструктор будет неявно вызываться каждый раз, когда мы передаем значение в функцию (не по ссылке), либо возвращаем из функции (опять же не по ссылке).</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">Vector<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">Vector</span><span class="token punctuation">(</span>const Vector<span class="token operator">&amp;</span> a<span class="token punctuation">)</span>
	<span class="token punctuation">:</span>elem<span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">double</span><span class="token punctuation">[</span>sz<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
	sz<span class="token punctuation">{</span>a<span class="token punctuation">.</span>sz<span class="token punctuation">}</span>
<span class="token punctuation">{</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>int i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>sz<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		elem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>В вышеуказанном примере конструктор копирования будет вызван в строчках 1 и 6.</p>
<h2>Присваивание копированием</h2>
<p>Этот метод будет вызываться, когда происходит присваивание не по ссылке.</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">Vector<span class="token operator">&amp;</span> Vector<span class="token punctuation">:</span><span class="token punctuation">:</span>operator<span class="token operator">=</span><span class="token punctuation">(</span>const Vector<span class="token operator">&amp;</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	double<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">double</span><span class="token punctuation">[</span>a<span class="token punctuation">.</span>sz<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>int i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	delete<span class="token punctuation">[</span><span class="token punctuation">]</span> elem<span class="token punctuation">;</span>
	elem<span class="token operator">=</span>p<span class="token punctuation">;</span>
	sz<span class="token operator">=</span>a<span class="token punctuation">.</span>sz<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>В вышеуказанном примере конструктор копирования будет вызван в строчке 3.</p>
<h1>Перемещение объектов</h1>
<p>Допустим, у нас есть такой код:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token number">1</span> Vector operator<span class="token operator">+</span><span class="token punctuation">(</span>const Vector<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> const Vector<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>
<span class="token number">2</span> <span class="token punctuation">{</span>
<span class="token number">3</span>     Vector <span class="token function">res</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">4</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span>int i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">!=</span>a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
<span class="token number">5</span>         res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token number">6</span>     <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token number">7</span> <span class="token punctuation">}</span></code></pre></div>
<p>Аргументы передаются по ссылке, тут все нормально. Но возвращать ссылку мы не можем (переменная на стеке res будет уничтожена как только мы выйдем из функции). Поэтому возвращаем значение и тут опять будет вызван конструктор копирования. Если вектор большой, то это будет весьма затратная операция.</p>
<p>Более того, если клиент будет использовать суммирование так:</p>
<p><code class="language-text">Vector v = v1 + v2 + v3</code></p>
<p>то в процессе будет осуществлено как минимум одно побочное копирование, которое нам в конечном счете совсем не нужно.</p>
<p>Чтобы избежать копирования большого количества полей объекта, можно реализовать семантику перемещения через <em>конструктор перемещения</em> или <em>присваивание перемещением</em>. </p>
<p>Обе эти конструкции используют <code class="language-text">&amp;&amp;</code>, что означает не ссылку на ссылку, а <strong>rvalue reference</strong>.</p>
<p>Реализуется конструктор/присваивание таким образом, чтобы нужные поля "переместились" из правой части в левую, то есть из правой части значения пропадают, а в левой - появляются.</p>
<p>Также мы можем "помочь" компилятору, указав явное перемещение командой <code class="language-text">std::move</code>.</p>
<p>При присваивании объекта, если компилятор находит у его типа операции перемещения, то использует их. Если нет = то находит и использует операции копирования. С <code class="language-text">std::move</code> то же самое, если он не найдет операции перемещения, то воспользуется копированием.</p>
<h2>std::move</h2>
<p>Все, что делает <code class="language-text">std::move</code> - принимает аргумент в виде lvalue или rvalue и возвращает его как rvalue БЕЗ вызова конструктора копирования:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>class <span class="token class-name">T</span><span class="token operator">></span>
typename remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>type<span class="token operator">&amp;&amp;</span>
<span class="token function">move</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>После этого в клиентском компилятор подбирает для копирования либо операцию перемещения, либо копирования, в зависимости от того, реализована ли операция перемещения (которая, напомню, принимает rvalue). Если не реализована, то rvalue превращается обратно в lvalue и подается в конструктор копирования.</p>
<h2>Perfect forwarding</h2>
<p>Допустим, у нас есть такая функция:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template <span class="token operator">&lt;</span>typename T<span class="token punctuation">,</span> typename A1<span class="token operator">></span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">factory</span><span class="token punctuation">(</span>A1<span class="token operator">&amp;</span> a1<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Мы не можем вызвать <code class="language-text">factory&lt;foo&gt;(5)</code>, потому что 5 это rvalue, функция принимает <code class="language-text">A1&amp;</code> - lvalue, а rvalue к lvalue не приводится.</p>
<p>Мы могли бы принимать константную ссылку:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template <span class="token operator">&lt;</span>typename T<span class="token punctuation">,</span> typename A1<span class="token operator">></span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">factory</span><span class="token punctuation">(</span>const A1<span class="token operator">&amp;</span> a1<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>но что если конструктор <code class="language-text">T</code> должен принимать не-константные ссылки?</p>
<p>Нам поможет использование rvalue и <code class="language-text">std::forward</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template <span class="token operator">&lt;</span>typename T<span class="token punctuation">,</span> typename A1<span class="token operator">></span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">factory</span><span class="token punctuation">(</span>A1<span class="token operator">&amp;&amp;</span> a1<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>forward<span class="token operator">&lt;</span>A1<span class="token operator">></span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p><code class="language-text">std::forward</code> просто передает аргумент дальше, сохраняя его "rvalue/lvalue-ness". То есть rvalue он передает как rvalue, а lvalue - как lvalue.</p>
<h2>Moveable но non-copyable типы</h2>
<p>Некоторые типы поддерживают присваивание только перемещением. К ним относятся:</p>
<ul>
<li><code class="language-text">fstream</code></li>
<li><code class="language-text">unique_ptr</code></li>
<li>типы, представляющие треды</li>
</ul>
<p>Засчет того, что они всегда перемещаются, мы можем их спокойно возвращать из фабричных функций по значению, не боясь, что возникнет копия или протухнет ссылка.</p>
<p>Так же мы можем такие типы спокойно передавать в стандартные контейнеры и если контейнеру нужно скопировать значение, то он обязательно сначала попробует его переместить:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">vector<span class="token operator">&lt;</span>unique_ptr<span class="token operator">&lt;</span>base<span class="token operator">></span><span class="token operator">></span> v1<span class="token punctuation">,</span> v2<span class="token punctuation">;</span>
v1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">unique_ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ok, moving, not copying</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
v2 <span class="token operator">=</span> v1<span class="token punctuation">;</span>             <span class="token comment">// Compile time error.  This is not a copyable type.</span>
v2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// Move ok.  Ownership of pointers transferred to v2.</span></code></pre></div>
<h2>Конструктор перемещения</h2>
<p>Имеет сигнатуру <code class="language-text">Vector(Vector&amp;&amp; a)</code>.</p>
<p>Пример реализации:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">Vector<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">Vector</span><span class="token punctuation">(</span>Vector<span class="token operator">&amp;&amp;</span> a<span class="token punctuation">)</span>
	<span class="token punctuation">:</span>elem<span class="token punctuation">{</span>a<span class="token punctuation">.</span>elem<span class="token punctuation">}</span><span class="token punctuation">,</span>
	sz<span class="token punctuation">{</span>a<span class="token punctuation">.</span>sz<span class="token punctuation">}</span>
<span class="token punctuation">{</span>
	a<span class="token punctuation">.</span>elem <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
	a<span class="token punctuation">.</span>sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>В указанном примере компилятор распознает возможность и вызовет конструктор перемещения в строке 6.</p>
<h2>Присваивание перемещением</h2>
<p>Имеет сигнатуру <code class="language-text">Vector&amp; operator=(Vector &amp;&amp; a)</code>.</p>
<h2>Автогенерируемые типы</h2>
<p>Конструктор перемещения и присваивание перемещением генерируются автоматически для типов, у которых не определены операции перемещения, копирования и деструктор.</p>
<p>Конструктор копирования генерируется автоматически для типов, у которых он не определен, а так же удаляется если определена хотя бы одна операция перемещения.</p>
<p>Оператор присваивания копированием генерируется автоматически для типов, у которых он не определен, а так же удаляется если определена хотя бы одна операция перемещения.</p>
<h1>Шаблоны</h1>
<p>Синтаксис такой:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
class <span class="token class-name">Vector</span> <span class="token punctuation">{</span>
private<span class="token punctuation">:</span>
	T<span class="token operator">*</span> elem<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Причем если есть функции, определенные снаружи скоупа класса, то для них шаблон должен быть определен точно так же:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
T<span class="token operator">&amp;</span> Vector<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>operator<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>int i<span class="token punctuation">)</span> const
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> elem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Причем придется так писать даже если тип внутри метода не используется:</p>
<p>И еще <strong>важное примечание</strong>. Шаблонные реализации методов <strong>не могут</strong> быть описаны в файле .cpp, только в .h! Поэтому если у нас в .h заголовке описывается шаблонный класс, то это нормально, если у него нет соответствующего .cpp файла и все реализации описаны прямо в заголовке!</p>
<p>Причина этого - в том, что все .cpp файлы компилируются по отдельности (а потом соединяются воедино линковщиком). В .cpp файле у нас, допустим, встречается <code class="language-text">Vector&lt;int&gt;</code>. Чтобы скомпилировать эту строчку, компилятору нужно сгенерить новый класс, а для этого он должен видеть реализацию шаблона. Если реализация описана в другом файле .cpp, то на данном этапе у компилятора нет к нему доступа, а есть только к тем, которые описаны в текущем файле в секциях <code class="language-text">#include</code> (обычно это файлы заголовков). Когда же он дойдет до компиляции того файла .cpp, в котором описана реализация шаблона, то он уже забудет, что нужно было сгенерить <code class="language-text">Vector&lt;int&gt;</code>, так как (см. выше) все файлы компилятся отдельно.</p>
<p>Еще часто делают так:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token comment">// Foo.h</span>
template <span class="token operator">&lt;</span>typename T<span class="token operator">></span>
struct Foo
<span class="token punctuation">{</span>
    void <span class="token function">doSomething</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

#include <span class="token string">"Foo.tpp"</span>

<span class="token comment">// Foo.tpp</span>
template <span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void Foo<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">doSomething</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//implementation</span>
<span class="token punctuation">}</span></code></pre></div>
<h2>Вывод типов для шаблонов</h2>
<p>Допустим, у нас есть такое объявление функции:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f</span><span class="token punctuation">(</span>ParamType param<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ParamType - это какая-то производная от T, например, const T&amp;</span></code></pre></div>
<p>и вызов функции выглядит так:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token function">f</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Тогда в зависимости от типа <code class="language-text">expr</code> будут получаться разные типы <code class="language-text">T</code> и <code class="language-text">ParamType</code>, причем вовсе не обязательно одинаковые. Неодинаковы они потому, что <code class="language-text">ParamType</code> может содержать ограничения, такие как <code class="language-text">const</code> или <code class="language-text">&amp;</code>. </p>
<p>При выводе этих типов есть 3 варианта:</p>
<h3>ParamType является указателем или ссылкой, но не универсальной ссылкой</h3>
<p>В этом случае:</p>
<ol>
<li>если тип <code class="language-text">expr</code> - ссылка, то она отбрасывается, получаем <code class="language-text">expr&#39;</code></li>
<li>после этого тип <code class="language-text">expr&#39;</code> паттерн-матчится против <code class="language-text">ParamType</code> для определения <code class="language-text">T</code>. При этом если в аргумент передается переменная типа <code class="language-text">Х</code>, то на принимающей стороне она может матчиться как на <code class="language-text">X</code>, так и на <code class="language-text">X&amp;</code> или <code class="language-text">X*</code>, так как это не противоречит правилам языка.</li>
</ol>
<p>Примеры:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template <span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

int x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> int, ParamType -> int&amp;. Здесь и далее вывод типов делает предположение, что внутрь передается не x, а ссылка на x. f(27) в этом случае вызвать не выйдет, так как rvalue не матчится на T&amp;, который означает lvalue.</span>

const int cx <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> const int, ParamType -> const int&amp;</span>

const int<span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> const int, ParamType -> const int&amp; (ссылка игнорится)</span></code></pre></div>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template <span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f</span><span class="token punctuation">(</span>const T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

int x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> int, ParamType -> const int&amp;</span>

const int cx <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> int, ParamType -> const int&amp;</span>

const int<span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> int, ParamType -> const int&amp; (ссылка игнорится)</span></code></pre></div>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template <span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">*</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

int x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> int, ParamType -> int*</span>

const int <span class="token operator">*</span>px <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> const int, ParamType -> const int*</span></code></pre></div>
<h3>ParamType является универсальной ссылкой</h3>
<p>Универсальная ссылка - это когда объявление шаблонного типа выглядит как <code class="language-text">T&amp;&amp;</code>. Универсальная - потому что это может означать как <em>rvalue</em>, так и <em>lvalue</em>.</p>
<p>В этом случае:</p>
<ol>
<li>Если <code class="language-text">expr</code> - <em>lvalue</em>, то <code class="language-text">T</code> и <code class="language-text">ParamType</code> выводятся как ссылки на <em>lvalue</em> того же типа.</li>
<li>Если <code class="language-text">expr</code> - <em>rvalue</em>, то используются "нормальные" правила, то есть как в 1 случае</li>
</ol>
<p>Примеры:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

int x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// x: lvalue, T -> int&amp;, ParamType -> int&amp;</span>

const int cx <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// cx: lvalue, T -> const int&amp;, ParamType -> const int&amp;</span>

const int<span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// rx: lvalue, T -> const int&amp;, ParamType -> const int&amp;</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 27: rvalue, T -> int, ParamType -> int&amp;&amp;</span></code></pre></div>
<h3>ParamType - не указатель и не ссылка</h3>
<p>В этом случае:</p>
<ol>
<li>Если тип <code class="language-text">expr</code> - ссылка, то она отбрасывается</li>
<li>Если после отбрасывания ссылки <code class="language-text">expr</code> является <code class="language-text">const</code>, то это отбросить тоже. Если она <code class="language-text">volatile</code>, то и это отбрасываем.</li>
<li>Матчим то, что получилось, против <code class="language-text">ParamType</code>, чтобы получить <code class="language-text">T</code>.</li>
</ol>
<p>Примеры:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>

int x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> int, ParamType -> int</span>

const int cx <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> int, ParamType -> int</span>

const int<span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> int, ParamType -> int</span></code></pre></div>
<h3>Особый случай с массивами</h3>
<p>Пусть у нас есть такой массив и такое определение шаблона:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>

const char name<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello!"</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Здесь вспомним, что массив это всегда синтаксический сахар для указателя, а значит тип T будет выведен как <code class="language-text">const char*</code>.</p>
<p>Пока ничего удивительного. Но, хоть функции и не могут принимать параметром настоящий массив, зато они могут принимать ссылку на массив!</p>
<p>И если наше определение шаблона выглядит так:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>то при вызове <code class="language-text">f(name)</code> тип T будет выведен как <code class="language-text">const char[6]</code>, а тип <code class="language-text">param</code> - как <code class="language-text">const char (&amp;)[6]</code>.</p>
<p>Этим можно пользоваться, выводя во время компиляции размер массива:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>size_t N<span class="token operator">></span> 
std<span class="token punctuation">:</span><span class="token punctuation">:</span>size_t <span class="token function">arraySize</span><span class="token punctuation">(</span>T <span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> noexcept <span class="token punctuation">{</span>
	<span class="token keyword">return</span> N<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

int keyVals<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
int mappedVals<span class="token punctuation">[</span><span class="token function">arraySize</span><span class="token punctuation">(</span>keyVals<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre></div>
<h3>Частный случай с параметрами-функциями</h3>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">void <span class="token function">someFunc</span><span class="token punctuation">(</span>int<span class="token punctuation">,</span> double<span class="token punctuation">)</span><span class="token punctuation">;</span>

template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f1</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>

template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f2</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">f1</span><span class="token punctuation">(</span>someFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// type -> void (*)(int, double)</span>

<span class="token function">f2</span><span class="token punctuation">(</span>someFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// type -> void (&amp;)(int, double)</span></code></pre></div>
<p>Общее правило - для массивов и функций значения превращаются в указатели на значения, кроме тех случаев, когда на стороне шаблона принимается аргумент типа ссылки.</p>
<h2>Вариативные шаблоны</h2>
<p>Вариативные шаблоны - это шаблоны с заранее неизвестным числом аргументов.</p>
<p>Пример:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token punctuation">,</span> typename <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Tail<span class="token operator">></span>
void <span class="token function">f</span><span class="token punctuation">(</span>T head<span class="token punctuation">,</span> Tail<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> tail<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">g</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// сделать что-то с первым параметром</span>
	<span class="token function">f</span><span class="token punctuation">(</span>tail<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// рекурсивно вызвать себя с оставшимися параметрами</span>
<span class="token punctuation">}</span>

void <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>  <span class="token comment">// когда ничего не осталось в списке типов - не делать ничего</span>

template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">g</span><span class="token punctuation">(</span>T x<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> x <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span>  <span class="token comment">// выведет 1 0.2 hello</span></code></pre></div>
<h1>Функторы</h1>
<p>Функторы - это объекты-функции, то есть объекты, которые могут быть вызваны как функции.</p>
<p>Чтобы создать функтор, нужно всего лишь у класса переопределить ооператор <code class="language-text">()</code>.</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
class <span class="token class-name">Less_than</span> <span class="token punctuation">{</span>
	const T val<span class="token punctuation">;</span>  <span class="token comment">// value to compare against</span>
public<span class="token punctuation">:</span>
	<span class="token function">Less_than</span><span class="token punctuation">(</span>const T<span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token function">val</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
	bool <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>const T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> const <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token operator">&lt;</span>val<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// call operator</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Less_than<span class="token operator">&lt;</span>int<span class="token operator">></span> lti <span class="token punctuation">{</span><span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// lti(i) will compare i to 42 using &lt; (i&lt;42)</span>
Less_than<span class="token operator">&lt;</span>string<span class="token operator">></span> lts <span class="token punctuation">{</span><span class="token string">"Backus"</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// lts(s) will compare s to "Backus" using &lt; (s&lt;"Backus")</span>

void <span class="token function">fct</span><span class="token punctuation">(</span>int n<span class="token punctuation">,</span> const string <span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	bool b1 <span class="token operator">=</span> <span class="token function">lti</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true if n&lt;42</span>
	bool b2 <span class="token operator">=</span> <span class="token function">lts</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true if s&lt;"Backus"</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<h1>Лямбды</h1>
<p>Лямбды описываются так:</p>
<p><code class="language-text">[&amp;](int a){ return a&lt;x; }</code></p>
<p>Здесь <code class="language-text">[&amp;]</code> - это capture list, или лист захвата. Возможные значения:</p>
<ul>
<li><code class="language-text">[&amp;]</code> что все переменные, используемые в теле лямбды, будут переданы по ссылке</li>
<li><code class="language-text">[&amp;x]</code> - передается только <code class="language-text">x</code>, по ссылке</li>
<li><code class="language-text">[=]</code> что все переменные, используемые в теле лямбды, будут переданы в виде копий</li>
<li><code class="language-text">[=x]</code> - передается только <code class="language-text">x</code>, в виде копии</li>
<li><code class="language-text">[]</code> - не передается ничего</li>
</ul>
<p>Принимать лямбду в качестве аргумента можем, используя тип <code class="language-text">std::function&lt;R(Args...)&gt;</code>, где <code class="language-text">R</code> - тип результата, а <code class="language-text">Args...</code> - типы аргументов.</p>
<p>Пример:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">void <span class="token function">f</span><span class="token punctuation">(</span>const std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">function</span><span class="token operator">&lt;</span><span class="token function">void</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token operator">></span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// принимаем функцию, принимающую string и возвращающую ничего</span></code></pre></div>
<h1>Стандартная библиотека</h1>
<h2>Коллекции</h2>
<ul>
<li><code class="language-text">vector&lt;T&gt;</code> - стандартный массив с динамическим размером. Проверок на выход за границы не делает, выдает мусор в этом случае</li>
<li><code class="language-text">list&lt;T&gt;</code> - двойной связанный список</li>
<li><code class="language-text">forward_list&lt;T&gt;</code> - одинарный связанный список</li>
<li><code class="language-text">deque&lt;T&gt;</code> - очередь с двумя концами</li>
<li><code class="language-text">set&lt;T&gt;</code> - множество</li>
<li><code class="language-text">multiset&lt;T&gt;</code> - множество, в котором значение может встречаться несколько раз</li>
<li><code class="language-text">map&lt;K,V&gt;</code> - ассоциативный массив, реализованный в виде красно-черного дерева поиска. Сложность поиска - <strong>O(log(n))</strong>.</li>
<li><code class="language-text">multimap&lt;K,V&gt;</code> - ассоциативный массив, в котором значение может встречаться несколько раз</li>
<li><code class="language-text">unordered_map&lt;K,V&gt;</code> - ассоциативный массив, реализованный в виде хэш-таблицы.</li>
<li><code class="language-text">unordered_multimap&lt;K,V&gt;</code> - ассоциативный мульти-массив, реализованный в виде хэш-таблицы.</li>
<li><code class="language-text">unordered_set&lt;T&gt;</code> - множество, реализованное как хэш-таблица</li>
<li><code class="language-text">unordered_multiset&lt;T&gt;</code> - мультимножество, реализованное как хэш-таблица</li>
</ul>
<p>Все эти коллекции представлены в заголовках: <code class="language-text">&lt;vector&gt;, &lt;list&gt;, &lt;map&gt;</code>.</p>
<p>Помимо перечисленных есть еще:</p>
<ul>
<li><code class="language-text">queue&lt;T&gt;</code></li>
<li><code class="language-text">stack&lt;T&gt;</code></li>
<li><code class="language-text">priority_queue&lt;T&gt;</code></li>
</ul>
<h3>list</h3>
<p>Вставка и удаление реализуются с использованием итераторов:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">void <span class="token function">f</span><span class="token punctuation">(</span>const Entry<span class="token operator">&amp;</span> ee<span class="token punctuation">,</span> list<span class="token operator">&lt;</span>Entry<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>iterator p<span class="token punctuation">,</span> list<span class="token operator">&lt;</span>Entry<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>iterator q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	list<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> ee<span class="token punctuation">)</span><span class="token punctuation">;</span>
	list<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<h3>map</h3>
<p>Инициализация:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> int<span class="token operator">></span> book <span class="token punctuation">{</span>
	<span class="token punctuation">{</span><span class="token string">"Ann"</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">{</span><span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token number">456</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<h3>unordered_map</h3>
<p>Инициализация такая же, как и у <code class="language-text">map</code>.</p>
<p>Вставка:</p>
<h3>Итерирование по любой коллекции</h3>
<p>Через begin-end:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token keyword">for</span><span class="token punctuation">(</span>auto p <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> p<span class="token operator">!=</span>list<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>p<span class="token punctuation">)</span>
	cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> p<span class="token operator">-</span><span class="token operator">></span>name<span class="token punctuation">;</span></code></pre></div>
<p>Через местный форыч:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token keyword">for</span><span class="token punctuation">(</span>const auto<span class="token operator">&amp;</span> p<span class="token punctuation">:</span> list<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> p<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<h1>Управление ресурсами</h1>
<p>В первую очередь нужно использовать RAII и контейнеры. Указатели стоит использовать лишь тогда, когда нужна именно семантика указателей, и даже в этом случае стоит по минимуму использовать <code class="language-text">new</code> и <code class="language-text">delete</code>, а вместо этого прибегать к смарт-указателям: <code class="language-text">unique_ptr</code> и <code class="language-text">shared_ptr</code>.</p>
<h2>unique_ptr</h2>
<p>Инициализируется двумя способами:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>unique_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span>param1<span class="token punctuation">,</span> param2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
auto foo <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>make_unique<span class="token operator">&lt;</span>Foo<span class="token operator">></span><span class="token punctuation">(</span>param1<span class="token punctuation">,</span> param2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// начиная с C++ 14</span></code></pre></div>
<p>Лучше использовать второй вариант, так как он короче и производительнее.</p>
<p>Пример использования <code class="language-text">unique_ptr</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">void <span class="token function">f</span><span class="token punctuation">(</span>int i<span class="token punctuation">,</span> int j<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	X<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">X</span><span class="token punctuation">;</span>
	unique_ptr<span class="token operator">&lt;</span>X<span class="token operator">></span> sp <span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">X</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">99</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> Z<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span><span class="token number">77</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	p<span class="token operator">-</span><span class="token operator">></span><span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	sp<span class="token operator">-</span><span class="token operator">></span><span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//...</span>
	delete p<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>В строчках 6-9 может произойти преждевременный выход и тогда указатель <code class="language-text">p</code> не освободится. А указатель <code class="language-text">sp</code> гарантирует, что его объект будет уничтожен не зависимо от того, каким образом мы выйдем из функции.</p>
<p>Кстати, если бы мы объявили <code class="language-text">x</code> как <code class="language-text">X x;</code>, то достигли бы того же эффекта.</p>
<p><code class="language-text">unique_ptr</code> <strong>запрещено копировать</strong>, можно только перемещать:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto bar <span class="token operator">=</span> foo<span class="token punctuation">;</span> <span class="token comment">// не скомпилируется</span>
auto bar2 <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">move</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// а здесь все норм</span></code></pre></div>
<p>Можно взять обычный указатель, но это плохая практика, так как нарушается семантика эксклюзивного использования:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">Foo<span class="token operator">*</span> f <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
f<span class="token operator">-</span><span class="token operator">></span><span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Также на <code class="language-text">unique_ptr</code> можно создавать ссылки и в этом уже ничего плохого нет, так как в этом случае владение объектом "одалживается на время", но обращение идет через все тот же умный указатель:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto ref <span class="token operator">=</span> <span class="token operator">&amp;</span>foo<span class="token punctuation">;</span>
ref<span class="token operator">-</span><span class="token operator">></span><span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p><code class="language-text">unique_ptr</code> без проблем приводится к <code class="language-text">shared_ptr</code>, что очень удобно, когда мы вовзращаем результат из фабричных функций и не знаем, какая семантика владения понадобится клиенту:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  unique_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> foo <span class="token operator">=</span> create<span class="token operator">&lt;</span>Foo<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> foo2 <span class="token operator">=</span> create<span class="token operator">&lt;</span>Foo<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre></div>
<p>В <code class="language-text">unique_ptr</code> вторым параметром можно передать функцию deleter, которая будет вызвана для удаления ресурса (по умолчанию делается просто <code class="language-text">delete</code>):</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">using namespace std<span class="token punctuation">;</span>

template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
unique_ptr<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">function</span><span class="token operator">&lt;</span><span class="token function">void</span><span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> unique_ptr<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">function</span><span class="token operator">&lt;</span><span class="token function">void</span><span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>T<span class="token operator">*</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"Deleting "</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token function">typeid</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> endl<span class="token punctuation">;</span>
    delete data<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  unique_ptr<span class="token operator">&lt;</span>Foo<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">function</span><span class="token operator">&lt;</span><span class="token function">void</span><span class="token punctuation">(</span>Foo<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">></span> foo <span class="token operator">=</span> create<span class="token operator">&lt;</span>Foo<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Для удобства можно использовать <code class="language-text">decltype</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">using namespace std<span class="token punctuation">;</span>

class <span class="token class-name">Foo</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">deleter</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"Deleting "</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token function">typeid</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> endl<span class="token punctuation">;</span>
  delete ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
unique_ptr<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token function">decltype</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>deleter<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> unique_ptr<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token function">decltype</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>deleter<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> deleter<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  auto foo <span class="token operator">=</span> create<span class="token operator">&lt;</span>Foo<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p><strong>ВАЖНО:</strong> Если в умном указателе вы держите указатель на <em>массив</em> объектов, то обязаны указать <code class="language-text">custom deleter</code>, вызывающий для этого массива <code class="language-text">delete[]</code> вместо <code class="language-text">delete</code>. Если этого не сделать, будет освобожден только первый объект из массива, остальные же утекут.</p>
<h2>shared_ptr</h2>
<p>Семантика похожа на <code class="language-text">unique_ptr</code>, только эти указатели можно как перемещать, так и копировать. Сам по себе является потокобезопасным, но не делает потокобезопасным внутренний объект.</p>
<p>Так же как и <code class="language-text">unique_ptr</code> создается двумя способами:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span>param1<span class="token punctuation">,</span> param2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
auto foo <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>make_shared<span class="token operator">&lt;</span>Foo<span class="token operator">></span><span class="token punctuation">(</span>param1<span class="token punctuation">,</span> param2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>И здесь тоже лучше использовать второй вариант.</p>
<p>Пример использования <code class="language-text">shared_ptr</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">void <span class="token function">f</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>fstream<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
void <span class="token function">g</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>fstream<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

void <span class="token function">user</span><span class="token punctuation">(</span>const string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> ios_base<span class="token punctuation">:</span><span class="token punctuation">:</span>openmode mode<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	shared_ptr<span class="token operator">&lt;</span>fstream<span class="token operator">></span> fp <span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">fstream</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>∗fp<span class="token punctuation">)</span> <span class="token keyword">throw</span> No_file<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// make sure the file was properly opened</span>
	<span class="token function">f</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">g</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Файл, открытый конструктором <code class="language-text">fp</code> будет уничтожен, когда последняя из использующих его функций (<code class="language-text">user</code>, <code class="language-text">f</code>, <code class="language-text">g</code>) уничтожит свою копию указателя.</p>
<p><code class="language-text">shared_ptr</code> усложняет рассуждения о времени жизни объекта, поэтому его стоит использовать только когда точно нужно разделяемое владение.</p>
<p>Опасно создавать <code class="language-text">shared_ptr</code> из указателя на объект:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto pw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Widget</span><span class="token punctuation">;</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw1</span><span class="token punctuation">(</span>pw<span class="token punctuation">,</span> loggingDeleter<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw2</span><span class="token punctuation">(</span>pw<span class="token punctuation">,</span> loggingDeleter<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>потому что так может возникнуть несколько <code class="language-text">shared_ptr</code> на один объект, когда закончится время жизни первого - объект будет уничтожен и тогда все остальные получает сегфолт при попытке обращения к нему. </p>
<p>Избежать этого помогает функция <code class="language-text">make_shared</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> spw1 <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>make_shared<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> spw2 <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>make_shared<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Но <code class="language-text">make_shared</code> не принимает кастоный делитер. В таких случаях поможет правило - не сохранять указатель в переменную, а создавать его прям в конструкторе <code class="language-text">shared_ptr</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Widget</span><span class="token punctuation">,</span> loggingDeleter<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Widget</span><span class="token punctuation">,</span> loggingDeleter<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Интересная особенность <code class="language-text">shared_ptr</code> - с его помощью можно создавать циклические ссылки, которые никогда не будут удалены. Эта проблема обходится при помощи <code class="language-text">weak_ptr</code>. Он похож на <code class="language-text">shared_ptr</code>, но не участвует в подсчете ссылок. И еще у него есть метод <code class="language-text">lock()</code>, возвращающий временный <code class="language-text">shared_ptr</code> на объект.</p>
<p><code class="language-text">weak_ptr</code> не имеет конструктора, его можно создать только из <code class="language-text">shared_ptr</code>.</p>
<p>Пример:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">#include <span class="token operator">&lt;</span>memory<span class="token operator">></span>
#include <span class="token operator">&lt;</span>iostream<span class="token operator">></span>

class <span class="token class-name">SomeClass</span> <span class="token punctuation">{</span>
public<span class="token punctuation">:</span>
    void <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"Hello!"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token operator">~</span><span class="token function">SomeClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"~SomeClass"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>weak_ptr<span class="token operator">&lt;</span>SomeClass<span class="token operator">></span> wptr<span class="token punctuation">;</span>

    <span class="token punctuation">{</span>
        auto ptr <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>make_shared<span class="token operator">&lt;</span>SomeClass<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        wptr <span class="token operator">=</span> ptr<span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>auto tptr <span class="token operator">=</span> wptr<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            tptr<span class="token operator">-</span><span class="token operator">></span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"lock() failed"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>auto tptr <span class="token operator">=</span> wptr<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        tptr<span class="token operator">-</span><span class="token operator">></span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"lock() failed"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<h1>Многопоточность</h1>
<p>Чтобы создать новый поток, нужно создать объект <code class="language-text">std::thread</code> и передать ему функтор в качестве аргумента:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">void <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

struct F <span class="token punctuation">{</span>
	void <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

void <span class="token function">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	thread t1 <span class="token punctuation">{</span>f<span class="token punctuation">}</span><span class="token punctuation">;</span>
	thread t2 <span class="token punctuation">{</span><span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

	t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Если в функтор нужно передать аргументы, то они перечисляются как остальные аргументы <code class="language-text">thread</code> после самого функтора:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">void <span class="token function">f</span><span class="token punctuation">(</span>int a<span class="token punctuation">)</span><span class="token punctuation">;</span>

thread t1 <span class="token punctuation">{</span>f<span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>Если из потоков нужно что-то вернуть, то придется одним из аргументов передавать указатель на место, куда вернуть результат:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">void <span class="token function">f</span><span class="token punctuation">(</span>int a<span class="token punctuation">,</span> int<span class="token operator">*</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>

int res<span class="token punctuation">;</span>
thread t1 <span class="token punctuation">{</span>f<span class="token punctuation">,</span> <span class="token number">52</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>res<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<h2>Синхронизация</h2>
<h3>mutex</h3>
<p>Вот так используем мютексы, чтобы синхронизировать доступ к разделяемой переменной из нескольких потоков:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">mutex m<span class="token punctuation">;</span>
int sh<span class="token punctuation">;</span>

void <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
	unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> lck<span class="token punctuation">{</span>m<span class="token punctuation">}</span><span class="token punctuation">;</span>
	sh<span class="token operator">+</span><span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Структура <code class="language-text">unique_lock</code> поддерживает RAII, поэтому мютекс будет автоматически захвачен (<code class="language-text">m.lock()</code>) в ее конструкторе и автоматически освобожден (<code class="language-text">m.unlock()</code>) в ее деструкторе по выходу из функции <code class="language-text">f</code>.</p>
<h3>condition_variable</h3>
<p>Механизм, позволяющий одному потоку ждать другого. В частности, позволяет потоку ждать выполнения некоего условия (события), которое выполняется как результат работы другого потока.</p>
<p>Функция <code class="language-text">cond.wait(unique_lock&lt;mutex&gt;&amp; lock)</code> блокирует текущий поток, пока кто-то не вызовет <code class="language-text">cond.notify_one</code> или <code class="language-text">cond.notify_all</code>. При вызове <code class="language-text">wait</code> автоматически отпускается <code class="language-text">lock</code>, а когда события дождались - он захватывается обратно. Иногда бывают ложные выстрелы события, поэтому лучше использовать в виде <code class="language-text">while(mcond.wait(lck))</code>. Перед вызовом <code class="language-text">wait</code> блокировка <code class="language-text">lock</code> должна быть уже захвачена.</p>
<p>В качестве второго параметра может принимать предикат, который будет автоматически проверяться для избежания ложных выстрелов события.</p>
<p>На этом основании можно решить классическую задачу producer-consumer:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">class <span class="token class-name">Message</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>

queue<span class="token operator">&lt;</span>Message<span class="token operator">></span> mqueue<span class="token punctuation">;</span>
condition_variable mcond<span class="token punctuation">;</span>
mutex mmutex<span class="token punctuation">;</span>

void <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> lck<span class="token punctuation">{</span>mmutex<span class="token punctuation">}</span><span class="token punctuation">;</span>			<span class="token comment">// захватываем lck</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>mcond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lck<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">/*do nothing*/</span><span class="token punctuation">;</span> <span class="token comment">// lck отпускается, а мы ждем события mcond</span>
												<span class="token comment">// когда дождались события mcond, lck автоматически захватывается вновь</span>
		auto m <span class="token operator">=</span> mqueue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		mqueue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		lck<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>							<span class="token comment">// совсем отпускаем lck</span>
		<span class="token comment">// ... process m...</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

void <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		Message m<span class="token punctuation">;</span>
		unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> lck <span class="token punctuation">{</span>mmutex<span class="token punctuation">}</span><span class="token punctuation">;</span>	<span class="token comment">// захватываем lck</span>
		mqueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
		mcond<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// "стреляем" событие, означающее, что в mqueue появились элементы</span>
											<span class="token comment">// lck автоматически отпускается</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<h2>Таски</h2>
<p>Есть несколько конструкций, более высокоуровневых, чем треды:</p>
<ul>
<li><code class="language-text">future</code>, <code class="language-text">promise</code></li>
<li><code class="language-text">packaged_task</code></li>
<li><code class="language-text">async()</code></li>
</ul>
<p>Все они находятся в заголовке <code class="language-text">&lt;future&gt;</code>.</p>
<h3><code class="language-text">future</code> и <code class="language-text">promise</code></h3>
<p>Позволяют передавать значение между тасками без использования локов.</p>
<p>Футуры получаются из промисов методом <code class="language-text">get_future()</code>. В промис можно записать значение методом <code class="language-text">set_value</code> или эксепшн методом <code class="language-text">set_Exception</code>, а из футура потом его прочитать методом <code class="language-text">get()</code>. При этом текущий поток будет заблокирован, пока результат не будет записан в соответствующий промис, а если в промис записан эксепшн, то <code class="language-text">get()</code> выстрелит его же.</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">void <span class="token function">product</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>promise<span class="token operator">&lt;</span>int<span class="token operator">></span><span class="token operator">&amp;&amp;</span> intPromise<span class="token punctuation">,</span> int a<span class="token punctuation">,</span> int b<span class="token punctuation">)</span><span class="token punctuation">{</span>
  intPromise<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span>a<span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

  int a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
  int b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

  std<span class="token punctuation">:</span><span class="token punctuation">:</span>promise<span class="token operator">&lt;</span>int<span class="token operator">></span> prodPromise<span class="token punctuation">;</span>

  std<span class="token punctuation">:</span><span class="token punctuation">:</span>future<span class="token operator">&lt;</span>int<span class="token operator">></span> prodResult<span class="token operator">=</span> prodPromise<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  std<span class="token punctuation">:</span><span class="token punctuation">:</span>thread <span class="token function">prodThread</span><span class="token punctuation">(</span>product<span class="token punctuation">,</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">move</span><span class="token punctuation">(</span>prodPromise<span class="token punctuation">)</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>

  std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"20*10= "</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> prodResult<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>

  prodThread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Если нужно в пропис передать исключение, то нужно вызвать <code class="language-text">promise.set_exception(e)</code>. Тогда при попытке получения результата через <code class="language-text">future.get()</code> пользователь получит это исключение.</p>
<p><code class="language-text">future.get()</code> можно вызывать лишь единожды. Все последующие вызовы выбросят исключение.</p>
<p>К <code class="language-text">std::future</code> можно обращаться только из одного потока. Если нужно из нескольких, то можно использовать <code class="language-text">std::shared_future</code>. <code class="language-text">future</code> реализует семантику перемещения, а <code class="language-text">shared_future</code> - копирования.</p>
<p>Футуры хороши когда нужно ждать какого-то одноразового события.</p>
<h3>packaged_task</h3>
<p>Принимает в конструктор функцию <code class="language-text">f</code>. Имеет функцию <code class="language-text">task.get_future()</code>, возвращающую футуру. Когда функция <code class="language-text">f</code> будет выполнена, эта футура перейдет в состояние <code class="language-text">ready</code> и вернет результат <code class="language-text">f</code>.</p>
<p>Удобно использовать, например, для реализации тред-пулов или других менеджеров заданий.</p>
<p>Пример очереди сообщений для GUI:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">#include <span class="token operator">&lt;</span>deque<span class="token operator">></span>
#include <span class="token operator">&lt;</span>mutex<span class="token operator">></span>
#include <span class="token operator">&lt;</span>future<span class="token operator">></span>
#include <span class="token operator">&lt;</span>thread<span class="token operator">></span>
#include <span class="token operator">&lt;</span>utility<span class="token operator">></span>

std<span class="token punctuation">:</span><span class="token punctuation">:</span>mutex m<span class="token punctuation">;</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>deque<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>packaged_task<span class="token operator">&lt;</span><span class="token function">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token operator">></span> tasks<span class="token punctuation">;</span>

bool <span class="token function">gui_shutdown_message_received</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
void <span class="token function">get_and_process_gui_message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

void <span class="token function">gui_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">gui_shutdown_message_received</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
    	<span class="token function">get_and_process_gui_message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	std<span class="token punctuation">:</span><span class="token punctuation">:</span>packaged_task<span class="token operator">&lt;</span><span class="token function">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> task<span class="token punctuation">;</span>
    	<span class="token punctuation">{</span>
    		std<span class="token punctuation">:</span><span class="token punctuation">:</span>lock_guard<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>mutex<span class="token operator">></span> <span class="token function">lk</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>tasks<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    			<span class="token keyword">continue</span><span class="token punctuation">;</span>
			task<span class="token operator">=</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">move</span><span class="token punctuation">(</span>tasks<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			tasks<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token punctuation">}</span>
		<span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
 <span class="token punctuation">}</span>

std<span class="token punctuation">:</span><span class="token punctuation">:</span>thread <span class="token function">gui_bg_thread</span><span class="token punctuation">(</span>gui_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>

template<span class="token operator">&lt;</span>typename Func<span class="token operator">></span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>future<span class="token operator">&lt;</span>void<span class="token operator">></span> <span class="token function">post_task_for_gui_thread</span><span class="token punctuation">(</span>Func f<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>packaged_task<span class="token operator">&lt;</span><span class="token function">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">task</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>future<span class="token operator">&lt;</span>void<span class="token operator">></span> res<span class="token operator">=</span>task<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>lock_guard<span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>mutex<span class="token operator">></span> <span class="token function">lk</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tasks<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">move</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> res<span class="token punctuation">;</span> 
<span class="token punctuation">}</span></code></pre></div>
<p>Здесь функция <code class="language-text">post_task_for_gui_thread</code> добавляет задания в очередь обработки для GUI-треда и возвращает соответствующие им футуры, а функция <code class="language-text">gui_thread()</code> по очереди обрабатывает задания. При выполнении очередного задания соответствующая ему футура получит состояние <strong>ready</strong>.</p>
<h3>async</h3>
<p>Наиболее близко к ключевому слову <code class="language-text">async</code> в С# (но все еще далеко). Без использования <code class="language-text">std::async</code> то же самое можно реализовать и при помощи <code class="language-text">std::packaged_task</code> и <code class="language-text">std::thread</code>, но если есть возможность использовать <code class="language-text">std::async</code>, то лучше использовать его.</p>
<p>Функция <code class="language-text">std::async</code> принимает на вход функцию и запускает ее в новом треде, а возвращает футуру, которая получит состояние <code class="language-text">ready</code> как только завершится переданная функция.</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">#include <span class="token operator">&lt;</span>future<span class="token operator">></span>
#include <span class="token operator">&lt;</span>iostream<span class="token operator">></span>

int <span class="token function">find_the_answer_to_ltuae</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
void <span class="token function">do_other_stuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>future<span class="token operator">&lt;</span>int<span class="token operator">></span> the_answer<span class="token operator">=</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">async</span><span class="token punctuation">(</span>find_the_answer_to_ltuae<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">do_other_stuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout<span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token string">"The answer is "</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span>the_answer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Один из параметров имеет тип <code class="language-text">std::launch</code> и он определяет, будет ли функция запущена в отдельном потоке, или в этом же. По умолчанию он имеет значение <code class="language-text">std::launch::deferred | std::launch::async</code>.</p>
<h1>Утилиты</h1>
<h2>Время</h2>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">using namespace std<span class="token punctuation">:</span><span class="token punctuation">:</span>chrono<span class="token punctuation">;</span>

auto t0 <span class="token operator">=</span> high_resolution_clock<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">do_work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
auto t1 <span class="token operator">=</span> high_resolution_clock<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> duration_cast<span class="token operator">&lt;</span>milliseconds<span class="token operator">></span><span class="token punctuation">(</span>t1<span class="token operator">-</span>t0<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"msec\n"</span><span class="token punctuation">;</span></code></pre></div>
<h2>Type functions</h2>
<p>Это такие функции, выполняемые во время компиляции и принимающие в качестве аргументов типы, или возвращающие типы.</p>
<p>Примеры:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">constexpr float min <span class="token operator">=</span> numeric_limits<span class="token operator">&lt;</span>float<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
constexpr int szl <span class="token operator">=</span> <span class="token function">sizeof</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token function">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>beg<span class="token punctuation">)</span><span class="token operator">></span> v<span class="token punctuation">;</span></code></pre></div>
<p>Отдельно проходят предикаты над типами:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">bool b <span class="token operator">=</span> is_arithmetic<span class="token operator">&lt;</span>int<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Еще есть <code class="language-text">is_class</code>, <code class="language-text">is_pod</code>, <code class="language-text">is_literal_type</code>, <code class="language-text">has_virtual_destructor</code>, и <code class="language-text">is_base_of</code>.</p>
<h3>iterator_traits</h3>
<p>Это такая функция над типом, позволяющая получить некоторые свойства типа итератора.</p>
<p>Пример:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>class <span class="token class-name">Iterator</span><span class="token operator">></span>
void <span class="token function">some_algorithm</span><span class="token punctuation">(</span>Iterator start<span class="token punctuation">,</span> Iterator end<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	typename std<span class="token punctuation">:</span><span class="token punctuation">:</span>iterator_traits<span class="token operator">&lt;</span>Iterator<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>value_type value <span class="token operator">=</span> <span class="token operator">*</span>start<span class="token punctuation">;</span>  <span class="token comment">// так получили тип значения, используемого в итераторе Iterator</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Структура <code class="language-text">iterator_traits</code> содержит следующие поля:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template <span class="token operator">&lt;</span>class <span class="token class-name">T</span><span class="token operator">></span>
struct iterator_traits <span class="token punctuation">{</span>
  typedef typename T<span class="token punctuation">:</span><span class="token punctuation">:</span>value_type value_type<span class="token punctuation">;</span>
  typedef typename T<span class="token punctuation">:</span><span class="token punctuation">:</span>difference_type difference_type<span class="token punctuation">;</span>
  typedef typename T<span class="token punctuation">:</span><span class="token punctuation">:</span>iterator_category iterator_category<span class="token punctuation">;</span>
  typedef typename T<span class="token punctuation">:</span><span class="token punctuation">:</span>pointer pointer<span class="token punctuation">;</span>
  typedef typename T<span class="token punctuation">:</span><span class="token punctuation">:</span>reference reference<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<h1>Макросы</h1>
<p>Оператор <code class="language-text">#</code> перед использованием аргумента обернет его в кавычки и будет использовать как строковый литерал.</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">#define <span class="token function">PRINT_TOKEN</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span>#token <span class="token string">" is %s"</span><span class="token punctuation">,</span> token<span class="token punctuation">)</span><span class="token punctuation">;</span>

char<span class="token operator">*</span> foo <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
<span class="token function">PRINT_TOKEN</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token comment">// => printf("foo" " is %d" "hello")   => "foo is hello"</span></code></pre></div>
<p>Оператор <code class="language-text">##</code> берет два токена и объединяет их в один. Результат может быть названием переменной, класса, или любым другим идентификатором.</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">#define <span class="token function">FIT</span><span class="token punctuation">(</span>function_index<span class="token punctuation">)</span> fit##<span class="token function">function_index</span><span class="token punctuation">(</span>int X<span class="token punctuation">,</span> int Y<span class="token punctuation">,</span> int x<span class="token punctuation">,</span> int y<span class="token punctuation">)</span>

int <span class="token function">FIT</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>X <span class="token operator">/</span> x<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>Y <span class="token operator">/</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

int <span class="token function">FIT</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">fmax</span><span class="token punctuation">(</span><span class="token function">fit1</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">fit1</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">,</span> y<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<h1>Работа с потоками</h1>
<h2>Примеры</h2>
<h3>Чтение всего файла</h3>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>string <span class="token function">readWholeFile</span><span class="token punctuation">(</span>const std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token operator">*</span> filepath<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	ifstream <span class="token function">file</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>istreambuf_iterator<span class="token operator">&lt;</span>char<span class="token operator">></span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>istreambuf_iterator<span class="token operator">&lt;</span>char<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<h2>Теория</h2>
<p>В C стандартная работа с IO осуществляется через пакеты <code class="language-text">stdio.h</code> и <code class="language-text">unistd.h</code> стандартной библиотеки. Там есть <code class="language-text">read()</code>, <code class="language-text">write()</code>, <code class="language-text">printf()</code>, <code class="language-text">scanf()</code> и другие.</p>
<p>В С++ стандартная работа с IO осуществляется через библиотеки <code class="language-text">iostream</code>, <code class="language-text">fstream</code> для файлов, <code class="language-text">sstream</code> для стрингов.</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;"
    >
      <a
    class="gatsby-resp-image-link"
    href="/hows-that-again/static/a6f30dc047f6dca176da3be4dfbc6e6c/73d01/IOclasses.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 81.42493638676845%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABJ0AAASdAHeZh94AAADSklEQVQ4y11UiXLaSBDV/3/IVu1u1XqT+AKCbWJjDCbBWAIkJEBcQgId6L55aQ3rvaZqaqS+prvf6+FOpxM+drU+Tt+1cbRNnBfJyhynIvuPXZ5nyLOs+qFd0lGCw7/WiQnPDkUWwzJsSIKMCS/BtT0yoKBlwfRJ6EMc8dA2a7JNzpeRD+cfLcxkiSlQnjMoy+rGAp6fQJRWkOUtXC9lslNxDhgHHiRJwmZLOtdDUeWRp+CsgwFpOsXR9ZjDP+nm0E0LrdcOGu0nqPq68qDLSjDfJIah72Db1rncSp4n4LyjDUWWYVk2C5gELqqskUXkFZCTQtlPcNCncC29agbtEkUcwHcOcE2dfVO955Id64C3tyEmE5H64mEiKXjujzAcz6EsdaRZgTyO8X0wIrkAQVpib7kk8/HYHaD52EPnOw9+qlLFEThD26DeaOC134fnWBhJI3zrP+L67gavoxdkZcwAkOYT3L3c44+bPzEQ+6yCA7HglX/B59ondIdtxJEFzjb3qNXreO50mGOehDAtC+paw1zdQFF3cGwHRRoijkMkpPc8hyHLWk3oukeHtaHqJVdSmv1eF9dXlzB3a9YH07TxQxBwc1/Db18uMFvwZJ8yPuZpwi4uPwJSkCDw/8aSi30H2mpOnNOQxREzzqKQeBzBtjbQtTkCd08BUso+QhpSpkFVCQWm3kZBBM/16TulOwnljIz8IIQfRngeCLhsPlBWtxgSOD/GU9w+tPH7ZQOj+Rxv4hRfmi38+vkGPX4EQVZRb3fwy8UnXBAOnm9TyUmANHBYk5PogNWax2olUF+WiEIdmjbGcvmOI/1Xet0QoapDaotC9cZUlUG0GsN1VGShCW671XBH0PcGYwiTBXhRhbrZQ5ptMZHXeBMUyAsNi5VBDFhCVDZ4H8/YOV1sMZY3EMQlo1NGZOeiIIBKQVvdB0aV29YtZqsFFjSKzXYD180r0t2zqRGmIurfaqi1anjqP2FrGOi9d3FFNl/JNggowwrqiv2nIiKEafwyIi21oZprRhE/IH75bKwqpKPAxsFYU4n7s+xUPQwx6WI6aZbZy3P6C/MiZ9uxbeJcgmMQQ1BnWO1WUBQFi4WK/d7EbDbHbqfTZT7+v34C5tSowgYzBOAAAAAASUVORK5CYII='); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="IO classes"
        title="IO classes"
        src="/hows-that-again/static/a6f30dc047f6dca176da3be4dfbc6e6c/dbb61/IOclasses.png"
        srcset="/hows-that-again/static/a6f30dc047f6dca176da3be4dfbc6e6c/19bd1/IOclasses.png 163w,
/hows-that-again/static/a6f30dc047f6dca176da3be4dfbc6e6c/d3bcb/IOclasses.png 325w,
/hows-that-again/static/a6f30dc047f6dca176da3be4dfbc6e6c/dbb61/IOclasses.png 650w,
/hows-that-again/static/a6f30dc047f6dca176da3be4dfbc6e6c/73d01/IOclasses.png 786w"
        sizes="(max-width: 650px) 100vw, 650px"
        loading="lazy"
      />
  </a>
    </span></p>
<p>Для поддержки различных чарсетов (char, wchar<em>t, char16</em>t, char32_t) классы потоков реализованы как шаблонные классы:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template <span class="token operator">&lt;</span>class <span class="token class-name">charT</span><span class="token punctuation">,</span> class <span class="token class-name">traits</span> <span class="token operator">=</span> char_traits<span class="token operator">&lt;</span>charT<span class="token operator">></span> <span class="token operator">></span>
class <span class="token class-name">basic_istream</span><span class="token punctuation">;</span>

template <span class="token operator">&lt;</span>class <span class="token class-name">charT</span><span class="token punctuation">,</span> class <span class="token class-name">traits</span> <span class="token operator">=</span> char_traits<span class="token operator">&lt;</span>charT<span class="token operator">></span> <span class="token operator">></span>
class <span class="token class-name">basic_ostream</span><span class="token punctuation">;</span></code></pre></div>
<ul>
<li><code class="language-text">char_t</code> - тип символа, зависящий от чарсета/кодировки, например, <code class="language-text">char</code> или <code class="language-text">wchar_t</code>.</li>
<li><code class="language-text">traints</code> - тип, содержащий свойства этого типа символа, например, порядок сортировки и прочее</li>
</ul>
<p>Предоставлены куча алиасов для конкретизаций этих шаблонных типов:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">typedef basic_ios<span class="token operator">&lt;</span>char<span class="token operator">></span>				ios<span class="token punctuation">;</span>
typedef basic_ios<span class="token operator">&lt;</span>wchar_t<span class="token operator">></span>			wios<span class="token punctuation">;</span>
typedef basic_istream<span class="token operator">&lt;</span>char<span class="token operator">></span>			istream<span class="token punctuation">;</span>
typedef basic_istream<span class="token operator">&lt;</span>wchar_t<span class="token operator">></span>		wistream<span class="token punctuation">;</span>
typedef basic_ostream<span class="token operator">&lt;</span>char<span class="token operator">></span>			ostream<span class="token punctuation">;</span>
typedef basic_ostream<span class="token operator">&lt;</span>wchar_t<span class="token operator">></span>		wostream<span class="token punctuation">;</span>
typedef basic_iostream<span class="token operator">&lt;</span>char<span class="token operator">></span>		iostream<span class="token punctuation">;</span>
typedef basic_iostream<span class="token operator">&lt;</span>wchar_t<span class="token operator">></span>		wiostream<span class="token punctuation">;</span>
typedef basic_streambuf<span class="token operator">&lt;</span>char<span class="token operator">></span>		streambuf<span class="token punctuation">;</span>
typedef basic_streambuf<span class="token operator">&lt;</span>wchar_t<span class="token operator">></span>	wstreambuf<span class="token punctuation">;</span></code></pre></div>
<p>Далее речь будет идти только о конкретизациях для типа <code class="language-text">char</code>, но вместо него можно подставить и другой тип:</p>
<ul>
<li><code class="language-text">ios_base</code>, <code class="language-text">ios</code>: общие свойства потоков, такие как  флаги формата, ширина поля, точность, локаль.</li>
<li><code class="language-text">istream</code>, <code class="language-text">ostream</code> - интерфейсы для ввода и вывода. Каждый из потоков - ондонаправленный.</li>
<li><code class="language-text">iostream</code> - интерфейс для двунаправленного ввода/вывода. Определен в заголовке <code class="language-text">&lt;istream&gt;</code>, не в <code class="language-text">&lt;iostream&gt;</code>.</li>
<li><code class="language-text">ifstream</code>, <code class="language-text">ofstream</code>, <code class="language-text">fstream</code> - однонаправленный и двунаправленный ввод/вывод в файлы</li>
<li><code class="language-text">streambuf</code>, <code class="language-text">filebuf</code>, <code class="language-text">stringbuf</code> - буферы памяти для потока, файлового потока и строкового потока соответственно</li>
</ul>
<p>Заголовок <code class="language-text">&lt;iostream&gt;</code> содержит также стандартные объекты потоков:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">istream cin<span class="token punctuation">;</span>
wistream wcin<span class="token punctuation">;</span>
ostream cout<span class="token punctuation">;</span>
wostream wcout<span class="token punctuation">;</span>
ostream cerr<span class="token punctuation">;</span>
wostream wcerr<span class="token punctuation">;</span>
ostream clog<span class="token punctuation">;</span>
wostream wclog<span class="token punctuation">;</span></code></pre></div>
<h2>ostream</h2>
<p>Содержит два набора функций - для форматированного и неформатированного вывода. Форматированный (через оператор <code class="language-text">&lt;&lt;</code>) берет числовые типы, конвертит их в строки и затем в поток символов. Неформатированный - принимает сразу поток байт.</p>
<p>Перегрузка оператора форматированного вывода выглядит так:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">ostream <span class="token operator">&amp;</span> operator<span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span></code></pre></div>
<p>Благодаря тому, что оператор возвращает ссылку на поток, оператор можно чейнить ( <code class="language-text">cout &lt;&lt; 123 &lt;&lt; 1.13 &lt;&lt; endl</code>).</p>
<h3>Флаш</h3>
<p>Флашить буфер вывода можно 3 способами:</p>
<ul>
<li><code class="language-text">ostream &amp; flush()</code>, причем можно так: <code class="language-text">cout.flush()</code>, а можно даже и так: <code class="language-text">cout &lt;&lt; &quot;hello&quot; &lt;&lt; flush</code></li>
<li>выводя в поток <code class="language-text">endl</code> (причем вывод <code class="language-text">\n</code> может и не флашить, а вот <code class="language-text">endl</code> флашит всегда)</li>
<li>нажав ожидание на потоке ввода: <code class="language-text">cout &lt;&lt; &quot;Enter a number&quot;; cin &gt;&gt; number&quot;;</code> - на втором операторе флашится <code class="language-text">cout</code>.</li>
</ul>
<h2>istream</h2>
<p>Также содержит форматированный и неформатированный ввод.</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">istream <span class="token operator">&amp;</span> operator<span class="token operator">></span><span class="token operator">></span> <span class="token punctuation">(</span>type <span class="token operator">&amp;</span><span class="token punctuation">)</span></code></pre></div>
<h2>Неформатированный ввод/вывод</h2>
<p><code class="language-text">put()</code> - выводит <code class="language-text">char</code>, возвращает ссылку на поток и может чейниться</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">ostream <span class="token operator">&amp;</span> <span class="token function">put</span><span class="token punctuation">(</span>char c<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p><code class="language-text">get()</code> - получает <code class="language-text">char</code> из инпута:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token comment">/// класс istream</span>
int get <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// берет один символ, возвращает его как int, если достигли конца файла, возвращает EOF</span>
istream <span class="token operator">&amp;</span> get <span class="token punctuation">(</span>char <span class="token operator">&amp;</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
istream <span class="token operator">&amp;</span> get <span class="token punctuation">(</span>char <span class="token operator">*</span> cstr<span class="token punctuation">,</span> streamsize n<span class="token punctuation">,</span> char delim <span class="token operator">=</span> <span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// берет n-1 символов, или пока не встретит указанный разделитель, и сохраняет его в C-строке cstr, символ разделителя при этом не сохраняет</span></code></pre></div>
<p><code class="language-text">getline()</code> - получает из потока линию и сохраняет в указанную строку вместе с разделителем строки</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">istream <span class="token operator">&amp;</span> getline <span class="token punctuation">(</span>char <span class="token operator">*</span> cstr<span class="token punctuation">,</span> streamsize n<span class="token punctuation">,</span> char delim <span class="token operator">=</span> <span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p><code class="language-text">read()</code></p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token comment">/// класс istream</span>
istream <span class="token operator">&amp;</span> read <span class="token punctuation">(</span>char <span class="token operator">*</span> buf<span class="token punctuation">,</span> streamsize n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// читает n символов из инпута, в отличие от get()/getline() не добавляет \0 в конце. Читает бинарные данные, а не строку.</span></code></pre></div>
<p><code class="language-text">write()</code></p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token comment">/// класс ostream</span>
ostream <span class="token operator">&amp;</span> <span class="token function">write</span><span class="token punctuation">(</span>const char <span class="token operator">*</span> buf<span class="token punctuation">,</span> streamsize n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// пишет n символов из буфера</span></code></pre></div>
<p><code class="language-text">gcount()</code></p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">streamsize <span class="token function">gcount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> const<span class="token punctuation">;</span> <span class="token comment">// возвращает количество символов, полученное предыдущей операцией неформатированного ввода get(), getline(), ignore() или read()</span></code></pre></div>
<h2>Состояния потока:</h2>
<p>На любом потоке могут быть вызваны следующие функции, возвращающие bool:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token function">good</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token operator">-</span> ошибок нет
<span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token operator">-</span> конец файла
<span class="token function">fail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token operator">-</span> последняя операция не смогла прочесть или записать данные
<span class="token function">bad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token operator">-</span> серьезная ошибка IO или буфера потока
<span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token operator">-</span> сбросить состояние</code></pre></div>
<h2>Файловый ввод/вывод</h2>
<p>Чтобы работать с файловыми потоками, нужно включить заголовки <code class="language-text">&lt;iostream&gt;</code> и <code class="language-text">&lt;fstream&gt;</code>.</p>
<p>Запись в файл осуществляется так же, как и с обычными потоками, но добавляются операции <code class="language-text">open()</code> и <code class="language-text">close()</code>, которые есть только у файловых потоков:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">#include <span class="token operator">&lt;</span>fstream<span class="token operator">></span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
ofstream fout<span class="token punctuation">;</span>
fout<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
fout<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Также можно открывать файл прямо в конструкторе потока:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">#include <span class="token operator">&lt;</span>fstream<span class="token operator">></span>

ofstream <span class="token function">fout</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p><strong>open() принимает только C-string, если нужно передать string, то нужно юзать c_str()</strong>.</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">void open <span class="token punctuation">(</span>const char<span class="token operator">*</span> filename<span class="token punctuation">,</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span>openmode mode <span class="token operator">=</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">in</span> <span class="token operator">|</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// можно указать несколько режимов через |, дефолтный для вывода равен ios::out | ios::trunc, для ввода - ios::in</span>
void close <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
bool is_open <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre></div>
<p><strong>Для работы с бинарными данными обязательно при открытии нужно указать флаг <code class="language-text">ios::binary</code></strong></p>
<p>При чтении из файла все точно так же:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">#include <span class="token operator">&lt;</span>fstream<span class="token operator">></span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
ifstream fin<span class="token punctuation">;</span>
fin<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
fin<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>ИЛИ</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">#include <span class="token operator">&lt;</span>fstream<span class="token operator">></span>

ifstream <span class="token function">fin</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>Для бинарных данных использовать <code class="language-text">read()</code>/<code class="language-text">write()</code>, для строковых - <code class="language-text">get()</code>/<code class="language-text">getline()</code>/<code class="language-text">put()</code>.</p>
<h3>Случайный доступ</h3>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token comment">// для входящих файлов (g означает get)</span>
istream <span class="token operator">&amp;</span> seekg <span class="token punctuation">(</span>streampos pos<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// абсолютное позиционирование</span>
istream <span class="token operator">&amp;</span> seekg <span class="token punctuation">(</span>streamoff offset<span class="token punctuation">,</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span>seekdir way<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// относительное (возможно отрицательное) позиционирование относительно seekdir:</span>
      <span class="token comment">// ios::beg (beginning), ios::cur (current), ios::end (end)</span>
streampos tellg <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// возвращает текущую абсолютную позицию</span>

<span class="token comment">// для исходящих файлов (p означает put)</span>
ostream <span class="token operator">&amp;</span> seekp <span class="token punctuation">(</span>streampos pos<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// абсолютное позиционирование</span>
ostream <span class="token operator">&amp;</span> seekp <span class="token punctuation">(</span>streamoff offset<span class="token punctuation">,</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span>seekdir way<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// относительное</span>
streampos tellp <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// возвращает текущую абсолютную позицию</span></code></pre></div>
<h2>Строковые потоки</h2>
<p>Описаны в заголовке <code class="language-text">&lt;sstream&gt;</code>:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">typedef basic_istringstream<span class="token operator">&lt;</span>char<span class="token operator">></span> istringstream<span class="token punctuation">;</span>
typedef basic_ostringstream<span class="token operator">&lt;</span>char<span class="token operator">></span> ostringstream<span class="token punctuation">;</span></code></pre></div>
<h3>istringstream</h3>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">explicit istringstream <span class="token punctuation">(</span>ios<span class="token punctuation">:</span><span class="token punctuation">:</span>openmode mode <span class="token operator">=</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">in</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// default with empty string</span>
explicit istringstream <span class="token punctuation">(</span>const string <span class="token operator">&amp;</span> buf<span class="token punctuation">,</span>
                        ios<span class="token punctuation">:</span><span class="token punctuation">:</span>openmode mode <span class="token operator">=</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">in</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// with initial string</span></code></pre></div>
<h3>ostringstream</h3>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">explicit ostringstream <span class="token punctuation">(</span>ios<span class="token punctuation">:</span><span class="token punctuation">:</span>openmode mode <span class="token operator">=</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// default with empty string</span>
explicit ostringstream <span class="token punctuation">(</span>const string <span class="token operator">&amp;</span> buf<span class="token punctuation">,</span> 
                        ios<span class="token punctuation">:</span><span class="token punctuation">:</span>openmode mode <span class="token operator">=</span> ios<span class="token punctuation">:</span><span class="token punctuation">:</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// with initial str</span>

string str <span class="token punctuation">(</span><span class="token punctuation">)</span> const<span class="token punctuation">;</span>           <span class="token comment">// Get contents</span>
void str <span class="token punctuation">(</span>const string <span class="token operator">&amp;</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Set contents</span></code></pre></div>
<h1>Регулярные выражения</h1>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>string <span class="token function">subject</span><span class="token punctuation">(</span><span class="token string">"Name: John Doe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token punctuation">:</span><span class="token punctuation">:</span>string result<span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>regex <span class="token function">re</span><span class="token punctuation">(</span><span class="token string">"Name: (.*)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token punctuation">:</span><span class="token punctuation">:</span>smatch match<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">regex_search</span><span class="token punctuation">(</span>subject<span class="token punctuation">,</span> match<span class="token punctuation">,</span> re<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> match<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result <span class="token operator">=</span> match<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    result <span class="token operator">=</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>regex_error<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Syntax error in the regular expression</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Матч может быть одним из типов:</p>
<ul>
<li><code class="language-text">std::cmatch</code> - для массива <code class="language-text">char</code></li>
<li><code class="language-text">std::smatch</code> - для <code class="language-text">std::string</code></li>
<li><code class="language-text">std::wcmatch</code> - для массива <code class="language-text">wchar_t</code></li>
<li><code class="language-text">std::wsmatch</code> - для <code class="language-text">std::wstring</code></li>
</ul>
<p>Функции:</p>
<ul>
<li><code class="language-text">regex_search()</code> - ищет и возвращает матчи, возвращает true или false</li>
<li><code class="language-text">regex_match()</code> - определяет, подходит ли ВСЯ строка subject под указанный регэксп, так же возвращает true или false</li>
</ul>
<h1>Работа с файловой системой</h1>
<h2>Рекурсивное удаление директории</h2>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">void <span class="token function">removeDirectoryRecursively</span><span class="token punctuation">(</span>const std<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token operator">&amp;</span> path<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    DIR<span class="token operator">*</span> dir <span class="token operator">=</span> <span class="token function">opendir</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    struct dirent <span class="token operator">*</span>nextFile<span class="token punctuation">;</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>nextFile <span class="token operator">=</span> <span class="token function">readdir</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> NULL<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>nextFile<span class="token operator">-</span><span class="token operator">></span>d_name<span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>nextFile<span class="token operator">-</span><span class="token operator">></span>d_name<span class="token punctuation">,</span> <span class="token string">".."</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>

        char filepath<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">sprintf</span><span class="token punctuation">(</span>filepath<span class="token punctuation">,</span> <span class="token string">"%s/%s"</span><span class="token punctuation">,</span> path<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nextFile<span class="token operator">-</span><span class="token operator">></span>d_name<span class="token punctuation">)</span><span class="token punctuation">;</span>

        struct stat direntStat<span class="token punctuation">;</span>
        <span class="token function">lstat</span><span class="token punctuation">(</span>filepath<span class="token punctuation">,</span> <span class="token operator">&amp;</span>direntStat<span class="token punctuation">)</span><span class="token punctuation">;</span>
        bool isDirectory <span class="token operator">=</span> <span class="token function">S_ISDIR</span><span class="token punctuation">(</span>direntStat<span class="token punctuation">.</span>st_mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>isDirectory<span class="token punctuation">)</span>
            <span class="token function">removeDirectoryRecursively</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">remove</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">closedir</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<h1>Правила выведения общего типа</h1>
<ul>
<li>Перед сравнениями и арифметическими операциями числа приводятся к общему типу</li>
<li>Все типы размера меньше <code class="language-text">int</code> приводятся к <code class="language-text">int</code></li>
<li>Из двух типов выбирается больший по размеру</li>
<li>Если размер одинаковый, выбирается беззнаковый</li>
</ul>
<h1>Словарь</h1>
<p><code class="language-text">std::unordered_map&lt;Key, Value&gt;</code></p>
<h2>Получение элемента по ключу</h2>
<p>Оператор [] создает элемент с дефолтным значением, если его там нет, поэтому он не константный.</p>
<p>Если нужен константный, то использовать <code class="language-text">map.at(int key)</code>, но он выбросит исключение, если такого ключа нет. Поэтому нужно предварительно всегда проверять наличие ключа через <code class="language-text">find()</code>.</p>
<p>Пример:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">!=</span> map<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<h2>Итерирование по всем ключам</h2>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token keyword">for</span><span class="token punctuation">(</span>const auto<span class="token operator">&amp;</span> iterator<span class="token punctuation">:</span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"Key: "</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> iterator<span class="token punctuation">.</span>first <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">", value: "</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> iterator<span class="token punctuation">.</span>second<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<h1>Лямбды</h1>
<p>В лямбду можно захватить только локальные переменные и аргументы функции. Если хочется передать член класса, то есть 2 варианта:</p>
<ol>
<li>передавать <code class="language-text">this</code> в лямбду, тогда все его поля будут автоматически переданы в лямбду по ссылке. </li>
</ol>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto f <span class="token operator">=</span> <span class="token punctuation">[</span>this<span class="token punctuation">]</span><span class="token punctuation">{</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> a <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>На эту тему есть <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-this-capture">правило</a> - <strong>если передаем в лямбду <code class="language-text">this</code>, то нужно явно указывать все остальные переменные</strong>, которые туда передаем, чтобы не было иллюзий, будто члены класса переданы по значению:</p>
<ol start="2">
<li>кэшировать нуэное поле в локальную переменную и передавать ее:</li>
</ol>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">auto a <span class="token operator">=</span> this<span class="token operator">-</span><span class="token operator">></span>a<span class="token punctuation">;</span>
auto f <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">{</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> a <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>И еще одно важное <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-value-capture">правило</a> - <strong>избегать передачи любых переменных в лямбду по ссылке, если эта лямбда будет использовано не-локально, то есть возвращена, сохранена на куче, или передана в другой поток</strong></p>
<p>В тех лямбдах, что будут использоваться строго локально - наоборот, стоит предпочитать передачу всегда по ссылке.</p>
<h1>Вывод типов для шаблонов</h1>
<p>Допустим, у нас есть такое объявление функции:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f</span><span class="token punctuation">(</span>ParamType param<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ParamType - это какая-то производная от T, например, const T&amp;</span></code></pre></div>
<p>и вызов функции выглядит так:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike"><span class="token function">f</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>то в зависимости от типа <code class="language-text">expr</code> будут получаться разные типы <code class="language-text">T</code> и <code class="language-text">ParamType</code>, причем вовсе не обязательно одинаковые. Неодинаковы они потому, что <code class="language-text">ParamType</code> может содержать ограничения, такие как <code class="language-text">const</code> или <code class="language-text">&amp;</code>. </p>
<p>При выводе этих типов есть 3 варианта:</p>
<h2>ParamType является указателем или ссылкой</h2>
<p>В этом случае:</p>
<ol>
<li>если тип <code class="language-text">expr</code> - ссылка, то она отбрасывается</li>
<li>после этого тип <code class="language-text">expr</code> паттерн-матчится против <code class="language-text">ParamType</code> для определения <code class="language-text">T</code>.</li>
</ol>
<p>Примеры:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template <span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

int x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> int, ParamType -> int&amp;</span>

const int cx <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> const int, ParamType -> const int&amp;</span>

const int<span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> const int, ParamType -> const int&amp; (ссылка игнорится)</span></code></pre></div>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template <span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f</span><span class="token punctuation">(</span>const T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

int x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> int, ParamType -> const int&amp;</span>

const int cx <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> int, ParamType -> const int&amp;</span>

const int<span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> int, ParamType -> const int&amp; (ссылка игнорится)</span></code></pre></div>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template <span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">*</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

int x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> int, ParamType -> int*</span>

const int <span class="token operator">*</span>px <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> const int, ParamType -> const int*</span></code></pre></div>
<h2>ParamType является универсальной ссылкой</h2>
<p>Универсальная ссылка - это когда объявление шаблонного типа выглядит как <code class="language-text">T&amp;&amp;</code>. Универсальная - потому что это может означать как <em>rvalue</em>, так и <em>lvalue</em>.</p>
<p>В этом случае:</p>
<ol>
<li>Если <code class="language-text">expr</code> - <em>lvalue</em>, то <code class="language-text">T</code> и <code class="language-text">ParamType</code> выводятся как ссылки на <em>lvalue</em>.</li>
<li>Если <code class="language-text">expr</code> - <em>rvalue</em>, то используются "нормальные" правила, то есть как в 1 случае</li>
</ol>
<p>Примеры:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

int x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// x: lvalue, T -> int&amp;, ParamType -> int&amp;</span>

const int cx <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// cx: lvalue, T -> const int&amp;, ParamType -> const int&amp;</span>

const int<span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// rx: lvalue, T -> const int&amp;, ParamType -> const int&amp;</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 27: rvalue, T -> int, ParamType -> int&amp;&amp;</span></code></pre></div>
<h2>ParamType - не указатель и не ссылка</h2>
<p>В этом случае:</p>
<ol>
<li>Если тип <code class="language-text">expr</code> - ссылка, то она отбрасывается</li>
<li>Если после отбрасывания ссылки <code class="language-text">expr</code> является <code class="language-text">const</code>, то это отбросить тоже. Если она <code class="language-text">volatile</code>, то и это отбрасываем.</li>
</ol>
<p>Примеры:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>

int x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> int, ParamType -> int</span>

const int cx <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> int, ParamType -> int</span>

const int<span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// T -> int, ParamType -> int</span></code></pre></div>
<h1>Вывод типа в рантайме</h1>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token function">typeid</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">'\n\''</span></code></pre></div>
<p>Второй вариант, с использованием Boost:</p>
<div class="gatsby-highlight" data-language="clike"><pre class="language-clike"><code class="language-clike">#include <span class="token operator">&lt;</span>boost<span class="token operator">/</span>type_index<span class="token punctuation">.</span>hpp<span class="token operator">></span>

template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
void <span class="token function">f</span><span class="token punctuation">(</span>const T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	using std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout<span class="token punctuation">;</span>
	using boost<span class="token punctuation">:</span><span class="token punctuation">:</span>typeindex<span class="token punctuation">:</span><span class="token punctuation">:</span>type_id_with_cvr<span class="token punctuation">;</span>

	cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"T = "</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> type_id_with_cvr<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pretty_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>

	cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"param = "</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> type_id_with_cvr<span class="token operator">&lt;</span><span class="token function">decltype</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pretty_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<h1>fPIC</h1>
<p><a href="https://www.collabora.com/about-us/blog/2014/10/01/dynamic-relocs,-runtime-overflows-and-fpic/">https://www.collabora.com/about-us/blog/2014/10/01/dynamic-relocs,-runtime-overflows-and-fpic/</a></p></div></div></div></div></div></div></div><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym");ym(56098288,"init",{"clickmap":true,"trackLinks":true,"accurateTrackBounce":true,"webvisor":true,"trackHash":true});</script><noscript><div><img src="https://mc.yandex.ru/watch/56098288" style="position:absolute;left:-9999px" alt=""/></div></noscript><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/blog/cpp";window.webpackCompilationHash="ae79f2442b648799db22";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-c14483461df837b8e0ee.js"],"component---src-templates-blog-template-js":["/component---src-templates-blog-template-js-e63d8ebd92abd897e273.js"],"component---src-pages-404-js":["/component---src-pages-404-js-54ff81d98f14a7da0346.js"],"component---src-pages-index-jsx":["/component---src-pages-index-jsx-e26f636638509b66d07b.js"],"component---src-pages-page-2-js":["/component---src-pages-page-2-js-e56f5911a753d0d06680.js"]};/*]]>*/</script><script src="/hows-that-again/component---src-templates-blog-template-js-e63d8ebd92abd897e273.js" async=""></script><script src="/hows-that-again/commons-313b70b8b727bdc3ecf8.js" async=""></script><script src="/hows-that-again/app-c14483461df837b8e0ee.js" async=""></script><script src="/hows-that-again/webpack-runtime-307e2eaa7f3c16e7ad2c.js" async=""></script></body></html>