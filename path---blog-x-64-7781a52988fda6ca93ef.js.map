{"version":3,"sources":["webpack:///path---blog-x-64-7781a52988fda6ca93ef.js","webpack:///./.cache/json/blog-x-64.json"],"names":["webpackJsonp","495","module","exports","data","markdownRemark","html","frontmatter","path","title","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,s3QAA8uPC,aAAsrBC,KAAA,YAAAC,MAAA,SAAmCC","file":"path---blog-x-64-7781a52988fda6ca93ef.js","sourcesContent":["webpackJsonp([184279855636086],{\n\n/***/ 495:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>X86 assembler tutorial</h1>\\n<p><a href=\\\"http://www.hep.wisc.edu/~pinghc/x86AssmTutorial.htm\\\">Источник</a></p>\\n<p>Ассемблер в UNIX использует особенный синтакс, в котором source и destination перепутаны местами:</p>\\n<pre><code class=\\\"language-asm\\\">opcode source, dest\\n\\nmovl %edx, %eax     # перемещает содержимое регистра edx в регистр eax\\naddl %edx, %eax     # складывает содержимое регистров edx и eax, результат кладет в eax\\n</code></pre>\\n<p>Также, к отличиям относится то, что все назнания регистров должны начинаться со знака <code>%</code>, а инструкции кончаются на <code>l</code>, <code>w</code> или <code>b</code>, означающие размер операнда: long (32 бита), word (16 бит), или byte (8 бит), соответственно.</p>\\n<h2>Регистры</h2>\\n<p>Регистры 32-битные.</p>\\n<p>Для разных частей одного и того же регистра есть разные имена, например, младшие 8 бит (0-7) регистра <code>%eax</code> носят имя <code>%al</code>, а следующие после них (8-15) - <code>%ah</code>. Первые 16 бит <code>%eax</code> (0-15) носят имя <code>%ax</code>. А <code>%eax</code> используется, когда нужно обратиться ко всем 32 битам регистра <code>eax</code>. Форма имени регистра должна совпадать с суффиксом инструкции, то есть для инструкций, кончающихся на <code>b</code> используются <code>%al</code> и <code>%ah</code>, для <code>w</code> - <code>%ax</code>, а для <code>l</code> - <code>%eax</code>.</p>\\n<p>Вот основные регистры процессора:</p>\\n<table>\\n<thead>\\n<tr>\\n<th>Название</th>\\n<th>Описание</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>EAX, EBX, ECX, EDX</td>\\n<td>регистры общего назначения, EAX обычено используется для вохвращаемых значений (stdcall)</td>\\n</tr>\\n<tr>\\n<td>EBP</td>\\n<td>Базовый указатель для текущего фрейма стека.</td>\\n</tr>\\n<tr>\\n<td>ESI, EDI</td>\\n<td>Индексные регистры, относятся к DS и ES соответственно</td>\\n</tr>\\n<tr>\\n<td>SS, DS, CS, ES, FS, GS</td>\\n<td>Сегментные регистры. Содержат селектор начала сегмента данных. Все содержат по 16 бит.</td>\\n</tr>\\n<tr>\\n<td>EIP</td>\\n<td>program counter / instruction pointer, относителен к CS (code segment)</td>\\n</tr>\\n<tr>\\n<td>ESP</td>\\n<td>stack pointer, относителен к SS (stack segment). Автоматически изменяется при push/pop</td>\\n</tr>\\n<tr>\\n<td>EFLAGS</td>\\n<td>Флаги</td>\\n</tr>\\n</tbody>\\n</table>\\n<h3>Разница между EBP и ESP</h3>\\n<p>ESP - указатель на вершину стека (т.к. стек растет сверху вниз, то вершина стека будет внизу стека). После пролога все локальные переменные, адрес возврата и аргументы функции оказываются над ним.</p>\\n<p>EBP - указатель на начало текущего фрейма стека (будет наверху той части стека, которая предназначается для текущей процедуры). Над ним - адрес возврата и аргументы функции, под ним - локальные переменные.</p>\\n<p>Обращение к локальным переменным обычно идет через EBP.</p>\\n<p>Пролог обычно выглядит так:</p>\\n<pre><code>pushl %ebp\\nmovl %esp, %ebp\\nsubl  &#x3C;some_number>, %esp\\n</code></pre>\\n<p>Таким образом, EBP всегда означает начало текущего фрейма, а ESP - инструкция, следующая за его концом, то есть место, куда будет сунуто значение при следующей команде <code>push</code>. Когда мы вызовем еще одну функцию, то она в своем прологе запушит на стек наш EBP и присвоит ему ESP, то есть инструкция, следующая за концом нашего фрейма, станет началом ее фрейма.</p>\\n<p>Обращение в коде к локальным переменным может выглядеть так:</p>\\n<pre><code class=\\\"language-asm\\\">movl eax, -4(%ebp)\\nmovl -8(%ebp), ebx\\n</code></pre>\\n<p>Обращение к аргументам (аргументы пушатся на стек в обратном порядке, то ест сначала самый правый, в конце самый левый):</p>\\n<pre><code class=\\\"language-asm\\\">movl 4(%ebp), %eax # прочесть **первый** аргумент в EAX\\nmovl 8(%ebp), %ebx # прочесть **второй** аргумент в EBX\\n</code></pre>\\n<p>А выход из функции (эпилог) выглядит так:</p>\\n<pre><code class=\\\"language-asm\\\">mov esp, ebp ;\\npop ebp ;\\nret\\n</code></pre>\\n<p>Для перечисленных ниже соглашений (кроме <code>[cdecl]</code> перед возвратом значений из функции подпрограмма обязана восстановить значения сегментных регистров, регистров <code>esp</code> и <code>ebp</code>. Значения остальных регистров могут не восстанавливаться.</p>\\n<p>Если размер возвращаемого значения функции не больше размера регистра <code>eax</code>, возвращаемое значение сохраняется в регистре <code>eax</code>. Иначе, возвращаемое значение сохраняется на вершине стека, а указатель на вершину стека сохраняется в регистре <code>eax</code>.</p>\\n<p>(в X64 везде используется fastcall, то есть при передаче аргументов в функцию первые несколько аргументов хранятся в регистрах (rcx-rdx-r8-r9 для Windows и rdi-rsi-rdx-rcx-r8-r9 для линукса, остальные - в стеке)</p>\\n<h2>Сегментация</h2>\\n<p>Все адреса формируются из адреса начала сегмента и сдвига. Чтобы вычислить адрес начала сегмента, процессор определяет, какой регистр сегмента используется, берет его значение и использует его в качестве индекса для GDT (global descriptor table), откуда получает абсолютный физический адрес начала сегмента. Затем процессор складывает этот адрес с указанным в инструкции сдвигом и получает финальный физический адрес.</p>\\n<p>У i486 есть 6 16-битных сегментных регистров:</p>\\n<ol>\\n<li><strong>CS</strong>: Code segment register - для обращения к инструкциям</li>\\n<li><strong>SS</strong>: Stack segment register - для обращения к стеку</li>\\n<li><strong>DS</strong>: Data segment register - для обращения памяти, не относящейся к стеку, то есть к куче</li>\\n<li><strong>ES, FS, GS</strong>: Extra segment registers - хз зачем, вроде могут использоваться в каких-то специальных инструкциях</li>\\n</ol>\\n<p><strong>НЕЛЬЗЯ</strong> копировать из сегментного регистра в сегментный регистр, то есть следующая операция запрещена:</p>\\n<pre><code class=\\\"language-asm\\\">movw seg-reg, seg-reg\\n</code></pre>\\n<p>Зато ничто не запрещает использовать в качестве промежуточного хранилища регистр или область памяти:</p>\\n<pre><code class=\\\"language-asm\\\">movw seg-reg,memory\\nmovw memory,seg-reg\\nmovw seg-reg,reg\\nmovw reg,seg-reg\\n</code></pre>\\n<h2>Частые/полезные инструкции</h2>\\n<ul>\\n<li><strong>pushl/popl</strong> - положить/снять 32-битное значение на стек</li>\\n<li><strong>pushal/popal</strong> - положить/снять со стека EAX, EBX, ECX, EDX, ESP, EBP, ESI, EDI (аналога в x64 нет)</li>\\n<li><strong>call</strong> - положить адрес возврата на стек и перейти к указанной метке в коде</li>\\n<li><strong>int</strong> - вызвать программное прерывание</li>\\n<li><strong>ret</strong> - вернуться из куска кода, в который перешли инструкцией <code>call</code>, то есть использовать лежащий на стеке адрес возврата и передать по нему управление. Адрес возврата ищется по адресу <code>RBP + 4</code>, поэтому регистр RBP обязательно нужно сохранять в прологе и восстанавливать в эпилоге.</li>\\n<li><strong>iretl</strong> - вернуться из куска кода, в который перешли благодаря прерыванию</li>\\n<li><strong>sti/cli</strong> - установить/очистить бит прерывания, чтобы включить/выключить все прерывания</li>\\n<li><strong>lea</strong> - Load Effective Address, похож на MOV, см. далее</li>\\n</ul>\\n<h2>Адресация</h2>\\n<p>Использование круглых скобок позволяет получить значение по указанному адресу.</p>\\n<p>Пример:</p>\\n<pre><code class=\\\"language-asm\\\">mov (%rsp), %rax        # прочитай 8 байт по адресу, указанному в регистре RSP и сохрани их в регистр RAX\\n</code></pre>\\n<p>Можно сразу указывать смещение (положительное либо отрицательное) относительно адреса:</p>\\n<pre><code class=\\\"language-asm\\\">mov 8(%rsp), %rax       # возьми rsp, прибавь к нему 8, прочитай 8 байт по получившемуся адресу и положи их в rax\\n</code></pre>\\n<p>Команда LEA позволяет выполнить умножение и несколько сложений сразу:</p>\\n<pre><code class=\\\"language-asm\\\"># rax := rcx*8 + rax + 123\\nlea 123(%rax,%rcx,8), %rax\\n</code></pre>\\n<h2>Пример</h2>\\n<pre><code class=\\\"language-c\\\">void function1() {\\n    int A = 10;\\n    A += 66;\\n}\\n</code></pre>\\n<p>компилится в:</p>\\n<pre><code class=\\\"language-asm\\\">function1:\\n1   pushl %ebp #\\n2   movl %esp, %ebp #,\\n3   subl $4, %esp #,\\n4   movl $10, -4(%ebp) #, A\\n5   leal -4(%ebp), %eax #, \\n6   addl $66, (%eax) #, A\\n7   leave\\n8   ret\\n</code></pre>\\n<ol>\\n<li>Бэкапим EBP на стек</li>\\n<li>Копируем указатель стека в EBP</li>\\n<li>Выделяем место на стеке в размере 4 байта для локальной переменной</li>\\n<li>Кладем значение 10 в область локальных переменных стека, то есть создаем переменную А со значением 10</li>\\n<li>Загружаем адрес переменной A в регистр EAX</li>\\n<li>Прибавляем 66 к EAX и кладем результат в EAX</li>\\n</ol>\\n<p>1-3: типичный пролог</p>\",\"frontmatter\":{\"path\":\"/blog/x64\",\"title\":\"x64\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---blog-x-64-7781a52988fda6ca93ef.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>X86 assembler tutorial</h1>\\n<p><a href=\\\"http://www.hep.wisc.edu/~pinghc/x86AssmTutorial.htm\\\">Источник</a></p>\\n<p>Ассемблер в UNIX использует особенный синтакс, в котором source и destination перепутаны местами:</p>\\n<pre><code class=\\\"language-asm\\\">opcode source, dest\\n\\nmovl %edx, %eax     # перемещает содержимое регистра edx в регистр eax\\naddl %edx, %eax     # складывает содержимое регистров edx и eax, результат кладет в eax\\n</code></pre>\\n<p>Также, к отличиям относится то, что все назнания регистров должны начинаться со знака <code>%</code>, а инструкции кончаются на <code>l</code>, <code>w</code> или <code>b</code>, означающие размер операнда: long (32 бита), word (16 бит), или byte (8 бит), соответственно.</p>\\n<h2>Регистры</h2>\\n<p>Регистры 32-битные.</p>\\n<p>Для разных частей одного и того же регистра есть разные имена, например, младшие 8 бит (0-7) регистра <code>%eax</code> носят имя <code>%al</code>, а следующие после них (8-15) - <code>%ah</code>. Первые 16 бит <code>%eax</code> (0-15) носят имя <code>%ax</code>. А <code>%eax</code> используется, когда нужно обратиться ко всем 32 битам регистра <code>eax</code>. Форма имени регистра должна совпадать с суффиксом инструкции, то есть для инструкций, кончающихся на <code>b</code> используются <code>%al</code> и <code>%ah</code>, для <code>w</code> - <code>%ax</code>, а для <code>l</code> - <code>%eax</code>.</p>\\n<p>Вот основные регистры процессора:</p>\\n<table>\\n<thead>\\n<tr>\\n<th>Название</th>\\n<th>Описание</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>EAX, EBX, ECX, EDX</td>\\n<td>регистры общего назначения, EAX обычено используется для вохвращаемых значений (stdcall)</td>\\n</tr>\\n<tr>\\n<td>EBP</td>\\n<td>Базовый указатель для текущего фрейма стека.</td>\\n</tr>\\n<tr>\\n<td>ESI, EDI</td>\\n<td>Индексные регистры, относятся к DS и ES соответственно</td>\\n</tr>\\n<tr>\\n<td>SS, DS, CS, ES, FS, GS</td>\\n<td>Сегментные регистры. Содержат селектор начала сегмента данных. Все содержат по 16 бит.</td>\\n</tr>\\n<tr>\\n<td>EIP</td>\\n<td>program counter / instruction pointer, относителен к CS (code segment)</td>\\n</tr>\\n<tr>\\n<td>ESP</td>\\n<td>stack pointer, относителен к SS (stack segment). Автоматически изменяется при push/pop</td>\\n</tr>\\n<tr>\\n<td>EFLAGS</td>\\n<td>Флаги</td>\\n</tr>\\n</tbody>\\n</table>\\n<h3>Разница между EBP и ESP</h3>\\n<p>ESP - указатель на вершину стека (т.к. стек растет сверху вниз, то вершина стека будет внизу стека). После пролога все локальные переменные, адрес возврата и аргументы функции оказываются над ним.</p>\\n<p>EBP - указатель на начало текущего фрейма стека (будет наверху той части стека, которая предназначается для текущей процедуры). Над ним - адрес возврата и аргументы функции, под ним - локальные переменные.</p>\\n<p>Обращение к локальным переменным обычно идет через EBP.</p>\\n<p>Пролог обычно выглядит так:</p>\\n<pre><code>pushl %ebp\\nmovl %esp, %ebp\\nsubl  &#x3C;some_number>, %esp\\n</code></pre>\\n<p>Таким образом, EBP всегда означает начало текущего фрейма, а ESP - инструкция, следующая за его концом, то есть место, куда будет сунуто значение при следующей команде <code>push</code>. Когда мы вызовем еще одну функцию, то она в своем прологе запушит на стек наш EBP и присвоит ему ESP, то есть инструкция, следующая за концом нашего фрейма, станет началом ее фрейма.</p>\\n<p>Обращение в коде к локальным переменным может выглядеть так:</p>\\n<pre><code class=\\\"language-asm\\\">movl eax, -4(%ebp)\\nmovl -8(%ebp), ebx\\n</code></pre>\\n<p>Обращение к аргументам (аргументы пушатся на стек в обратном порядке, то ест сначала самый правый, в конце самый левый):</p>\\n<pre><code class=\\\"language-asm\\\">movl 4(%ebp), %eax # прочесть **первый** аргумент в EAX\\nmovl 8(%ebp), %ebx # прочесть **второй** аргумент в EBX\\n</code></pre>\\n<p>А выход из функции (эпилог) выглядит так:</p>\\n<pre><code class=\\\"language-asm\\\">mov esp, ebp ;\\npop ebp ;\\nret\\n</code></pre>\\n<p>Для перечисленных ниже соглашений (кроме <code>[cdecl]</code> перед возвратом значений из функции подпрограмма обязана восстановить значения сегментных регистров, регистров <code>esp</code> и <code>ebp</code>. Значения остальных регистров могут не восстанавливаться.</p>\\n<p>Если размер возвращаемого значения функции не больше размера регистра <code>eax</code>, возвращаемое значение сохраняется в регистре <code>eax</code>. Иначе, возвращаемое значение сохраняется на вершине стека, а указатель на вершину стека сохраняется в регистре <code>eax</code>.</p>\\n<p>(в X64 везде используется fastcall, то есть при передаче аргументов в функцию первые несколько аргументов хранятся в регистрах (rcx-rdx-r8-r9 для Windows и rdi-rsi-rdx-rcx-r8-r9 для линукса, остальные - в стеке)</p>\\n<h2>Сегментация</h2>\\n<p>Все адреса формируются из адреса начала сегмента и сдвига. Чтобы вычислить адрес начала сегмента, процессор определяет, какой регистр сегмента используется, берет его значение и использует его в качестве индекса для GDT (global descriptor table), откуда получает абсолютный физический адрес начала сегмента. Затем процессор складывает этот адрес с указанным в инструкции сдвигом и получает финальный физический адрес.</p>\\n<p>У i486 есть 6 16-битных сегментных регистров:</p>\\n<ol>\\n<li><strong>CS</strong>: Code segment register - для обращения к инструкциям</li>\\n<li><strong>SS</strong>: Stack segment register - для обращения к стеку</li>\\n<li><strong>DS</strong>: Data segment register - для обращения памяти, не относящейся к стеку, то есть к куче</li>\\n<li><strong>ES, FS, GS</strong>: Extra segment registers - хз зачем, вроде могут использоваться в каких-то специальных инструкциях</li>\\n</ol>\\n<p><strong>НЕЛЬЗЯ</strong> копировать из сегментного регистра в сегментный регистр, то есть следующая операция запрещена:</p>\\n<pre><code class=\\\"language-asm\\\">movw seg-reg, seg-reg\\n</code></pre>\\n<p>Зато ничто не запрещает использовать в качестве промежуточного хранилища регистр или область памяти:</p>\\n<pre><code class=\\\"language-asm\\\">movw seg-reg,memory\\nmovw memory,seg-reg\\nmovw seg-reg,reg\\nmovw reg,seg-reg\\n</code></pre>\\n<h2>Частые/полезные инструкции</h2>\\n<ul>\\n<li><strong>pushl/popl</strong> - положить/снять 32-битное значение на стек</li>\\n<li><strong>pushal/popal</strong> - положить/снять со стека EAX, EBX, ECX, EDX, ESP, EBP, ESI, EDI (аналога в x64 нет)</li>\\n<li><strong>call</strong> - положить адрес возврата на стек и перейти к указанной метке в коде</li>\\n<li><strong>int</strong> - вызвать программное прерывание</li>\\n<li><strong>ret</strong> - вернуться из куска кода, в который перешли инструкцией <code>call</code>, то есть использовать лежащий на стеке адрес возврата и передать по нему управление. Адрес возврата ищется по адресу <code>RBP + 4</code>, поэтому регистр RBP обязательно нужно сохранять в прологе и восстанавливать в эпилоге.</li>\\n<li><strong>iretl</strong> - вернуться из куска кода, в который перешли благодаря прерыванию</li>\\n<li><strong>sti/cli</strong> - установить/очистить бит прерывания, чтобы включить/выключить все прерывания</li>\\n<li><strong>lea</strong> - Load Effective Address, похож на MOV, см. далее</li>\\n</ul>\\n<h2>Адресация</h2>\\n<p>Использование круглых скобок позволяет получить значение по указанному адресу.</p>\\n<p>Пример:</p>\\n<pre><code class=\\\"language-asm\\\">mov (%rsp), %rax        # прочитай 8 байт по адресу, указанному в регистре RSP и сохрани их в регистр RAX\\n</code></pre>\\n<p>Можно сразу указывать смещение (положительное либо отрицательное) относительно адреса:</p>\\n<pre><code class=\\\"language-asm\\\">mov 8(%rsp), %rax       # возьми rsp, прибавь к нему 8, прочитай 8 байт по получившемуся адресу и положи их в rax\\n</code></pre>\\n<p>Команда LEA позволяет выполнить умножение и несколько сложений сразу:</p>\\n<pre><code class=\\\"language-asm\\\"># rax := rcx*8 + rax + 123\\nlea 123(%rax,%rcx,8), %rax\\n</code></pre>\\n<h2>Пример</h2>\\n<pre><code class=\\\"language-c\\\">void function1() {\\n    int A = 10;\\n    A += 66;\\n}\\n</code></pre>\\n<p>компилится в:</p>\\n<pre><code class=\\\"language-asm\\\">function1:\\n1   pushl %ebp #\\n2   movl %esp, %ebp #,\\n3   subl $4, %esp #,\\n4   movl $10, -4(%ebp) #, A\\n5   leal -4(%ebp), %eax #, \\n6   addl $66, (%eax) #, A\\n7   leave\\n8   ret\\n</code></pre>\\n<ol>\\n<li>Бэкапим EBP на стек</li>\\n<li>Копируем указатель стека в EBP</li>\\n<li>Выделяем место на стеке в размере 4 байта для локальной переменной</li>\\n<li>Кладем значение 10 в область локальных переменных стека, то есть создаем переменную А со значением 10</li>\\n<li>Загружаем адрес переменной A в регистр EAX</li>\\n<li>Прибавляем 66 к EAX и кладем результат в EAX</li>\\n</ol>\\n<p>1-3: типичный пролог</p>\",\"frontmatter\":{\"path\":\"/blog/x64\",\"title\":\"x64\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/blog-x-64.json\n// module id = 495\n// module chunks = 184279855636086"],"sourceRoot":""}