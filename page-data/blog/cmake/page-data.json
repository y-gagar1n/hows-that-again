{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/cmake","webpackCompilationHash":"dc1ee7a18d03536f883e","result":{"data":{"markdownRemark":{"html":"<h1>CMake</h1>\n<p>Туториал: <a href=\"https://cliutils.gitlab.io/modern-cmake/\">https://cliutils.gitlab.io/modern-cmake/</a></p>\n<p>Набор популярных хелперов: <a href=\"https://github.com/CLIUtils/cmake\">https://github.com/CLIUtils/cmake</a> (добавляется в проект командой <code class=\"language-text\">set(CMAKE_MODULE_PATH &quot;${PROJECT_SOURCE_DIR}/cmake&quot; ${CMAKE_MODULE_PATH})</code>)</p>\n<h2>Опции</h2>\n<p>Опция может быть установлена через <code class=\"language-text\">-D</code>, например, <code class=\"language-text\">cmake -DCMAKE_BUILD_TYPE=Build</code>.</p>\n<p>Полный список опций можно получить через <code class=\"language-text\">cmake -L</code> или <code class=\"language-text\">cmake -LH</code>. Второй вариант выдаст комментарии к каждой опции, если они указаны в скриптах. При первом запуске эти команды совершат запуск CMake, сгенерят все артефакты и только после этого выдадут список опций, не пугайтесь.</p>\n<p>Все опции перечислены <a href=\"https://cmake.org/cmake/help/v3.0/manual/cmake-variables.7.html\">здесь</a></p>\n<h3>Основные опции</h3>\n<ul>\n<li><code class=\"language-text\">CMAKE_BUILD_TYPE</code> - тип билда: Release, RelWithDebInfo, Debug и т.д.</li>\n<li><code class=\"language-text\">PROJECT_SOURCE_DIR</code> - полный путь к текущему проекту. Будет итерироваться по папкам вверх, пока не найдет CMakeLists.txt, в котором есть инструкция <strong>project</strong></li>\n<li><code class=\"language-text\">CMAKE_CURRENT_SOURCE_DIR</code> - полный путь к папке, которая обрабатывается cmake-ом (то есть если вызвали <strong>cmake /proj/a</strong>, то там будет <strong>/proj/a</strong>). Когда делаем библиотеку, лучше использовать эту опцию вместо <code class=\"language-text\">PROJECT_SOURCE_DIR</code>, чтобы облегчить клиентам включение нашего CMake проекта как субмодуля.</li>\n<li><code class=\"language-text\">PROJECT_BINARY_DIR</code> - полный путь к папке билда проекта. Обычно это папка, откуда запускаем cmake.</li>\n<li><code class=\"language-text\">CMAKE_INSTALL_PREFIX</code> - путь, куда будет установлена программа при <strong>make install</strong></li>\n<li><code class=\"language-text\">CMAKE_COMMAND</code> - полный путь к cmake</li>\n<li><code class=\"language-text\">PROJECT_NAME</code> - имя проекта, указанное в команде <code class=\"language-text\">project</code></li>\n</ul>\n<h2>Команды</h2>\n<h3>Основные команды</h3>\n<ul>\n<li><code class=\"language-text\">project(learncmake C)</code> - устанавливает переменную <code class=\"language-text\">$PROJECT_NAME</code>. Вторым аргументов передается язык.</li>\n<li><code class=\"language-text\">include_directories( include )</code> - подключает инклюды, то есть папки, в которых искать заголовочные файлы. Равнозначно <code class=\"language-text\">-I</code> в <strong>GCC</strong>. Это глобальная команда, поэтому не рекомендуется к использованию.</li>\n<li><code class=\"language-text\">target_include_directories(one PUBLIC include)</code> - подключает инклюды для указанного первым аргументом таргета. <code class=\"language-text\">PUBLIC</code> означает, что все таргеты, которые ссылаются на этот, должны так же включать эту директорию. Другие варианты - <code class=\"language-text\">PRIVATE</code> (только текущий таргет) и <code class=\"language-text\">INTERFACE</code> (только зависимости).</li>\n<li><code class=\"language-text\">include(ext.cmake)</code> - загружает и запускает скрипт cmake из указанного файла</li>\n<li><code class=\"language-text\">set(KEY VALUE)</code> - установка переменных</li>\n<li><code class=\"language-text\">set(SOURCES main.c a.c b.c)</code> - установка списка <code class=\"language-text\">[main.c a.c b.c]</code> в качестве значения переменной SOURCES</li>\n<li><code class=\"language-text\">${SOURCES}</code> - обращение к значению переменной SOURCES</li>\n<li><code class=\"language-text\">configure_file ( &quot;a.h.in&quot; &quot;a.h&quot; )</code> - берет файл <strong>a.h.in</strong>, подставляет туда значения переменных CMake и сохраняет как <strong>a.h</strong>. В файлах на них нужно ссылаться как: <code class=\"language-text\">${PROJECT_SOURCE_DIR}</code> или <code class=\"language-text\">@PROJECT_SOURCE_DIR@</code>. Строчки вида <code class=\"language-text\">#cmakedefine VAR ...</code> будут заменены либо на <code class=\"language-text\">#define VAR ...</code> либо на <code class=\"language-text\">/* #undef VAR */</code> в зависимости от того, установлено ли значение <code class=\"language-text\">VAR</code> в ложь (в том смысле, в котором if считает выражения ложью)</li>\n<li><code class=\"language-text\">add_subdirectory(source_dir)</code> - включение папки со своим CMakeLists.txt в билд. Путь может быть относительным или абсолютным. Если CMakeLists.txt найден в папке, то CMake его обработает сразу же, прежде чем перейдет к следующей команде.</li>\n<li><code class=\"language-text\">find_program(YASM_EXE NAMES yasm)</code> - ищет программу yasm и сохраняет путь к ней в переменной <strong>YASM_EXE</strong></li>\n<li><code class=\"language-text\">find_package(SWIG REQUIRED)</code> - находит внешний проект и загружает оттуда его переменные. Например, после загрузки SWIG будет проинициализирована <strong>SWIG_EXECUTABLE</strong>. Список экспортируемых переменных можно найти на странице <strong>Find[package_name]</strong> в <a href=\"https://cmake.org/cmake/help/v3.2/module/FindSWIG.html\">документации CMake</a>, или в <a href=\"https://github.com/Kitware/CMake/blob/master/Modules/FindSWIG.cmake\">исходниках</a></li>\n<li><code class=\"language-text\">message(STATUS &quot;hello&quot;)</code> - вывод сообщения, первый аргумент задает уровень из списка STATUS/WARNING/AUTHOR_WARNING/SEND_ERROR/FATAL_ERROR</li>\n<li><code class=\"language-text\">option(VSDK_CPU_ONLY &quot;set to true in only cpu should be used&quot; OFF)</code> - опция, которую пользователь может задать при вызове cmake: <code class=\"language-text\">cmake . -DVSDK_CPU_ONLY=On</code>. Второй аргумент - словесное описание, третий - дефолтное значение. Обращаться к опции потом можно по имени: <code class=\"language-text\">if(VSDK_CPU_ONLY) ...</code></li>\n<li><code class=\"language-text\">install( TARGETS ${PROJECT_NAME}_firbuilder DESTINATION bin)</code> - задает правила установки. Первый аргумент задает таргет, второй - задает путь установки. Если относительный, то будет аппенднут к <code class=\"language-text\">$CMAKE_INSTALL_PREFIX</code></li>\n<li><code class=\"language-text\">find_package(package [REQUIRED])</code> - ищет и загружает свойства внешнего проекта. В папке <code class=\"language-text\">${CMAKE_MODULE_PATH}</code> будет искаться файл <code class=\"language-text\">Find&lt;package&gt;.cmake</code>. Если найден, то будет тут же обработан cmake-ом. Если такой файл не найден, то ищется конфиг под именем <code class=\"language-text\">&lt;name&gt;Config.cmake</code> или <code class=\"language-text\">&lt;lower-case-name&gt;-config.cmake</code></li>\n<li><code class=\"language-text\">list(APPEND LIBS ${vsd_LIBRARY})</code> - функция list описывает операции со списками. Первый аргумент обозначает операцию, в данном случае - append.</li>\n<li><code class=\"language-text\">add_custom_target(makedir1 ALL COMMAND ${CMAKE_COMMAND} DEPENDS target1 -E make_directory &quot;${PROJECT_BINARY_DIR}/src/ssd&quot;)</code> - добавляет таргет без аутпута, то есть он будет выполняться всегда. Первый аргумент - имя таргета. <code class=\"language-text\">ALL</code> означает, что таргет будет добавлен в таргет all. <code class=\"language-text\">COMMAND</code> - задает команду, все что после нее - тело команды. <code class=\"language-text\">DEPENDS</code> - задает другие таргеты, от которых зависит этот. Когда строится этот таргет, будут построены и все, перечисленные в <code class=\"language-text\">DEPENDS</code>. <code class=\"language-text\">-E</code> означает запуск cmake в командном режиме, <code class=\"language-text\">make_directory</code> - команда создания папки.</li>\n<li><code class=\"language-text\">add_custom_command( OUTPUT ${SRC_ASM}.o COMMAND ${YASM_EXE} ARGS -p ${SRC_ASM_INPUT}.asm DEPENDS source.cpp)</code> - работает на этапе генерации, добавляет кастомную команду для генерации аутпута. <code class=\"language-text\">OUTPUT</code> задает аутпут, для генерации которого указывается команда (команда не обязательно должна создавать этот аутпут, здесь мы всего лишь указываем, какого аутпута мы от нее ожидаем), <code class=\"language-text\">COMMAND</code> - команду, а <code class=\"language-text\">ARGS</code> - аргументы. <code class=\"language-text\">DEPENDS</code> - задает список файлов или таргетов, от которых зависит эта команда.</li>\n<li><code class=\"language-text\">string(TOUPPER ${STR_INPUT} STR_OUTPUT)</code> - провести операцию, указанную первым аргументом, на значении, указанном во втором аргументе, и сохранить результат в переменную, указанную в третьем.</li>\n<li><code class=\"language-text\">execute_process(COMMAND ${GIT_EXECUTABLE} submodule update --init --recursive WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} RESULT_VARIABLE GIT_SUBMOD_RESULT)</code> - работает на этапе конфигурации, запускает внешний процесс, в данном случае обновляет сабмодули гита. Путь к файлу процесса лучше не хардкодить, а найти заранее командой типа <code class=\"language-text\">find_package(Git)</code>. Если же нужно запустить команду на этапе генерации, например, скопировать папку или запустить скрипт для генерации каких-то файлов, то нужно использовать команду <code class=\"language-text\">add_custom_command</code>.</li>\n</ul>\n<h3>Вызовы компилятора</h3>\n<ul>\n<li><code class=\"language-text\">add_executable( ${EXE_NAME} ${SOURCES} )</code> - создает вызываемый файл на основании файлов, перечисленных в <code class=\"language-text\">SOURCES</code>. Первый аргумент будет использован как имя таргета и имя полученного исполняемого файла.</li>\n<li><code class=\"language-text\">add_library( ${LIB_NAME} ${LIBS_SOURCES})</code> - создает библиотеку на основании файлов, перечисленных в <code class=\"language-text\">SOURCES</code>. По умолчанию создает статическую (если не указана опция <code class=\"language-text\">BUILD_SHARED_LIBS</code>). Если нужно разделяемую, то нужно указать тип: <code class=\"language-text\">add_library( ${LIB_NAME} SHARED ${LIBS_SOURCES})</code></li>\n<li><code class=\"language-text\">target_link_libraries( ${TARGET_NAME} ${LIB_NAME} )</code> - линкует библиотеки и исполняемые файлы. Первый аргумент - это таргет, он должен предварительно быть создан командой <code class=\"language-text\">add_executable()</code> или <code class=\"language-text\">add_library()</code>. Остальные аргументы - имена таргетов или библиотек. В результате <code class=\"language-text\">TARGET_NAME</code> будет зависеть от <code class=\"language-text\">LIB_NAME</code>.</li>\n<li><code class=\"language-text\">add_definitions( --std=c99)</code> - добавление флагов для компилятора</li>\n</ul>\n<h3>Условия</h3>\n<ul>\n<li><code class=\"language-text\">if( CAFFE_ROOT)</code> - проверка, установлена ли переменная CAFFE_ROOT</li>\n<li><code class=\"language-text\">if( NOT CAFFE_ROOT)</code> - проверка, что не установлена переменная CAFFE_ROOT</li>\n<li><code class=\"language-text\">if( CAFFE_ROOT STREQUAL &quot;&quot;)</code> - проверка, что переменная CAFFE_ROOT равна \"\"</li>\n</ul>\n<h2>Generator expressions</h2>\n<p>Билд состоит из 2 шагов:</p>\n<ol>\n<li>Этап конфигурации</li>\n<li>Этап генерации</li>\n</ol>\n<p>Когда мы билдим для нескольких платформ или для нескольких конфигураций, некоторые значения (имена, пути аутпутов) нам могут быть известны только на этапе генерации. Для работы с ними существуют т.н. generator expressions, имеющие форму <code class=\"language-text\">$&lt;KEYWORD&gt;</code> или <code class=\"language-text\">$&lt;KEYWORD:value&gt;</code>. Keywords берутся из константного множества и у всех этих выражений разная семантика, смотреть <a href=\"https://cmake.org/cmake/help/v3.4/manual/cmake-generator-expressions.7.html#id4\">здесь</a></p>\n<p>Некоторые из выражений возвращают 0 или 1 и тогда они могут быть сами использованы в качестве keyword:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target_compile_options(MyTarget PRIVATE &quot;$&lt;$&lt;CONFIG:Debug&gt;:--my-flag&gt;&quot;)</code></pre></div>\n<p>Здесь флаг <code class=\"language-text\">--my-flag</code> будет применен, если использована конфигурация билда Debug.</p>\n<p>Когда используются:</p>\n<ul>\n<li>когда нужно что-то сделать только для конкретного языка</li>\n<li>когда нужно что-то сделать в зависимости от конфигурации билда</li>\n<li>когда нужно указать различные локации для построения и установки</li>\n</ul>\n<h2>Функции</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function(SIMPLE REQUIRED_ARG)\n    message(STATUS &quot;Simple arguments: ${REQUIRED_ARG}, followed by ${ARGV}&quot;)\n    set(${REQUIRED_ARG} &quot;From SIMPLE&quot; PARENT_SCOPE)\nendfunction()\n\nsimple(This)\nmessage(&quot;Output: ${This}&quot;)</code></pre></div>\n<p>Аргументы внутри функции можно специфицировать командой <code class=\"language-text\">cmake_parse_arguments</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function(COMPLEX)\ncmake_parse_arguments(\n    COMPLEX_PREFIX\n    &quot;SINGLE;ANOTHER&quot;\n    &quot;ONE_VALUE;ALSO_ONE_VALUE&quot;\n    &quot;MULTI_VALUES&quot;\n    ${ARGN}\n)\n\nendfunction()\n\ncomplex(SINGLE ONE_VALUE value MULTI_VALUES some other values)</code></pre></div>\n<p>После вызова внутри функции <code class=\"language-text\">simple</code> будут следующие аргументы:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">COMPLEX_PREFIX_SINGLE = TRUE\nCOMPLEX_PREFIX_ANOTHER = FALSE\nCOMPLEX_PREFIX_ONE_VALUE = &quot;value&quot;\nCOMPLEX_PREFIX_ALSO_ONE_VALUE = &lt;UNDEFINED&gt;\nCOMPLEX_PREFIX_MULTI_VALUES = &quot;some;other;values&quot;</code></pre></div>\n<p>Все оставшиеся аргументы будут в переменной <code class=\"language-text\">COMPLEX_PREFIX_UNPARSED_ARGUMENTS</code>.</p>\n<h2>Чтение опций из файлов</h2>\n<p>Допустим, версия проекта хранится в файле <code class=\"language-text\">Version.hpp</code> и мы хотим ее оттуда прочитать в наш скрипт CMake.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">set(VERSION_REGEX &quot;#define MY_VERSION[ \\t]+\\&quot;(.+)\\&quot;&quot;)\t// создаем регэксп для чтения и сохраняем в переменной VERSION_REGEX\n\nfile(STRINGS &quot;${CMAKE_CURRENT_SOURCE_DIR}/include/My/Version.hpp&quot;\n    VERSION_STRING REGEX ${VERSION_REGEX})\t// читаем файл, обрабатываем нашим регэкспом, результат сохраняем в переменную VERSION_STRING\n\nstring(REGEX REPLACE ${VERSION_REGEX} &quot;\\\\1&quot; VERSION_STRING &quot;${VERSION_STRING}&quot;)\t// если найдено несколько версий, берем первую\n\nproject(My LANGUAGES CXX VERSION ${VERSION_STRING})\t// задаем версию проекта</code></pre></div>\n<h2>C++11</h2>\n<p>вот так можно установить версию языка (выбор между <code class=\"language-text\">cxx_std_11</code>, <code class=\"language-text\">cxx_std_14</code>, <code class=\"language-text\">cxx_std_17</code>):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target_compile_features(myTarget PUBLIC cxx_std_11)\nset_target_properties(myTarget PROPERTIES CXX_EXTENSIONS OFF)</code></pre></div>\n<p>Вторая строчка необязательна, но облегчит жизнь, без нее будет использован флаг <code class=\"language-text\">-std=g++11</code> вместо <code class=\"language-text\">-std=c++11</code>.</p>\n<p>Есть и другой способ:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">set(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CMAKE_CXX_EXTENSIONS OFF)</code></pre></div>\n<p>первая строчка устанавливает стандарт, а вторая указывает, что нужно его использовать. Однако этот метод не стоит использовать для сборки библиотек.</p>\n<h2>Субмодули гита</h2>\n<p>Вот так выкачиваем субмодули при построении:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">find_package(Git QUIET)\nif(GIT_FOUND AND EXISTS &quot;${PROJECT_SOURCE_DIR}/.git&quot;)\n# Update submodules as needed\n    option(GIT_SUBMODULE &quot;Check submodules during build&quot; ON)\n    if(GIT_SUBMODULE)\n        message(STATUS &quot;Submodule update&quot;)\n        execute_process(COMMAND ${GIT_EXECUTABLE} submodule update --init --recursive\n                        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n                        RESULT_VARIABLE GIT_SUBMOD_RESULT)\n        if(NOT GIT_SUBMOD_RESULT EQUAL &quot;0&quot;)\n            message(FATAL_ERROR &quot;git submodule update --init failed with ${GIT_SUBMOD_RESULT}, please checkout submodules&quot;)\n        endif()\n    endif()\nendif()\n\nif(NOT EXISTS &quot;${PROJECT_SOURCE_DIR}/extern/repo/CMakeLists.txt&quot;)\n    message(FATAL_ERROR &quot;The submodules were not downloaded! GIT_SUBMODULE was turned off or failed. Please update submodules and try again.&quot;)\nendif()</code></pre></div>\n<p>А так включаем проект в процесс билда:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">add_subdirectory(extern/repo)</code></pre></div>\n<h3>Бонус: сохранение версии субмодуля в переменную</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">execute_process(COMMAND ${GIT_EXECUTABLE} rev-parse --short HEAD\n                WORKING_DIRECTORY &quot;${CMAKE_CURRENT_SOURCE_DIR}&quot;\n                OUTPUT_VARIABLE PACKAGE_GIT_VERSION\n                ERROR_QUIET\n                OUTPUT_STRIP_TRAILING_WHITESPACE)</code></pre></div>\n<h2>Часто используемые утилиты</h2>\n<p>Набор часто используемых утилит можно использовать через команду <code class=\"language-text\">cmake -E &lt;mode&gt;</code> в <code class=\"language-text\">add_custom_command</code>. </p>\n<p>Список утилит можно найти <a href=\"https://cmake.org/cmake/help/latest/manual/cmake.1.html#run-a-command-line-tool\">здесь</a>.</p>\n<h2>Рекомендуемая структура проекта</h2>\n<p>Если наш проект называется <code class=\"language-text\">projects</code>, библиотека в нем называется <code class=\"language-text\">lib</code>, а исполняемый файл - <code class=\"language-text\">app</code>, то рекомендуется следующая структура:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- project\n  - .gitignore\n  - README.md\n  - LICENCE.md\n  - CMakeLists.txt\n  - cmake\n    - FindSomeLib.cmake\n  - include\n    - project\n      - lib.hpp\n  - src\n    - CMakeLists.txt\n    - lib.cpp\n  - apps\n    - CMakeLists.txt\n    - app.cpp\n  - tests\n    - testlib.cpp\n  - docs\n    - Doxyfile.in\n  - extern\n    - googletest\n  - scripts\n    - helper.py</code></pre></div>\n<p><code class=\"language-text\">CMakeLists.txt</code> есть почти во всех папках с <strong>.cpp</strong> и нет в папке <code class=\"language-text\">include</code>. Это потому что содержимое папки <code class=\"language-text\">include</code> должно копироваться в <code class=\"language-text\">/usr/include</code> как есть и не содержать никаких лишних файлов. По этой же причине, в папке <code class=\"language-text\">include</code> выделена папка для нашего проекта - чтобы наверняка не было конфликтов.</p>\n<p>В папке <code class=\"language-text\">extern</code> должны лежать внешние зависимости в виде субмодулей гита.</p>\n<p>В <code class=\"language-text\">.gitignore</code> должна быть строчка <code class=\"language-text\">/build*</code>.</p>\n<h2>Пример</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">cmake_minimum_required(VERSION 3.8)\n\nproject(Calculator LANGUAGES CXX)\n\nadd_library(calclib STATIC src/calclib.cpp include/calc/lib.hpp)   // создаем таргет calclib, который будет статической библиотекой, собираемой из файлов src/calclib.cpp и include/calc/lib.hpp\n\ntarget_include_directories(calclib PUBLIC include)\t// подключаем папку include с заголовками, которые могут понадобиться при билде таргета/библиотеки calclib\n\ntarget_compile_features(calclib PUBLIC cxx_std_11)\t// указываем флаги компиляции для таргета calclib\n\nadd_executable(calc apps/calc.cpp)\t// создаем таргет calc, который будет исполняемым файлом, собираемым из файла apps/calc.cpp\n\ntarget_link_libraries(calc PUBLIC calclib)\t// указываем, что таргет/исполняемый файл calc зависит от таргета/либы calclib</code></pre></div>\n<p>Другой пример:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">find_package(PythonInterp REQUIRED)\nadd_custom_command(OUTPUT &quot;${CMAKE_CURRENT_BINARY_DIR}/include/Generated.hpp&quot;\n    COMMAND &quot;${PYTHON_EXECUTABLE}&quot; &quot;${CMAKE_CURRENT_SOURCE_DIR}/scripts/GenerateHeader.py&quot; --argument\n    DEPENDS some_target)\n\nadd_custom_target(generate_header ALL\n    DEPENDS &quot;${CMAKE_CURRENT_BINARY_DIR}/include/Generated.hpp&quot;)\n\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/include/Generated.hpp DESTINATION include)</code></pre></div>\n<p>Здесь, при запуске <code class=\"language-text\">cmake</code> без указания таргета будет запущен таргет <code class=\"language-text\">generate_header</code> (так как ему указано <code class=\"language-text\">ALL</code>). Он зависит от <code class=\"language-text\">Generated.hpp</code>, который указан как <code class=\"language-text\">OUTPUT</code> команды во второй строчке. Но эта команда сама зависит от таргета <code class=\"language-text\">some_target</code> (здесь не указан). Когда будет построен <code class=\"language-text\">some_target</code>, команда запуститься, запустит процесс питона, подаст в него скрипт <code class=\"language-text\">GenerateHeader.py</code>, питон сгенерит файл <code class=\"language-text\">include/Generated.hpp</code>, после чего таргет <code class=\"language-text\">generate_header</code> будет завершен.</p>","frontmatter":{"path":"/blog/cmake","title":"CMake"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}