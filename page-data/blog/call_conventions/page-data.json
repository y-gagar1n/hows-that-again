{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/call_conventions","webpackCompilationHash":"1663f2fba8fdf0d86a21","result":{"data":{"markdownRemark":{"html":"<h1>Соглашения вызова</h1>\n<p><a href=\"https://en.wikibooks.org/wiki/X86_Disassembly/Functions_and_Stack_Frames\">Вики</a></p>\n<p><a href=\"https://www.codeproject.com/Articles/1388/Calling-Conventions-Demystified\">CodeProject</a></p>\n<p>(<a href=\"https://stackoverflow.com/questions/1395591/what-is-exactly-the-base-pointer-and-stack-pointer-to-what-do-they-point\">https://stackoverflow.com/questions/1395591/what-is-exactly-the-base-pointer-and-stack-pointer-to-what-do-they-point</a>)</p>\n<blockquote>\n<p>TL;DR: Для x86 в винде используется <strong>Microsoft x64 calling convention</strong>, в линуксе <strong>System V ABI</strong>.</p>\n</blockquote>\n<p>В x86 - 8 32-битных регистров.</p>\n<p>В x64 - 16 64-битных регистров. 64-битные версии <strong>Е*</strong> регистров называются <strong>R*</strong>. Дополнительные регистры получили названия <code class=\"language-text\">r8...r15</code>.</p>\n<ul>\n<li><strong>ESP</strong> - <em>stack pointer</em>, вершина стека. Указывает на текущую вершину стэка. Операции <code class=\"language-text\">push</code> и <code class=\"language-text\">pop</code> читают из <strong>ESP</strong> адрес, по которому обращаться к стэку, а в конце раобты меняют значение <strong>ESP</strong>. После пролога функции все локальные переменные и аргументы оказываются выше <strong>ESP</strong>.</li>\n<li><strong>EBP</strong> - <em>frame pointer</em>, вершина фрейма. Все аргументы функции и адрес возврата находятся выше его, а локальные переменные - ниже.</li>\n</ul>\n<h2>Синтаксис MOV</h2>\n<p><code class=\"language-text\">mov %eax, %edx</code></p>\n<p>Есть два синтаксиса:</p>\n<ul>\n<li><strong>Intel</strong>: перемещает <strong>EDX</strong> в <strong>EAX</strong>. Используется во всяких MASM, TASM, NASM, FASM. </li>\n<li><strong>AT&#x26;T</strong>: перемещает <strong>EAX</strong> в <strong>EDX</strong>. Используется во всех Unix-системах.</li>\n</ul>\n<p>Так как работаем в основном в линуксе, то в большинстве случаев будет встречаться вариант, когда <code class=\"language-text\">mov %eax, %edx</code> означает присвовить регистру <strong>edx</strong> значение регистра <strong>edx</strong>.</p>\n<h2>Как определить используемое соглашение</h2>\n<p>Делаем <code class=\"language-text\">nm</code> на интересующей библиотеке и смотрим на имена символов.</p>\n<p>Если начинаются с <code class=\"language-text\">_</code> и не содержат <code class=\"language-text\">@</code>, то это <code class=\"language-text\">__cdecl</code>.</p>\n<p>Если начинаются с <code class=\"language-text\">_</code> и содержат <code class=\"language-text\">@</code>, то это <code class=\"language-text\">__stdcall</code>.</p>\n<p>Если начинается с <code class=\"language-text\">@</code> и содержит еще одну <code class=\"language-text\">@</code>, то это <code class=\"language-text\">__fastcall</code>.</p>\n<h2>Пролог</h2>\n<p>Обычно функция начинается с автосгенерированного пролога:</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">push ebp ; сохраняем вершину фрейма, чтобы после выхода из функции вызывающая функция смогла обращаться к своим локальным переменным\nmov esp, ebp ; перемещаем вершину фрейма вниз, записывая в нее текущее значение вершины стека\nsub esp, 20 ; локальные переменные функции находятся на стеке и ниже вершины фрейма, поэтому уменьшаем вершину стека на 20 байт, чтобы выделить 20 байт под локальные переменные</code></pre></div>\n<p>После этого <strong>EBP</strong> будет указывать на начало текущего фрейма, а <strong>ESP</strong> - на его конец.</p>\n<p>Затем в коде обращение к локальным переменным может выглядеть так:</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">mov eax, [ebp-4] ; сохраняем eax в первую локальную переменную\nmov ebx, [ebp-8] ; читаем вторую локальную переменную в регистр ebx</code></pre></div>\n<h2>Эпилог</h2>\n<p>А выход из функции (эпилог) выглядит так:</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">mov ebp, esp;   ; грохаем все локальные переменные со стека\npop ebp;        ; восстанавливаем предыдущее значение ebp, чтобы оно указывало на вершину фрейма вызывающей функции\nret             ; возвращаемся в вызывающую функцию</code></pre></div>\n<p>Для перечисленных ниже соглашений (кроме <code class=\"language-text\">[cdecl]</code>) перед возвратом значений из функции подпрограмма обязана восстановить значения сегментных регистров, регистров <code class=\"language-text\">esp</code> и <code class=\"language-text\">ebp</code>. Значения остальных регистров могут не восстанавливаться.</p>\n<p>Если размер возвращаемого значения функции не больше размера регистра <code class=\"language-text\">eax</code>, возвращаемое значение сохраняется в регистре <code class=\"language-text\">eax</code>. Иначе, возвращаемое значение сохраняется на вершине стека, а указатель на вершину стека сохраняется в регистре <code class=\"language-text\">eax</code>.</p>\n<h2>Соглашения</h2>\n<p>Пусть у нас есть такая функция:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">sumExample</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Которая вызывается вот так:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token function\">sumExample</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>System V ABI</h3>\n<p><a href=\"https://wiki.osdev.org/System_V_ABI\">https://wiki.osdev.org/System_V_ABI</a></p>\n<p>Функции вызываются командами <code class=\"language-text\">call</code> и <code class=\"language-text\">callq</code>, которые пушат на стек адрес следующей инструкции и вызывают джамп. Возврат осуществляется командой <code class=\"language-text\">ret</code>, которая попает со стека адрес возврата и джампает на него. Перед вызовом <code class=\"language-text\">call</code> стэк выравнивается по 16 байтам.</p>\n<p>Аргументы, переданные через стек, могут быть модифированы вызываемой функцией.</p>\n<h4>x86</h4>\n<p>Аргументы передаются через стек. </p>\n<p>Функции сохраняют значения регистров <code class=\"language-text\">ebx, esi, edi, ebp, esp</code>, а регистры <code class=\"language-text\">eax, ecx, edx</code> могут быть затерты. Значение возвращается через регистр <code class=\"language-text\">eax</code>, а если он больше 32 бит, то верхние 32 бита идут в <code class=\"language-text\">edx</code>.</p>\n<h4>x64</h4>\n<p>Аргументы передаются в регистрах <code class=\"language-text\">rdi, rsi, rdx, rcx, r8, r9</code>, остальные - на стеке, справа налево. </p>\n<p>Функции сохраняют значения регистров <code class=\"language-text\">rbx, rsp, rbp, r12, r13, r14, r15</code>, а регистры <code class=\"language-text\">rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11</code> могут быть затерты. Значение возвращается через регистр <code class=\"language-text\">rax</code>, а если он больше 64 бит, то верхние 64 бита идут в <code class=\"language-text\">rdx</code>.</p>\n<p>Пример:</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">sum.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;sumExample&gt;:\n   0:   55                      push   %rbp               ; бэкапим вершину стека родителя\n   1:   48 89 e5                mov    %rsp,%rbp          ; заводим себе фрейм\n   4:   89 7d fc                mov    %edi,-0x4(%rbp)    ; кладем в локальную переменную первый аргумент  \n   7:   89 75 f8                mov    %esi,-0x8(%rbp)    ; кладем в локальную переменную второй аргумент\n   a:   8b 55 fc                mov    -0x4(%rbp),%edx    ; из локальной переменной перемещаем первый аргумент в регистр edx\n   d:   8b 45 f8                mov    -0x8(%rbp),%eax    ; из локальной переменной перемещаем второй аргумент в регистр eax\n  10:   01 d0                   add    %edx,%eax          ; складываем регистры, результат окажется в eax\n  12:   5d                      pop    %rbp               ; ресторим вершину стека родителя\n  13:   c3                      retq                      ; возвращаемся\n\n0000000000000014 &lt;main&gt;:\n  14:   55                      push   %rbp               ; бэкапим вершину стека родителя\n  15:   48 89 e5                mov    %rsp,%rbp          ; заводим себе фрейм\n  18:   48 83 ec 10             sub    $0x10,%rsp         ; заводим место на стеке для 2 переменных (хз зачем, вроде оно тут не используется)\n  1c:   be 03 00 00 00          mov    $0x3,%esi          ; пишем 3 в регистр первого аргумента \n  21:   bf 02 00 00 00          mov    $0x2,%edi          ; пишем 2 в регистр второго аргумента\n  26:   e8 00 00 00 00          callq  2b &lt;main+0x17&gt;     ; вызываем sumExample\n  2b:   89 45 fc                mov    %eax,-0x4(%rbp)    ; кладем результат в локальную переменную\n  2e:   90                      nop\n  2f:   c9                      leaveq\n  30:   c3                      retq</code></pre></div>\n<h3>cdecl</h3>\n<p><code class=\"language-text\">cdecl</code> — соглашение о вызовах, используемое компиляторами для языка <strong>C</strong>.</p>\n<p>Аргументы функций передаются через стек, справа налево. Аргументы, размер которых меньше 4-х байт, расширяются до 4-х байт. Очистку стека производит <strong>вызывающая</strong> программа. Это основной способ вызова функций с переменным числом аргументов (например, <code class=\"language-text\">[printf()](https://ru.wikipedia.org/wiki/Printf)</code>). Названия функций имеют префикс '_'. Способы получения возвращаемого значения функции приведены в таблице.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/hows-that-again/static/b9425fe9a118d6287eb920b2d7ba0a4d/91670/calling-convention-return.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 12.153846153846155%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsSAAALEgHS3X78AAAAdklEQVQI1z2JSw6DIAAFvf8NmzYaFBEof0Ttavwsuphk3rzOh8ikvliXkfOCGCWTVEyzZpSG13vg04un37/SFmPdw936QaAv18bhQ6LT1jNrj3EFHzPbftAu9uNHiBEhLXLxqEUTUiXmlVQqKVdKbZS1/ffaNk4KrJX4x41vmgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Таблица 1\"\n        title=\"Таблица 1\"\n        src=\"/hows-that-again/static/b9425fe9a118d6287eb920b2d7ba0a4d/dbb61/calling-convention-return.png\"\n        srcset=\"/hows-that-again/static/b9425fe9a118d6287eb920b2d7ba0a4d/19bd1/calling-convention-return.png 163w,\n/hows-that-again/static/b9425fe9a118d6287eb920b2d7ba0a4d/d3bcb/calling-convention-return.png 325w,\n/hows-that-again/static/b9425fe9a118d6287eb920b2d7ba0a4d/dbb61/calling-convention-return.png 650w,\n/hows-that-again/static/b9425fe9a118d6287eb920b2d7ba0a4d/6b691/calling-convention-return.png 975w,\n/hows-that-again/static/b9425fe9a118d6287eb920b2d7ba0a4d/91670/calling-convention-return.png 1300w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Перед вызовом функции вставляется код, называемый <strong>прологом</strong> и выполняющий следующие действия:</p>\n<ul>\n<li>сохранение значений регистров, используемых внутри функции;</li>\n<li>запись в стек аргументов функции</li>\n</ul>\n<p>После вызова функции вставляется код, называемый <strong>эпилогом</strong> и выполняющий следующие действия:</p>\n<ul>\n<li>восстановление значений регистров, сохранённых кодом пролога;</li>\n<li>очистка стека (от локальных переменных и аргументов).</li>\n</ul>\n<p>Пример:</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">    ; sumExample(2, 3)\n\n    ; записываем в стек аргументы функции справа налево\n    push 3\n    push 2\n\n    ; вызываем функцию\n    call _sumExample\n\n    ; очищаем стек от аргументов\n    add esp,8\n\n    ; копишуем возвращаемое значение (eax) в локальную переменную c\n    mov dword ptr [c],eax</code></pre></div>\n<p>Вызываемая функция выглядит так:</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">; пролог\n\npush ebp\nmov ebp,esp   ; после этого над EBP находятся аргументы 2 и 3, а под ним будут локальные переменные\nsub esp,0C0h  ; выделяем на стеке место для 12 байт под локальные переменные\npush ebx\npush esi\npush edi\nlea edi,[ebp-0C0h]  ; lea = load effective address, получаем адрес в памяти для вершины стека\nmov ecx,30h\nmov eax,0CCCCCCCCh\nrep stos dword ptr [edi]\n\n; return a + b;\nmov eax,dword ptr [a]\nadd eax,dword ptr [b]\n\n; эпилог\npop edi\npop esi\npop ebx\nmov esp,ebp\npop ebp\n\nret</code></pre></div>\n<h3>stdcall или winapi</h3>\n<p><code class=\"language-text\">stdcall</code> или <code class=\"language-text\">winapi</code> — соглашение о вызовах, применяемое в Windows для вызова функций WinAPI.</p>\n<p>Аргументы функций передаются через стек, справа налево. Очистку стека производит вызываемая подпрограмма. Названия функций имеют префикс '_' и постфикс вида '@+необходимое количество байт на стэке'.</p>\n<p>Пример:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">; // push arguments to the stack, from right to left\n  push        3\n  push        2\n\n; // call the function\n  call        _sumExample@8\n\n; // copy the return value from EAX to a local variable (int c)  \n  mov         dword ptr [c],eax</code></pre></div>\n<p>Код функции:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">; // function prolog goes here (the same code as in the __cdecl example)\n\n; //    return a + b;\n  mov         eax,dword ptr [a]\n  add         eax,dword ptr [b]\n\n; // function epilog goes here (the same code as in the __cdecl example)\n\n; // cleanup the stack and return\n  ret         8</code></pre></div>\n<p>Так как очистку стэка производит вызываемая программа, то размер бинарников получается меньше, чем у cdecl. Однако функциям с переменным числом аргументов приходится использовать cdecl, потому что только вызывающий код знает количество аргументов.</p>\n<h3>fastcall</h3>\n<p><code class=\"language-text\">fastcall</code> — общее название соглашений, передающих параметры через регистры (обычно это самый быстрый способ, отсюда название). Если для сохранения всех параметров и промежуточных результатов регистров не достаточно, используется стек.</p>\n<p>Соглашение о вызовах <code class=\"language-text\">fastcall</code> не стандартизировано, поэтому используется только для вызова процедур и функций, не экспортируемых из исполняемого модуля и не импортируемых извне.\nВ компиляторах фирмы Borland для соглашения __fastcall, называемого также register[5], параметры передаются слева направо в регистрах eax, edx, ecx, а если параметров больше трёх — в стеке, также слева направо. Исходное значение указателя на вершину стека (значение регистра esp) возвращает вызываемая подпрограмма.</p>\n<p>В 32-разрядной версии компилятора фирмы Microsoft, а также в компиляторе GCC, соглашение __fastcall, также называемое __msfastcall, определяет передачу первых двух параметров слева направо в регистрах ecx и edx, а остальные параметры передаются справа налево в стеке. Очистку стека производит вызываемая подпрограмма.</p>\n<p>Названия функций начинаются с @ и заканчиваются на @ + необходимое количество байт на стэке.</p>\n<p>Пример:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">; // put the arguments in the registers EDX and ECX\n  mov         edx,3\n  mov         ecx,2\n\n; // call the function\n  call        @fastcallSum@8\n\n; // copy the return value from EAX to a local variable (int c)  \n  mov         dword ptr [c],eax</code></pre></div>\n<p>Код функции:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">; // function prolog\n\n  push        ebp  \n  mov         ebp,esp\n  sub         esp,0D8h\n  push        ebx  \n  push        esi  \n  push        edi  \n  push        ecx  \n  lea         edi,[ebp-0D8h]\n  mov         ecx,36h\n  mov         eax,0CCCCCCCCh\n  rep stos    dword ptr [edi]\n  pop         ecx  \n  mov         dword ptr [ebp-14h],edx\n  mov         dword ptr [ebp-8],ecx\n; // return a + b;\n  mov         eax,dword ptr [a]\n  add         eax,dword ptr [b]\n;// function epilog  \n  pop         edi  \n  pop         esi  \n  pop         ebx  \n  mov         esp,ebp\n  pop         ebp  \n  ret</code></pre></div>\n<h3>thiscall</h3>\n<p>thiscall — соглашение о вызовах, используемое компиляторами для языка C++ при вызове методов классов в объектно-ориентированном программировании.</p>\n<p>Аргументы функции передаются через стек, справа налево. Очистку стека производит вызывающая программа. Соглашение thiscall отличается от cdecl соглашения только тем, что указатель на объект, для которого вызывается метод (указатель this), записывается в регистр ecx[8]. Если же используется функция с переменным количеством аргументов, то this кладется на стэк последним.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">push        3\npush        2\nlea         ecx,[sumObj]\ncall        ?sum@CSum@@QAEHHH@Z            ; CSum::sum\nmov         dword ptr [s4],eax</code></pre></div>\n<p>Код функции:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    push        ebp\n    mov         ebp,esp\n    sub         esp,0CCh\n    push        ebx\n    push        esi\n    push        edi\n    push        ecx\n    lea         edi,[ebp-0CCh]\n    mov         ecx,33h\n    mov         eax,0CCCCCCCCh\n    rep stos    dword ptr [edi]\n    pop         ecx\n    mov         dword ptr [ebp-8],ecx\n    mov         eax,dword ptr [a]\n    add         eax,dword ptr [b]\n    pop         edi\n    pop         esi\n    pop         ebx\n    mov         esp,ebp\n    pop         ebp\n    ret         8</code></pre></div>\n<p>To cut a long story short, we'll outline the main differences between the calling conventions:</p>\n<ul>\n<li><code class=\"language-text\">__cdecl</code> is the default calling convention for C and C++ programs. The advantage of this calling convetion is that it allows functions with a variable number of arguments to be used. The disadvantage is that it creates larger executables.</li>\n<li><code class=\"language-text\">__stdcall</code> is used to call Win32 API functions. It does not allow functions to have a variable number of arguments.</li>\n<li><code class=\"language-text\">__fastcall</code> attempts to put arguments in registers, rather than on the stack, thus making function calls faster.</li>\n<li><code class=\"language-text\">Thiscall</code> calling convention is the default calling convention used by C++ member functions that do not use variable arguments.</li>\n</ul>\n<h2>X64</h2>\n<p>В X64 все Е* регистры называются R*. <a href=\"https://msdn.microsoft.com/ru-ru/library/9z1stfyw.aspx\">https://msdn.microsoft.com/ru-ru/library/9z1stfyw.aspx</a></p>\n<p>В X64 используется только __fastcall, причем регистры используются для передачи первых 4 аргументов. Аргументы передаются в регистрах RCX, RDX, R8 и R9.</p>","frontmatter":{"path":"/blog/call_conventions","title":"Call conventions"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}