{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/oauth","result":{"data":{"markdownRemark":{"html":"<h1 id=\"oauth\" style=\"position:relative;\"><a href=\"#oauth\" aria-label=\"oauth permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OAuth</h1>\n<p>OAUth2 работает так (<a href=\"https://aaronparecki.com/2012/07/29/2/oauth2-simplified\">https://aaronparecki.com/2012/07/29/2/oauth2-simplified</a>): </p>\n<p>Есть сервис автоматизирующий что-нибудь на фейсбуке. Это клиент. Когда я хочу залогиниться в него через фейсбук, происходит следующее: </p>\n<ol>\n<li>При создании приложение клиента регистрируется в ФБ, указывая URI редиректа и получает Client ID. </li>\n<li>При запросе авторизации клиент редиректит пользователя к Oauth API фейсбука, передавая в ссылке Client Id, redirect URI и возможно дополнительную информацию об уровне доступа. Ссылка примерно такого вида: </li>\n</ol>\n<p><a href=\"https://oauth2server.com/auth?response_type=code&#x26;client_id=CLIENT_ID&#x26;redirect_uri=REDIRECT_URI&#x26;scope=photos\">https://oauth2server.com/auth?response_type=code&#x26;client_id=CLIENT_ID&#x26;redirect_uri=REDIRECT_URI&#x26;scope=photos</a> </p>\n<p>На этой странице у пользователя спрашивается, готов ли он предоставить доступ. </p>\n<ol start=\"3\">\n<li>Если пользователь согласен, то ФБ редиректит его по redirect URI обратно на клиента, передавая параметром auth code </li>\n</ol>\n<p><a href=\"https://oauth2client.com/cb?code=AUTH_CODE_HERE\">https://oauth2client.com/cb?code=AUTH_CODE_HERE</a> </p>\n<ol start=\"4\">\n<li>Клиент, получив auth code, отправляет его серверу чтобы получить access<em>token. В запросе он указывает известный только ему client</em>secret. </li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">POST https://api.oauth2server.com/token \ngrant_type=authorization_code&amp;\ncode=AUTH_CODE_HERE&amp;\nredirect_uri=REDIRECT_URI&amp;\nclient_id=CLIENT_ID&amp;\nclient_secret=CLIENT_SECRET </code></pre></div>\n<ol start=\"5\">\n<li>Все операции клиента в дальнейшем проводятся с использованием этого токена. </li>\n</ol>\n<p>Это процесс для серверных приложений (процесс называется <strong>authorization code flow / explicit flow</strong>). Важное отличие от клиентских: на этапе 2 передается <code class=\"language-text\">response_type=code</code>. </p>\n<h2 id=\"implicit-flow\" style=\"position:relative;\"><a href=\"#implicit-flow\" aria-label=\"implicit flow permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Implicit flow</h2>\n<p>В случае client-side приложений используется <strong>implicit flow</strong>, на 2 этапе передается response<em>type=token и на этапе 3 клиенту приходит сразу токен (<a href=\"https://oauth2client.com/cb?token=ACCESS\">https://oauth2client.com/cb?token=ACCESS</a></em>TOKEN) </p>\n<p>Explicit mode нужен, чтобы пользователь не узнал токен. Если пользователю известен токен, то он может утечь к другому, опасному приложению. Чтобы этого не было, такие токены обычно делают short-lived. </p>\n<h2 id=\"resource-owner-password-flow\" style=\"position:relative;\"><a href=\"#resource-owner-password-flow\" aria-label=\"resource owner password flow permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Resource Owner Password Flow</h2>\n<p>При локальном логине (т.е. без использования сторонних соцсетей) используется Resource Owner Password Flow (<a href=\"http://oauthlib.readthedocs.io/en/latest/oauth2/grants/password.html\">http://oauthlib.readthedocs.io/en/latest/oauth2/grants/password.html</a>) </p>\n<p>В этом случае все довольно просто: </p>\n<ol>\n<li>пользователь шлет серверу авторизации в открытом виде (через https!) логин и пароль </li>\n<li>сервер авторизации отвечает токеном </li>\n<li>в последующих запросах клиент включает токен в заголовок http. </li>\n</ol>\n<p>По идее это нужно для того, чтобы когда у тебя отдельные сервер авторизации и сервер приложения, то сервер приложения ничего не знал о логине и пароле пользователя. </p>\n<p>Пример использования этого flow для WebAPI (<a href=\"http://www.asp.net/web-api/overview/security/individual-accounts-in-web-api\">http://www.asp.net/web-api/overview/security/individual-accounts-in-web-api</a>) </p>\n<p>Зачем нужно использовать OAuth <a href=\"http://stackoverflow.com/questions/7561631/oauth-2-0-benefits-and-use-cases-why\">http://stackoverflow.com/questions/7561631/oauth-2-0-benefits-and-use-cases-why</a></p>","frontmatter":{"path":"/blog/oauth","title":"OAuth"}}},"pageContext":{}},"staticQueryHashes":["3649515864"]}