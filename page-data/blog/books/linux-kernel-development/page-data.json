{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/books/linux-kernel-development","result":{"data":{"markdownRemark":{"html":"<h1 id=\"linux-kernel-development\" style=\"position:relative;\"><a href=\"#linux-kernel-development\" aria-label=\"linux kernel development permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Linux Kernel Development</h1>\n<p><a href=\"https://www.amazon.com/Linux-Kernel-Development-Robert-Love/dp/0672329468\">https://www.amazon.com/Linux-Kernel-Development-Robert-Love/dp/0672329468</a></p>\n<h2 id=\"introduction-to-the-linux-kernel\" style=\"position:relative;\"><a href=\"#introduction-to-the-linux-kernel\" aria-label=\"introduction to the linux kernel permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Introduction to the Linux Kernel</h2>\n<p>Отличия ядра Linux от классических Unix-систем:</p>\n<ul>\n<li>Линукс поддерживает динамическую загрузку модулей ядра, несмотря на то что ядро монолитное</li>\n<li>Ядро Linux является <strong>вытесняющим</strong>. Это означает, что даже процессы ядра могут быть остановлены и запущены заново (т.е. у них тоже бывает context switch). В случае не-вытесняющих ядер все процессы в контексте ядра работают, пока не завершается.</li>\n<li>Линукс не делает различий между тредами и процессами. Для Линукса это всё процессы, просто некоторые еще и могут шарить между собой ресурсы.</li>\n<li>Линукс игнорирует некоторые фичи Unix, потому что разработчики Линукса решили что они плохо спроектированы, например, концепт STREAMS, или стандарты, которые невозможно нормально реализовать.</li>\n</ul>\n<h2 id=\"как-сбилдить-ядро\" style=\"position:relative;\"><a href=\"#%D0%BA%D0%B0%D0%BA-%D1%81%D0%B1%D0%B8%D0%BB%D0%B4%D0%B8%D1%82%D1%8C-%D1%8F%D0%B4%D1%80%D0%BE\" aria-label=\"как сбилдить ядро permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Как сбилдить ядро</h2>\n<h3 id=\"конфигурация\" style=\"position:relative;\"><a href=\"#%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F\" aria-label=\"конфигурация permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Конфигурация</h3>\n<p>Сначала нужно настроить билд. Самый базовый (но не простой) способ это:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">make</span> config</code></pre></div>\n<p>Но он наверняка займет много времени, потому что консольный. Есть псевдографический способ:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">make</span> menuconfig</code></pre></div>\n<p>И самый простой - когда автомаитчески подбирается подходящая конфигурация для ващей текущей архитектуры:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">make</span> defconfig</code></pre></div>\n<p>Конфигурация сохраняется в корне сорцов в файле .config. Его можно редактировать и вручную, но тогда лучше перед билдом провалидировать конфиг командой:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">make</span> oldconfig</code></pre></div>\n<p>Опция CONFIG<em>IKCONFIG</em>PROC кладет конфигурацию билда в <code class=\"language-text\">/proc/config.gz</code>. Можно использовать текущую конфигурацию для нового билда вот так:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">zcat /proc/config.gz <span class=\"token operator\">></span> .config\n<span class=\"token function\">make</span> oldconfig</code></pre></div>\n<h3 id=\"билд\" style=\"position:relative;\"><a href=\"#%D0%B1%D0%B8%D0%BB%D0%B4\" aria-label=\"билд permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Билд</h3>\n<p>Все просто:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">make</span> -j32</code></pre></div>\n<h3 id=\"установка\" style=\"position:relative;\"><a href=\"#%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0\" aria-label=\"установка permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Установка</h3>\n<p>В случае убунты делаем так, сначала устанавливаем модули:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">make</span> modules_install</code></pre></div>\n<p>Модули установятся в /lib/modules в папки, соответствующие версии ядра, поэтому можно не бояться сломать текущее состояние ОС.</p>\n<p>Затем устанавливаем само ядро:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">make</span> <span class=\"token function\">install</span></code></pre></div>\n<p>Эта команда установит файл ядра в <code class=\"language-text\">/boot</code>, например, <code class=\"language-text\">/boot/vmlinuz-5.14.0-rc6+</code>, а так же сама поправит конфиги grub, чтобы при следующей загрузке машины автоматически загружалось самое последнее ядро. Если мы ходим загружать другое ядро, то после экрана BIOS/UEFI надо 1 раз нажать ESC, и появится меню grub. Это не всегда удобно, поэтому посмотрим как поменять поведение grub при загрузке.</p>\n<h3 id=\"настройка-grub\" style=\"position:relative;\"><a href=\"#%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-grub\" aria-label=\"настройка grub permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Настройка GRUB</h3>\n<p>Конфиг grub лежит в <code class=\"language-text\">/boot/grub/grub.cfg</code>, но его трогать нельзя. Этот конфиг собирается утилитой <code class=\"language-text\">update-grub</code> при модификации файлов в <code class=\"language-text\">/etc/grub.d</code> и <code class=\"language-text\">/etc/default/grub</code>.</p>\n<p>Чтобы включить автопоказ меню grub с выбором версии ядра при загрузке, нужно сделать так:</p>\n<ol>\n<li>Бэкапим <code class=\"language-text\">etc/default/grub</code> в <code class=\"language-text\">/etc/default/grub.bak</code></li>\n<li>В <code class=\"language-text\">/etc/default/grub</code> выставляем:</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">GRUB_TIMEOUT_STYLE</span><span class=\"token operator\">=</span>countdown\n<span class=\"token assign-left variable\">GRUB_TIMEOUT</span><span class=\"token operator\">=</span><span class=\"token number\">5</span></code></pre></div>\n<ol start=\"3\">\n<li>Делаем <code class=\"language-text\">sudo update-grub</code>.</li>\n</ol>\n<p>Все, теперь при запуске машины в определенный момент на экране появится обратный отсчет 5 секунд, нужно нажать ESC, выбрать Advanced и затем свою версию ядра.</p>\n<p>Еще можно поменять GRUB_DEFAULT (туда нужно указать не порядковый номер, а id для menuentry из grub.cfg), но у меня почему-то не вышло.</p>\n<p>И еще можно автоматически запускать ту же версию, что и в прошлый раз (я пока не пробовал):</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">GRUB_DEFAULT</span><span class=\"token operator\">=</span>saved\n<span class=\"token assign-left variable\">GRUB_SAVEDEFAULT</span><span class=\"token operator\">=</span>true</code></pre></div>\n<h2 id=\"менеджмент-процессов\" style=\"position:relative;\"><a href=\"#%D0%BC%D0%B5%D0%BD%D0%B5%D0%B4%D0%B6%D0%BC%D0%B5%D0%BD%D1%82-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2\" aria-label=\"менеджмент процессов permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Менеджмент процессов</h2>\n<p>Новый процесс создается системным вызовов <code class=\"language-text\">fork()</code>. Если нужно запустить другую программу, то новый поток сразу после этого запускает <code class=\"language-text\">exec()</code>. Этот вызов создает новое адресное пространство и загружает в него программу. В совр еменных ядрах Линукса <code class=\"language-text\">fork()</code> реализован через вызов <code class=\"language-text\">clone()</code>.</p>\n<p>По завершении программа вызывает <code class=\"language-text\">exit()</code>, который завершает процесс и освобождает все ресурсы. Родительский процесс дожидается окончания дочернего вызовом <code class=\"language-text\">wait4()</code>. Когда процесс завершается, он становится зомби, пока родитель не вызовет <code class=\"language-text\">wait()</code> или <code class=\"language-text\">waitpid()</code>.</p>\n<p>Разница между <code class=\"language-text\">wait()</code> и <code class=\"language-text\">wait4()</code> в том, что ядро реализует только <code class=\"language-text\">wait4()</code>, а все остальные <code class=\"language-text\">wait()</code>, <code class=\"language-text\">waitpid()</code>, <code class=\"language-text\">wait3()</code>, и собственно <code class=\"language-text\">wait4()</code> это функции С, т.е. врапперы над ядерным <code class=\"language-text\">wait4()</code>. Ну и еще некоторые отличия по семантике есть, <code class=\"language-text\">wait4()</code> возращает некоторую статистику по процессу, а <code class=\"language-text\">wait()</code> - нет.</p>\n<p>Список процессов хранится в зацикленном двойном связанном списке task list. Каждый элемент списка это дескриптор процессе, описываемый структурой <code class=\"language-text\">task_struct</code> (см. <code class=\"language-text\">&lt;linux/sched.h&gt;</code>). У каждого потока в конце стэка лежит структура <code class=\"language-text\">thread_info</code>, которая ссылается на дескриптор процесса task_struct.</p>\n<p><code class=\"language-text\">thread_info</code> описан в <code class=\"language-text\">arch/x86/include/asm/thread_info.h</code>.</p>\n<h2 id=\"шедулинг-процессов\" style=\"position:relative;\"><a href=\"#%D1%88%D0%B5%D0%B4%D1%83%D0%BB%D0%B8%D0%BD%D0%B3-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2\" aria-label=\"шедулинг процессов permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Шедулинг процессов</h2>\n<p>Мультитаскинг бывает кооперативный, а бывает вытесняющий (preemptive).</p>\n<p>Кооперативный - процессы сами решают, когда им передать управление другим процессам (это называется yielding).</p>\n<p>Вытесняющий - шедулер решает, останавливает и возобновляет процессы.</p>\n<p>До версии 2.5 в линуксе был какой-то совсем простой шедулер, обычно называемый O(n) scheduler. O(n) означает, что для выбора следующего процесса шедулеру приходилось просматривать все запущенные процессы. Соответственно с накоплением количества процессов переключение происходило все медленнее.</p>\n<p>В 2.6 O(n) scheduler заменен на O(1) scheduler. Он, соответственно, шедулит процессы всегда за константное время. Его основной проблемой были сложные эвристики, при помощи которых он пытался распознать интерактивные процессы, чтобы возобновлять их с меньшей задержкой. Сложность эвристик неизбежно приводила к ошибкам и интерактивные приложения все равно тормозили.</p>\n<p>В 2.6.23 на смену пришел CFS - Completely Fair Scheduler. <a href=\"https://developer.ibm.com/tutorials/l-completely-fair-scheduler/\">https://developer.ibm.com/tutorials/l-completely-fair-scheduler/</a></p>\n<h3 id=\"linux-scheduler-algorithm\" style=\"position:relative;\"><a href=\"#linux-scheduler-algorithm\" aria-label=\"linux scheduler algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Linux scheduler algorithm</h3>\n<p>Все процессы делятся на разные типы и для разных типов могут работать разные алгоритмы, так называемые scheduler classes. Каждый класс шедулера имеет приоритет, а основной код шедулера в каждой итерации выбирает тот шедулер, который имеет наивысший приоритет и работающий процесс. Выбранный шедулер и решает, кто будет запущен следующим.</p>\n<p>CFS - это класс шедулера для процессов с приоритетом SCHED_NORMAL. Он описан в <code class=\"language-text\">kernel/sched/fair.c</code>.</p>\n<p>Чтобы помнить, какой процесс сколько уже проработал, CFS использует структуру <code class=\"language-text\">sched_entity</code> (<code class=\"language-text\">&lt;linux/sched.h&gt;</code>). В дескрипторе процесса (<code class=\"language-text\">task_struct</code>) эта структура находится в поле <code class=\"language-text\">se</code>.</p>\n<p>Одно из полей <code class=\"language-text\">sched_entity</code> - vruntime. Это время работы процесса, нормализованное по количеству процессов. Измеряется в наносекундах. Цель шедулера - расшедулить так, чтобы vruntime у всех процессов был одинаковый. Для этого CFS поддерживает красно-черное дерево процессов и выбирает всегда тот, у которого наименьший vruntime.</p>","frontmatter":{"path":"/blog/books/linux-kernel-development","title":"linux-kernel-development"}}},"pageContext":{}},"staticQueryHashes":["3649515864"]}