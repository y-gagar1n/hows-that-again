{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/books/effective-modern-cpp","webpackCompilationHash":"e01bf4f90eb9cfaa4689","result":{"data":{"markdownRemark":{"html":"<h1>Effective Modern C++</h1>\n<h2>Вывод типов через auto</h2>\n<p>Тип для <code class=\"language-text\">auto</code> выводится так же, как и для шаблонов. В том выводе типов у нас есть определение шаблона и его вызов:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\nvoid <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>ParamType param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">f</span><span class=\"token punctuation\">(</span>expr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Когда переменная объявляется через <code class=\"language-text\">auto</code>, то <code class=\"language-text\">auto</code> выступает в роли <strong>T</strong>, а спецификатор типа - как <code class=\"language-text\">ParamType</code>. Например:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">auto x <span class=\"token operator\">=</span> <span class=\"token number\">27</span><span class=\"token punctuation\">;</span>\t\t\t<span class=\"token comment\">// auto -> T, auto -> ParamType</span>\nconst auto cx <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// auto -> T, const auto -> ParamType</span>\nconst auto<span class=\"token operator\">&amp;</span> rx <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// auto -> T, const auto&amp; -> ParamType</span></code></pre></div>\n<p>Для вывода представим соответствующие им шаблоны и их вызовы:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\nvoid <span class=\"token function\">func_x</span><span class=\"token punctuation\">(</span>T param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">func_x</span><span class=\"token punctuation\">(</span><span class=\"token number\">27</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// ParamTYpe -> int, T -> int</span>\n\ntemplate<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\nvoid <span class=\"token function\">func_cx</span><span class=\"token punctuation\">(</span>const T param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">func_cx</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// ParamType -> const int, T -> int</span>\n\ntemplate<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\nvoid <span class=\"token function\">func_rx</span><span class=\"token punctuation\">(</span>const T<span class=\"token operator\">&amp;</span> param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">func_rx</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// ParamType -> const int&amp;, T -> int</span></code></pre></div>\n<p>Во всех остальных случаях логика точно такая же как и для вывода типа шаблона. Но есть одно исключение, о нем дальше.</p>\n<h3>Особый случай для initializer_list</h3>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">auto x1 <span class=\"token operator\">=</span> <span class=\"token number\">27</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// int</span>\nauto <span class=\"token function\">x2</span><span class=\"token punctuation\">(</span><span class=\"token number\">27</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// int</span>\nauto x3 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">27</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// std::initializer_list&lt;int> = {27}</span>\nauto x4<span class=\"token punctuation\">{</span><span class=\"token number\">27</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// std::initializer_list&lt;int> = {27}</span></code></pre></div>\n<p>Так происходит потому что в выводе типов через <code class=\"language-text\">auto</code> прописано особое правило: <strong>если значение для авто-объявленной переменной заключено в фигурные скобки, то тип ВСЕГДА выводится как std::initializer_list</strong>.</p>\n<p>При этом в выводе типов для шаблонов такого правила нет и это единственное место где алгоритмы различаются:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\nvoid <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>T param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token number\">11</span><span class=\"token punctuation\">,</span> <span class=\"token number\">23</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ОШИБКА КОМПИЛЯЦИИ!</span>\n\ntemplate<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\nvoid <span class=\"token function\">f2</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>initializer_list<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">fw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token number\">11</span><span class=\"token punctuation\">,</span><span class=\"token number\">23</span><span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// все ок, тип T выводится как int</span></code></pre></div>\n<h2>decltype</h2>\n<p><strong>decltype</strong> - это функция, которая принимает переменную, а возвращает ее тип. Может быть использована там, где ожидается указание типа.</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">const int i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\t\t\t<span class=\"token comment\">// decltype(i) -> const int</span>\nbool <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>const Widget<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// decltype(w) -> const Widget&amp;, decltype(f) -> bool(const Widget&amp;)</span></code></pre></div>\n<p>Обычно используется там, где тип возвращаемого значения зависит от типа аргумента:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template<span class=\"token operator\">&lt;</span>typename Container<span class=\"token punctuation\">,</span> typename Index<span class=\"token operator\">></span>\nauto <span class=\"token function\">authAndAccess</span><span class=\"token punctuation\">(</span>Container<span class=\"token operator\">&amp;</span> c<span class=\"token punctuation\">,</span> Index i<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token function\">decltype</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">authenticateser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> c<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>здесь <code class=\"language-text\">auto</code> не имеет отношения к выводу типов, а лишь указывает, что возвращаемый тип будет указан после списка параметров (trailing return type syntax). Такой синтаксис необходимо использовать, когда тип возвращаемого значения зависит от типов параметров.</p>\n<p>В C++14 можно возвращать из функций <code class=\"language-text\">auto</code>, не указывая тип после стрелочки, но с этим бывают проблемы, поэтому рекомендуется возвращать <code class=\"language-text\">decltype(auto)</code>.</p>\n<p>С <code class=\"language-text\">authAndAccess</code> осталась одна проблема - она не сможет принимать rvalue для контейнера. Модифицируем так, чтобы мог:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template<span class=\"token operator\">&lt;</span>typename Container<span class=\"token punctuation\">,</span> typename Index<span class=\"token operator\">></span>\nauto <span class=\"token function\">get</span><span class=\"token punctuation\">(</span>Container<span class=\"token operator\">&amp;&amp;</span> c<span class=\"token punctuation\">,</span> Index i<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token function\">decltype</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>forward<span class=\"token operator\">&lt;</span>Container<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">authenticateUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>forward<span class=\"token operator\">&lt;</span>Container<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Теперь для <strong>c</strong> типа lvalue функция будет возвращать lvalue, а для rvalue - rvalue.</p>\n<h3>Особенность поведения decltype</h3>\n<p>Применение <strong>decltype</strong> к имени переменной возвращает тип этого имени. Однако применение к lvalue, котороя является чем-то более сложным, чем имя, возвращает ссылку на lvalue. То есть <strong>decltype</strong> над выражением не-именем, имеющим тип <strong>T</strong> вернет тип <strong>T&#x26;</strong>. Такое поведение редко на что-либо влияет, однако есть интересное следствие:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">int x <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">decltype</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// int</span>\n<span class=\"token function\">decltype</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// int&amp;</span></code></pre></div>\n<p>Как видно, оборачивание значения в скобки может поменять значение, возвращаемое <strong>decltype</strong>. Это особенно важно в C++14, где можно возвращать из функции <code class=\"language-text\">decltype(auto)</code> и случайно можно вернуть ссылку на элемент вместо элемента.</p>\n<h2>Используйте auto вместо явных определений типов</h2>\n<h3>auto не даст создать неинициализированный объект</h3>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">int x<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// не инициализирован!</span>\n\nauto x<span class=\"token punctuation\">;</span> <span class=\"token comment\">// не скомпилится!</span></code></pre></div>\n<h3>Позволяет не писать сложные типы</h3>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template<span class=\"token operator\">&lt;</span>typename It<span class=\"token operator\">></span>\nvoid <span class=\"token function\">dwim</span><span class=\"token punctuation\">(</span>It b<span class=\"token punctuation\">,</span> It e<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">!=</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\ttypename std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>iterator_traits<span class=\"token operator\">&lt;</span>It<span class=\"token operator\">></span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>value_type currValue <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>b<span class=\"token punctuation\">;</span>\n\tauto currValue2 <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>b<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Экономить память при использовании функторов</h3>\n<p>Тип лямбды неизвестен до компиляции, поэтому описать его точно - невозможно. Приходится использовать тип <code class=\"language-text\">std::function</code>. </p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token keyword\">function</span><span class=\"token operator\">&lt;</span><span class=\"token function\">bool</span><span class=\"token punctuation\">(</span>const std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>unique_ptr<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">,</span> const std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>unique_ptr<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token operator\">></span>\n\tfuncs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>const std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>unique_ptr<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> a<span class=\"token punctuation\">,</span> const std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>unique_ptr<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token operator\">*</span>a <span class=\"token operator\">&lt;</span> <span class=\"token operator\">*</span>b<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Но у него есть недостаток - он всегда занимает фиксированный размер в памяти, и если его не хватает, то аллоцирует память в куче. Тогда как реальный тип замыкания, выводимый во время компиляции и используемый с помощью <strong>auto</strong> всегда занимает ровно столько места, сколько ему требуется.</p>\n<p>Плюс к этому, из-за особенностей реализации, при вызове функции через <code class=\"language-text\">std::function</code> запрещается инлайнинг и добавляется непрямой вызов функции (indirect function calls), что ухудшает производительность по сравнению с <strong>auto</strong>.</p>\n<h3>Неявные приведения типов</h3>\n<p>Допустим, есть такой код:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>vector<span class=\"token operator\">&lt;</span>int<span class=\"token operator\">></span> v<span class=\"token punctuation\">;</span>\nunsigned sz <span class=\"token operator\">=</span> v<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Все бы ничего, да только <code class=\"language-text\">v.size()</code> возвращает вовсе не <strong>unsigned</strong>, а <code class=\"language-text\">std::vector&lt;int&gt;::size_type</code>.</p>\n<p>Другой пример:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>unordered_map<span class=\"token operator\">&lt;</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string<span class=\"token punctuation\">,</span> int<span class=\"token operator\">></span> m<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>const std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>pair<span class=\"token operator\">&lt;</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string<span class=\"token punctuation\">,</span> int<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> p<span class=\"token punctuation\">:</span> m<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Реальный тип элементов, содержащихся в <code class=\"language-text\">unordered_map</code> - <code class=\"language-text\">std::pair&lt;const std::string, int&gt;</code>. В результате компилятор не сможет привести <code class=\"language-text\">std::pair&lt;const std::string, int&gt;</code> к <code class=\"language-text\">std::pair&lt;std::string, int&gt;</code> и будет для каждого члена создавать временный объект, ссылку на который копировать в <strong>p</strong>. После каждой итерации временный объект будет уничтожен.</p>\n<p>Использование <strong>auto</strong> в этом случае делает код проще и производительнее:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>unordered_map<span class=\"token operator\">&lt;</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string<span class=\"token punctuation\">,</span> int<span class=\"token operator\">></span> m<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>const auto<span class=\"token operator\">&amp;</span> p<span class=\"token punctuation\">:</span> m<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Иногда auto выводит не то, что нужно</h2>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>vector<span class=\"token operator\">&lt;</span>bool<span class=\"token operator\">></span> <span class=\"token function\">features</span><span class=\"token punctuation\">(</span>const Widget<span class=\"token operator\">&amp;</span> w<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nWidget w<span class=\"token punctuation\">;</span>\nauto highPriority <span class=\"token operator\">=</span> <span class=\"token function\">features</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">processWidget</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">,</span> highPriority<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Как ни удивительно, этот код приводит к undefined behavior. Дело в том, что оператор <code class=\"language-text\">[]</code> для <code class=\"language-text\">std::vector&lt;bool&gt;</code> возвращает <code class=\"language-text\">std::vector&lt;bool&gt;::reference</code>. Так происходит потому, что булевого типа у вектора есть специальная реализация, которая хранит по одному биту на элемент. Теперь оператор <code class=\"language-text\">[]</code> должен возвращать ссылку на бит, но в C++ запрещены ссылки на биты. Поэтому приходится возвращать тип, который <em>ведет себя</em> как <code class=\"language-text\">bool&amp;</code>. ЭТо означает, что он, помимо прочего, должен быть неявно приводим к <code class=\"language-text\">bool</code>. </p>\n<p>Получается, что когда мы делаем <code class=\"language-text\">bool highPriority = features(w)[5]</code>, то возвращается <code class=\"language-text\">std::vector&lt;bool&gt;::reference</code>, который приводится к <code class=\"language-text\">bool</code> и дальше все нормально.</p>\n<p>А вот когда мы делаем <code class=\"language-text\">auto highPriority = features(w)[5]</code>, то дальше все зависит от реализации типа <code class=\"language-text\">std::vector&lt;bool&gt;::reference</code>. Одна из реализаций представляет из себя:</p>\n<ul>\n<li>указатель на машинное слово вектора, в котором содержится интересующий бит</li>\n<li>сдвиг в этом слове</li>\n</ul>\n<p>Итак, вызов <code class=\"language-text\">features</code> возвращает временный объект-вектор. Оператор <code class=\"language-text\">[]</code> возвращает <code class=\"language-text\">std::vector&lt;bool&gt;::reference</code>, в котором содержится ссылка на элемент внутри временного объекта-вектора. Мы записываем это в <code class=\"language-text\">highPriority</code>, после чего временный объект уничтожается, а в <code class=\"language-text\">highPriority</code> остается висячая ссылка на уничтоженный объект.</p>\n<p>Здесь <code class=\"language-text\">std::vector&lt;bool&gt;::reference</code> - это прокси-класс, который не предназначен для того, чтобы жить дольше, чем одно выражение. Поэтому <strong>auto</strong> очень плохо дружит с прокси-классами.</p>\n<p>Такие прокси-классы очень тяжело найти заранее, однако когда стало понятно, что проблема в прокси-классе, не стоит избавляться от <strong>auto</strong>. Лучший способ - использовать явное приведение типа:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">auto highPriority <span class=\"token operator\">=</span> static_cast<span class=\"token operator\">&lt;</span>bool<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token function\">features</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>Различия между () и {} при инициализации объектов</h2>\n<p>Для начало важно отличать инициализацию от присвоения:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">Widget w1<span class=\"token punctuation\">;</span>\t\t\t<span class=\"token comment\">// инициализация, вызван дефолтный конструктор</span>\nWidget w2 <span class=\"token operator\">=</span> w1<span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// инициализация, вызывается конструктор копирования</span>\nw1 <span class=\"token operator\">=</span> w2<span class=\"token punctuation\">;</span>\t\t\t<span class=\"token comment\">// присвоение, вызывается оператор =</span></code></pre></div>\n<p>В C++ 11 представлена <em>uniform initialization</em> - предпочтительный способ инициализации:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">int x<span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nstd<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>vector<span class=\"token operator\">&lt;</span>int<span class=\"token operator\">></span> v<span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Тот же синтаксис можно использовать и для задания дефолтных значений не-статическим полям классов, наравне с синтаксисом через <strong>=</strong>:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">class <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">{</span>\nprivate<span class=\"token punctuation\">:</span>\n\tint x<span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// ОК</span>\n\tint y <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// тоже ок</span>\n\tint <span class=\"token function\">z</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// ошибка компиляции!</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Однако если инициализируем не-копируемый тип, то <strong>{}</strong> валиден наравне с синтаксисом через <strong>()</strong>:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>atomic<span class=\"token operator\">&lt;</span>int<span class=\"token operator\">></span>ai1<span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// OK</span>\nstd<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>atomic<span class=\"token operator\">&lt;</span>int<span class=\"token operator\">></span><span class=\"token function\">ai2</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// OK</span>\nstd<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>atomic<span class=\"token operator\">&lt;</span>int<span class=\"token operator\">></span>ai3 <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// ошибка!</span></code></pre></div>\n<p>Поэтому, чтобы не путаться, лучше всегда использовать универсальную (uniform) инициализацию вида <code class=\"language-text\">int x{0};</code>.</p>\n<h3>{} запрещает преобразование типа с потерей точности</h3>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">double x<span class=\"token punctuation\">,</span>y<span class=\"token punctuation\">,</span>z<span class=\"token punctuation\">;</span>\nint sum1<span class=\"token punctuation\">{</span> x<span class=\"token operator\">+</span>y<span class=\"token operator\">+</span>z <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// не скомпилится, так как сумма даблов может быть невыразима через int</span>\nint <span class=\"token function\">sum2</span><span class=\"token punctuation\">(</span> x<span class=\"token operator\">+</span>y<span class=\"token operator\">+</span>z <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// спокойно компилится и приводит к неожиданному поведению при выполнении</span>\nint sum3 <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> y <span class=\"token operator\">+</span> z<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// аналогично sum2</span></code></pre></div>\n<h3>{} не подвержена most vexing parse</h3>\n<p>В С++ есть такое правило - все, что может быть интерпретировано как объявелние, должно быть интерпретировано как объявление.</p>\n<p>Поэтому часто, когда хотим инициализировать переменную дефолтным конструктором через скобки, вместо этого получается объявление функции:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">Widget <span class=\"token function\">w1</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// когда у конструктора есть параметры, то все норм</span>\nWidget <span class=\"token function\">w2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// а вот когда хотис использовать дефолтный конструктор, то получается объявление функции</span></code></pre></div>\n<p>С использованием <strong>{}</strong> код выглядит так и не содержит этой проблемы:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">Widget w3<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>Недостаток: опять проблемы с initializer_list</h3>\n<p>Если при инициализации через <strong>{}</strong> имеется конструктор, принимающий <code class=\"language-text\">initializer_list</code>, и он может быть теоретически использован, то будет использован именно он:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">class <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n\t<span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span>int i<span class=\"token punctuation\">,</span> bool b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span>int i<span class=\"token punctuation\">,</span> double d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>initializer_list<span class=\"token operator\">&lt;</span>long double<span class=\"token operator\">></span> il<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nWidget <span class=\"token function\">w1</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// будет вызван первый конструктор</span>\nWidget w2<span class=\"token punctuation\">{</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// 3-й</span>\nWidget <span class=\"token function\">w3</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// 2-й</span>\nWidget w4<span class=\"token punctuation\">{</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5.0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// 3-й</span></code></pre></div>\n<p>Причем иногда путь довольно непрост:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">class <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  <span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span>int i<span class=\"token punctuation\">,</span> bool b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span>int i<span class=\"token punctuation\">,</span> double d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>initializer_list<span class=\"token operator\">&lt;</span>long double<span class=\"token operator\">></span> il<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  operator <span class=\"token function\">float</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> const<span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// оператор преобразования Widget во float</span>\n\n  <span class=\"token comment\">// конструктор копирования</span>\n  <span class=\"token comment\">// конструктор перемещения</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nWidget <span class=\"token function\">w5</span><span class=\"token punctuation\">(</span>w4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t\t\t<span class=\"token comment\">// вызывается конструктор копирования </span>\nWidget w6<span class=\"token punctuation\">{</span>w4<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\t\t\t\t<span class=\"token comment\">// вызывается преобразование к float и затем конструктор с initializer_list, так как float может быть преобразован к long double</span>\nWidget <span class=\"token function\">w7</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>w4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// конструктор перемещения</span>\nWidget w8<span class=\"token punctuation\">{</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>w4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// опять конструктор с initializer_list через преобразование к float</span></code></pre></div>\n<p>Более того, компилятор настолько сильно хочет использовать <code class=\"language-text\">initializer_list</code>, что даже идеально подходящие другие конструкторы ему не помеха:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">class <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  <span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span>int i<span class=\"token punctuation\">,</span> bool b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span>int i<span class=\"token punctuation\">,</span> double d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>initializer_list<span class=\"token operator\">&lt;</span>bool<span class=\"token operator\">></span> il<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nWidget w<span class=\"token punctuation\">{</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5.0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// ошибка компиляции!</span></code></pre></div>\n<p>Компилятор, несмотря на то, что есть конструктор, принимающий <strong>int</strong> и <strong>double</strong>, опять попытался использовать конструктор с <code class=\"language-text\">initializer_list</code> и не смог, потому что для этого требуется сужающее приведение <strong>int</strong> и <strong>double</strong> к <strong>bool</strong>, а сужающие приведения запрещены в инициализации через <strong>{}</strong>.</p>\n<p>Однако и из этого правила есть исключение - если есть дефолтный конструктор и мы вызываем инициализацию без параметров, то дефолтный конструктор имеет высший приоритет над конструктором с <code class=\"language-text\">initializer_list</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\"> class <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  <span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>initializer_list<span class=\"token operator\">&lt;</span>int<span class=\"token operator\">></span> il<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nWidget w1<span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// дефолтный конструктор</span>\nWidget w2<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// дефолтный конструктор</span>\nWidget <span class=\"token function\">w3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// most vexing parse! объявляет функцию</span>\n\nWidget <span class=\"token function\">w4</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// только так мы в этом случае можем вызвать конструктор с initializer_list</span>\nWidget w5<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// ну или так</span></code></pre></div>\n<p>Один из выводов из всего этого - если вы автор библиотеки, то не стоит добавлять конструктор, принимающий <code class=\"language-text\">initializer_list</code>, так как тогда возможно клиенты не смогут использовать ваши остальные конструкторы.</p>\n<h2>Используйте nullptr вместо 0 и NULL</h2>\n<p>В С++98 использование 0 и NULL приводило к тому, что перегрузки, принимающие указатель, могли не вызываться:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">void <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>int<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nvoid <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>bool<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nvoid <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>void<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t\t<span class=\"token comment\">// f(int)</span>\n<span class=\"token function\">f</span><span class=\"token punctuation\">(</span>NULL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// могло не скомпилиться, но если компилилось, то вызывало f(int)</span></code></pre></div>\n<p>Все потому, что 0 - это целочисленный тип и NULL часто был определен тоже как численный тип.</p>\n<p>Преимущество <strong>nullptr</strong> - он не может быть интерпретирован как численный тип, только как указатель. Тип <strong>nullptr</strong> - <code class=\"language-text\">std::nullptr_t</code>. ЭТот тип неявно приводит к себе указатели всех типов, поэтому <strong>nullptr</strong> - универсальный указатель.</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\"><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>nullptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// f(void*)</span></code></pre></div>\n<h2>Используйте alias вместо typedef</h2>\n<p>В С++98 были <strong>typedef</strong>:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">typedef\n     std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>unique_ptr<span class=\"token operator\">&lt;</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>unordered_map<span class=\"token operator\">&lt;</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string<span class=\"token punctuation\">,</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string<span class=\"token operator\">></span><span class=\"token operator\">></span>\n     UPtrMapSS<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Они устарели, когда в C++11 появились алиасы:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\"> using UPtrMapSS <span class=\"token operator\">=</span>\n     std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>unique_ptr<span class=\"token operator\">&lt;</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>unordered_map<span class=\"token operator\">&lt;</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string<span class=\"token punctuation\">,</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string<span class=\"token operator\">></span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Еще один пример, демонстрирующий повышенную читаемость алиасов по сравнению с тайпдефом:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">typedef void <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>FP<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>int<span class=\"token punctuation\">,</span> const std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nusing FP <span class=\"token operator\">=</span> void <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>int<span class=\"token punctuation\">,</span> const std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Основное преимущество - алиасы могут быть шаблонизированы, а тайпдефы - нет. В С++98 приходилось извращаться и определять тайпдефы внутри шаблонизированных структур:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\nstruct MyAllocList <span class=\"token punctuation\">{</span> \n\ttypedef std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>list<span class=\"token operator\">&lt;</span>T<span class=\"token punctuation\">,</span> MyAlloc<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">></span> type<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nMyAllocList<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>type lw<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Если же после этого мы захотим использовать этот шаблно внутри другого шаблонизированного класса, то придется писать <code class=\"language-text\">typename</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\nclass <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">{</span>\nprivate<span class=\"token punctuation\">:</span>\n\ttypename MyAllocList<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>type list<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Кстати, при использовании type traits так и приходится писать, так как они были реализованы с использованием тайпдефов, а не алиасов, несмотря на то, что были введены в C++11. В С++14 признали эту ошибку и для каждого класса <code class=\"language-text\">std::transformation&lt;T&gt;::type</code> теперь есть соответствующий <code class=\"language-text\">std::transformation_t&lt;T&gt;</code>, реализованный через алиасы.</p>\n<p>Так вот, в С++11 есть алиасы и использовать их мы можем так:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\nusing MyAllocList <span class=\"token operator\">=</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>list<span class=\"token operator\">&lt;</span>T<span class=\"token punctuation\">,</span> MyAlloc<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\nMyAllocList<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span> lw<span class=\"token punctuation\">;</span></code></pre></div>\n<h2>Используйте scoped enums вместо unscoped enums</h2>\n<p>Есть такое правило, что имя, объявленное внутри фигурных скобок, видно только внутри области, ограниченной этими скобками. Это правило соблюдается всегда, кроме енумов в C++98.</p>\n<p>Поэтому енумы в C++98 - unscoped enums:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">enum Color <span class=\"token punctuation\">{</span>red<span class=\"token punctuation\">,</span> black<span class=\"token punctuation\">,</span> white<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nauto white <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// ОШИБКА КОМПИЛЯЦИИ! white уже определен</span></code></pre></div>\n<p>В С++11 им на замену пришли scoped enums:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">enum class <span class=\"token class-name\">Color</span> <span class=\"token punctuation\">{</span>red<span class=\"token punctuation\">,</span> black<span class=\"token punctuation\">,</span> white<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nauto white <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// все норм</span>\nColor c <span class=\"token operator\">=</span> white<span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// ОШИБКА КОМПИЛЯЦИИ! нет имени white в текущем скоупе</span>\nColor c <span class=\"token operator\">=</span> Color<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>white<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// ok</span>\nauto c <span class=\"token operator\">=</span> Color<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>white<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// ok</span></code></pre></div>\n<p>Помимо ограниченной видимости, вторая причина, по которой стоит использовать scoped enums - более строгая типизация. Unscoped enums свободно неявно приводятся к целочисленным типам и типам с плавающей точкой:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">Color c <span class=\"token operator\">=</span> Color<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>red<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>c <span class=\"token operator\">&lt;</span> <span class=\"token number\">14.5</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\t<span class=\"token comment\">// ОШИБКА КОМПИЛЯЦИИ</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>static_vast<span class=\"token operator\">&lt;</span>double<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">14.5</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\t\t<span class=\"token comment\">// OK</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>И еще одно преимущество - при использовании scoped enums не нужно перекомпиливать клиентов енума при добавлении в него нового значения. А с unscoped enums - нужно.</p>\n<p>Дефолтный тип для scoped enums - int, для unscoped enums - нет дефолтного.</p>\n<h2>Используйте deleted функции вместо private undefined</h2>\n<p>В С++98 когда нужно запретить вызов какой-либо функции (обычно конструктора присваивания или копирования), то определяют ее как private и просто не пишут ее реализацию:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template <span class=\"token operator\">&lt;</span>class <span class=\"token class-name\">charT</span><span class=\"token punctuation\">,</span> class <span class=\"token class-name\">traits</span> <span class=\"token operator\">=</span> char_traits<span class=\"token operator\">&lt;</span>charT<span class=\"token operator\">></span> <span class=\"token operator\">></span>\n   class <span class=\"token class-name\">basic_ios</span> <span class=\"token punctuation\">:</span> public ios_base <span class=\"token punctuation\">{</span>\n   public<span class=\"token punctuation\">:</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\nprivate<span class=\"token punctuation\">:</span>\n     <span class=\"token function\">basic_ios</span><span class=\"token punctuation\">(</span>const basic_ios<span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>            <span class=\"token comment\">// not defined</span>\n     basic_ios<span class=\"token operator\">&amp;</span> operator<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>const basic_ios<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// not defined</span>\n   <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>private</strong> гарантирует, что внешний код не имеет доступ к этим функциям. Отсутствие реализации для таких функций гарантирует, что даже если какой-то какой-то код, имеющий к ним доступ, попытается их вызвать, он получит ошибку на этапе линковки.</p>\n<p>В C++11 такие функции определяются как удаленные:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template <span class=\"token operator\">&lt;</span>class <span class=\"token class-name\">charT</span><span class=\"token punctuation\">,</span> class <span class=\"token class-name\">traits</span> <span class=\"token operator\">=</span> char_traits<span class=\"token operator\">&lt;</span>charT<span class=\"token operator\">></span> <span class=\"token operator\">></span> \nclass <span class=\"token class-name\">basic_ios</span> <span class=\"token punctuation\">:</span> public ios_base <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token function\">basic_ios</span><span class=\"token punctuation\">(</span>const basic_ios<span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> delete<span class=\"token punctuation\">;</span> \n\tbasic_ios<span class=\"token operator\">&amp;</span> operator<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>const basic_ios<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> delete<span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Удаленные функции никак не могут быть использованы и такие попытки приведт к ошибкам на этапе компиляции.</p>\n<p>А еще, используя удаленные функции, можно запретить использование шаблонных функций с определенными типами:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\nvoid <span class=\"token function\">processPointer</span><span class=\"token punctuation\">(</span>T<span class=\"token operator\">*</span> ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ntemplate<span class=\"token operator\">&lt;</span><span class=\"token operator\">></span>\nvoid processPointer<span class=\"token operator\">&lt;</span>void<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>void<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> delete<span class=\"token punctuation\">;</span>\ntemplate<span class=\"token operator\">&lt;</span><span class=\"token operator\">></span>\nvoid processPointer<span class=\"token operator\">&lt;</span>char<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>char<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> delete<span class=\"token punctuation\">;</span>\ntemplate<span class=\"token operator\">&lt;</span><span class=\"token operator\">></span>\nvoid processPointer<span class=\"token operator\">&lt;</span>const void<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>const void<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> delete<span class=\"token punctuation\">;</span>\ntemplate<span class=\"token operator\">&lt;</span><span class=\"token operator\">></span>\nvoid processPointer<span class=\"token operator\">&lt;</span>const char<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>const char<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> delete<span class=\"token punctuation\">;</span></code></pre></div>\n<h2>Declare overriding functions override.</h2>\n<p>Для переопределения виртуальной функции должны совпадать: названия функций, типы аргументов, константность функций, квалификаторы ссылок.</p>\n<p>Должны быть совместимыми: возвращаемый тип и exception specification.</p>\n<p>Помимо этого, конечно же, метоб в базовом классе должен быть обозначен как virtual.</p>\n<p>ПРИМЕЧАНИЕ: Квалификаторы ссылок это такие вот штуки:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">class <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  void <span class=\"token function\">doWork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// может быть вызвана, только когда *this - lvalue</span>\n  void <span class=\"token function\">doWork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// *this - rvalue</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nw<span class=\"token punctuation\">.</span><span class=\"token function\">doWork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// вызовется первый</span>\n\nmakeWidget<span class=\"token punctuation\">.</span><span class=\"token function\">doWork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// вызовется второй</span></code></pre></div>\n<p>Так вот, все эти ограничения означают, что очень легко допустить ошибку при использовании виртуальных функций. Если ограничения не соблюдены, то код скомпилиться, но в наследнике вместо переопределения будет создана новая функция.</p>\n<p>В C++11 для решения этой проблемы появилось ключевое слово <code class=\"language-text\">override</code>.</p>\n<h2>Prefer const_terators to iterators</h2>\n<p>В C++11 добавились функции <code class=\"language-text\">cbegin</code> и <code class=\"language-text\">cend</code>, которые возвращают <code class=\"language-text\">const_iterator</code> даже для не-константных контейнеров.</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>vector<span class=\"token operator\">&lt;</span>int<span class=\"token operator\">></span> values<span class=\"token punctuation\">;</span>\nauto it <span class=\"token operator\">=</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>values<span class=\"token punctuation\">.</span><span class=\"token function\">cbegin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> values<span class=\"token punctuation\">.</span><span class=\"token function\">cend</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1983</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nvalues<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">,</span> <span class=\"token number\">1998</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Единственный недостаток у таких функций - в C++11 у них нет non-member версий, как у <code class=\"language-text\">begin</code> и <code class=\"language-text\">end</code>. В С++14 - уже есть.</p>\n<p>В generic-коде лучше использовать non-member версии.</p>\n<h2>Declare functions noexcept if they won't emit exceptions</h2>\n<ul>\n<li>вызывающие функции могут проверять наличие <code class=\"language-text\">noexcept</code> у функции и использовать более безопасный/производительный код</li>\n</ul>\n<p>Например, при <code class=\"language-text\">push_back</code> в <code class=\"language-text\">std::vector</code>, если длина превышает вместимость, то создается новый вектор побольше и все элементы копируются туда. Затем, когда все успешно скопировались, старый вектор уничтожается. Это нужно для защиты от исключений - если на копировании N-го элемента возникнет исключение, то старый вектор останется неизменным.</p>\n<p>Но если имеется конструктор перемещения и он помечен как <code class=\"language-text\">noexcept</code>, то в этом алгоритме может быть использовано перемещение вместо копирования, ведь мы точно знаем, что исключения на N-м элементе возникнуть не может.</p>\n<ul>\n<li>компилятор генерирует более производительный код, потому что <strong>может</strong> не генерировать код разматывания стека при исключении для функций, помеченных как <code class=\"language-text\">noexcept</code>.</li>\n</ul>\n<p>Вторая причина очень важна. Оптимизаторам не нужно хранить где-то заранее размотанный стэк на случай исключения, не нужно гарантировать, что объекты в <code class=\"language-text\">noexcept</code> функции будут уничтожены в обратном порядке создания в случае исключения.</p>\n<p>Однако в этом случае, если в функции произойдет исключение, и оно покинет функцию, то моментально будет вызван <code class=\"language-text\">std::terminate</code></p>\n<h3>Условный noexcept</h3>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template <span class=\"token operator\">&lt;</span>class <span class=\"token class-name\">T</span><span class=\"token punctuation\">,</span> size_t N<span class=\"token operator\">></span>\nvoid <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>T <span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n          T <span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token function\">noexcept</span><span class=\"token punctuation\">(</span><span class=\"token function\">noexcept</span><span class=\"token punctuation\">(</span><span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>a<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ntemplate <span class=\"token operator\">&lt;</span>class <span class=\"token class-name\">T1</span><span class=\"token punctuation\">,</span> class <span class=\"token class-name\">T2</span><span class=\"token operator\">></span>\nstruct pair <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  void <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>pair<span class=\"token operator\">&amp;</span> p<span class=\"token punctuation\">)</span> <span class=\"token function\">noexcept</span><span class=\"token punctuation\">(</span><span class=\"token function\">noexcept</span><span class=\"token punctuation\">(</span><span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>first<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">noexcept</span><span class=\"token punctuation\">(</span><span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>second<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Здесь noexcept-ность нашей функции обмена зависит от noexcept-ности обмена внутренних элементов - первого элемента массива, либо обоих элементов структуры pair.</p>\n<h2>Use constexpr whenever possible</h2>\n<h3>constexpr objects</h3>\n<p>Когда применяется к объектам, <code class=\"language-text\">constexpr</code> определяет значение, которое не только константно, но еще и известно во время компиляции.</p>\n<p>ТАкие значения могут быть помещены в read-only память. Могут быть применены там, где требуется <em>integral constant expression</em>, например, в качестве длин массивов, аргументов шаблонов, значений енумов, спецификаторов выравнивания.</p>\n<h3>constexpr functions</h3>\n<p>Когда применяется к функциям, то все сложнее. Такие функции возвращают константы времени компиляции только когда их аргументами являются константы времени компиляции. В остальных случаях они возвращают обычные значения и работают в рантайме.</p>\n<p>Преимущество в том, что не нужны 2 разных функции, одна из которых работает в компайл-тайме, а другая в рантайме.</p>\n<p>Ограничения constexpr-функции:</p>\n<ul>\n<li>В C++11 должна содержать не больше одного выражения. Однако оно может быть сколь угодно сложным. Вместо if-else можно использовать \"?:\", а вместо циклов - рекурсию. В С++14 такого ограничения нет.</li>\n<li>Может принимать и возвращать только типы-литералы, то есть типы, чьи значения определены на этапе компиляции. В C++11 это все типы, кроме <code class=\"language-text\">void</code>. Пользовательские типы могут быть литералами, когда коструктор и все используемые функции определены как <code class=\"language-text\">constexpr</code>.</li>\n</ul>\n<h2>Make const member functions thread safe</h2>\n<p>Члены класса, помеченные, как <code class=\"language-text\">mutable</code>, могут быть изменены const-функциями. В этом случае только разработчик ответственнен за то, что изменение mutable-поля не разрушит константность функции.</p>\n<p>mutable-поля могут быть полезны, например, при реализации кэширования в константной функции.</p>\n<p>Пользователь const-функции не знает, используются ли внутри mutable переменные, поэтому он всегда предполагает, что такая функция потокобезопасна. </p>\n<p>Поэтому при использовании mutable-полей, нужно обеспечить потокобезопасность для своей функции, например, через <code class=\"language-text\">std::atomic</code>, или мютексы, если таких полей несколько. </p>\n<p>При использовании мютекса, конечно, его придется тоже сделать <code class=\"language-text\">mutable</code>.</p>\n<p>Пример:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">class <span class=\"token class-name\">Point</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  double <span class=\"token function\">distanceFromOrigin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> const noexcept\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">++</span>callCount<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">sqrt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">*</span> x<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>y <span class=\"token operator\">*</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\nprivate<span class=\"token punctuation\">:</span>\n     mutable std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>atomic<span class=\"token operator\">&lt;</span>unsigned<span class=\"token operator\">></span> callCount<span class=\"token punctuation\">{</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n     double x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>Understand special member function generation</h2>\n<p>В C++98 автогененерировались:</p>\n<ul>\n<li>дефолтный конструктор: <code class=\"language-text\">Widget()</code></li>\n<li>деструктор: <code class=\"language-text\">~Widget()</code></li>\n<li>конструктор копирования: <code class=\"language-text\">Widget(const Widget&amp;)</code></li>\n<li>оператор присваивания копии: <code class=\"language-text\">Widget&amp; operator=(const Widget&amp;)</code></li>\n</ul>\n<p>Они генерировались только, если реально использовались в коде. Все эти фунции генерируются как <code class=\"language-text\">public inline</code>. Все, кроме деструктора - не виртуальные. Деструктор генерируется как виртуальный, когда это деструктор в наследованном классе, а в родительском он виртуальный.</p>\n<p>В С++11 в списку автогенерируемых функций добавились:</p>\n<ul>\n<li>конструктор перемещения: <code class=\"language-text\">Widget(Widget&amp;&amp; rhs)</code></li>\n<li>оператор присваивания перемещением: <code class=\"language-text\">Widget&amp; operator=(Widget&amp;&amp; rhs)</code></li>\n</ul>\n<p>Эти операции так же генерируются только, если нужны, и их дефолтные реализации осуществляют memberwise move не-статических членов класса. То есть конструктор перемещения вызывает конструктор перемещения для всхе не-статических членов, передавая туда соответствующие члены из <code class=\"language-text\">rhs</code>, а оператор присваивания перемещением аналогичным образом присваивает членам <code class=\"language-text\">lhs</code> соответствующие члены <code class=\"language-text\">rhs</code>.</p>\n<p>Конструктор перемещения также конструирует перемещением все члены базовых классов, а оператор присваивания перемещением присваивает их перемещением.</p>\n<p>Когда речь идет о конструировании перемещением, или присваивании перемением, то это еще не значит, что перемещение обязательно произойдет. На самом деле будет выполнен \"запрос перемещения\", потому что не-перемещаемые типы будут просто скопированы. Внутри каждого конструктора перемещения и присваивания перемещением все равно находится обычный <code class=\"language-text\">std::move</code>, который полагается на наличие соответствующих функций.</p>\n<h3>Генерация копирования и перемещения</h3>\n<p><strong>Две операции копирования генерируются независимо друг от друга.</strong> То есть, если пользователь объявил конструктор копирования, но не объявил присваивание копированием, а потом написал код, который требует присваивание копированием, то оператор присваивания копированием будет сгенерирован.</p>\n<p><strong>Операции перемещения, напротив, генерируются зависимо.</strong> Если пользователь определил одну из них, это не дает компилятору сгенерировать другую. Мотивация такова - если пользовать определил, например, конструктор перемещением, значит, есть что-то, что его не устраивает в дефолтной memberwise-реализации перемещения. А значит оператор присваивания перемещением тоже будет сгенерирован неправильно.</p>\n<p>Более того, <strong>операции перемещения не генерируются, если определена хотя бы одна операция копирования</strong>. Мотивация такая же - если явно определена операция копирования, значит дефолтная не устраивает, значит дефолтная memberwise-реализация перемещения, скорее всего, тоже будет ошибочна.</p>\n<p>В обратную сторону работает точно так же. <strong>Операции копирования не генерируются, если определена хотя бы одна операция перемещения</strong>.</p>\n<p>Помимо этого, <strong>операции перемещения не генерируются, если определен деструктор</strong>, потому что наличие деструктора обычно говорит о том, что здесь происходит какой-то менеджмент ресурсов, а в этом случае при копировании нужно тоже что-то с ресурсом сделать. См. Правило Трех.</p>\n<p>Итак, операции перемещения генерируются только когда в классе соблюдаются следующие правила:</p>\n<ul>\n<li>Не определена ни одна операция копирования</li>\n<li>Не определена ни одна операция перемещения</li>\n<li>Не определен деструктор</li>\n</ul>\n<p>Последнее правило может привести к серьезному ухудшению производительности при простом добавлении деструктора в класс, так как операции перемещения перестанут генерироваться и класс будет всегда копироваться. Поэтому при указании деструктора нужно всегда обязательно добавлять операции перемещения и копирования, даже если они реализуются через <code class=\"language-text\">=default</code>.</p>\n<p>Итак, окончательный список автогенерируемых функций таков:</p>\n<table>\n<thead>\n<tr>\n<th>Операция</th>\n<th>Сигнатура</th>\n<th>Правило  автогенерации</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Дефолтный конструктор</td>\n<td><code class=\"language-text\">Widget()</code></td>\n<td>Только если в классе не определено никаких конструкторов</td>\n</tr>\n<tr>\n<td>Деструктор</td>\n<td><code class=\"language-text\">~Widget()</code></td>\n<td>По умолчанию <code class=\"language-text\">noexcept</code>. Виртуальный, если деструктор родительского класса тоже виртуальный</td>\n</tr>\n<tr>\n<td>Конструктор копирования</td>\n<td><code class=\"language-text\">Widget(const Widget&amp;)</code></td>\n<td>memberwise-копирование не-статических членов. Только, если не определен явно. Удаляется, если определена операция перемещения. Не рекомендуется использовать автосгенерируемый, если в классе есть оператор присваивания копированием, или деструктор.</td>\n</tr>\n<tr>\n<td>Оператор присваивания копированием</td>\n<td><code class=\"language-text\">Widget&amp; operator=(const Widget&amp;)</code></td>\n<td>memberwise-копирование не-статических членов. Только если не определен явно. Удаляется, если определена операция перемещения. Не рекомендуется использовать автосгенерируемый, если в классе есть конструктор копирования, или деструктор.</td>\n</tr>\n<tr>\n<td>Конструктор перемещения</td>\n<td><code class=\"language-text\">Widget(Widget&amp;&amp; rhs</code>)</td>\n<td>memberwise-перемещение не-статических членов. Только если в классе не определена ни одна операция копирования, перемещения, или деструктор.</td>\n</tr>\n<tr>\n<td>Оператор присваивания перемещением</td>\n<td><code class=\"language-text\">Widget&amp; operator=(Widget&amp;&amp; rhs)</code></td>\n<td>Аналогично конструктору перемещения</td>\n</tr>\n</tbody>\n</table>\n<h2>Use std::unique_ptr for exclusive-ownership resource management</h2>\n<p>Имеют такой же размер, как и сырые указатели (если не используются кастомные делетеры). Для большинства операций генерируют те же инструкции.</p>\n<p>Перемещение <code class=\"language-text\">std::unique_ptr</code> перемещает владение от пойнтера-источника к пойнтеру-назначению. Пойнтер-источник при этом выставляется в null. </p>\n<p>Копирование <code class=\"language-text\">std::unique_ptr</code> запрещено.</p>\n<p>Типичный кейс - тип возвращаемого значения для фабричной функции.</p>\n<p>Может быть задан специфичный делетер:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">auto delInvmt <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>Investment<span class=\"token operator\">*</span> pInvestment<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">makeLogEntry</span><span class=\"token punctuation\">(</span>pInvestment<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  delete pInvestment<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nstd<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>unique_ptr<span class=\"token operator\">&lt;</span>Investment<span class=\"token punctuation\">,</span> <span class=\"token function\">decltype</span><span class=\"token punctuation\">(</span>delInvmt<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> <span class=\"token function\">pInv</span><span class=\"token punctuation\">(</span>nullptr<span class=\"token punctuation\">,</span> delInvmt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Кастомные делетеры увеличивают размер пойнтера. </p>\n<p>Если делетер указан в виде указателя на функцию, то размер пойнтера увеличивается с 1 слова до 2. </p>\n<p>Если же это функтор, то дельта размера зависит от того, сколько состояния хранится в функторе. Функторы без состояния (например, лямбды без захваченных переменных) не увеличивают размер вообще. </p>\n<p>Поэтому когда кастомный делетер может быть реализован как функция, либо как лямбда без состояния, лучше выбирать лямбду.</p>\n<h3>std::unique_ptr&#x3C;T[]></h3>\n<p>Для массивов используется вторая форма <code class=\"language-text\">unique_ptr</code>. Благодаря этому, всегда однозначно известно, на какой тип сущности указывает пойнтер. </p>\n<p>Для сингл-формы не определен оператор индексации, а мульти-форма не имеет оператора разыменования.</p>\n<h3>std::unique<em>ptr -> std::shared</em>ptr</h3>\n<p><code class=\"language-text\">std::unique_ptr</code> легко и эффективно конвертируется в <code class=\"language-text\">std::shared_ptr</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>shared_ptr<span class=\"token operator\">&lt;</span>Investment<span class=\"token operator\">></span> sp <span class=\"token operator\">=</span> <span class=\"token function\">makeInvestment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nstd<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>unique_ptr<span class=\"token operator\">&lt;</span>Investment<span class=\"token operator\">></span> <span class=\"token function\">makeInvestment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Поэтому клиент фабрики может сам решать, какая модель владения ему нужна.</p>\n<h2>Use std::shared_ptr for shared-ownership resource management</h2>\n<p>У каждого <code class=\"language-text\">shared_ptr</code> есть счетчик ссылок. Это конечно влияет на производительность:</p>\n<ul>\n<li>размер <code class=\"language-text\">std::shared_ptr</code> в 2 раза больше размера сырого указателя</li>\n<li>память для счетчика ссылок аллоцируется динамически. Объект, на который ссылается указатель, ничего о счетчике не знает, поэтому счетчик должен храниться вне его. Использование <code class=\"language-text\">std::make_shared</code> избегает оверхеда динамической аллокации.</li>\n<li>инкременты и декременты счетчика ссылок атомарны, потому что могут быть одновременные читатели и писатели в разных потоках. Поэтому операции увеличения и уменьшения сетчика ссылок довольно медленные.</li>\n</ul>\n<p>При перемещении <code class=\"language-text\">std::shared_ptr</code> счетчик ссылок остается неизменным, поэтому перемещение таких указателей быстрее, чем копирование.</p>\n<p><code class=\"language-text\">std::shared_ptr</code> тоже поддерживает кастомные делетеры, но у них тип делетера не является частью типа указателя:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">auto loggingDel <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>Widget <span class=\"token operator\">*</span>pw<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">}</span>\n\nstd<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>shared_ptr<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span> <span class=\"token function\">spw</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Widget</span><span class=\"token punctuation\">,</span> loggingDel<span class=\"token punctuation\">)</span></code></pre></div>\n<p>Благодаря этому указатели с разными типами делетеров могут быть помещены в одну коллекцию, переданы в одну и ту же функцию и быть приводимы один к другому.</p>\n<p>Еще одно отличие от <code class=\"language-text\">std::unique_ptr</code> - указание кастомного делетера не увеличивает размер указателя. Размер всегда равняется двум обычным указателям. На самом деле, память под делетер выделяется, но она просто не является частью указателя. Дело в том, что второй указатель в <code class=\"language-text\">std::shared_ptr</code> - указатель не просто на счетчик ссылок, а на так называетмый управляющий блок - <em>control block</em>. Такой блок есть для каждого объекта, управляемого <code class=\"language-text\">std::shared_ptr</code>. Этот блок содержит:</p>\n<ul>\n<li>счетчик ссылок</li>\n<li>копию кастомного делетера</li>\n<li>копию кастомного аллокатора, если указан</li>\n<li>вторичный счетчик ссылок, используемый для <code class=\"language-text\">std::weak_ptr</code>.</li>\n</ul>\n<p>Управляющий блок создается функцией, которая создает первый <code class=\"language-text\">std::shared_ptr</code> на объект. Но так как в момент создания невозможно узнать, является ли этот указатель первым, то происходит следующее:</p>\n<ul>\n<li><code class=\"language-text\">std::make_shared</code> <strong>всегда</strong> создает управляющий блок.</li>\n<li>управляющий блок создается, когда <code class=\"language-text\">std::shared_ptr</code> конструируется из <code class=\"language-text\">std::unique_ptr</code> или <code class=\"language-text\">std::auto_ptr</code>. Это возможно, потому что эти указатели не используют контрольных блоков, так что созданный точно будет первым.</li>\n<li>управляющий блок создается, когда <code class=\"language-text\">std::shared_ptr</code> создается из сырого указателя.</li>\n</ul>\n<p>Получается, что управляющий блок не создается, когда <code class=\"language-text\">std::shared_ptr</code> создается из другого <code class=\"language-text\">std::shared_ptr</code> или <code class=\"language-text\">std::weak_ptr</code>.</p>\n<p>Следствием этих правил является то, что если мы создаем больше одного <code class=\"language-text\">std::shared_ptr</code> из одного сырого указателя, то получаем гарантированное undefined behavior, потому что объект будет иметь несколько контрольных блоков, что значит несколько счетчиков ссылок, что значит он будет уничтожен несколько раз.</p>\n<p>Отсюда следует правило: не передавать сырые указатели в конструктор <code class=\"language-text\">std::shared_ptr</code>. Вместо этого следует использовать <code class=\"language-text\">std::make_shared</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>shared_ptr<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span> spw1 <span class=\"token operator\">=</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>make_shared<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Однако это невозможно, если нужно указать кастомый делетер. В таком случае сырой указатель можно передать, но нужно удостовериться, что он передается как <em>rvalue</em> и не сохраняется ни в какую переменную, что увеличило бы риск повторного создания <code class=\"language-text\">std::shared_ptr</code> из этой переменной:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>shared_ptr<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span> <span class=\"token function\">spw2</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Widget</span><span class=\"token punctuation\">,</span> loggingDel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>shared<em>from</em>this</h3>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>vector<span class=\"token operator\">&lt;</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>shared_ptr<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span><span class=\"token operator\">></span> processedWidgets<span class=\"token punctuation\">;</span>\n\nclass <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  void <span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    processedWidgets<span class=\"token punctuation\">.</span><span class=\"token function\">emplace_back</span><span class=\"token punctuation\">(</span>this<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Это очень опасный код. Опасен он тем, что при вызове <code class=\"language-text\">emplace_back</code> в вектор кладется не <code class=\"language-text\">shared_ptr</code>, а сырой указатель<code class=\"language-text\">this</code>. Он будет приведен к <code class=\"language-text\">shared_ptr</code>, а значит, будет создан новый управляющий блок на <code class=\"language-text\">this</code>. Если есть еще какие-нибудь <code class=\"language-text\">std::shared_ptr</code>, ссылающиеся на наш объект, то рано или поздно это приведет к undefined behavior.</p>\n<p>Выход - использовать <code class=\"language-text\">std::enable_shared_from_this</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>vector<span class=\"token operator\">&lt;</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>shared_ptr<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span><span class=\"token operator\">></span> processedWidgets<span class=\"token punctuation\">;</span>\n\nclass <span class=\"token class-name\">Widget</span><span class=\"token punctuation\">:</span> public std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>enable_shared_from_this<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  void <span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    processedWidgets<span class=\"token punctuation\">.</span><span class=\"token function\">emplace_back</span><span class=\"token punctuation\">(</span><span class=\"token function\">shared_from_this</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Функция <code class=\"language-text\">shared_from_this</code> обращается к управляющему блоку, ассоциированному с текущим объектом и выбросит исключение, если такового нет. Поэтому обычно наследники <code class=\"language-text\">std::enable_shared_from_this</code> закрывают конструктор и делают фабричную функцию, возвращающую <code class=\"language-text\">std::shared_ptr</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">class <span class=\"token class-name\">Widget</span><span class=\"token punctuation\">:</span> public std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>enable_shared_from_this<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  template<span class=\"token operator\">&lt;</span>typename<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> Ts<span class=\"token operator\">></span>\n  static std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>shared_ptr<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span> <span class=\"token function\">create</span><span class=\"token punctuation\">(</span>Ts<span class=\"token operator\">&amp;&amp;</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  void <span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\nprivate<span class=\"token punctuation\">:</span>\n  <span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>std::shared_ptr&#x3C;T[]></h3>\n<p>Перегрузки для массивов - нет, в отличие от <code class=\"language-text\">std::unique_ptr</code>. И не стоит пытаться передавать туда массив. Во-первых, <code class=\"language-text\">std::shared_ptr</code> не поддерживает оператор <strong>[]</strong>. Во-вторых, <code class=\"language-text\">std::shared_ptr</code> поддерживает конвертацию devived-to-base, которая работает для отдельных объектов, но плохо будет работать с массивами. </p>\n<h2>Use std::weak<em>ptr for std::shared</em>ptr-like pointers that can dangle</h2>\n<p>Иногда бывает нужно использовать указатель, который ведет тебя как <code class=\"language-text\">shared_ptr</code>, но при этом не участвует в подсчете ссылок. ТАкой указатель есть - это <code class=\"language-text\">std::weak_ptr</code>. Он знает, когда он указывает в пустоту, то есть когда объект, на который он указывает, больше не существует.</p>\n<p>На самом деле <code class=\"language-text\">std::weak_ptr</code> не является умным указателем, это улучшение над <code class=\"language-text\">std::shared_ptr</code>. Поэтому <code class=\"language-text\">std::weak_ptr</code> нельзя разыменовать и нельзя проверить его на равенство null.</p>\n<p><code class=\"language-text\">std::weak_ptr</code> обычно конструируются из <code class=\"language-text\">std::shared_ptr</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">auto spw <span class=\"token operator\">=</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>make_shared<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nstd<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>weak_ptr<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span> <span class=\"token function\">wpw</span><span class=\"token punctuation\">(</span>spw<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nspw <span class=\"token operator\">=</span> nullptr<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>wpw<span class=\"token punctuation\">.</span><span class=\"token function\">expired</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"weak_ptr is dangling now\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Операции разыменования нет по причине того, что нельзя разделять операцию проверки на <code class=\"language-text\">expired</code> и операцию разыменования - ведь объект может уничтожиться между этими вызовами. Поэтому есть атомарная операция, объединяющая эти две:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>shared_ptr<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span> spw1 <span class=\"token operator\">=</span> wpw<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nauto spw2 <span class=\"token operator\">=</span> wpw<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>spw2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Если объект заэкспайрился, то <code class=\"language-text\">lock()</code> вернет <em>null</em>.</p>\n<p>Второй вариант - создать <code class=\"language-text\">shared_ptr</code> из <code class=\"language-text\">weak_ptr</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>shared_ptr<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span> <span class=\"token function\">spw3</span><span class=\"token punctuation\">(</span>wpw<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">std::weak_ptr</code> полезен при реализации кэширования - в этом случае кэширующий указатель стоит реализовать в виде <code class=\"language-text\">weak_ptr</code>.</p>\n<p>Еще его используют при реализации паттерна Observer. В нем наблюдатели держат копию субъекта таким <code class=\"language-text\">std::weak_ptr</code>, чтобы не расширять его лайфтайм.</p>\n<p>Ну и наконец третий кейс - циклические ссылки. При использовании <code class=\"language-text\">shared_ptr</code> мы получили бы утечку памяти, а если одну из ссылок сделать <code class=\"language-text\">weak_ptr</code>, то все хорошо.</p>\n<p>Размер у <code class=\"language-text\">std::weak_ptr</code> - такой же, как у <code class=\"language-text\">shared_ptr</code>, они используют те же управляющие блоки. Операции создания, уничтожения и присваивания изменяют вторичный счетчик ссылок в управляющем блоке.</p>\n<h2>Prefer std::make<em>unique and std::make</em>shared to direct use of new</h2>\n<p>Рассмотрим код:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\"><span class=\"token function\">processWidget</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>shared_ptr<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Widget</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">computePriority</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Как ни странно, этот код может привести к утечке памяти. Это происходит, если операции располагаются при компиляции следующим образом:</p>\n<ol>\n<li><code class=\"language-text\">new Widget()</code></li>\n<li><code class=\"language-text\">computePriority()</code></li>\n<li><code class=\"language-text\">std::shared_ptr()</code></li>\n</ol>\n<p>Если на 2 шаге наша функция выстрелит исключение, то мы получим зависший <code class=\"language-text\">new Widget</code>, на который никто не указывает - получили утечку.</p>\n<p>Другая причина - эффективность. Посмотрим на код:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>shared_ptr<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span> <span class=\"token function\">spw</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Widget</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Здесь производится не одна, а две динамических аллокации. Сначала создается <code class=\"language-text\">Widget</code>, а потом управляющий блок для него.</p>\n<p>Если же мы используем <code class=\"language-text\">make_shared</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">auto spw <span class=\"token operator\">=</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>make_shared<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>то осуществляется лишь одна аллокация, потому что <code class=\"language-text\">make_shared</code> аллоцирует один кусок памяти и для <code class=\"language-text\">Widget</code> и для его управляющего блока. Помимо того, уменьшается и размер программы, потому что становится меньше инструкций аллоцирования.</p>\n<h3>Ограничения</h3>\n<ul>\n<li><code class=\"language-text\">make</code>-функции не позволяют указать кастомный делетер</li>\n<li>есть традиционная путаница с <code class=\"language-text\">initializer_list</code>:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">auto upv <span class=\"token operator\">=</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>make_unique<span class=\"token operator\">&lt;</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>vector<span class=\"token operator\">&lt;</span>int<span class=\"token operator\">></span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Здесь будет создан вектор с 10 элементами, каждый из которых равен 20. А значит внутри для инициализации используется синтаксис с круглыми скобками, а не с фигурными.</p>\n<ul>\n<li>контрольный блок должен существовать, пока не будет уничтоен последний <code class=\"language-text\">shared_ptr</code>, ссылающийся на него <strong>И</strong> последний <code class=\"language-text\">weak_ptr</code>, ссылающийся на него. А так как <code class=\"language-text\">make_shared</code> аллоцирует один кусок памяти для контрольного блока и для объекта, то и память, выделенная для объекта не может быть освобождена, пока не уничтожится последний <code class=\"language-text\">std::weak_ptr</code>. То есть объект давно уничтожился, но он продолжает занимать память. В случае использования <code class=\"language-text\">new</code> память освободится, как только объект уничтожится, независимо от наличия <code class=\"language-text\">weak_ptr</code>, ссылающися на него.</li>\n</ul>\n<h2>When using the Pimpl Idiom, define special member function in the implementation file</h2>\n<p>Pimpl Idiom - техника, используемая для уменьшения времени билда. Члены класса заменяются на указатель на класс/структуру реализации, члены класса перемещаются в класс реализации и обращение к ним осуществляется через указатель.</p>\n<p>До применения:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\"><span class=\"token comment\">// Widget.h</span>\n\n#include <span class=\"token string\">\"Gadget.h\"</span>\n#include <span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span>\n#include <span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">></span>\n\nclass <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  <span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\nprivate<span class=\"token punctuation\">:</span>\n  std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string name<span class=\"token punctuation\">;</span>\n  std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>vector<span class=\"token operator\">&lt;</span>double<span class=\"token operator\">></span> data<span class=\"token punctuation\">;</span>\n  Gadget g1<span class=\"token punctuation\">,</span> g2<span class=\"token punctuation\">,</span> g3<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Клиенты <code class=\"language-text\">Widget</code> должны включать <code class=\"language-text\">&lt;string&gt;</code>, <code class=\"language-text\">&lt;vector&gt;</code> и <code class=\"language-text\">gadget.h</code>. Главная проблема здесь в том, что если заголовок <code class=\"language-text\">gadget.h</code> меняется, то все клиенты должны перестроиться.</p>\n<p>После применения для С++98:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\"><span class=\"token comment\">// Widget.h</span>\nclass <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  <span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token operator\">~</span><span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\nprivate<span class=\"token punctuation\">:</span>\n  struct Impl<span class=\"token punctuation\">;</span>\n  Impl <span class=\"token operator\">*</span>pImpl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Структура <code class=\"language-text\">Widget::Impl</code> определена где-то в другом файле. Здесь мы видим <em>неполный тип</em>. С таким типом можно сделать очень мало вещей, и одна из них - определение указателя.</p>\n<p>Вторая часть паттерна - динамическое создание и уничтожение <code class=\"language-text\">Widget::Impl</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\"><span class=\"token comment\">// Widget.cpp</span>\n\n#include <span class=\"token string\">\"Widget.h\"</span>\n#include <span class=\"token string\">\"Gadget.h\"</span>\n#include <span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span>\n#include <span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">></span>\n\nstruct Widget<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>Impl <span class=\"token punctuation\">{</span>\n  std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string name<span class=\"token punctuation\">;</span>\n  std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>vector<span class=\"token operator\">&lt;</span>double<span class=\"token operator\">></span> data<span class=\"token punctuation\">;</span>\n  Gadget g1<span class=\"token punctuation\">,</span> g2<span class=\"token punctuation\">,</span> g3<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nWidget<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token function\">pImpl</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Impl</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\nWidget<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token operator\">~</span><span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> delete pImpl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Зависимости от <code class=\"language-text\">std::string</code>, <code class=\"language-text\">std::vector</code> и <code class=\"language-text\">Gadget</code> остались, но они переехали из <code class=\"language-text\">Widget.h</code> в <code class=\"language-text\">Widget.cpp</code>.</p>\n<p>В С++11 можем использовать <code class=\"language-text\">std::unique_ptr</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\"><span class=\"token comment\">// Widget.h</span>\n\nclass <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span> \n  <span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\nprivate<span class=\"token punctuation\">:</span>\n  struct Impl<span class=\"token punctuation\">;</span>\n  std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>unique_ptr<span class=\"token operator\">&lt;</span>Impl<span class=\"token operator\">></span> pImpl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\"><span class=\"token comment\">// Widget.cpp</span>\n\n#include <span class=\"token string\">\"Widget.h\"</span>\n#include <span class=\"token string\">\"Gadget.h\"</span>\n#include <span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span>\n#include <span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">></span>\n\nstruct Widget<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>Impl <span class=\"token punctuation\">{</span>\n  std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string name<span class=\"token punctuation\">;</span>\n  std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>vector<span class=\"token operator\">&lt;</span>double<span class=\"token operator\">></span> data<span class=\"token punctuation\">;</span>\n  Gadget g1<span class=\"token punctuation\">,</span> g2<span class=\"token punctuation\">,</span> g3<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nWidget<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token function\">pImpl</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>make_unique<span class=\"token operator\">&lt;</span>Impl<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>Реализация <code class=\"language-text\">make_unique</code> в C++11 может выглядеть так:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template<span class=\"token operator\">&lt;</span>typename T<span class=\"token punctuation\">,</span> typename<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> Ts<span class=\"token operator\">></span>\nstd<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>unique_ptr<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">make_unique</span><span class=\"token punctuation\">(</span>Ts<span class=\"token operator\">&amp;&amp;</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> params<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>unique_ptr<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>forward<span class=\"token operator\">&lt;</span>Ts<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Understand std::move and std::forward</h2>\n<p><code class=\"language-text\">std::move</code> ничего не перемещает, а <code class=\"language-text\">std::forward</code> ничего не форвардит. В рантайме они не делают ничего, потому что даже не генерируют исполняемого кода. Все что они делают - конвертируют типы.</p>\n<p><code class=\"language-text\">std::move</code> приводит аргумент к <em>rvalue</em>.</p>\n<p><code class=\"language-text\">std::forward</code> тоже приводит к <em>rvalue</em>, но только если аргумент был инициализирован как <em>rvalue</em>.</p>\n<p>Пример реализации <code class=\"language-text\">std::move</code>: </p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\ntypename remove_reference<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>type<span class=\"token operator\">&amp;&amp;</span>\n<span class=\"token function\">move</span><span class=\"token punctuation\">(</span>T<span class=\"token operator\">&amp;&amp;</span> param<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  using ReturnType <span class=\"token operator\">=</span> typename remove_reference<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>type<span class=\"token operator\">&amp;&amp;</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> static_cast<span class=\"token operator\">&lt;</span>ReturnType<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Так как тип аргумента <code class=\"language-text\">T&amp;&amp;</code> может означать как <code class=\"language-text\">rvalue</code>, так и <code class=\"language-text\">lvalue</code>, то нам нужен тип <code class=\"language-text\">remove_reference</code>. Он снимает ссылку, если <code class=\"language-text\">T</code> - ссылочный тип и оставляет все как есть, если нет.</p>\n<p>Все <code class=\"language-text\">rvalue</code> передаются перемещением, поэтому после применения <code class=\"language-text\">std::move</code> на объекте, он сможет быть переданным куда-то путем перемещения, а не копирования.</p>\n<p>Однако не всегда <code class=\"language-text\">rvalue</code> передаются перемещением, а значит и <code class=\"language-text\">std::move</code> не всегда будет перемещать. Например, значение не будет перещеаться из константы:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">class <span class=\"token class-name\">Annotation</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  explicit <span class=\"token function\">Annotation</span><span class=\"token punctuation\">(</span>const std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string text<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">:</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">}</span>\nprivate<span class=\"token punctuation\">:</span>\n  std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string value<span class=\"token punctuation\">;</span>    \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>В примере выше text в value попадет путем копирования, так как он не может переместиться из константы.</p>\n<h2>Distinquish universal references from rvalue references</h2>\n<p><code class=\"language-text\">T&amp;&amp;</code> имеет два значения:</p>\n<ul>\n<li>rvalue reference</li>\n<li>universal reference</li>\n</ul>\n<p>Универсальная ссылка может быть привязана к rvalue, lvalue, константам, не-константам, volatile, не-volatile, и даже к <code class=\"language-text\">const volatile</code>-объектам.</p>\n<p>Обычно универсальные ссылки используются в типах шаблонов и в auto-декларациях:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\nvoid <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>T<span class=\"token operator\">&amp;&amp;</span> param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nauto<span class=\"token operator\">&amp;&amp;</span> var2 <span class=\"token operator\">=</span> var1<span class=\"token punctuation\">;</span></code></pre></div>\n<p>В обоих этих случаях присутствует вывод типа, поэтому используется универсальная ссылка. </p>\n<p>Если вывода типа (к которому относится <strong>&#x26;&#x26;</strong>) нет, то <code class=\"language-text\">T&amp;&amp;</code> означает ссылку на rvalue:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">void <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>Widget<span class=\"token operator\">&amp;&amp;</span> param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nWidget<span class=\"token operator\">&amp;&amp;</span> var1 <span class=\"token operator\">=</span> <span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Форма вывода типа очень важна, чтобы использовалась универсальная ссылка, тип <strong>обязательно</strong> должен быть <code class=\"language-text\">T&amp;&amp;</code>. В следующем примере правило не соблюдается и поэтому используется ссылка на rvalue:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\nvoid <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>vector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">&amp;&amp;</span> param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ntemplate<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\nvoid <span class=\"token function\">f2</span><span class=\"token punctuation\">(</span>const T<span class=\"token operator\">&amp;&amp;</span> param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nstd<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>vector<span class=\"token operator\">&lt;</span>int<span class=\"token operator\">></span> v<span class=\"token punctuation\">;</span>\n<span class=\"token function\">f</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// ОШИБКА, lvalue не принимается</span>\n\n<span class=\"token function\">f2</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// ОШИБКА, lvalue не принимается</span></code></pre></div>\n<p>Более того, не всегда присутствие <code class=\"language-text\">T&amp;&amp;</code> в шаблоне означает использование универсальной ссылки. Вот пример:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template<span class=\"token operator\">&lt;</span>class <span class=\"token class-name\">T</span><span class=\"token punctuation\">,</span> class <span class=\"token class-name\">Allocator</span> <span class=\"token operator\">=</span> allocator<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">></span>\nclass <span class=\"token class-name\">vector</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  void <span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>T<span class=\"token operator\">&amp;&amp;</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Это не является универсальной ссылкой, так как <code class=\"language-text\">T</code> полностью определяется конкретным классом с подставленными типамию Например, для класса <code class=\"language-text\">Widget</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">class <span class=\"token class-name\">vector</span><span class=\"token operator\">&lt;</span>Widget<span class=\"token punctuation\">,</span> allocator<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  void <span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>Widget<span class=\"token operator\">&amp;&amp;</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Никакого вывода типов здесь нет.</p>\n<p>В то же время, функция <code class=\"language-text\">employ_back</code> <em>использует</em> вывод типа, а значит и универсальную ссылку:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template<span class=\"token operator\">&lt;</span>class <span class=\"token class-name\">T</span><span class=\"token punctuation\">,</span> class <span class=\"token class-name\">Allocator</span> <span class=\"token operator\">=</span> allocator<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">></span>\nclass <span class=\"token class-name\">vector</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  template <span class=\"token operator\">&lt;</span>class<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> Args<span class=\"token operator\">></span>\n  void <span class=\"token function\">emplace_back</span><span class=\"token punctuation\">(</span>Args<span class=\"token operator\">&amp;&amp;</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Если поьзователь сам указывает типы при использовании шаблона, то вывода типов опять нет и универсальная ссылка не используется.</p>\n<h2>Use std::move on rvalue references, std::forward on universal references</h2>\n<p>Если у нас есть ссылка на rvalue, то этот объект точно может быть перемещен. Но внутри функции это уже становится ссылкой на lvalue. Чтобы не потратить возможность впустую, такие аргументы <strong>всегда</strong> должны передаваться через <code class=\"language-text\">std::move</code>, чтобы они привелись к rvalue:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">class <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  <span class=\"token function\">Widget</span><span class=\"token punctuation\">(</span>Widget<span class=\"token operator\">&amp;&amp;</span> rhs<span class=\"token punctuation\">)</span>      <span class=\"token comment\">// ссылка на rvalue</span>\n  <span class=\"token punctuation\">:</span> <span class=\"token function\">name</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>rhs<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">p</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>rhs<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>В свою очередь, универсальная ссылка <em>может</em> быть привязана к объекту, который может быть перемещен. Их нужно перемещать (т.е. приводить к rvalue) только если они были инициализированы rvalue:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">class <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  template<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\n  void <span class=\"token function\">setName</span><span class=\"token punctuation\">(</span>T<span class=\"token operator\">&amp;&amp;</span> newName<span class=\"token punctuation\">)</span>     <span class=\"token comment\">// универсальная ссылка</span>\n  <span class=\"token punctuation\">{</span> name <span class=\"token operator\">=</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>forward<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>newName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Такой код не скопилится, если в него передавать <code class=\"language-text\">newName</code> с типом, отличным от <strong>string</strong>. При этом он будет работать чуть производительнее кода, в котором аргументом принимается <code class=\"language-text\">std::string&amp;&amp;</code>, так как в том варианте нужно создавать временный <strong>string</strong> для принятия аргумента, потом еще деструктить его, а здесь - этого всего не нужно, муваем напрямую из литерала.</p>\n<p><strong>Отсюда вывод</strong>: замена шаблона, принимающего универсальную ссылку парой функций, принимающих ссылки на rvalue и lvalue добавит оверхеда в рантайме. Помимо этого такая замена может привести к комбинаторному взрывы, когда аргументов станет больше одного.</p>\n<p>Еще одно правило - не стоит <strong>никогда</strong> использовать <code class=\"language-text\">std::move</code> на универсальных ссылках, потому что тогда может оказаться, что нам пришла ссылка на lvalue, а мы превратим ее объект в пустое значение.</p>\n<h3>return std::move не работает для локальных переменных</h3>\n<p>Все, сказанное выше, справедливо лишь для аргументов, полученных на вход функции. Если же у нас есть локальная переменная, которую мы хотим вернуть, то бессмысленно и даже вредно передавать ее через <code class=\"language-text\">std::move</code>, потому что таким образом мы помешаем компилятору провести оптимизацию <em>return value optimization (RVO)</em>.</p>\n<p>Эта оптимизация конструирует возвращаемую локальную переменную сразу в той памяти, которая выделена для возвращаемого значения функции.</p>\n<p>RVO используется, когда:</p>\n<ol>\n<li>Тип локальной переменной точно такой же, как и возвращаемый тип функции</li>\n<li>Возвращается локальная переменная</li>\n</ol>\n<p>Пример:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">Widget <span class=\"token function\">makeWidget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  Widget w<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  <span class=\"token keyword\">return</span> w<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// здесь будет произведено перемещение, а не копирование</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Если же мы возвращаем <code class=\"language-text\">std::move(w)</code>, то мы возвращаем ссылку на <code class=\"language-text\">w</code>, а не саму <code class=\"language-text\">w</code>. Это значит, что правило 1 о совпадении типов больше не соблюдается и RVO применена быть не может.</p>\n<p>Но допустим, мы предполагаем, что в каком-то сложном коде компилятор не сможет применить RVO и решаем там заюзать <code class=\"language-text\">std::move</code>. Как ни странно, это все еще плохая идея. Стандарт говорит, что если условия RVO выполнены, но компилятор решает не применять оптимизацию, то возвращаемый объект <em>должен быть обработан как rvalue</em>. То есть он сам за вас подставит <code class=\"language-text\">std::move</code>.</p>\n<p>То же правило справедливо и для аргументов, принимаемых по значению. То есть такой код:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">Widget <span class=\"token function\">makeWidget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  Widget w<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  <span class=\"token keyword\">return</span> w<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>будет на самом деле скомпилирован как:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">Widget <span class=\"token function\">makeWidget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  Widget w<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  <span class=\"token keyword\">return</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>При передаче аргументов-по-ссылке или локальных переменных в другие функции такие оптимизации не применяются, поэтому здесь можно спокойно использовать <code class=\"language-text\">std::move</code>.</p>\n<p>Резюме:</p>\n<ul>\n<li>применяйте <code class=\"language-text\">std::move</code> к ссылкам на rvalue и <code class=\"language-text\">std::forward</code> к универсальным ссылкам при последнем их использовании</li>\n<li>делаейте то же самое для ссылок, возвращаемых из функций, которые возвращают по значению</li>\n<li>никогда не используйте <code class=\"language-text\">std::move</code> или <code class=\"language-text\">std::forward</code> для локальных объектов, которые подходят для RVO</li>\n</ul>\n<h2>Avoid overloading on universal references</h2>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span> multiset<span class=\"token operator\">&lt;</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string<span class=\"token operator\">></span> names<span class=\"token punctuation\">;</span>\n\ntemplate<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\nvoid <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>T<span class=\"token operator\">&amp;&amp;</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  names<span class=\"token punctuation\">.</span><span class=\"token function\">emplace</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>forward<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nstd<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string <span class=\"token function\">nameFromIdx</span><span class=\"token punctuation\">(</span>int idx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nvoid <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>int idx<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  names<span class=\"token punctuation\">.</span><span class=\"token function\">emplace</span><span class=\"token punctuation\">(</span><span class=\"token function\">nameFromIdx</span><span class=\"token punctuation\">(</span>idx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Здесь у нас 2 перегрузки метода <code class=\"language-text\">add</code>. Пока мы в аргумент передаем <strong>string</strong> или <strong>int</strong>, все нормально.</p>\n<p>Но если мы сделаем так:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">short nameIdx<span class=\"token punctuation\">;</span>\n<span class=\"token function\">add</span><span class=\"token punctuation\">(</span>nameIdx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// ошибка!</span></code></pre></div>\n<p>получим ошибку компиляции. Дело в том, что из двух перегрузок компилятор выбирает ту, которая принимает универсальную ссылку, так как там есть прямой матч типа на T, а в случае int-перегрузки матч непрямой, нужно еще приводить <strong>short</strong> к <strong>int</strong>. Далее, когда перегрузка с универсальной ссылкой пытается сдедлать <code class=\"language-text\">names.emplace(std::foward&lt;short&gt;(name))</code>, получается ошибка, так как <strong>short</strong> не может быть добавлен в сет строк.</p>\n<p>Функции, принимающие универсальные ссылки - самые жадные функции в C++, они подсовывают свои перегрузки как точные матчи для почти любых типов аргументов.</p>\n<p>Особенно неприятно становится, когда у нас есть конструктор, принимающий универсальную ссылку. Компилятор автоматически генерирует кострукторы перемещения и копирования, а затем при попытке копирования объекта попытается использовать перегрузку с универсальной ссылкой, потому что она самая жадная, и выдаст ошибку компиляции:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">class <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  template<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\n  explicit <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>T<span class=\"token operator\">&amp;&amp;</span> n<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">:</span> <span class=\"token function\">name</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>forward<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n  explicit <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>int idx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>const Person<span class=\"token operator\">&amp;</span> rhs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// compiler-generated</span>\n\n  <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>Person<span class=\"token operator\">&amp;&amp;</span> rhs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>         <span class=\"token comment\">// compiler-generated</span>\n<span class=\"token punctuation\">}</span>\n\nPerson <span class=\"token function\">p</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Nancy\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nauto <span class=\"token function\">cloneOfP</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>       <span class=\"token comment\">// ОШИБКА</span></code></pre></div>\n<p>Вдвойне неприятно, потому что здесь мы даже не можем избавиться от перегрузок переименованием, ведь у конструкторов нельзя менять имена.</p>\n<p>Здесь может помочь использование <code class=\"language-text\">const</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">const Person <span class=\"token function\">p</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Nancy\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nauto <span class=\"token function\">cloneOfP</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// компилится</span></code></pre></div>\n<p>Такой вариант сработал, потому что здесь сработал прямой матч типа <code class=\"language-text\">const Person&amp;</code> на сгенерированный конструктор копирования и такой матч сильнее, чем матч универсальной ссылки.</p>\n<h2>Familiarize yourself with alternatives to overloading on universal references</h2>\n<p>Тут очень много текста, поэтому просто приведы примеры кода для решения проблем, описанных в предыдущем пункте</p>\n<h3>Using tag dispatch</h3>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\nvoid <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>T<span class=\"token operator\">&amp;&amp;</span> name<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token function\">addImpl</span><span class=\"token punctuation\">(</span>\n    std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>forward<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>is_integral<span class=\"token operator\">&lt;</span>typename std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>remove_reference<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>type<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\ntemplate<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\nvoid <span class=\"token function\">addImpl</span><span class=\"token punctuation\">(</span>T<span class=\"token operator\">&amp;&amp;</span> name<span class=\"token punctuation\">,</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>false_type<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{</span>\n  names<span class=\"token punctuation\">.</span><span class=\"token function\">emplace</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>forward<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nvoid <span class=\"token function\">addImpl</span><span class=\"token punctuation\">(</span>int idx<span class=\"token punctuation\">,</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>true_type<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{</span>\n  <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token function\">nameFromIdx</span><span class=\"token punctuation\">(</span>idx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Constraining templates that take universal references</h3>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">class <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  template<span class=\"token operator\">&lt;</span>\n    typename T<span class=\"token punctuation\">,</span>\n    typename <span class=\"token operator\">=</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>enable_if_t<span class=\"token operator\">&lt;</span>\n      <span class=\"token operator\">!</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>is_base_of<span class=\"token operator\">&lt;</span>Person<span class=\"token punctuation\">,</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>decay_t<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">></span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>value\n<span class=\"token operator\">&amp;&amp;</span>\n      <span class=\"token operator\">!</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>is_integral<span class=\"token operator\">&lt;</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>remove_reference_t<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">></span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>value\n    <span class=\"token operator\">></span> \n  <span class=\"token operator\">></span>\n  explicit <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>T<span class=\"token operator\">&amp;&amp;</span> n<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">:</span> <span class=\"token function\">name</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>forward<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n  <span class=\"token punctuation\">{</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">}</span>\n\n  explicit <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>int idx<span class=\"token punctuation\">)</span> \n  <span class=\"token punctuation\">:</span> <span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token function\">nameFromIdx</span><span class=\"token punctuation\">(</span>idx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n  <span class=\"token punctuation\">{</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\nprivate<span class=\"token punctuation\">:</span>\n  std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>Trade-off</h3>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">class <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  template<span class=\"token operator\">&lt;</span>\n    typename T<span class=\"token punctuation\">,</span>\n    typename <span class=\"token operator\">=</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>enable_if_t<span class=\"token operator\">&lt;</span>\n      <span class=\"token operator\">!</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>is_base_of<span class=\"token operator\">&lt;</span>Person<span class=\"token punctuation\">,</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>decay_t<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">></span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>value\n      <span class=\"token operator\">&amp;&amp;</span>\n      <span class=\"token operator\">!</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>is_integral<span class=\"token operator\">&lt;</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>remove_reference_t<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">></span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>value\n    <span class=\"token operator\">></span> \n  <span class=\"token operator\">></span>\n  explicit <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>T<span class=\"token operator\">&amp;&amp;</span> n<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">:</span> <span class=\"token function\">name</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>forward<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// assert that a std::string can be created from a T object</span>\n    <span class=\"token function\">static_assert</span><span class=\"token punctuation\">(</span>\n      std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>is_constructible<span class=\"token operator\">&lt;</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string<span class=\"token punctuation\">,</span> T<span class=\"token operator\">></span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>value<span class=\"token punctuation\">,</span>\n      <span class=\"token string\">\"Parameter n can't be used to construct a std::string\"</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> \n  <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>Understand reference collapsing</h2>\n<p>При использовании универсальных ссылок в шаблное выводитмый тип T содержит в себе информацию, была ли передана ссылка на lvalue или rvalue. Например, если есть такое определение шаблона:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\nvoid <span class=\"token function\">func</span><span class=\"token punctuation\">(</span>T<span class=\"token operator\">&amp;&amp;</span> param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>тип T будет выведен как:</p>\n<ul>\n<li>lvalue reference, если в качестве аргумента передана lvalue</li>\n<li>non-reference, если передана rvalue</li>\n</ul>\n<p>Пример для нашего шаблона <code class=\"language-text\">func</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">Widget w<span class=\"token punctuation\">;</span>\nWidget <span class=\"token function\">widgetFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">func</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                  <span class=\"token comment\">// T => Widget&amp;</span>\n\n<span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token function\">widgetFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// T => Widget</span></code></pre></div>\n<p>Благодаря этому правилу работают универсальные ссылки и <code class=\"language-text\">std::forward</code>.</p>\n<p>Пользователю нельзя делать ссылки на ссылки:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">auto<span class=\"token operator\">&amp;</span> <span class=\"token operator\">&amp;</span> rx <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// ОШИБКА</span></code></pre></div>\n<p>Но компилятор может, используя механизм <em>reference collapsing</em>. Благодаря этому механизму у нас есть универсальные ссылки, которые по сути есть схлопнутые rvalue reference на другую ссылку. Например, в следующем примере lvalue передается в шаблон функции, принимающий rvalue:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">template<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\nvoid <span class=\"token function\">func</span><span class=\"token punctuation\">(</span>T<span class=\"token operator\">&amp;&amp;</span> param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nauto w <span class=\"token operator\">=</span> <span class=\"token function\">makeWidget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">func</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Для T выводится тип <code class=\"language-text\">Widget&amp;</code>, а значит конкретная функция имеет вид:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">void <span class=\"token function\">func</span><span class=\"token punctuation\">(</span>Widget<span class=\"token operator\">&amp;</span> <span class=\"token operator\">&amp;&amp;</span> param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Видим тут ссылку на ссылку и компилятор ничего не имеет против.</p>\n<p>Дело в том, что если ссылка на ссылку появляется в разрешенном контексте (напр. при конкретизации шаблона), то ссылки \"схлопываются\" в одну ссылку по следующему правилу:</p>\n<p>  Если любая из ссылок ссылается на lvalue, то результат становится ссылкой на lvalue. Иначе, если обе ссылки на rvalue, то результат становится ссылкой на rvalue.</p>\n<ul>\n<li>&#x26; + &#x26; = &#x26;</li>\n<li>&#x26; + &#x26;&#x26; = &#x26;</li>\n<li>&#x26;&#x26; + &#x26; = &#x26;</li>\n<li>&#x26;&#x26; + &#x26;&#x26; = &#x26;&#x26;</li>\n</ul>\n<p>В примере выше у нас получается rvalue reference на lvalue reference, что схлопывается в lvalue reference. Если бы на вход поступила rvalue reference, то результат схлопывания был бы тоже rvalue reference. Именно так и работает универсальная ссылка.</p>\n<p>Схлопывание ссылок разрешено в 4 контекстах:</p>\n<ul>\n<li>конкретизация шаблона</li>\n<li>генерация типов для auto (<code class=\"language-text\">auto&amp;&amp; w1 = w;</code> выводит lvalue)</li>\n<li>генерация и использование <code class=\"language-text\">typedef</code> и алиасов (<code class=\"language-text\">typedef T&amp;&amp; Ref</code>)</li>\n<li>использование <code class=\"language-text\">decltype</code></li>\n</ul>\n<h2>Assume that move operations are not present, not cheap, and not used</h2>\n<p>Многие типы стандартной библиотеки были переипсаны в C++11, чтобы поддержать семантику перемещения. Однако многие остались пока без этой поддержки.</p>\n<p>Среди тех, которые поддерживают перемещение, некоторые типы перемещают медленно просто потому что семантика типа не позволяет сделать это иначе. Например, <code class=\"language-text\">std::array</code> хранит все элементы в себе, поэтому для него перемещение, хоть и работает быстрее копирования, все равно требует линейного перемещения всех своих объектов. Для остальных контейнеров, как, например, <code class=\"language-text\">std::vector</code>, перемещение заключается в перемещении указателя на начало массива в куче, поэтому выполняется за константное время.</p>\n<p><code class=\"language-text\">std::string</code>, в свою очередь, поддерживает перемещение за константное время, но оно не всегда становится от этого сильно быстрее линейного копирования. Дело в том, что многие реализации используют <em>small string optimization (SSO)</em>. Благодаря этой оптимизации \"маленькие\" (не более 15 символов) строки хранятся в буфере внутри объекта <code class=\"language-text\">std::string</code>а динамически аллоцируемая память не используется. Перемещение таких \"маленьких\" строк работает не быстрее, чем копирование.</p>\n<p>А еще бывает так, что даже при корректной и производительной реализации перемещения, компилятор все равно выбирает копирование, потому что реализация перемещения не помечена как <code class=\"language-text\">noexcept</code>. Так бывает, например, в контейнерах, когда компилятор хочет убедиться, что не возникнет ситуации, когда при перемещении i-го элемента выбросится исключение и у нас получится 2 объекта в неконсистентном состоянии.</p>\n<h2>Avoid default capture modes</h2>\n<p>Захват по ссылке может привести к висячим ссылкам, если время жизни замыкания превышает время жизни переменной, ссылка на которую используется в лямбде. Когда мы такие ссылки провисываем в списке захвата вручную, то за их лайфтаймом легче уследить.</p>\n<p>Казалось бы, эту проблему может решить захват по значению. Но если мы захватываем по значению указатель, никто не мешает коду вне лямбды освободить память, на которую ссылается этот указатель, и мы опять получаем висячую ссылку.</p>\n<p>Вообще, надо понимать, что при использовании дефолтного захвата по значению, захватываются только локальные переменные, аргументы функции и указатель <code class=\"language-text\">this</code>. </p>\n<p>Статические объекты могут быть использованы внутри лямбды, но они не захватываются. То есть захват по значению для них не работает в том смысле, что не делается копия значения, как пользователь может ожидать при использовании <code class=\"language-text\">[=]</code>.</p>\n<p>Поля объекта тоже захватываются, но при использовании <code class=\"language-text\">[=]</code> может сложиться ложное впечатление, что они захватились по значению, в то время как на самом деле захватился <code class=\"language-text\">this</code> и обращение к полям объекта идет автоматически через него, то есть обращение к полям объекта опять-таки идет по ссылке.</p>\n<h2>Use init capture to move objects into closures</h2>\n<p>У лямбд в C++11 есть большая проблема - туда нельзя передать move-only объекты, то есть, например, <code class=\"language-text\">std::unique_ptr</code> или <code class=\"language-text\">std::future</code>.</p>\n<p>Проблему эту позволяет решить init capture, появившаяся в C++14:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">class <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  bool <span class=\"token function\">isValidated</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> const<span class=\"token punctuation\">;</span>\n  bool <span class=\"token function\">isProcessed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> const<span class=\"token punctuation\">;</span>\n  bool <span class=\"token function\">isArchived</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> const<span class=\"token punctuation\">;</span>\nprivate<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nauto pw <span class=\"token operator\">=</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>make_unique<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\nauto func <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>pw <span class=\"token operator\">=</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>pw<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span> \n  <span class=\"token keyword\">return</span> pw<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">isValidated</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n         <span class=\"token operator\">&amp;&amp;</span> pw<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">isArchived</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>В С++11 без использования этой фичи код может быть переписан так:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">class <span class=\"token class-name\">IsValAndArch</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  using DataType <span class=\"token operator\">=</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>unique_ptr<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n  explicit <span class=\"token function\">IsValAndArch</span><span class=\"token punctuation\">(</span>DataType<span class=\"token operator\">&amp;&amp;</span> ptr<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">:</span> <span class=\"token function\">pw</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n     bool <span class=\"token function\">operator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> const\n     <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> pw<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">isValidated</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> pw<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">isArchived</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\nprivate<span class=\"token punctuation\">:</span>\n  DataType pw<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nauto func <span class=\"token operator\">=</span> <span class=\"token function\">IsValAndArch</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>make_unique<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Есть и другой, чуть более сложный для понимания, но требующий меньше кода, вариант:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">auto func <span class=\"token operator\">=</span>\n     std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span> \n      <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>const std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>unique_ptr<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> pws<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">{</span> \n        <span class=\"token keyword\">return</span> pw<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">isValidated</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> pw<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">isArchived</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>make_unique<span class=\"token operator\">&lt;</span>Widget<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>Use decltype on auto&#x26;&#x26; parameters to std::forward them</h2>\n<p>В C++14 появились джененрик лямбды, у которых в списке параметров можно использовать тип <code class=\"language-text\">auto</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">auto f <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>auto x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Сгенерированный класс замыкания выглядит так:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">class <span class=\"token class-name\">SomeCompilerGeneratedClassName</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  template<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\n  auto <span class=\"token function\">operator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>T x<span class=\"token punctuation\">)</span> const\n  <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Но ва этой лямбде есть недостаток - она плохо работает со ссылками на rvalue, а именно не форвардит их.</p>\n<p>Исправленный вариант:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">auto f <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>auto<span class=\"token operator\">&amp;&amp;</span> x<span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>forward<span class=\"token operator\">&lt;</span><span class=\"token function\">decltype</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Если нужна лямбда, принимающая множество параметров, можем применить вариадичный шаблон:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">auto f <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>auto<span class=\"token operator\">&amp;&amp;</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> params<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>forward<span class=\"token operator\">&lt;</span><span class=\"token function\">decltype</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>Prefer lambdas to std::bind</h2>\n<ul>\n<li>Лямбды намного более читабельны. </li>\n<li>Лямбды могут инлайниться, бинды - нет.</li>\n<li>У биндов неочевидная семантика копирования аргументов - при создании бинда аргументы копируются по значению, а при использовании результата аргументы передаются по функции. И это из кода нигде не понятно, это можно только запомнить.</li>\n</ul>\n<p>В С++11 без использования бинда не обойтись, когда:</p>\n<ul>\n<li>хотим передать аргументы в замыкание перемещением</li>\n<li>дженерик лямбда</li>\n</ul>\n<p>Дженерик лямбда через бинд реализуется так:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">class <span class=\"token class-name\">PolyWidget</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  template<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\n  void <span class=\"token function\">operator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>const T<span class=\"token operator\">&amp;</span> param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nPolyWidget pw<span class=\"token punctuation\">;</span>\n\nauto boundPW <span class=\"token operator\">=</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>pw<span class=\"token punctuation\">,</span> _1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">boundPW</span><span class=\"token punctuation\">(</span><span class=\"token number\">1930</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">boundPW</span><span class=\"token punctuation\">(</span>nullptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">boundPW</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Rosebud\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>В С++14 лямбды поддерживают оба этих пункта, поэтому там смысла использовать бинд нет вообще никогда.</p>\n<h2>Prefer task-based programming to thread-based</h2>\n<p>Thread-based:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>thread <span class=\"token function\">t</span><span class=\"token punctuation\">(</span>doAsyncWork<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Task-based:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">auto fut <span class=\"token operator\">=</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">async</span><span class=\"token punctuation\">(</span>doAsyncWork<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Основные различия:</p>\n<ul>\n<li>таска возвращает значение, в котором клиент может быть заинтересован. Из потока получить значение не так просто</li>\n<li>если функция стреляет исключение, то в случае таски оно будет выстрелено при попытке взять значение, а в случае потока оно крэшнет весь процесс</li>\n<li>если превышен максимально возможный лимит потоков в системе, конструктор <code class=\"language-text\">std::thread</code> выбросит <code class=\"language-text\">std::system_error</code>. Таски же могут быть запущены в текущем потоке, если потоков в системе слишком много. Для GUI-потоков можно передавать специальную политику запуска <code class=\"language-text\">std::launch::async</code>, чтобы гарантировать, что таска точно будет запущена в отдельном потоке</li>\n<li>таски имеют больше информации о загруженности системы, чтобы проводить более эффективную балансировку нагрузки</li>\n</ul>\n<p>Использование тредов оправдано, когда:</p>\n<ul>\n<li>нужен доступ к низкоуровневым свойствам тредов, например, приоритету</li>\n<li>нужно вручную затюнить использование тредов в приложении</li>\n<li>нужно реализовать механизмы мульти-трединга, отсутствующие в C++ concurrency API, например, тред-пулы</li>\n</ul>\n<h2>Specify std::launch::async if asynchronicity is essential</h2>\n<p>Таски обычно создаются так:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">auto fut <span class=\"token operator\">=</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">async</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nauto fut2 <span class=\"token operator\">=</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">async</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>launch<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>async<span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Во втором варианте вторым аргументом передается политика запуска.</p>\n<p>Есть 2 стандартных политики запуска:</p>\n<ul>\n<li><code class=\"language-text\">std::launch::async</code> - функция должна быть обязательно запущена асинхронно, т.е. на другом потоке</li>\n<li><code class=\"language-text\">std::launch::deferred</code> - функция будет запущено только когда для футуры будет вызван <code class=\"language-text\">get</code> или <code class=\"language-text\">wait</code>. Если не будет вызван, то функция никогда не запустится.</li>\n</ul>\n<p>Дефолтная политки запуска при этом - объединение этих двух: <code class=\"language-text\">std::launch::async | std::launch::deferred</code>. Она значит, что функция может быть запущена как синхронно, так и асинхронно, в зависимости от текущей нагрузки.</p>\n<p>У дефолтной политики есть и свои недостатки:</p>\n<ul>\n<li>невозможно предсказать, будет ли функция выполняться одновременно с текущим потоком, создающим таск</li>\n<li>невозможно предсказать, будет ли функция выполняться на другом потоке при вызове <code class=\"language-text\">get</code> или <code class=\"language-text\">wait</code></li>\n<li>невозможно предсказать, будет ли функция выполнена вообще, потому что может быть непросто гарантировать, что <code class=\"language-text\">get/wait</code> будут точно вызываться во всех ветях исполнения</li>\n<li>плохо работает с thread_local переменными, потому что невозможно предсказать, переменные чьего потока будут использоваться</li>\n<li>использование функций <code class=\"language-text\">wait_for</code> и <code class=\"language-text\">wait_until</code> может сломаться, потому что если использовать их на таске, вызванном с политикой <code class=\"language-text\">std::launch::deferred</code>, то они будут всегда возвращать <code class=\"language-text\">std::launch::deferred</code> и никогда - <code class=\"language-text\">std::future_status::ready</code></li>\n</ul>\n<p>Все эти баги сложно отследить, потому что они будут проявляться только под большой нагрузкой. Вдобавок к этому, нет никакой возможности узнать, отложен ли таск. Приходится пользоваться таким вот костылем:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">auto fut <span class=\"token operator\">=</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">async</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>fut<span class=\"token punctuation\">.</span><span class=\"token function\">wait_for</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span>s<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>future_status<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>deferred<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  auto res <span class=\"token operator\">=</span> fut<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>fut<span class=\"token punctuation\">.</span><span class=\"token function\">wait_for</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span>ms<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>future_status<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>ready<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  <span class=\"token punctuation\">}</span>\n  auto res <span class=\"token operator\">=</span> fut<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Make std::threads unjoinable on all paths</h2>\n<p>К unjoinable-тредам относятся:</p>\n<ul>\n<li><code class=\"language-text\">std::thread</code> с дефолтным конструктором, то есть без указанной функции</li>\n<li><code class=\"language-text\">std::thread</code>, из которого \"перестили\"</li>\n<li>приджойненные треды</li>\n<li>задетаченные треды</li>\n</ul>\n<h2>Be aware of varying thread handle destructor behavior</h2>\n<p>И <code class=\"language-text\">std::thread</code> и футуры могут считаться хэндлами системных потоков. Но они очень сильно различаются по поведению деструкторов.</p>\n<p>Деструктор потока вызывает <code class=\"language-text\">terminate()</code> если тред не заджойнен.</p>\n<p>Деструктор футуры иногда как будто бы делает <code class=\"language-text\">join</code>, иногда <code class=\"language-text\">detach</code>, а иногда ни то, ни другое. Но он точно никогда не вызывает завершение программы.</p>\n<p>Напомним, что футура - это один конец канала общения клиента потока и функтора, работающего в другом потоке.  Фуктор, используя объект <code class=\"language-text\">std::promise</code>, пишет результат вычисления в канал, а клиент читает этот результат с помощью футуры.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/hows-that-again/static/36a5dc06450d824be93bef9715fbfada/b12db/future.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 11.670020120724347%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAhElEQVQI122OuwrCMABF+/+/4ODk4Org4qAUtCIiakEKiTWS+EIFYx5LCsfiKA6Xc4Yz3OzyeJFvJfPqSCX2GK1pmoaU0ne/7r1Ht40xJ5Q6IGrFbKeYbATXpyWT5kZ3OKU3WlBWAve2+BCIMRL+0DmHtRYp2xNFwXJd0h+v6Axy6vOdD+3gkuI9JN2FAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Future\"\n        title=\"Future\"\n        src=\"/hows-that-again/static/36a5dc06450d824be93bef9715fbfada/dbb61/future.png\"\n        srcset=\"/hows-that-again/static/36a5dc06450d824be93bef9715fbfada/19bd1/future.png 163w,\n/hows-that-again/static/36a5dc06450d824be93bef9715fbfada/d3bcb/future.png 325w,\n/hows-that-again/static/36a5dc06450d824be93bef9715fbfada/dbb61/future.png 650w,\n/hows-that-again/static/36a5dc06450d824be93bef9715fbfada/6b691/future.png 975w,\n/hows-that-again/static/36a5dc06450d824be93bef9715fbfada/b12db/future.png 994w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Однако на самом деле все чуть сложнее. Что если функтор вызывается раньше, чем клиент вызовет <code class=\"language-text\">get()</code> у футуры? Результат нужно где-то хранить. В промисе - нельзя, потому что функтор завершается и вместе с ним может завершиться промис. В футуре - тоже нельзя, так как из <code class=\"language-text\">std::future</code> может быть сделано <code class=\"language-text\">std::shared_future</code> и тогда результат придется копировать несколько раз. А если результат не-копируем, то придется как-то заранее знать, какая из <code class=\"language-text\">std::shared_future</code> умрет последней и хранить в ней.</p>\n<p>Поэтому результат операции хранится снаруже футуры и промиса, в месте под названием <em>shared state</em>:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/hows-that-again/static/8043f9d0a79929ae236e55cd8c292804/d418b/future-shared-state.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 16.839916839916842%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAwUlEQVQI11WOy26CUBRF+d5O/ZdOOlCnTT+g1fjoIzUxFRQfKJdLCYnGgS1GIb4udwnoQE/2npycs/Y2tE4BnUlnuvh2/qMI150hpWS33xc7pdTdDVdGzjI+BoJqrctL28Q0LcIwLB63mw2Hkyaw36k/PvBVLuENO2yTHUK4CM/Dskys/oDn1g+Vty6ftsAY/S5o9KZ0xj5xnBTpuU/HY96b9XxG//UJp1klWgaorEyaKlarPxzHQfo+3yNZMCbBgjNN6Nwl0Re31wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Future with shared state\"\n        title=\"Future with shared state\"\n        src=\"/hows-that-again/static/8043f9d0a79929ae236e55cd8c292804/dbb61/future-shared-state.png\"\n        srcset=\"/hows-that-again/static/8043f9d0a79929ae236e55cd8c292804/19bd1/future-shared-state.png 163w,\n/hows-that-again/static/8043f9d0a79929ae236e55cd8c292804/d3bcb/future-shared-state.png 325w,\n/hows-that-again/static/8043f9d0a79929ae236e55cd8c292804/dbb61/future-shared-state.png 650w,\n/hows-that-again/static/8043f9d0a79929ae236e55cd8c292804/d418b/future-shared-state.png 962w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Вот это вот разделяемое состояние определяет поведение деструктора футуры:</p>\n<ul>\n<li>деструктор последней футуры, ссылающеся на разделяемое состояние для не-отложенной (<code class=\"language-text\">std::launch::async</code>) таски, запущенной через <code class=\"language-text\">std::async</code> блочится, пока таска, связанная с футурой не завершится. Для <code class=\"language-text\">std::future</code> это условие выполняется всегда, для <code class=\"language-text\">std::shared_future</code> - только для последней.</li>\n<li>деструкторы остальных футур просто уничтожают футуры и ничего не ждут</li>\n</ul>\n<p>Для обычных <code class=\"language-text\">std::future</code> можно говорить, что если они запущены с <code class=\"language-text\">std::launch::async</code>, то их деструкторы будут блочиться.</p>\n<p>Имея объект футуры, невозможно определить, заблочится ли она в деструкторе.</p>\n<h2>Consider void futures for one-shot event communication</h2>\n<p>Когда одному потоку надо дождаться некоего события во втором потоке, есть такие опции:</p>\n<ul>\n<li><code class=\"language-text\">std::condition_variable</code></li>\n</ul>\n<p>Thread 1:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>condition_varaible cv<span class=\"token punctuation\">;</span>\nstd<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>mutex m<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\ncv<span class=\"token punctuation\">.</span><span class=\"token function\">notify_one</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Thread 2:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\"><span class=\"token punctuation\">{</span>\n  std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>unique_lock<span class=\"token operator\">&lt;</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>mutex<span class=\"token operator\">></span> <span class=\"token function\">lk</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  cv<span class=\"token punctuation\">.</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>lk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Недостатки:</p>\n<ol>\n<li>если тред 1 занотифаит прежде чем тред 2 начал ждать, то тред 2 зависнет.</li>\n<li><code class=\"language-text\">wait</code> в треде 2 подвержен ложным пробуждениям (spurious wakeups). Решается передачей предиката в <code class=\"language-text\">wait</code>. Но не всегда есть возможность в предикате сообщить треду 2, что произошло нужное событие в треде 1.</li>\n<li>Мьютекс используется не по назначению (его назначение - синхронизировать доступ к переменным, а не передавать события)</li>\n</ol>\n<hr>\n<ul>\n<li>разделяемый <code class=\"language-text\">std::atomic&lt;bool&gt;</code></li>\n</ul>\n<p>Thread 1:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>atomic<span class=\"token operator\">&lt;</span>bool<span class=\"token operator\">></span> <span class=\"token function\">flag</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\nflag <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Thread 2:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\"><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>flag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>Недостатки:</p>\n<ol>\n<li>жрет процессорное время</li>\n<li>жрет ресурсы для контекст-свитча</li>\n</ol>\n<hr>\n<ul>\n<li>не-атомарный флаг, но под мютексом</li>\n</ul>\n<p>Thread 1:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>condition_variable cv<span class=\"token punctuation\">;</span>\nstd<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>mutex m<span class=\"token punctuation\">;</span>\n\nbool <span class=\"token function\">flag</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">{</span>\n  std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>lock_guard<span class=\"token operator\">&lt;</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>mutex<span class=\"token operator\">></span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  flag <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\ncv<span class=\"token punctuation\">.</span><span class=\"token function\">notify_one</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Thread 2:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\"><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">{</span>\n  std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>unique_lock<span class=\"token operator\">&lt;</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>mutex<span class=\"token operator\">></span> <span class=\"token function\">lk</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  cv<span class=\"token punctuation\">.</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>lk<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> flag<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>Недостатки:</p>\n<ul>\n<li>сложный код, фактически передаем информацию о наступлении события дважды - через <code class=\"language-text\">cv</code> и через <code class=\"language-text\">flag</code>  </li>\n<li>все еще нужно проверять flag в <code class=\"language-text\">wait</code></li>\n</ul>\n<hr>\n<ul>\n<li>футура, возвращающая void!</li>\n</ul>\n<p>Thread 1:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>promise<span class=\"token operator\">&lt;</span>void<span class=\"token operator\">></span> p<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\np<span class=\"token punctuation\">.</span><span class=\"token function\">set_value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Thread 2:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">p<span class=\"token punctuation\">.</span><span class=\"token function\">get_future</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Не требует мутексов, работает если <code class=\"language-text\">set_value()</code> вызван раньше, чем <code class=\"language-text\">wait()</code> и не подвержен ложным пробуждениям.</p>\n<p>Недостатки:</p>\n<ul>\n<li>динамически аллоцируемое <strong>shared state</strong> между промисом и футурой</li>\n<li>промис может быть выставлен только единожды, то есть этот механизм годится только для одноразовых сообщений. Это главное отличие от механизмов, построенных на использовании condvar и флагов.</li>\n</ul>\n<p>Типичный пример использования техники:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>promise<span class=\"token operator\">&lt;</span>void<span class=\"token operator\">></span> p<span class=\"token punctuation\">;</span>\n\nvoid <span class=\"token function\">react</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nvoid <span class=\"token function\">detect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>thread <span class=\"token function\">t</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">{</span>\n    p<span class=\"token punctuation\">.</span><span class=\"token function\">get_future</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">react</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  p<span class=\"token punctuation\">.</span><span class=\"token function\">set_value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  t<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Если использовать здесь <code class=\"language-text\">std::shared_future</code>, то подписчиков на событие может быть несколько:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>promise<span class=\"token operator\">&lt;</span>void<span class=\"token operator\">></span> p<span class=\"token punctuation\">;</span>\n\nvoid <span class=\"token function\">react</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nvoid <span class=\"token function\">detect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  auto sf<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">get_future</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">share</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>vector<span class=\"token operator\">&lt;</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>thread<span class=\"token operator\">></span> vt<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>int i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> threadsToRun<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    vt<span class=\"token punctuation\">.</span><span class=\"token function\">emplace_back</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>sf<span class=\"token punctuation\">]</span><span class=\"token punctuation\">{</span> \n      sf<span class=\"token punctuation\">.</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token function\">react</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  p<span class=\"token punctuation\">.</span><span class=\"token function\">set_value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// запускаем все ожидающие потоки</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>auto<span class=\"token operator\">&amp;</span> t<span class=\"token punctuation\">:</span> vt<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    t<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Use std::atomic for concurrency, volatile for special memory</h2>\n<p>Операции над <code class=\"language-text\">std::atomic</code> производятся, как будто бы они были защищены мютексом, но при этом используют специальные машинные инструкции, которые эффективнее мютексов.</p>\n<p>А еще <code class=\"language-text\">std::atomic</code> нагладывает ограничения на изменение порядка инструкций, а именно: <strong>ни одна команда, предшествующая записи вstd::atomic не может быть расположена после нее</strong>.</p>\n<p><code class=\"language-text\">volatile</code> не делает ничего из этого, поэтому оно не подходит для параллельного программирования.</p>\n<p>Так для чего же оно нужно? А нужно оно, чтобы сказать компиляторам, что они работают с памятью, которая ведет себя \"ненормально\".</p>\n<p>Под \"нормальной\" памятью мы понимаем такую память, для которой если мы записали значение по некоторому адресу, то он останется неизменным, пока что-нибудь его не перепишет.</p>\n<p>То есть если есть такой код:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">int x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\nauto y <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\ny <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n\nx <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\nx <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>компилятор может сделать вывод, что между двумя присвоениями значение <code class=\"language-text\">x</code> не меняется, а значит первое присвоение в каждой паре можно безопасно удалить:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">int x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\nauto y <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\nx <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Но применительно к ключевому слову <code class=\"language-text\">volatile</code> мы говорим о \"ненормальной\", или \"специальной\" памяти. Наиболее часто используемая \"специальная\" память используется при <code class=\"language-text\">memory mapped I/O</code>. В такой памяти адреса общаются напрямую с периферийными устройствами, то есть сенсорами, дисплейями, принтерами, сетевыми портами и т.д.</p>\n<p>В этой ситуации если видим такой код:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">auto y <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\ny <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span></code></pre></div>\n<p>нельзя удалить второе присвоение, потому что, например, сенсор, к которому привязано хначение x мог изменить показания</p>\n<p>Или вот такой код:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">x <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\nx <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Его возможно тоже нельзя менять, если, например, запись в x издает определенную радиокоманду.</p>\n<p>Ключевое слово <code class=\"language-text\">volatile</code> говорит компилятору, что здесь мы работаем с именно такой \"специальной\" памятью. Это приказ компилятору \"не проводи никаких оптимизаций на этой памяти\".</p>\n<p>При его использовании: </p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">volatile int x<span class=\"token punctuation\">;</span>\n\nauto y <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\ny <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\nx <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\nx <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>никакие строчки кода компилятором удалены не будут.</p>\n<p>Теперь должно быть понятно, почему <code class=\"language-text\">std::atomic</code> нельзя использовать для работы со \"специальной\" памятью, ведь он <strong>не запрещает</strong> удалять лишние, с точки зрения компилятора, строчки. </p>\n<p>Ну и не лишним будет добавить, что приведенный выше код для <code class=\"language-text\">std::atomic</code> вообще не скомпилится, потому что операции копирования для <code class=\"language-text\">std::atomic</code> удалены. Это сделано потому что атомарное копирование обычно не поддерживается железом. Перемещение тоже не поддерживается.</p>\n<p>Если нужно скопировать значение <code class=\"language-text\">x</code> в <code class=\"language-text\">y</code>, то нужно делать так:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>atomic<span class=\"token operator\">&lt;</span>int<span class=\"token operator\">></span> <span class=\"token function\">y</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// или так</span>\ny<span class=\"token punctuation\">.</span><span class=\"token function\">store</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Но между чтением и записью, естественно, никакой атомарности не сохраняется.</p>\n<p>Компилятор мог бы оптимизировать этот код:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">register <span class=\"token operator\">=</span> x<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nstd<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>atomic<span class=\"token operator\">&lt;</span>int<span class=\"token operator\">></span> <span class=\"token function\">y</span><span class=\"token punctuation\">(</span>register<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ny<span class=\"token punctuation\">.</span><span class=\"token function\">store</span><span class=\"token punctuation\">(</span>register<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>и если бы мы работали со специальной память, такая оптимизация была бы неприемлема. Это еще один пример, почему <code class=\"language-text\">std::atomic</code> и <code class=\"language-text\">volatile</code> не взаимозаменяемы:</p>\n<ul>\n<li><code class=\"language-text\">std::atomic</code> - для данных, доступ к которым осуществляется из нескольких тредов без использования мютексов. Он нужен для написания параллельного кода.</li>\n<li><code class=\"language-text\">volatile</code> - для памяти, у которой чтения и записи не должны быть оптимизированы. Это нужно для работы со специальной памятью.</li>\n</ul>\n<h2>Consider pass by value for copyable parameters that are cheap to move and always copied</h2>\n<p>Пусть у нас есть такой вот код:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">class <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  void <span class=\"token function\">addName</span><span class=\"token punctuation\">(</span>const std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string<span class=\"token operator\">&amp;</span> newName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    names<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>newName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  void <span class=\"token function\">addName</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string<span class=\"token operator\">&amp;&amp;</span> newName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    names<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>newName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n  <span class=\"token punctuation\">}</span>\n\nprivate<span class=\"token punctuation\">:</span>\n  std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>vector<span class=\"token operator\">&lt;</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string<span class=\"token operator\">></span> names<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>С точки зрения эффективности тут все хорошо: lvalue передаются по ссылки и копируются, rvalue тоже передаются по ссылке, но перемещаются. Но есть проблема - это 2 функции вместо одной.</p>\n<p>Можем попробовать переписать с использованием универсальной ссылки:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">class <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  template<span class=\"token operator\">&lt;</span>typename T<span class=\"token operator\">></span>\n  void <span class=\"token function\">addName</span><span class=\"token punctuation\">(</span>T<span class=\"token operator\">&amp;&amp;</span> newName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    names<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>forward<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>newName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Здесь меньше кода, но так как это шаблон, то в объектном коде использующей библиотеки все равно будет 2 функции. На самом деле даже больше - по 2 на <code class=\"language-text\">std::string</code> и каждый тип, приводимый к <code class=\"language-text\">std::string</code>. </p>\n<p>Кроме того, есть типы, которые не могут быть переданы как универсальная ссылка.</p>\n<p>Выход простой - передаем копию и не паримся:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">class <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">{</span>\npublic<span class=\"token punctuation\">:</span>\n  void <span class=\"token function\">addName</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string newName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    names<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>newName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Почему это работает? Дело в том, что компилятор C++11 стал достаточно умен, чтобы в случае, когда аргументом передается rvalue, передавать его не копированием, а перемещением. Тогда в случае передачи lvalue у нас получается копирование и перемещение, а в случае rvalue - два перемещения. По сравнению с перегрузками и универсальными ссылками - это <strong>на одно перемещение больше в обоих случаях</strong>.</p>\n<p>То есть такой вариант все-таки чуть менее эффективен. Именно поэтому в заголовке пункта стоит уточнение, что тип должен быть <strong>дешев для перемещения</strong>.</p>\n<p>Там еще есть уточнение про копируемые типы. Дело в том ,что если тип не копируем, то в варианте с перегрузками не нужна первая перегрузка. Тогда достаточно одной функции и первый вариант не имеет недостатков.</p>\n<p>И последнее уточнение - применять эту технику стоит лишь для аргументов, которые в теле функции <strong>всегда</strong> копируются. Иначе перемещение копирования в заголовок может быть лишним оверхедом для тех случаев, когда значение потом не используется и получается, что копировали зря. В таком случае передача ссылки подошла бы лучше.</p>\n<h2>Consider emplacement instead of insertion</h2>\n<p>У <code class=\"language-text\">std::vector</code> есть такая перегрузка специально для rvalue:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">void <span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>T<span class=\"token operator\">&amp;&amp;</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Рассмотрим такой код, использующий ее:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>vector<span class=\"token operator\">&lt;</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>string<span class=\"token operator\">></span> vs<span class=\"token punctuation\">;</span>\nvs<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"xyzzy\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Как ни странно, этот невинный код приводит аж к 2 конструкциям типа <code class=\"language-text\">string</code>: </p>\n<ul>\n<li>первый раз конструктор вызывается, чтобы привести литерал типа <code class=\"language-text\">const char[6]</code> к типу <code class=\"language-text\">std::string</code>, получим временное значение <code class=\"language-text\">temp</code></li>\n<li>второй раз вызывается внутри метода <code class=\"language-text\">push_back</code>, чтобы скопировать значение из ссылки rvalue на <code class=\"language-text\">temp</code>.</li>\n</ul>\n<p>Не очень-то эффективно 2 раза вызывать конструктор. Хотелось бы обойтись лишь одним. Поэтому был введен специальный метод - <code class=\"language-text\">emplace_back()</code>.</p>\n<p>Он форвардит свои аргументы в <code class=\"language-text\">std::vector</code>, чтобы внутри него.с этими аргументами вызвать конструктор <code class=\"language-text\">std::string</code>, достигая того же эффекта, что и <code class=\"language-text\">push_back()</code> без использования временных переменных.</p>\n<p>Пример:</p>\n<div class=\"gatsby-highlight\" data-language=\"clike\"><pre class=\"language-clike\"><code class=\"language-clike\">vs<span class=\"token punctuation\">.</span><span class=\"token function\">emplace_back</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"xyzzy\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nvs<span class=\"token punctuation\">.</span><span class=\"token function\">emplace_back</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'x'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// создаст std::string из 50 символов x</span></code></pre></div>\n<p>Метод <code class=\"language-text\">emplace_back</code> доступен для всех стандартных контейнеров, у которых есть <code class=\"language-text\">push_back</code>. </p>\n<p>Если передать в <code class=\"language-text\">emplace_back</code> не <code class=\"language-text\">char[]</code>, а сразу <code class=\"language-text\">std::string</code>, то он будет вести себя аналогично <code class=\"language-text\">push_back</code>, так как в этом случае <code class=\"language-text\">push_back</code> создает лишь один объект. То есть по идее он может во всех ситуациях заменить <code class=\"language-text\">push_back</code>. Но это только по идее.</p>\n<p>В действительности, бывают ситуации, когда <code class=\"language-text\">push_back</code> работает быстрее. Эти ситуации зависят от многих факторов - от типа аргумента, типа контейнера, позиции в контейнере, куда вставляется элемент, возможности выстреливания исключения из операции копирования, а для контейнеров, в которых запрещены дубликаты - от того, есть ли уже такое значение в контейнере. ТАк что единственный способ узнать наверняка - побенчмаркать.</p>\n<p>Но есть эвристические проверки, которые помогут определить, когда <code class=\"language-text\">emplace_back</code> сработает быстрее, чем <code class=\"language-text\">push_back</code>. Если все эти проверки проходят, то это так:</p>\n<ul>\n<li>добавляемое значение конструктится, а не присваивается. Это зависит от реализации метода добавления, но обычно конструктится, когда, мы добавляем новое значение в контейнер, а присваивается - когда заменяем старое. Если присваивается, то придется создавать временный объект, из которого будет осуществлено перемещение, а значит <code class=\"language-text\">emplace_back</code> теряет свои достоинства</li>\n<li>тип передаваемого аргумента отличается от типа элементов контейнера</li>\n<li>контейнер не будет, или очень редко будет отвергать новое значение как дубликат. Это важно, потому что когда значение отвергнуто, мы в <code class=\"language-text\">emplace_back</code> уже создали объект и получается, что создали зря</li>\n</ul>","frontmatter":{"path":"/blog/books/effective-modern-cpp","title":"Effective Modern C++"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}