---
title: "RabbitMQ"
path: "/blog/rabbitmq"
---
# RabbitMQ

## Терминология

Queue - очередь

Binding - привязка

Exchange - точка обмена

Topic - топик

Routing key - ключ роутинга

Binding key - ключ привязки

Payload - тело сообщения

Acknowledgement - подтверждение

## Принципы работы

Продюсеры создают сообщения и шлют их на брокера.

Сообщения состоят из ключа роутинга, идентификатора точки обмена и тела сообщения.

Консюмеры подсоединяются к брокеру, подписываются на *очередь* и принимают из нее сообщения. Ключ сообщения и идентификатор точки обмена консюмер не получает - только тело. После получения **каждого** сообщения консюмер должен послать **acknowledgement**, вручную или автоматически. Пока не послать подтверждение, следующее сообщение в этот консюмер не придет.

Прежде чем читать или писать сообщения в очередь, приложение должно поднять *AMQP-канал*. Это виртуальный канал связи внутри TCP-соединения, по которому посылаются команды AMQP. Таких каналов может быть много внутри одного TCP-соединения и они нужны, чтобы каждому потоку не приходилось открывать свое TCP-соединение, что было бы очень дорого (TCP-соединения не потокобезопасны, могут использоваться не больше чем одним потоком на запись и не больше чем одним - на чтение).

### Создание новых очередей

И консюмеры и продюсеры могут создавать новые очереди командой *queue.declare*, но консюмеры не могут использовать команду, пока подписаны на другую очередь в этом же канале.

Для очередей могут быть заданы специальные свойства:

- **exclusive**: очередь становится приватной и только текущее приложение может быть ее консюмером
- **auto-delete**: очередь автоматически удаляется, когда от нее отписывается последний консюмер.
- **durable**: сообщения не теряются при рестарте RabbitMQ. 

Если нужна временная очередь для текущего приложения, то можно создать ее со свойствами **exclusive** и **auto-delete**.

Если попытаться записать сообщение в несуществующую очередь, то оно будет просто проигнорировано, поэтому лучше всегда заранее ее явно создавать. Если при попытке создания окажется, что очередь с такими же параметрами уже есть, то Rabbit не сделает ничего и вернет успех.

### Точки обмена / exchanges

Продюсеры шлют сообщения не напрямую в очереди, а в точки обмена (exchange). Очереди *привязываются* к эксченджам посредством ключей привязок. Получив сообщение в эксчендж, Rabbit сравнивает ключ роутинга сообщения (который может быть и пустым), с имеющимся ключами привязок. Найдя соответствие, Rabbit посылает сообщение в нужную очередь. Если соответствие не найдено, то сообщение игнорируется.

Такое разделение позволяет изолировать продюсера от логики распределения сообщений по очередям.

Используя такую схему, можно реализовывать разные паттерны рассылки сообщений:

- **direct**: сообщение шлется в одну конкретную очередь. Создаем дефолтную точку обмена с пустым именем. При создании очереди, она автоматически будет привязана к дефолтной точке обмена, используя имя очереди в качестве ключа привязки. После этого достаточно слать сообщения в точку обмена без имени с названием очереди вместо ключа роутинга.
- **fanout**: каждое сообщение шлется сразу на несколько очередей. Для реализации нужно привязать все заинтересованные очереди к одной точке обмена под одним и тем же ключом привязки. Потом этот ключ используем в качестве ключа роутинга и готово.
- **topic**: используем символ * в ключах привязок, легче объяснить картинкой

![Topic exchange](rabbitmq-topic-exchange.png)

Для того, чтобы указать правило привязки *match-all*, нужно использовать символ "#". Его отличие от * в том, что * считает знак "." разделителем частей и матчит любой текст только лишь в соответствующей части ключа. То есть logs.* === logs.critical, но logs.* != logs.critical.minor.

### Виртуальные хосты

Внутри одного сервера RabbitMQ можно запустить несколько виртуальных инстансов RabbitMQ, которые будут друг от друга полностью изолированы. При старте RabbitMQ автоматически создает один дефолтный vhost. 

Добавление и удаление виртуальных хостов осуществляется командами `rabbitmqctl add_vhost [vhost_name]` и `rabbitmqctl delete_vhost [vhost_name]`.

### Гарантии доставки

Чтобы сообщения не терялись никогда, должны быть выполнены 3 условия:

1. очередь должна быть durable
2. точка обмена тоже должна быть durable
3. для сообщения должен быть указан *delivery mode=2*. 

Только в этом случае гарантируется надежное хранение сообщения вплоть до момента, когда поступит подтверждение от консюмера, получившего его. После этого RabbitMQ помечает сообщение, как мусор для сборщика мусора.

#### Confirm mode

Для повышенных гарантий доставки на стороне продюсера, можно перевести канал в confirm mode. В этом режиме каждому сообщению присваивается уникальный идентификатор. Когда сообщение доставлено всем нужным очередям, канал отправит продюсеру *publisher confirm* с идентификатором сообщения и атрибутом метода = Ack. Если сообщение и очереди устойчивы (durable), то конфирм придет только после того, как сообщение будет записано на диск.

Если из-за внутренних ошибок RabbitMQ сообщение утеряно, то в продюсер будет отправлен конфирм с атрибутом метода = Nack.

## Кластеризация

TODO: все очень плохо с репликацией






