---
title: "Riak"
path: "/blog/riak"
---
# Riak

Сложные динамические запросы к Riak, использующие индексы, map reduce и прочее - очень медленные. Riak быстрый только когда получаем записи по ключу. 

Ключи могут использоваться как неймспейсы. Ключ должен вычислят со как функция от содержимого.

**Bucket** это всего лишь namespace, он никак не отделен физически от других бакетов. Riak просто использует его название при составлении полного ключа. Поэтому чтобы получить все сущности из одного бакета, ему приходится просмотреть вообще все сущности

Есть 2 стратегии разрешения конфликтов: `last_write_wins` и `allow_mult`. Первая просто берет ту запись, которая пришла позже, вторая - позволяет хранить несколько конфликтных копий с тем, чтобы приложение само из них выбрало. 

Когда в кластере появляется или исчезает новая нода, партишены равномерно распределяются между всеми нодами и новой ноде присылают все значения, за которые она теперь отвечает. Аналогично, когда нода не способна отвечать, за нее отмечают соседние ноды, а когда она появится в сети, они ей расскажут все, что произошло за ее отсутствие (**hinted handoff**). 

Конфигурация кольца распространяется посредством протокола слухов (**gossip protocol**) и известна всем нодам.

Когда узел получает значение, он его реплицирует на следующие N-1 партишенов.
