---
title: "Algorithms"
path: "/blog/algorithms"
---

# Алгоритмы

## Сумма двух

Имея массив целых чисел, нужно вернуть индексы двух элементов, сумма которых будет равна заданному числу

### Пример

Допустим, у нас есть массив `nums == [2, 7, 11, 15]` и нужно получить число 9.

Так как `nums[0] + nums[1] == 2 + 7 == 9`, то возвращаем массив индексов `[0,1]`.

### Решение

1.  Сортируем массив по возрастанию;
2.  Идем по массиву с двух концов навстречу друг другу счетчиками i (слева) и j (справа);
3.  Если `nums[i] + nums[j] < target`, то увеличиваем i;
4.  Иначе, если `nums[i] + nums[j] > target`, то уменьшаем j;
5.  Если же `nums[i] + nums[j] == target`, то очевидно возвращаем `[i, j]`.

## Самая длинная подстрока без повторяющихся символов

Имея строку, найти в ней самую длинную подстроку без повторяющихся символов.

### Примеры

"abcabcbb" => "abc"

"bbbbb" => "b"

pwwkew => "wke"

### Решение

Для решения используем так называемое скользящее окно - это подстрока нашей входной строки `input`, которая не содержит повторяющихся символов, начинается в начале `input` и постепенно движется (скользит) по направлению к ее концу.

Нам понадобится словарь символов, у которого ключом будет символ, а значением - индекс последнего такого символа в строке, который нам встретился. Назовем этот словарь **s**. Если известно, что все символы входят в некое подмножество/алфавит (например, символы латинского алфавита a-z), то можно вместо словаря использовать массив на `n` элементов, где n = длина алфавита.

1.  Инициализируем `start=0`, это будет левая граница нашего скользящего окна.
2.  Идем счетчиком `i` с левого края.
3.  Если `s` содержит `input[i]` и `s[input[i]]>=start`, то мы встретили первый повторяющийся символ в текущем окне.
    1.  Длина соответствующей подстроки равна `i-start+1`, нужно ее сравнить с текущим максимумом. Если эта длина больше текущего максимума, то запоминаем строку и обновляем максимум.
    2.  Теперь нам нужно сдвинуть левый край окна и мы можем его сдвинуть сразу к символу справа от первого (левого) повторяющегося символа из нашей пары, т.к. для любого края левее этого, подстрока уже заведомо будет содержать повторяющийся символ. Таким образом, `start = s[input[i]] + 1`.
4.  Запоминаем в наше множество индекс текущего символа: `s[input[i]] = i`.

## Медиана 2 отсортированных массивов

Имея 2 отсортированных массива, найти их медиану. Сложность должна быть `O(log(n+m))`. Медиана - это число, разделяющее множество на 2 подмножества одинаковой длины, одно из которых всегда меньше другого.

### Пример

Для массивов [1, 3] и [2] медиана равна 2.0.

Для [1, 2] и [3, 4] медиана равна (2 + 3) / 2 = 2.5

### Решение

Пусть на входе у нас есть массивы `a` и `b`, обозначим их длины как `m` и `n` соответственно.

Чтобы выполнить условия задачи, нам нужно разбить входное множество, состоящее из элементов массивов `m` и `n` на 2 подмножества, удовлетворяющие следующим критериям:

1.  Критерий равенства длин - в подмножествах одинаковое количество элементов.
2.  Критерий соотношения граничных элементов отсортированных подмножеств - максимальный элемент левого подмножества должен быть меньше или равен минимальному элементу правого.

Сейчас обьясню, что это значит. Допустим, мы разбиваем массив A в точке i, а массив B в точке j.

```
left | right

A[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1]

B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1]
```

Тогда условия будут выглядеть так:

1.  `len(left) == len(right) -> i + j == (m - i) + (n - j) -> j == (m + n) / 2 - i -> (учтем нечетные длины, прибавив к числителю 1) j == (m + n + 1) / 2 - i`
2.  `max(left) <= min(right) -> A[i-1] <= B[j] && B[j-1] <= A[i]`

Если эти условия соблюдены, то искомая медиана будет равна:

`median = (max(left) + min(right)) / 2`

Значит, задача свелась к следующей:

> Найти `i` в `[0, m]`, такую, что:
> `A[i-1] <= B[j] && B[j-1] <= A[i] где j = (m + n + 1) / 2 - i`

Это мы можем сделать половинным делением.

Когда нашли i, медиана будет равна:

> `max(A[i-1], B[j-1])`, если `m+n` нечетное
> и `(max(A[i-1], B[j-1]) + min(A[i], B[j])) / 2`, если `m+n` четное

## Найти подмассив с максимальной суммой

### Вариант 1. Разделяй и властвуй

Делим массив на 2 половины и возвращаем максимум из:

1.  максимальная сумма в левой половине
2.  максимальная сумма в правой половине
3.  максимальная сумма в подмассиве, пересекающем середину

1 и 2 пункт - это просто рекурсивные вызовы.

3 пункт посложнее - там нужно от середины идти влево и вправо, и считать масимальную сумму элементов левой и правой половины, а потом суммировать их.

Рассмотрим пример, допустим у нас такой массив:

    6 1 -3 4 -1 3 -5 4

Максимальная сумма идущих подряд элементов в левой половине = 7 для последовательности `6 1`.

Максимальная сумма идущих подряд элементов в правой половине = 4 для последовательности `4`.

Максимальная сумма в подмассиве, пересекающем середину - складывается из:

* максимальной суммы идущих подряд элементов левой половины, включающих самый **правый** элемент левой половины. В данном случае это 8 для последовательности `6 1 -3 4`.
* максимальной суммы идущих подряд элементов правой половины, включающих самый **левый** элемент правой половины. В данном случае это 2 для последовательности `-1 3`.

Получили максимальную сумму в подмассиве, пересекающем середину = 8 + 2 = 10.

Результат выбираем как максимум из трех полученных максимумов, то есть `max(7, 4, 10) == 10`, то есть последовательность `6 1 -3 4 -1 3`.

Сложность - `O(nlogn)`

### Вариант 2. Алгоритм Кадане.

Алгоритм Кадане - это специализированный алгоритм именно для этой задачи. Объяснять это словами будет тяжело, лучше сразу кодом.

На псевдокоде описывается очень просто:

```
Initialize:
max_so_far = 0
max_ending_here = 0

Loop for each element of the array:
  max_ending_here = max_ending_here + a[i]
  if(max_ending_here < 0)
    max_ending_here = 0
  if(max_so_far < max_ending_here)
    max_so_far = max_ending_here
return max_so_far
```

Идея так же проста - идем по массиву скользящим окном, ищем последовательные подмассивы, сумма которых больше нуля и берем максимальную сумму из них.

Пример:

    2 -3 8 -1

Алгоритм выдаст 8 и это правильно.

Если бы кусок перед 8 выдавал результат больше нуля, то он бы увеличивал масимальную сумму и мы бы его взяли.

Если он меньше нуля, то он точно уменьшает сумму и мы его не берем.

Более сложный пример:

	3 2 -7 2 1 -2 4 -1 3 -5 4

Идем слева направо, считаем сумму:

```
3 => max = 3
3 + 2 = 5 => max = 5
3 + 2 - 7 = -2 < 0 начинаем считать заново
2 < max
2 + 1 = 3 < max
2 + 1 - 2 = 1 < max
2 + 1 - 2 + 4 = 5 == max
2 + 1 - 2 + 4 - 1 = 4 < max
2 + 1 - 2 + 4 - 1 + 3 = 7 > max обновляем max = 7
2 + 1 - 2 + 4 - 1 + 3 - 5 = 2 < max
2 + 1 - 2 + 4 - 1 + 3 - 5 + 4 = 6 < max
```

Итог: максимум = 7 для последовательности `2 1 -2 4 -1 3`.

## Найти отсутствующий элемент

Есть массив из N-1 различных чисел от 1 до N. Нужно найти отсутствующий элемент.

### Решение 1

Суммируем все элементы массива и вычитаем результат из ожидаемой суммы всех чисел от 1 до N, которая равна `n \* (n+1) / 2`. Результат вычитания будет ответом.

### Решение 2

XOR-им все числа от 1 до N, затем поверх этого XOR-им все элементы нашего массива. Результат будет ответом.

Вот почему это работает:

    (A1 ^ A2 ^ A3) ^ (A1 ^ A3) = (A1 ^ A1) ^ A2 ^ (A3 ^ A3) = 0 ^ A2 ^ 0 = A2

## Найти точку эквилибриума в массиве

Точка эквилибриума - это такой элемент массива, у которого сумма всех элементов слева равна сумме всех элементов справа.

### Решение 1

Допустим, наш исходный массив `input` равен `[1, 2, 3, 4, 5, 6, 7, 2, 9, 10]`.

Создаем массив аггрегированных сумм, где каждый `i`-й элемент равен сумме элементов `0..i-1` исходного массива. Полученный массив `sums` будет таким: `[1, 3, 6, 10, 15, 21, 28, 30, 39, 49]`

Теперь идем по `input` справа налево и так же считаем аггрегированные суммы, но на каждом шаге сравниваем полученный элемент с элементом массива `sums`, стоящим на 2 позиции левее.

Потом идем справа налево, так же считаем подвижную сумму и сравниваем ее с элементом в массиве сумм на 2 левее текущего. Как только эти значения становятся равны, мы останавливаемся и выдаем в качестве результата элемент, стоящий между ними.

Для нашего примера, идем по `input` справа налево и считаем аггрегированную сумму `rsum`:

1.  Крайний правый элемент `input` равен 10, значит `rsum = 10`. Индекс крайнего правого элемента равен **9**, сравниваем его с `sum[7]==30`. **10 < 30**, поэтому продолжаем.
2.  Следующий справа элемент `input[8]` равен 9, сумма `rsum` становится **10+9=19**, индекс равен **8**, сравниваем с `sum[6]==28`. **19<28**, продолжаем.
3.  Следующий справа элемент `input[7]` равен 2, сумма `rsum` становится **19+2=21**, индекс равен **7**, сравниваем с `sum[5]==21`. **21==21**, условие выхода выполнилось. Индекс эквилибриума равен **7-1==6**, поэтому возвращаем `input[6] == 7`.

Недостаток этого решения в том, что нужен дополнительный массив.

### Решение 2

Этот вариант решения сложнее для реализации, но ему не нужен дополнительный массив.

```
Считаем сумму всех элементов массива sum
leftsum = 0
rightsum = sum
Идем по массиву слева направо, на каждом шаге:
  rightsum -= a[i]
  Если leftsum == rightsum, то точка эквилибриума найдена
  leftsum += a[i]
```

Рассмотрим на нашем примере `[1, 2, 3, 4, 5, 6, 7, 2, 9, 10]`.

| i   | a[i] | rightsum | leftsum |
| --- | ---- | -------- | ------- |
| -   | -    | 49       | 0       |
| 0   | 1    | 48       | 1       |
| 1   | 2    | 46       | 3       |
| 2   | 3    | 43       | 6       |
| 3   | 4    | 39       | 10      |
| 4   | 5    | 34       | 15      |
| 5   | 6    | 28       | 21      |
| 6   | 7    | 21       | 21      |

В последней строке суммы сошлись, точка эквилибриума найдена, возвращаем `a[i]`==**7**.

## External sorting (внешняя сортировка)

Применяется для сортировки огромных массивов данных, которые не уменьшаются в память. Массив делится на чанки, помещающиеся в память, каждый из чанков сортируется и пишется на диск. Затем из каждого файла берется начальный мини-чанк и между мини-чанками производится merging на диск. Когда какой-то из мини-чанков пустеет, он заполняется следующими данными из своего файла.

### Пример

Есть 900 МБ файл и 100 МБ памяти.

1.  Делим файл на 9 чанков по 100 МБ, сортируем каждый quicksort-ом и пишем в отдельный файл на диске.
2.  Из каждого файла берем первые 10 МБ (мини-чанки) и еще 10 МБ выделяем на выходной буфер.
3.  Проходим по 9 мини-чанкам, берем первый элемент, ищем минимальный. Когда нашли - аппендим его в выходной буфер, а из мини-чанка удаляем.
4.  Если после очередного удаления мини-чанк опустел, то заполняем его следующими 10 МБ из его файла.
5.  Если после очередной записи в выходной буфер он заполнился, то флашим его на диск и очищаем.

Этап мержа (шаг 3) здесь неэффективен, так как требует приблизительно `N * (k - 1)` сравнений.

Можно на этом этапе использовать [min-heap](<https://en.wikipedia.org/wiki/Heap_(data_structure)>) с ключом равным первому элементу чанка.

## QuickSort

```csharp
public static class QuickSort
{
	public static void Sort<T>(T[] input) where T:IComparable
	{
		SortImpl(input, 0, input.Length);
	}
	private static void SortImpl<T>(T[] a, int lo, int hi) where T : IComparable
	{
		if (hi - lo <= 1) return;
		T pivot = a[lo];
		int l = lo, r = hi - 1;
		while (l <= r)
		{
			while (a[l].CompareTo(pivot) < 0 && l < hi) l++;
			while (a[r].CompareTo(pivot) > 0 && r >= lo) r--;
			if (l <= r)
			{
				Swap(a, l, r);
				l++;
				r--;
			}
		}

		Swap(a, lo, l - 1);
		SortImpl<T>(a, lo, l);
		SortImpl<T>(a, l, hi);
	}

	private static void Swap<T>(T[] input, int a, int b)
	{
		T tmp = input[a];
		input[a] = input[b];
		input[b] = tmp;
	}
}
```

## Красно-черные деревья

Это бинарные поисковые деревья, удовлетворяющие следующим условиям:

1.  Каждый узел может быть либо красным, либо черным
2.  Корень всегда черный
3.  Родителем красного узла не может быть красный узел
4.  Для каждого листового узла количество черных узлов на пути до корня одинаково

Для обеспечения этих свойств при вставке узла проводится ребалансировка дерева. Сначала пробуем **перекрашивание**, если оно не работает, то **вращение**. Если дядя красный, то перекрашиваем, если черный - то вращаем и/или перекрашиваем.

Алгоритм вставки (x - вставляемый узел):

1.  Делаем x красным и производим стандартную вставку в поисковое бинарное дерево
2.  Если x - корень, то делаем его черным и завершаем вставку, иначе - красным
3.  Если родитель x - красный и он корень, то просто делаем его черным и завершаем вставку
4.  Если x не корень или родитель x не черный (в этом случае дедушка точно будет черный), то мы получили **красный-красный-черный**, что нарушает свойство 3. Попробуем это исправить:
    1.  если дядя x - красный, то мы можем просто перекрасить папу и дядю, так как они оба красные и перекрашивание их в черный увеличит количество черных узлов для обоих ветвей деда и не нарушит свойство 4. Однако чтобы не менять количество черных в ветвях нашего поддерева и чтобы не пришлось ребалансировать поддерево брата деда, мы еще и перекрашиваем деда в красный:
    2.  перекрашиваем родителя и дядю в черный
    3.  перекрашиваем деда в красный

![red-black tree](./redBlackCase2.png 'red black case')

5.  eсли дяди нет, или дядя х - черный, то мы не можем перекрасить папу в черный, т.к. это увеличит количество черных узлов на одной ветви, оставим неизменным на остальных и автоматически нарушится свойство 4. Поэтому приходится вертеть:
    1.  p - parent узла х, g - grandfather узла х
    2.  возможны 4 случая:
    3.  p слева от g, x слева от p
    4.  p слева от g, x справа от p
    5.  p справа от g, x справа от p
    6.  p справа от g, x слева от p
    7.  Для каждого из этих 4 случаев нам нужно нарушающий свойство 3 путь от x вида **красный-красный-черный** в **красный с двумя черными детьми**. Как это сделать - смотрим на картинке (картинка из другой книги, поэтому там добавляемый узел - не x, а просто тот, который самый нижний и в кружочке. На этих случаях всегда x < y < z, поэтому y в результате становится корнем поддерева:

![red-black tree](./redBlackCase3.png 'red black case')

6. После этого нужно перекрасить наше поддерево, сделав корень черным, а его детей красным.

Вращение дерева:

![tree rotation](./Tree_Rotations.gif 'tree rotation')