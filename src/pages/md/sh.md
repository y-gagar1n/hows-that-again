---
title: "sh"
path: "/blog/sh"
---
# sh


## Parameter expansion

```
for i in 1 2 
do
	my_secret_process ${i}_tmp
done
```

Такая форма записи позволит подставить 1_tmp и 2_tmp. Если делать без скобок, то получится пустота, так как у нас нет переменной i_tmp

## Чтение переменных

```sh
FOO=bar
echo "Hello, $FOO!"   # Hello, bar! - сработает только с двойными кавычками, так как они слабые
echo 'Hello, $FOO!'   # Hello, $FOO! - не сработает, так как одинарные кавычки - строгие
```

## xargs

```
xargs -I % ls /% | head
```

`xargs [OPTIONS] COMMAND` - будет читать аргументы из ввода и подставлять их в команду. -I % означает, что плейсхолдер для аргумента обозначается знаком процента.

## grep

`grep -E [a-z]{10}` - регулярное выражение

`grep a[[:blank:]]` - ищем все слова, кончающиеся на а

`grep -c PATTERN` - выводит не строчки, а количество вхождений паттерна в файле

## find

`find -type f -exec grep PATTERN {} \;` : **-exec** позволяет выполнить указанную после него команду для каждого найденного файла. {} - плейсхолдер для полного пути файла. \; - конец команды.

## Выход из скрипта после первой провалившейся команды

Нужно вставить в начало скрипта:

```sh
set -e
```

## Отладка

`sh -n <script>` -проверка на синтаксические ошибки

`sh -v <script>` - выводит все команды на экран перед выполнением

`sh -x <script>` - тоже выводит, но после подстановки всех переменных и прочей обработки

`sh -u <script>` - выводит ошибку, если используется неопределенная переменная

```
set -o xtrace
...
set +o xtrace
```

Такой код можно написать вокруг проблемного участка кода, чтобы только в этом коде выводить на экран команды с подстановкой переменных.

`trap ‘echo Exiting: critical variable = $critical_variable’ EXIT` - а так мы можем выводить значение интересующей нас переменнойперед выходом из скрипта