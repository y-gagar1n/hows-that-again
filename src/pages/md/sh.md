---
title: "sh"
path: "/blog/sh"
---
# sh


## Parameter expansion

```
for i in 1 2 
do
	my_secret_process ${i}_tmp
done
```

Такая форма записи позволит подставить 1_tmp и 2_tmp. Если делать без скобок, то получится пустота, так как у нас нет переменной i_tmp

## Чтение переменных

```sh
FOO=bar
echo "Hello, $FOO!"   # Hello, bar! - сработает только с двойными кавычками, так как они слабые
echo 'Hello, $FOO!'   # Hello, $FOO! - не сработает, так как одинарные кавычки - строгие
```

## Специальные переменные

- `$0` - название скрипта
- `$1, $2, $3...` - первый, второй, третий аргумент
- `$#` - количество аргументов
- `$@` - все аргументы
- `$$` - текущий PID
- `$?` - exit code последней выполненной команды

## Условия

```sh
if [ "$1" = "hi" ]; then
	echo "hello"
else
	echo "bye"
fi
```

Кавычки вокруг `$1` и `hi` не обязательнц, но нужны на случай, если в `$1` будет пустота, либо слова со спец. символами.

Причем **[** здесь - это симлинк к команде  **test**:

```sh
$ type -a [
[ is a shell builtin
[ is /bin/[
```

Таким образом, `if` просто проверяет, равен ли 0 результат следующего за ним `test`.

**Проверки для файлов:**

- `-f`: есть ли такой обычный файл на диске (`if [ -f 'filename.txt' ]`)
- `-d`: есть ли такая директория
- `-e`: есть ли такой файловый дескриптор
- `-s`: true, если файл есть и не пустой
- `-h`: есть ли такой симлинк
- `-a`: логическое "и" (`if [ -f file1 -a file2 ]`)
- `-o`: логическое "или"
- `-r`: читаемый
- `-w`: редактируемый
- `-x`: выполняемый
- `-nt`: newer than (`if [ file1 -nt file2 ]`)
- `-ot`: older than

Все эти команды (кроме `-h`) поддерживают симлинки. То есть если **link** это симлинк на файл, то `[ -f link ]` вернет 0.

**Проверки для строк:**

- `-z`: true, если строка пуста
- `-n`: true, если строка не пуста

**Арифметические проверки:**

ВАЖНО: `=` проверяет на равенство только строки, **но не числа**.

Обратить условие можно, добавив **!** перед ним: `if [ ! -f 'filename.txt' ]`. Для проверки чисел на равенство, нужно использовать `-eq`.

- `-eq`: equal
- `-ne`: not equal
- `-lt`: less than
- `-gt`: greater than
- `-le`: less than or equal
- `-ge`: greater than or equal

Вслед за `if` может идти любая команда, поэтому и нужна ";" перед `then`. Если не указать точку с запятой, то `then` будет распознана как аргумент команды. Можно не писать точку с запятой, но тогда `then` должен быть на следующей строчке.

Пример другой команды:

```sh
if grep -q daemon /etc/passwd; then
   echo The daemon user is in the passwd file.
else
   echo There is a big problem. daemon is not in the passwd file.
fi
```

## switch-case

```sh
case $1 in
	bye)
		echo Fine, bye.
		;; 
	hi|hello)
		echo Nice to see you.
		;;
	what*)
		echo Whatever.
		;; 
	*)
		echo 'Huh?'
		;; 
esac
```

## Циклы

### for

```sh
for str in one two three four; do
   echo $str
done
```

```sh
FLAGS=(foo bar baz)
for f in $FLAGS; do
	echo $f
done
```

### while

```sh
FILE=/tmp/whiletest.$$;
echo firstline > $FILE
while tail -10 $FILE | grep -q firstline; do
	# add lines to $FILE until tail -10 $FILE no longer prints "firstline" 
	echo -n Number of lines in $FILE:' '
	wc -l $FILE | awk '{print $1}'
	echo newline >> $FILE
done

rm -f $FILE
```

## xargs

```
xargs -I % ls /% | head
```

`xargs [OPTIONS] COMMAND` - будет читать аргументы из ввода и подставлять их в команду. -I % означает, что плейсхолдер для аргумента обозначается знаком процента.

## grep

`grep -R def .` - рекурсивно ищет "def" во всех файлах текущей директории

`grep -E [a-z]{10}` - регулярное выражение

`grep a[[:blank:]]` - ищем все слова, кончающиеся на а

`grep -c PATTERN` - выводит не строчки, а количество вхождений паттерна в файле

## find

`find . -name "*setup*"` - рекурсивно искать все файлы с именем, содержащим **setup**, начиная с текущей директории

`find -type f -exec grep PATTERN {} \;` : **-exec** позволяет выполнить указанную после него команду для каждого найденного файла. {} - плейсхолдер для полного пути файла. \; - конец команды.

## Выход из скрипта после первой провалившейся команды

Нужно вставить в начало скрипта:

```sh
set -e
```

## Отладка

`sh -n <script>` -проверка на синтаксические ошибки

`sh -v <script>` - выводит все команды на экран перед выполнением

`sh -x <script>` - тоже выводит, но после подстановки всех переменных и прочей обработки

`sh -u <script>` - выводит ошибку, если используется неопределенная переменная

```
set -o xtrace
...
set +o xtrace
```

Такой код можно написать вокруг проблемного участка кода, чтобы только в этом коде выводить на экран команды с подстановкой переменных.

`trap ‘echo Exiting: critical variable = $critical_variable’ EXIT` - а так мы можем выводить значение интересующей нас переменной перед выходом из скрипта