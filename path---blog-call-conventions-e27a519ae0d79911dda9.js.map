{"version":3,"sources":["webpack:///path---blog-call-conventions-e27a519ae0d79911dda9.js","webpack:///./.cache/json/blog-call-conventions.json"],"names":["webpackJsonp","423","module","exports","data","markdownRemark","html","frontmatter","path","title","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,o7XAA4tUC,aAA2wDC,KAAA,yBAAAC,MAAA,sBAA6DC","file":"path---blog-call-conventions-e27a519ae0d79911dda9.js","sourcesContent":["webpackJsonp([109290739445578],{\n\n/***/ 423:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p><a href=\\\"https://en.wikibooks.org/wiki/X86_Disassembly/Functions_and_Stack_Frames\\\">Вики</a></p>\\n<p>(<a href=\\\"https://stackoverflow.com/questions/1395591/what-is-exactly-the-base-pointer-and-stack-pointer-to-what-do-they-point\\\">https://stackoverflow.com/questions/1395591/what-is-exactly-the-base-pointer-and-stack-pointer-to-what-do-they-point</a>)</p>\\n<pre><code>**TL;DR**: Для x86 в винде используется **stdcall**, в линуксе **cdecl**\\nДля x64 везде используется **fastcall**, но в винде и в линуксе используются разные регистры (и разное их количество) для сохранения первых аргументов.\\n</code></pre>\\n<p>В X86 8 32-битных регистров.</p>\\n<p>В X64 регистры 16 64-битных. 64-битные версии Е* регистров называются R*. Дополнительные регистры получили названия r8...r15.</p>\\n<p>В X86 инструкция MOV A, B означает, что значение B копируется в A.</p>\\n<p>ESP - stack pointer. Указывает на вершину стэка. Операции push и pop берут из него адрес, по которому обращаться к стэку, а затем меняют значение этого регистра. После пролога функции все локальные переменные и аргументы оказываются выше его.</p>\\n<p>EBP - frame pointer. Все аргументы функции и адрес возврата находятся выше его, а локальные переменные - ниже.</p>\\n<p>Обычно функция начинается с автосгенерированного пролога:</p>\\n<pre><code>push ebp ; Preserve current frame pointer - сохраняем его, чтобы после выхода из функции наш caller смог обращаться к своим локальным переменным\\n`mov ebp, esp ; Create new frame pointer pointing to current stack top`\\nsub esp, 20 ; allocate 20 bytes worth of locals on stack.\\n</code></pre>\\n<p>Именно после этого ebp будет указывать на начало текущего фрейма, а esp - на его конец.</p>\\n<p>Затем в коде обращение к локальным переменным может выглядеть так:</p>\\n<pre><code>`mov [ebp-4], eax ; Store eax in first local\\nmov ebx, [ebp - 8] ; Load ebx from second local`&#x3C;/div>\\n</code></pre>\\n<p>А выход из функции (эпилог) выглядит так:</p>\\n<pre><code>`mov esp, ebp ;\\npop ebp ;\\nret\\n</code></pre>\\n<p>Для перечисленных ниже соглашений (кроме <code>[cdecl]</code> перед возвратом значений из функции подпрограмма обязана восстановить значения сегментных регистров, регистров <code>esp</code> и <code>ebp</code>. Значения остальных регистров могут не восстанавливаться.</p>\\n<p>Если размер возвращаемого значения функции не больше размера регистра <code>eax</code>, возвращаемое значение сохраняется в регистре <code>eax</code>. Иначе, возвращаемое значение сохраняется на вершине стека, а указатель на вершину стека сохраняется в регистре <code>eax</code>.</p>\\n<h3>cdecl</h3>\\n<p><code>cdecl</code> (сокращение от англ. c declaration) — соглашение о вызовах, используемое компиляторами для языка Си.</p>\\n<p>Аргументы функций передаются через стек, справа налево. Аргументы, размер которых меньше 4-х байт, расширяются до 4-х байт. Очистку стека производит <strong>вызывающая</strong> программа. Это основной способ вызова функций с переменным числом аргументов (например, <code>[printf()](https://ru.wikipedia.org/wiki/Printf)</code>). Названия функций имеют префикс '_'. Способы получения возвращаемого значения функции приведены в таблице.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/b9425fe9a118d6287eb920b2d7ba0a4d/a8a2c/calling-convention-return.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 12.153846153846155%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsSAAALEgHS3X78AAAAdklEQVQI1z2JSw6DIAAFvf8NmzYaFBEof0Ttavwsuphk3rzOh8ikvliXkfOCGCWTVEyzZpSG13vg04un37/SFmPdw936QaAv18bhQ6LT1jNrj3EFHzPbftAu9uNHiBEhLXLxqEUTUiXmlVQqKVdKbZS1/ffaNk4KrJX4x41vmgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Таблица 1\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/b9425fe9a118d6287eb920b2d7ba0a4d/10273/calling-convention-return.png\\\"\\n        srcset=\\\"/hows-that-again/static/b9425fe9a118d6287eb920b2d7ba0a4d/9b14a/calling-convention-return.png 163w,\\n/hows-that-again/static/b9425fe9a118d6287eb920b2d7ba0a4d/94962/calling-convention-return.png 325w,\\n/hows-that-again/static/b9425fe9a118d6287eb920b2d7ba0a4d/10273/calling-convention-return.png 650w,\\n/hows-that-again/static/b9425fe9a118d6287eb920b2d7ba0a4d/2fc6f/calling-convention-return.png 975w,\\n/hows-that-again/static/b9425fe9a118d6287eb920b2d7ba0a4d/a8a2c/calling-convention-return.png 1300w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Перед вызовом функции вставляется код, называемый <strong>прологом</strong> и выполняющий следующие действия:</p>\\n<ul>\\n<li>сохранение значений регистров, используемых внутри функции;</li>\\n<li>запись в стек аргументов функции</li>\\n</ul>\\n<p>После вызова функции вставляется код, называемый <strong>эпилогом</strong> и выполняющий следующие действия:</p>\\n<ul>\\n<li>восстановление значений регистров, сохранённых кодом пролога;</li>\\n<li>очистка стека (от локальных переменных).</li>\\n</ul>\\n<p>Пример:</p>\\n<pre><code>    ; // push arguments to the stack, from right to left\\n    push        3\\n    push        2\\n\\n    ; // call the function\\n    call        _sumExample\\n\\n    ; // cleanup the stack by adding the size of the arguments to ESP register\\n    add         esp,8\\n\\n    ; // copy the return value from EAX to a local variable (int c)\\n    mov         dword ptr [c],eax\\n</code></pre>\\n<p>Вызываемая функция выглядит так:</p>\\n<pre><code>; // function prolog\\npush ebp\\nmov ebp,esp\\nsub esp,0C0h\\npush ebx\\npush esi\\npush edi\\nlea edi,[ebp-0C0h]\\nmov ecx,30h\\nmov eax,0CCCCCCCCh\\nrep stos dword ptr [edi]\\n\\n; // return a + b;\\nmov eax,dword ptr [a]\\nadd eax,dword ptr [b]\\n\\n; // function epilog\\npop edi\\npop esi\\npop ebx\\nmov esp,ebp\\npop ebp\\n\\nret\\n</code></pre>\\n<h3>stdcall или winapi</h3>\\n<p><code>stdcall</code> или <code>winapi</code> — соглашение о вызовах, применяемое в Windows для вызова функций WinAPI.</p>\\n<p>Аргументы функций передаются через стек, справа налево. Очистку стека производит вызываемая подпрограмма. Названия функций имеют префикс '_' и постфикс вида '@+необходимое количество байт на стэке'.</p>\\n<p>Пример:</p>\\n<pre><code>; // push arguments to the stack, from right to left\\n  push        3\\n  push        2\\n\\n; // call the function\\n  call        _sumExample@8\\n\\n; // copy the return value from EAX to a local variable (int c)  \\n  mov         dword ptr [c],eax\\n</code></pre>\\n<p>Код функции:</p>\\n<pre><code>; // function prolog goes here (the same code as in the __cdecl example)\\n\\n; //    return a + b;\\n  mov         eax,dword ptr [a]\\n  add         eax,dword ptr [b]\\n\\n; // function epilog goes here (the same code as in the __cdecl example)\\n\\n; // cleanup the stack and return\\n  ret         8\\n</code></pre>\\n<p>Так как очистку стэка производит вызываемая программа, то размер бинарников получается меньше, чем у cdecl. Однако функциям с переменным числом аргументов приходится использовать cdecl, потому что только вызывающий код знает количество аргументов.</p>\\n<h3>fastcall</h3>\\n<p><code>fastcall</code> — общее название соглашений, передающих параметры через регистры (обычно это самый быстрый способ, отсюда название). Если для сохранения всех параметров и промежуточных результатов регистров не достаточно, используется стек.</p>\\n<p>Соглашение о вызовах <code>fastcall</code> не стандартизировано, поэтому используется только для вызова процедур и функций, не экспортируемых из исполняемого модуля и не импортируемых извне.\\nВ компиляторах фирмы Borland для соглашения __fastcall, называемого также register[5], параметры передаются слева направо в регистрах eax, edx, ecx, а если параметров больше трёх — в стеке, также слева направо. Исходное значение указателя на вершину стека (значение регистра esp) возвращает вызываемая подпрограмма.</p>\\n<p>В 32-разрядной версии компилятора фирмы Microsoft, а также в компиляторе GCC, соглашение __fastcall, также называемое __msfastcall, определяет передачу первых двух параметров слева направо в регистрах ecx и edx, а остальные параметры передаются справа налево в стеке. Очистку стека производит вызываемая подпрограмма.</p>\\n<p>Названия функций начинаются с @ и заканчиваются на @ + необходимое количество байт на стэке.</p>\\n<p>Пример:</p>\\n<pre><code>; // put the arguments in the registers EDX and ECX\\n  mov         edx,3\\n  mov         ecx,2\\n\\n; // call the function\\n  call        @fastcallSum@8\\n\\n; // copy the return value from EAX to a local variable (int c)  \\n  mov         dword ptr [c],eax\\n</code></pre>\\n<p>Код функции:</p>\\n<pre><code>; // function prolog\\n\\n  push        ebp  \\n  mov         ebp,esp\\n  sub         esp,0D8h\\n  push        ebx  \\n  push        esi  \\n  push        edi  \\n  push        ecx  \\n  lea         edi,[ebp-0D8h]\\n  mov         ecx,36h\\n  mov         eax,0CCCCCCCCh\\n  rep stos    dword ptr [edi]\\n  pop         ecx  \\n  mov         dword ptr [ebp-14h],edx\\n  mov         dword ptr [ebp-8],ecx\\n; // return a + b;\\n  mov         eax,dword ptr [a]\\n  add         eax,dword ptr [b]\\n;// function epilog  \\n  pop         edi  \\n  pop         esi  \\n  pop         ebx  \\n  mov         esp,ebp\\n  pop         ebp  \\n  ret\\n</code></pre>\\n<h3>thiscall</h3>\\n<p>thiscall — соглашение о вызовах, используемое компиляторами для языка C++ при вызове методов классов в объектно-ориентированном программировании.</p>\\n<p>Аргументы функции передаются через стек, справа налево. Очистку стека производит вызывающая программа. Соглашение thiscall отличается от cdecl соглашения только тем, что указатель на объект, для которого вызывается метод (указатель this), записывается в регистр ecx[8]. Если же используется функция с переменным количеством аргументов, то this кладется на стэк последним.</p>\\n<pre><code>push        3\\npush        2\\nlea         ecx,[sumObj]\\ncall        ?sum@CSum@@QAEHHH@Z            ; CSum::sum\\nmov         dword ptr [s4],eax\\n</code></pre>\\n<p>Код функции:</p>\\n<pre><code>    push        ebp\\n    mov         ebp,esp\\n    sub         esp,0CCh\\n    push        ebx\\n    push        esi\\n    push        edi\\n    push        ecx\\n    lea         edi,[ebp-0CCh]\\n    mov         ecx,33h\\n    mov         eax,0CCCCCCCCh\\n    rep stos    dword ptr [edi]\\n    pop         ecx\\n    mov         dword ptr [ebp-8],ecx\\n    mov         eax,dword ptr [a]\\n    add         eax,dword ptr [b]\\n    pop         edi\\n    pop         esi\\n    pop         ebx\\n    mov         esp,ebp\\n    pop         ebp\\n    ret         8\\n</code></pre>\\n<p>To cut a long story short, we'll outline the main differences between the calling conventions:</p>\\n<ul>\\n<li><code>__cdecl</code> is the default calling convention for C and C++ programs. The advantage of this calling convetion is that it allows functions with a variable number of arguments to be used. The disadvantage is that it creates larger executables.</li>\\n<li><code>__stdcall</code> is used to call Win32 API functions. It does not allow functions to have a variable number of arguments.</li>\\n<li><code>__fastcall</code> attempts to put arguments in registers, rather than on the stack, thus making function calls faster.</li>\\n<li><code>Thiscall</code> calling convention is the default calling convention used by C++ member functions that do not use variable arguments.</li>\\n</ul>\\n<h2>X64</h2>\\n<p>В X64 все Е* регистры называются R*. <a href=\\\"https://msdn.microsoft.com/ru-ru/library/9z1stfyw.aspx\\\">https://msdn.microsoft.com/ru-ru/library/9z1stfyw.aspx</a></p>\\n<p>В X64 используется только __fastcall, причем регистры используются для передачи первых 4 аргументов. Аргументы передаются в регистрах RCX, RDX, R8 и R9.</p>\",\"frontmatter\":{\"path\":\"/blog/call_conventions\",\"title\":\"Call conventions\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---blog-call-conventions-e27a519ae0d79911dda9.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p><a href=\\\"https://en.wikibooks.org/wiki/X86_Disassembly/Functions_and_Stack_Frames\\\">Вики</a></p>\\n<p>(<a href=\\\"https://stackoverflow.com/questions/1395591/what-is-exactly-the-base-pointer-and-stack-pointer-to-what-do-they-point\\\">https://stackoverflow.com/questions/1395591/what-is-exactly-the-base-pointer-and-stack-pointer-to-what-do-they-point</a>)</p>\\n<pre><code>**TL;DR**: Для x86 в винде используется **stdcall**, в линуксе **cdecl**\\nДля x64 везде используется **fastcall**, но в винде и в линуксе используются разные регистры (и разное их количество) для сохранения первых аргументов.\\n</code></pre>\\n<p>В X86 8 32-битных регистров.</p>\\n<p>В X64 регистры 16 64-битных. 64-битные версии Е* регистров называются R*. Дополнительные регистры получили названия r8...r15.</p>\\n<p>В X86 инструкция MOV A, B означает, что значение B копируется в A.</p>\\n<p>ESP - stack pointer. Указывает на вершину стэка. Операции push и pop берут из него адрес, по которому обращаться к стэку, а затем меняют значение этого регистра. После пролога функции все локальные переменные и аргументы оказываются выше его.</p>\\n<p>EBP - frame pointer. Все аргументы функции и адрес возврата находятся выше его, а локальные переменные - ниже.</p>\\n<p>Обычно функция начинается с автосгенерированного пролога:</p>\\n<pre><code>push ebp ; Preserve current frame pointer - сохраняем его, чтобы после выхода из функции наш caller смог обращаться к своим локальным переменным\\n`mov ebp, esp ; Create new frame pointer pointing to current stack top`\\nsub esp, 20 ; allocate 20 bytes worth of locals on stack.\\n</code></pre>\\n<p>Именно после этого ebp будет указывать на начало текущего фрейма, а esp - на его конец.</p>\\n<p>Затем в коде обращение к локальным переменным может выглядеть так:</p>\\n<pre><code>`mov [ebp-4], eax ; Store eax in first local\\nmov ebx, [ebp - 8] ; Load ebx from second local`&#x3C;/div>\\n</code></pre>\\n<p>А выход из функции (эпилог) выглядит так:</p>\\n<pre><code>`mov esp, ebp ;\\npop ebp ;\\nret\\n</code></pre>\\n<p>Для перечисленных ниже соглашений (кроме <code>[cdecl]</code> перед возвратом значений из функции подпрограмма обязана восстановить значения сегментных регистров, регистров <code>esp</code> и <code>ebp</code>. Значения остальных регистров могут не восстанавливаться.</p>\\n<p>Если размер возвращаемого значения функции не больше размера регистра <code>eax</code>, возвращаемое значение сохраняется в регистре <code>eax</code>. Иначе, возвращаемое значение сохраняется на вершине стека, а указатель на вершину стека сохраняется в регистре <code>eax</code>.</p>\\n<h3>cdecl</h3>\\n<p><code>cdecl</code> (сокращение от англ. c declaration) — соглашение о вызовах, используемое компиляторами для языка Си.</p>\\n<p>Аргументы функций передаются через стек, справа налево. Аргументы, размер которых меньше 4-х байт, расширяются до 4-х байт. Очистку стека производит <strong>вызывающая</strong> программа. Это основной способ вызова функций с переменным числом аргументов (например, <code>[printf()](https://ru.wikipedia.org/wiki/Printf)</code>). Названия функций имеют префикс '_'. Способы получения возвращаемого значения функции приведены в таблице.</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/hows-that-again/static/b9425fe9a118d6287eb920b2d7ba0a4d/a8a2c/calling-convention-return.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block;  max-width: 650px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 12.153846153846155%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsSAAALEgHS3X78AAAAdklEQVQI1z2JSw6DIAAFvf8NmzYaFBEof0Ttavwsuphk3rzOh8ikvliXkfOCGCWTVEyzZpSG13vg04un37/SFmPdw936QaAv18bhQ6LT1jNrj3EFHzPbftAu9uNHiBEhLXLxqEUTUiXmlVQqKVdKbZS1/ffaNk4KrJX4x41vmgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"Таблица 1\\\"\\n        title=\\\"\\\"\\n        src=\\\"/hows-that-again/static/b9425fe9a118d6287eb920b2d7ba0a4d/10273/calling-convention-return.png\\\"\\n        srcset=\\\"/hows-that-again/static/b9425fe9a118d6287eb920b2d7ba0a4d/9b14a/calling-convention-return.png 163w,\\n/hows-that-again/static/b9425fe9a118d6287eb920b2d7ba0a4d/94962/calling-convention-return.png 325w,\\n/hows-that-again/static/b9425fe9a118d6287eb920b2d7ba0a4d/10273/calling-convention-return.png 650w,\\n/hows-that-again/static/b9425fe9a118d6287eb920b2d7ba0a4d/2fc6f/calling-convention-return.png 975w,\\n/hows-that-again/static/b9425fe9a118d6287eb920b2d7ba0a4d/a8a2c/calling-convention-return.png 1300w\\\"\\n        sizes=\\\"(max-width: 650px) 100vw, 650px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    </p>\\n<p>Перед вызовом функции вставляется код, называемый <strong>прологом</strong> и выполняющий следующие действия:</p>\\n<ul>\\n<li>сохранение значений регистров, используемых внутри функции;</li>\\n<li>запись в стек аргументов функции</li>\\n</ul>\\n<p>После вызова функции вставляется код, называемый <strong>эпилогом</strong> и выполняющий следующие действия:</p>\\n<ul>\\n<li>восстановление значений регистров, сохранённых кодом пролога;</li>\\n<li>очистка стека (от локальных переменных).</li>\\n</ul>\\n<p>Пример:</p>\\n<pre><code>    ; // push arguments to the stack, from right to left\\n    push        3\\n    push        2\\n\\n    ; // call the function\\n    call        _sumExample\\n\\n    ; // cleanup the stack by adding the size of the arguments to ESP register\\n    add         esp,8\\n\\n    ; // copy the return value from EAX to a local variable (int c)\\n    mov         dword ptr [c],eax\\n</code></pre>\\n<p>Вызываемая функция выглядит так:</p>\\n<pre><code>; // function prolog\\npush ebp\\nmov ebp,esp\\nsub esp,0C0h\\npush ebx\\npush esi\\npush edi\\nlea edi,[ebp-0C0h]\\nmov ecx,30h\\nmov eax,0CCCCCCCCh\\nrep stos dword ptr [edi]\\n\\n; // return a + b;\\nmov eax,dword ptr [a]\\nadd eax,dword ptr [b]\\n\\n; // function epilog\\npop edi\\npop esi\\npop ebx\\nmov esp,ebp\\npop ebp\\n\\nret\\n</code></pre>\\n<h3>stdcall или winapi</h3>\\n<p><code>stdcall</code> или <code>winapi</code> — соглашение о вызовах, применяемое в Windows для вызова функций WinAPI.</p>\\n<p>Аргументы функций передаются через стек, справа налево. Очистку стека производит вызываемая подпрограмма. Названия функций имеют префикс '_' и постфикс вида '@+необходимое количество байт на стэке'.</p>\\n<p>Пример:</p>\\n<pre><code>; // push arguments to the stack, from right to left\\n  push        3\\n  push        2\\n\\n; // call the function\\n  call        _sumExample@8\\n\\n; // copy the return value from EAX to a local variable (int c)  \\n  mov         dword ptr [c],eax\\n</code></pre>\\n<p>Код функции:</p>\\n<pre><code>; // function prolog goes here (the same code as in the __cdecl example)\\n\\n; //    return a + b;\\n  mov         eax,dword ptr [a]\\n  add         eax,dword ptr [b]\\n\\n; // function epilog goes here (the same code as in the __cdecl example)\\n\\n; // cleanup the stack and return\\n  ret         8\\n</code></pre>\\n<p>Так как очистку стэка производит вызываемая программа, то размер бинарников получается меньше, чем у cdecl. Однако функциям с переменным числом аргументов приходится использовать cdecl, потому что только вызывающий код знает количество аргументов.</p>\\n<h3>fastcall</h3>\\n<p><code>fastcall</code> — общее название соглашений, передающих параметры через регистры (обычно это самый быстрый способ, отсюда название). Если для сохранения всех параметров и промежуточных результатов регистров не достаточно, используется стек.</p>\\n<p>Соглашение о вызовах <code>fastcall</code> не стандартизировано, поэтому используется только для вызова процедур и функций, не экспортируемых из исполняемого модуля и не импортируемых извне.\\nВ компиляторах фирмы Borland для соглашения __fastcall, называемого также register[5], параметры передаются слева направо в регистрах eax, edx, ecx, а если параметров больше трёх — в стеке, также слева направо. Исходное значение указателя на вершину стека (значение регистра esp) возвращает вызываемая подпрограмма.</p>\\n<p>В 32-разрядной версии компилятора фирмы Microsoft, а также в компиляторе GCC, соглашение __fastcall, также называемое __msfastcall, определяет передачу первых двух параметров слева направо в регистрах ecx и edx, а остальные параметры передаются справа налево в стеке. Очистку стека производит вызываемая подпрограмма.</p>\\n<p>Названия функций начинаются с @ и заканчиваются на @ + необходимое количество байт на стэке.</p>\\n<p>Пример:</p>\\n<pre><code>; // put the arguments in the registers EDX and ECX\\n  mov         edx,3\\n  mov         ecx,2\\n\\n; // call the function\\n  call        @fastcallSum@8\\n\\n; // copy the return value from EAX to a local variable (int c)  \\n  mov         dword ptr [c],eax\\n</code></pre>\\n<p>Код функции:</p>\\n<pre><code>; // function prolog\\n\\n  push        ebp  \\n  mov         ebp,esp\\n  sub         esp,0D8h\\n  push        ebx  \\n  push        esi  \\n  push        edi  \\n  push        ecx  \\n  lea         edi,[ebp-0D8h]\\n  mov         ecx,36h\\n  mov         eax,0CCCCCCCCh\\n  rep stos    dword ptr [edi]\\n  pop         ecx  \\n  mov         dword ptr [ebp-14h],edx\\n  mov         dword ptr [ebp-8],ecx\\n; // return a + b;\\n  mov         eax,dword ptr [a]\\n  add         eax,dword ptr [b]\\n;// function epilog  \\n  pop         edi  \\n  pop         esi  \\n  pop         ebx  \\n  mov         esp,ebp\\n  pop         ebp  \\n  ret\\n</code></pre>\\n<h3>thiscall</h3>\\n<p>thiscall — соглашение о вызовах, используемое компиляторами для языка C++ при вызове методов классов в объектно-ориентированном программировании.</p>\\n<p>Аргументы функции передаются через стек, справа налево. Очистку стека производит вызывающая программа. Соглашение thiscall отличается от cdecl соглашения только тем, что указатель на объект, для которого вызывается метод (указатель this), записывается в регистр ecx[8]. Если же используется функция с переменным количеством аргументов, то this кладется на стэк последним.</p>\\n<pre><code>push        3\\npush        2\\nlea         ecx,[sumObj]\\ncall        ?sum@CSum@@QAEHHH@Z            ; CSum::sum\\nmov         dword ptr [s4],eax\\n</code></pre>\\n<p>Код функции:</p>\\n<pre><code>    push        ebp\\n    mov         ebp,esp\\n    sub         esp,0CCh\\n    push        ebx\\n    push        esi\\n    push        edi\\n    push        ecx\\n    lea         edi,[ebp-0CCh]\\n    mov         ecx,33h\\n    mov         eax,0CCCCCCCCh\\n    rep stos    dword ptr [edi]\\n    pop         ecx\\n    mov         dword ptr [ebp-8],ecx\\n    mov         eax,dword ptr [a]\\n    add         eax,dword ptr [b]\\n    pop         edi\\n    pop         esi\\n    pop         ebx\\n    mov         esp,ebp\\n    pop         ebp\\n    ret         8\\n</code></pre>\\n<p>To cut a long story short, we'll outline the main differences between the calling conventions:</p>\\n<ul>\\n<li><code>__cdecl</code> is the default calling convention for C and C++ programs. The advantage of this calling convetion is that it allows functions with a variable number of arguments to be used. The disadvantage is that it creates larger executables.</li>\\n<li><code>__stdcall</code> is used to call Win32 API functions. It does not allow functions to have a variable number of arguments.</li>\\n<li><code>__fastcall</code> attempts to put arguments in registers, rather than on the stack, thus making function calls faster.</li>\\n<li><code>Thiscall</code> calling convention is the default calling convention used by C++ member functions that do not use variable arguments.</li>\\n</ul>\\n<h2>X64</h2>\\n<p>В X64 все Е* регистры называются R*. <a href=\\\"https://msdn.microsoft.com/ru-ru/library/9z1stfyw.aspx\\\">https://msdn.microsoft.com/ru-ru/library/9z1stfyw.aspx</a></p>\\n<p>В X64 используется только __fastcall, причем регистры используются для передачи первых 4 аргументов. Аргументы передаются в регистрах RCX, RDX, R8 и R9.</p>\",\"frontmatter\":{\"path\":\"/blog/call_conventions\",\"title\":\"Call conventions\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/blog-call-conventions.json\n// module id = 423\n// module chunks = 109290739445578"],"sourceRoot":""}