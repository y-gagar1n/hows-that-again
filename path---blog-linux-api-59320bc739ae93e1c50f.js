webpackJsonp([79569183618093],{447:function(e,n){e.exports={data:{markdownRemark:{html:'<h1>Работа с аргументами запуска</h1>\n<pre><code class="language-cpp">while ((opt = getopt(argc, argv, "nt:")) != -1) {\n   switch (opt) {\n   case \'n\':\n       flags = 1;\n       break;\n   case \'t\':\n       nsecs = atoi(optarg);\n       tfnd = 1;\n       break;\n   default: /* \'?\' */\n       fprintf(stderr, "Usage: %s [-t nsecs] [-n] name\\n",\n               argv[0]);\n       exit(EXIT_FAILURE);\n   }\n}\n</code></pre>\n<p>Третьим аргументом <code>getopt</code> принимает список допустимых опций. Если после символа стоит двоеточие, значит эта опция принимает аргумент, тогда <code>getopt</code> помещает указатель на текст, последующий за буквой опции, либо весь следующий аргумент, в переменную <code>optarg</code>. Если же там 2 двоеточия, то это означает опциональный аргумент, если он отсутствует, то<code>optarg</code> будет равен нулю.</p>\n<p><code>optind</code> - индекс следующего аргумента, который будет обработан.</p>\n<h1>Работа с файлами</h1>\n<p>3 стандартных дескриптора:</p>\n<ul>\n<li>0: стандартный ввод</li>\n<li>1: стандартный вывод</li>\n<li>2: стандартный поток ошибок</li>\n</ul>\n<h2>Системные вызовы для работы с файлами</h2>\n<ul>\n<li><code>fd = open(pathname, flags, mode)</code>: открывает указанный файл, возвращает его дескриптор. Если окрыть не удалось, вернется отрицательный дескриптор (ошибку можно будет получить через <code>errno</code>). Во флагах через <code>|</code> можно указать, что файл открывается на чтение/запись, что его нужно создать, если он не существует. <code>mode</code> - разрешения файла, если будет создан новый.</li>\n<li><code>numread = read(fd, buffer, count)</code>: читать <code>count</code> байт в буфер. Возвращает количество прочтенных байт, или 0, если достигнут EOF.</li>\n<li><code>numwritten = write(fd, buffer, count)</code>: писать <code>count</code> байт из буфера.</li>\n<li><code>status = close(fd)</code>: закрывает дескриптор и все связанные с ним ресурсы ядра</li>\n</ul>\n<h2>Пример копирования файла</h2>\n<pre><code class="language-c">#include &#x3C;iostream>\n#include &#x3C;fcntl.h>\n#include &#x3C;unistd.h>\n\n#ifndef BUF_SIZE\n#define BUF_SIZE 1024\n#endif\n\nint main(int argc, char *argv[]) {\n    int inputFd, outputFd, openFlags;\n\n    mode_t filePerms;\n    ssize_t numRead;\n\n    char buf[BUF_SIZE];\n\n    if (argc != 3 || argv[1] == "--help") {\n        std::cout &#x3C;&#x3C; "usage: copy old-file new-file" &#x3C;&#x3C; std::endl;\n        exit(EXIT_FAILURE);\n    }\n\n    inputFd = open(argv[1], O_RDONLY);\n    if (inputFd == -1) exit(EXIT_FAILURE);\n\n    openFlags = O_CREAT | O_WRONLY | O_TRUNC;\n    filePerms = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;\n    outputFd = open(argv[2], openFlags, filePerms);\n    if(outputFd == -1) return 1;\n\n    while(numRead = read(inputFd, buf, BUF_SIZE))\n    {\n        if(write(outputFd, buf, numRead) != numRead) exit(EXIT_FAILURE);\n    }\n    if(numRead == -1) exit(EXIT_FAILURE);\n\n    if(close(inputFd) == -1) exit(EXIT_FAILURE);\n    if(close(outputFd) == -1) exit(EXIT_FAILURE);\n\n    exit(EXIT_SUCCESS);\n}\n</code></pre>\n<p>ПРИМЕЧАНИЕ: в C++ стандартный способ работы с файлами - через <code>ofstream</code>, <code>ifstream</code>, <code>fstream</code>:</p>\n<pre><code class="language-cpp">#include &#x3C;iostream>\n#include &#x3C;fstream>\n\nconst static int BUF_SIZE = 4096;\n\nusing std::ios_base;\n\nint main(int argc, char** argv) {\n\n   std::ifstream in(argv[1],\n      ios_base::in | ios_base::binary);  // Use binary mode so we can\n   std::ofstream out(argv[2],            // handle all kinds of file\n      ios_base::out | ios_base::binary); // content.\n   \n   // Make sure the streams opened okay...\n\n   char buf[BUF_SIZE];\n\n   do {\n      in.read(&#x26;buf[0], BUF_SIZE);      // Read at most n bytes into\n      out.write(&#x26;buf[0], in.gcount()); // buf, then write the buf to\n   } while (in.gcount() > 0);          // the output.\n\n   // Check streams for problems...\n\n   in.close();\n   out.close();\n}\n</code></pre>\n<h2>Неблокирующий ввод/вывод</h2>\n<p>Если в <code>open</code> передать флаг <code>O_NONBLOCK</code>, то в случае невозможности выполнить системный вызов I/O (открытие, чтение, запись) будет возвращена ошибка <code>EAGAIN</code> или <code>EWOULDBLOCK</code> в зависимости от вызова, а не блокировка исполнения как обычно.</p>\n<p>Неблокирующий I/O может быть использован с пайпами, очередями FIFO, сокетами, терминалами, псевдотерминалами и т.д. Так как файловые дескрипторы для пайпов и сокетов получаются не через <code>open</code>, то для них флаг активируется через вызов <code>fcntl()</code>.</p>\n<p>Для обычных файлов флаг <code>O_NONBLOCK</code> игнорируется, так как кэш буфера ядра и так гарантирует, что I/O над обычными файлами не блокирующий. </p>\n<h2>Манипуляции с дескриптором открытого файла</h2>\n<p>Системным вызовом <code>fcntl</code> можно управлять дескриптором уже открытого файла, например, поменять флаги открытия.</p>\n<pre><code class="language-cpp">#include &#x3C;unistd.h>\n#include &#x3C;fcntl.h>\n\nint fcntl(int fd, int cmd, ... /* arg */ );\n</code></pre>\n<p>Последний аргумент зависит от второго аргумента <code>cmd</code>, то есть от того действия, которое мы пытаемся осуществить.</p>\n<p>Мы можем:</p>\n<h3>получить флаги</h3>\n<pre><code class="language-cpp">int flags, accessMode;\nflags = fcntl(fd, F_GETFL);\nif(flags == -1) \n    errExit("fcntl");\nif(flags &#x26; O_SYNC)\n    printf("writes are synchronized\\n");\n</code></pre>\n<p>А вот режим доступа проверить не так просто, но все равно можно:</p>\n<pre><code class="language-cpp">accessMode = flags &#x26; O_ACCMODE;\nif(accessMode == O_WRONLY || accessMode == O_RDWR)\n    printf("file is writable\\n");\n</code></pre>\n<h3>установить флаги</h3>\n<p>Можно модифицировать флаги: <code>O_APPEND</code>, <code>O_NONBLOCK</code>, <code>O_NOATIME</code>, <code>O_ASYNC</code> и <code>O_DIRECT</code>. Попытки модификации других флагов - игнорируются.</p>\n<p>Причем указание флага <code>O_ASYNC</code> в <code>open()</code> тоже игнорируется - его можно установить только через <code>fcntl()</code>.</p>\n<pre><code class="language-cpp">fcntl(fd, F_SETFL, O_ASYNC | O_NONBLOCK);\n</code></pre>\n<h2>Альтернативные модели I/O</h2>\n<p>Традиционная модель работы с файлами имеет 2 существенных недостатка:</p>\n<ul>\n<li>работает только с одним дескриптором одновременно</li>\n<li>каждый системный вызов блокирует выполнение, пока передача данных не завершилась</li>\n</ul>\n<p>В некоторых приложениях нам бывает нужно:</p>\n<ul>\n<li>проверить, возможен ли ввод/вывод в дескриптор, не блокируя исполнение, если невозможен</li>\n<li>монитортиь несколько дескрипторов, пока ввод/вывод станет доступен на любом из них</li>\n</ul>\n<p>Для этого можно использовать неблокирующий I/O или многопроцессность/многопоточность:</p>\n<ul>\n<li>при использовании неблокирующего I/O мы можем открыть N дескрипторов и периодически чтением каждого из них проверять, доступно ли для них I/O. Это, конечно, неэффективно по CPU, а так же при больших интервалах реакция приложения на событие I/O может быть слишком долгой.</li>\n<li>при использовании многопроцессности мы можем создавать новый процесс, чтобы выполнять I/O. Тогда родительский процесс не будет заблокирован, а дочерний заблокируется, пока I/O не будет выполнен. Недостаток - сложно создавать процессы и понадобится какой-то IPC, чтобы сообщать родителю о статусе операции I/O.</li>\n<li>при использовании многопоточности можем создавать для I/O не процесс, а поток. Это менее накладно по ресурсам, но IPC все равно понадобится.</li>\n</ul>\n<p>Чтобы избежать этих недостатков для решения задачи слежения за несколькими дескрипторами с целью узнать, когда они станут готовы для I/O (без блокирования) применяются следующие техники</p>\n<h3>Мультиплексирование I/O</h3>\n<p>Позволяет процессу одновременно следить за несколькими дескрипторами, чтобы узнать когда на любом из них становится доступен I/O. </p>\n<p>При этом важно понимать, что событие доступности I/O не означает, что последующий вызов I/O будет передавать данные. Например, для обычных файлов неблокирующий вызов доступен всегда. А вот для сокетов - только когда действительно есть данные для чтения или для отправки.</p>\n<p>Самая старая техника, поэтому главное достоинство - портируемость. Главный недостаток - плохая масштабируемость на большие (сотни и тысячи) количества дескрипторов.</p>\n<p>Мультиплексирование осуществляется вызовами <code>select()</code> и <code>poll()</code>.</p>\n<h4>select()</h4>\n<p>Блокироует выполнение, пока один или несколько дескрипторов не станут готовы</p>\n<pre><code class="language-c">#include &#x3C;sys/time.h>  /* Включать для портируемости */\n#include &#x3C;sys/select.h>\n\nint select(int nfds, fd_set * readfds, fd_set * writefds, fd_set * exceptfds, struct timeval * timeout );\n</code></pre>\n<p>Возвращает количество готовых дескрипторов, 0 при таймауте, -1 при ошибке. Если какой-либо дескриптор указан в нескольких наборах, то он будет учтен соответствующее количество раз.</p>\n<ul>\n<li><code>nfds</code> - число, на 1 большее, чем самый большой дескриптор среди наборов</li>\n<li><code>readfds</code> - набор дескрипторов на чтение</li>\n<li><code>writefds</code> - набор дескрипторов на запись</li>\n<li><code>exceptfds</code> - набор дескрипторов, у которых мы ждем т.н. exception condition (это не имеет ничего общего с ошибками)</li>\n<li><code>timeout</code> - указывает интервал, в течение которого вызов <code>select()</code> заблокирует выполнение, либо же <code>NULL</code>, если нужно ждать бесконечно. Если указать <code>timeval { tv_sec=0, tv_usec=0}</code>, то блокировки не будет вообще, просто сразу ответит, какие дескрипторы уже готовы.</li>\n</ul>\n<p>Вместо любого из наборов можно передать <code>NULL</code>, если этот класс событий нас не интересует.</p>\n<p>Наборы могут иметь размерность, не большую, чем константа <code>FD_SETSIZE</code>, в Линуксе она равна 1024. </p>\n<p>С типом <code>fd_set</code> работаем посредством следующих операций:</p>\n<pre><code class="language-c">#include &#x3C;sys/select.h>\nvoid FD_ZERO(fd_set * fdset );  // инициализирует набор, делая его пустым\nvoid FD_SET(int fd , fd_set * fdset );  // добавляет дескриптор в набор\nvoid FD_CLR(int fd , fd_set * fdset );  // удаляет дескриптор из набора\nint FD_ISSET(int fd , fd_set * fdset ); // возвращает 1, если дескриптор есть в наборе, иначе 0\n</code></pre>\n<p>Вызов <code>select()</code> модифицирует переданные в него наборы <code>fd_set</code> таким образом, что после завершения они содержат набор готовых дескрипторов. Но чтобы узнать эти дескрипторы, придется для каждого из интересующих нас дескрипторов, вызвать <code>FD_ISSET</code>.</p>\n<h4>poll()</h4>\n<p>Работает так же, как и <code>select()</code>, разница лишь в API. В <code>poll()</code> мы предоставляем список дескрипторов, где для каждого указан набор интересующих событий</p>\n<pre><code class="language-c">#include &#x3C;poll.h>\nint poll(struct pollfd fds[], nfds_t nfds, int timeout);\n</code></pre>\n<p>Возвращает количество готовых дескрипторов, 0 при таймауте, -1 при ошибке.</p>\n<p><code>fds[]</code> содержит массив дескрипторов. Сртуктура <code>pollfd</code> имеет следующий вид:</p>\n<pre><code class="language-c">struct pollfd {\n    int fd;         // дескриптор\n    short events;   // бит-маска интересующих ивентов\n    short revents;  // бит-маска выстреливших ивентов\n}\n</code></pre>\n<p><code>nfds</code> - количество элементов в массиве <code>fds</code>.</p>\n<p>Далее приведен список битов, которые могут быть выставлены для <code>events</code> и <code>revents</code>:</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/hows-that-again/static/d290a97e10b14fdde5d5ab83e4a558f2/ee7d1/events-revents-bits.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block;  max-width: 638px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 55.01567398119123%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAABcUlEQVQoz22S2a6CQBBE5/+/zhgJbiDggiAgrogsbU4nTe7DnaRCAz1V1TXjlsulXC4XuV6v4nmezGYzieNY5vO51ovFQtbrtf4LgkAej4fc7/d/AY/bbrdSVZUSbjYb3Zgkifi+rzWEx+NRTqeTpGkqZVlKnue6uSiKCbwfDgdxqEK63+9Vves6VXu9XlojFobhREo/73w31HWtQgi63W4njI0TSNq2lefzOdU0Q4A6pABHTISr2+2mPTwx4mgG/DQSnFJ/v98pCmLAAS4NEPV9L8MwKOh1BE5eOMA+KtinhjjLMiVEFFImIh6A6OfzkaZp9KmHQgMbwPv9Vlc0UpMho0RRpILn81lJEaEHV38XvQ4iHOIUy6jZqZMlJ2quICNDyBnfHBqmawNgZ0QWY1MbOfcSGCHk/GON46hgaYar1UodMgakLMKG1FQtQ66MOUXALjTiQB3SzLWhiWauBDVjUZMfcdBn01jm7MOQ1Yj8AMERNEXs/IPBAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="Events & Revents bits"\n        title=""\n        src="/hows-that-again/static/d290a97e10b14fdde5d5ab83e4a558f2/ee7d1/events-revents-bits.png"\n        srcset="/hows-that-again/static/d290a97e10b14fdde5d5ab83e4a558f2/c235e/events-revents-bits.png 163w,\n/hows-that-again/static/d290a97e10b14fdde5d5ab83e4a558f2/5eba7/events-revents-bits.png 325w,\n/hows-that-again/static/d290a97e10b14fdde5d5ab83e4a558f2/ee7d1/events-revents-bits.png 638w"\n        sizes="(max-width: 638px) 100vw, 638px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>Аргумент <code>timeout</code> ведет себя так же, как и у <code>select()</code>, только с другими ключевыми значениями:</p>\n<ul>\n<li>-1: блокировать без ограничений по времени</li>\n<li>0: не блокировать,сразу возвращать</li>\n<li>\n<blockquote>\n<p>0: означает миллисекунды, сколько ждем</p>\n</blockquote>\n</li>\n</ul>\n<h3>Signal-driven I/O</h3>\n<p>Процесс просит у ядра послать сигнал, когда I/O становится доступен на определенном дескрипторе. На большом количестве дескрипторов эта техника работает лучше, чем мультиплексирование.</p>\n<p>Алгоритм использования таков:</p>\n<ol>\n<li>\n<p>Создаем хэндлер для сигнала <code>SIGIO</code>.</p>\n</li>\n<li>\n<p>Вызовом <code>fnctl()</code> устанавливаем владельца дескриптора файла, то есть процесс, который будет получать сигналы о готовености I/O. Обычно это текущий процесс: <code>fcntl(fd, F_SETOWN, pid);</code></p>\n</li>\n<li>\n<p>Через <code>fcntl()</code> устанавливаем дескриптору флаг <code>O_NONBLOCK</code></p>\n</li>\n<li>\n<p>Через <code>fnctl()</code> включаем signal-driven i/o, выставив флаг <code>O_ASYNC</code>. Это может быть объединено с предыдущим шагом:</p>\n<pre><code class="language-c">flags = fcntl(fd, F_GETFL); \nfcntl(fd, F_SETFL, flags | O_ASYNC | O_NONBLOCK);\n</code></pre>\n</li>\n<li>\n<p>Вызывающий процесс теперь может заниматься своими делами. Когда I/O станет досутпен, ядро сгенерит сигнал и вызовет указанный хэндлер</p>\n</li>\n<li>\n<p>Signal-driven I/O генерирует edge-triggered нотификации. Это значит, что при получении нотификации нужно в цикле читать данные из дескриптора до тех пор, пока не получим ошибку <code>EAGAIN</code> или <code>EWOULDBLOCK</code>.</p>\n</li>\n</ol>\n<h3>epoll</h3>\n<p>Техника, доступная только в линуксе. Объединяет достоинства предыдущих двух техник.</p>\n<p>По сравению с signal-driven имеет преимущества:</p>\n<ul>\n<li>не нужно работать с сигналами</li>\n<li>монжо указать, какой конкретно ивет нас интересует - готовность к чтению, или к записи</li>\n<li>можно выбрать между level-triggered и edge-triggered нотификациями.</li>\n</ul>\n<p>Чтобы использовать аналогичные фичи в модели signal-driven I/O, все равно придется использовать непортируемые линукс-специфичные фичи.</p>\n<h3>libevent</h3>\n<p>Сторонняя библиотека, предоставляющая слой абстракции для мониторинга за файловыми дескрипторами. Использует все вышеперечисленные (и не только) техники и может включать/выключать их в зависимости от ОС.</p>\n<h3>Типы нотификаций</h3>\n<ul>\n<li>Level-triggered: выстреливается, когда дескриптор становится доступен для осуществления системного вызова I/O без блокирования. После этого можно выполнить (а можно и не выполнять) необходимую I/O операцию и повторить мониторинг, чтобы узнать, когда I/O станет доступен снова. Важно, что нам необязательно читать все доступные данные, можем прочитать сколько угодно и повторить мониторинг, просто если мы прочитали не все, то событие выстрелит сразу же.</li>\n<li>Edge-triggered: выстреливается, когда произошла некоторая I/O активность на дескрипторе (нарпример, стали доступны данные для чтения). Отличие в том, что событие не выстрелит, пока не произойдет следующее событие I/O (например, доступна следующая порция данных на чтение). Кроме того, мы обычно не знаем, сколько именно данных нам стало доступно для неблокирующего I/O. Поэтому обычно мы помещаем дескриптор в неблокирующий режим и совершаем операции в цикле, пока не получим ошибку <code>EAGAIN</code> или <code>EWOULDBLOCK</code>.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>I/O model</th>\n<th>Level-triggered?</th>\n<th>Edge-triggered?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>select(), poll()</td>\n<td>X</td>\n<td></td>\n</tr>\n<tr>\n<td>signal-driven</td>\n<td></td>\n<td>X</td>\n</tr>\n<tr>\n<td>epoll</td>\n<td>X</td>\n<td>X</td>\n</tr>\n</tbody>\n</table>\n<h1>Сигналы</h1>\n<p>Сигналы - это, иными словами, "программные прерывания". Они могут быть вызваны ядром в любой момент при наступлении интересующего события, а после выполнения хэндлера, выполнение продолжается с той же строчки, на которой было прервано.</p>\n<h2>Подписка на сигнал</h2>\n<p>Есть два способа: <code>signal()</code> и <code>sigaction()</code>.</p>\n<h3>signal()</h3>\n<p>Этот вызов более старый, но имеет более простое API. Однако у него есть различия в поведении среди различных имплементаций UNIX, поэтому <code>signal()</code> не рекомендуется к использованию в кросс-платформенных системах.</p>\n<pre><code class="language-c">#include &#x3C;signal.h>\n\nvoid ( *signal(int sig, void (*handler)(int)) ) (int);\n</code></pre>\n<ul>\n<li><code>handler</code> - указатель на функцию, принимающую <code>int</code> и возвращающую ничего</li>\n<li><code>signal</code> - фукнция, принимающая <code>int</code> и <code>pointer</code>, а возвращающая указатель на функцию, принимающую <code>int</code> и возвращающую ничего.</li>\n</ul>\n<p>На самом деле <code>signal</code> возвращает указатель на предыдущий хэндлер. Это нужно для установки "временных" хэндлеров, которые можно потом откатить:</p>\n<pre><code class="language-c">void (*oldHandler)(int);\n\noldHandler = signal(SIGINT, newHandler);\n\n/// здесь сигнал SIGINT обрабатывается новым хэндлером\n\nsignal(SIGINT, oldHandler); // возвращаем старый хэндлер\n</code></pre>\n<p>Вместо указателя на хэндлер можно подавать:</p>\n<ul>\n<li><code>SIG_DFL</code> - откатиться к дефолтному хэндлеру</li>\n<li><code>SIG_IGN</code> - игнорировать сигнал</li>\n</ul>\n<h3>sigaction()</h3>\n<p>Имеет более сложный API, но зато позволяет получить хэндлер, не меняя его, а так же позволяет установить некоторые атрибуты, контролирующие, что произойдет, когда хэндлер будет вызван. Помимо этого, <code>sigaction()</code> более портируем, чем <code>signal()</code>.</p>\n<pre><code class="language-c">#include &#x3C;signal.h>\n\nint sigaction(int sig, const struct sigaction *act, struct sigaction *oldact);\n\nstruct sigaction {\n    void (*sa_handler)(int);    // адрес хэндлера\n    sigset_t sa_mask;           // сигналы, заблокированные во время работы хэндлера\n    int sa_flags;               // флаги, контролирующие работу хэндлера\n    void (*sa_restorer)(void);  // не для использования\n};\n</code></pre>\n<p>Так же, как и в <code>signal()</code>, вместо поля <code>sa_handler</code> можно подать <code>SIG_IGN</code> или <code>SIG_DFL</code>.</p>\n<p><code>sa_mask</code> позволяет перечислить сигналы, которым нельзя прерывать выполнение этого хэндлера. Сигнал, который вызван в хэндлер, автоматически занесен в фильтр, то есть сам себя рекурсивно хэндлер сигнала прервать не может.</p>\n<p>Вручную добавлять и убирать сигналы из фильтра процесса можно вызовом <code>sigprocmask()</code>.</p>\n<h3>Наборы сигналов</h3>\n<p>Несколько сигналов могут быть объединены в страктуру <code>sigset_t</code>. Для управления таким множеством есть специальные функции:</p>\n<pre><code class="language-c">#include &#x3C;signal.h>\n\nint sigemptyset(sigset_t *set);     // инициализация нулями, то есть исключает все сигналы\nint sigfillset(sigset_t *set);      // инициализация единицами, то есть включает все сигналы\n\nint sigaddset(sigset_t *set, int sig);  // добавление сигнала в набор\nint sigdelset(sigset_t *set, int sig);  // удаление сигнала из набора\n\nint sigismember(const sigset_t *set, int sig); // 1, если сигнал входит в набор, иначе 0\n\nint sigandset(sigset_t *dest, sigset_t *left, sigset_t *right); // кладет пересечение left и right в dest\nint sigorset(sigset_t *dest, sigset_t *left, sigset_t *right);  // кладет объединение left и right в dest\n\nint sigisemptyset(const sigset_t *set);     // 1, если набор пустой, иначе 0\n</code></pre>\n<h3>kill()</h3>\n<p>С помощью вызова <code>kill()</code> можно послать сигнал другому процессу или группе процессов</p>\n<pre><code class="language-c">#include &#x3C;signal.h>\n\nint kill(pid_t pid, int sig);\n</code></pre>\n<h3>pause()</h3>\n<p>Системный вызов <code>pause()</code> прерывает исполнение до тех пор, пока не будет вызван какой-либо хэндлер сигнала</p>\n<pre><code class="language-c">#include &#x3C;unistd.h>\n\nint pause(void);\n</code></pre>\n<p>Всегда возвращает -1 и выставляет <code>errno</code> в <code>EINTR</code>.</p>',frontmatter:{path:"/blog/linux-api",title:"Linux API"}}},pathContext:{}}}});
//# sourceMappingURL=path---blog-linux-api-59320bc739ae93e1c50f.js.map