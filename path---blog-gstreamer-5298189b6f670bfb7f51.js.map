{"version":3,"sources":["webpack:///path---blog-gstreamer-5298189b6f670bfb7f51.js","webpack:///./.cache/json/blog-gstreamer.json"],"names":["webpackJsonp","440","module","exports","data","markdownRemark","html","frontmatter","path","title","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,iymBAA4hiBC,aAAk7EC,KAAA,kBAAAC,MAAA,eAA+CC","file":"path---blog-gstreamer-5298189b6f670bfb7f51.js","sourcesContent":["webpackJsonp([76495366757855],{\n\n/***/ 440:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>Gstreamer</h1>\\n<p><a href=\\\"https://habr.com/ru/post/251427/\\\">https://habr.com/ru/post/251427/</a></p>\\n<pre><code class=\\\"language-cpp\\\">#include &#x3C;gst/gst.h>\\nint main (int argc, char * argv[]) {\\n\\n    if (argc != 3) {\\n        g_print (\\\"Syntax error\\\\n\\\");\\n        return -1;\\n    }\\n\\n    GstElement *pipeline, *src, *dst;\\n    /* Сюда будет читаться результат попытки запуска потока. */\\n    GstStateChangeReturn ret;\\n    /* bus - это шина конвейера. Через нее мы можем получать сообщения о событиях. */\\n    GstBus *bus;\\n    GstMessage *msg;\\n\\n    /* Инициализация GStreamer */\\n    gst_init (NULL, NULL);\\n\\n    /* Создаем элементы */\\n    pipeline = gst_element_factory_make (\\\"pipeline\\\", \\\"pipe\\\");\\n    src = gst_element_factory_make (\\\"filesrc\\\", \\\"src\\\");\\n    dst = gst_element_factory_make (\\\"filesink\\\", \\\"dst\\\");\\n    if ( !pipeline || !src || !dst ) {\\n        g_printerr (\\\"Unable to create some elements\\\\n\\\");\\n        return -1;\\n    }\\n\\n    /* Добавляем элементы в конвейер */\\n    gst_bin_add_many (GST_BIN(pipeline), src, dst, NULL);\\n\\n    /* И связываем их */\\n    if ( gst_element_link (src, dst) != TRUE )  {\\n        g_printerr (\\\"Elements can not be linked\\\\n\\\");\\n        gst_object_unref (pipeline);\\n        return -1;\\n    }\\n\\n    /* Задаем элементам свойства */\\n    g_object_set (src, \\\"location\\\", argv[1], NULL);\\n    g_object_set (dst, \\\"location\\\", argv[2], NULL);\\n\\n    /* Запускаем конвейер */\\n    ret = gst_element_set_state (pipeline, GST_STATE_PLAYING);\\n    if ( ret == GST_STATE_CHANGE_FAILURE ) {\\n        g_printerr (\\\"Unable to set pipeline to the playing state\\\\n\\\");\\n        gst_object_unref (pipeline);\\n        return -1;\\n    }\\n\\n    /* Мало просто установить режим PLAYING. Нужно ждать либо конца потока, либо \\n     * ошибок. Для начала подключаемся к шине конвейера (эти манипуляции будут \\n     * описаны в следующей статье) */\\n    bus = gst_element_get_bus (pipeline);\\n\\n    /* И ожидаем события на шине. Когда событие произойдет, функция вернет \\n     * сообщение, которое мы будем парсить. */\\n    msg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE, GST_MESSAGE_ERROR | GST_MESSAGE_EOS);\\n\\n    /* Парсим сообщение */\\n    if (msg != NULL)\\n    {\\n        GError *err;\\n        gchar *debug_info;\\n\\n        switch ( GST_MESSAGE_TYPE (msg) )\\n        {\\n            case GST_MESSAGE_ERROR:\\n                gst_message_parse_error (msg, &#x26;err, &#x26;debug_info);\\n                g_printerr (\\\"Error received from element %s: %s\\\\n\\\", GST_OBJECT_NAME (msg->src), err->message);\\n                g_printerr (\\\"Debugging information: %s\\\\n\\\", debug_info ? debug_info : \\\"none\\\");\\n                g_clear_error (&#x26;err);\\n                g_free (debug_info);\\n                break;\\n\\n            case GST_MESSAGE_EOS:\\n                g_print (\\\"We reach End-Of-Stream\\\\n\\\");\\n                break;\\n\\n            default:\\n                g_printerr (\\\"Unexpected message received\\\\n\\\");\\n                break;\\n        }\\n        gst_message_unref (msg);\\n    }\\n\\n    /* Освобождаем ресурсы */\\n    gst_object_unref (bus);\\n    gst_element_set_state (pipeline, GST_STATE_NULL);\\n    gst_object_unref (pipeline);\\n\\n    return 0;\\n}\\n</code></pre>\\n<h2>Типичное создание пайплайна</h2>\\n<pre><code class=\\\"language-cpp\\\">pipeline = gst_pipeline_new (\\\"my-pipeline\\\");\\n\\nbus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));\\ngst_bus_add_signal_watch (bus);\\ng_signal_connect (bus, \\\"message\\\", (GCallback) cb_message,\\n  pipeline);\\n\\nsrc = gst_element_factory_make (\\\"uridecodebin\\\", \\\"src\\\");\\nif (src == NULL)\\ng_error (\\\"Could not create 'uridecodebin' element\\\");\\n\\ng_object_set (src, \\\"uri\\\", argv[1], NULL);\\n\\ncsp = gst_element_factory_make (\\\"videoconvert\\\", \\\"csp\\\");\\nif (csp == NULL)\\ng_error (\\\"Could not create 'videoconvert' element\\\");\\n\\nvs = gst_element_factory_make (\\\"videoscale\\\", \\\"vs\\\");\\nif (csp == NULL)\\ng_error (\\\"Could not create 'videoscale' element\\\");\\n\\nsink = gst_element_factory_make (\\\"autovideosink\\\", \\\"sink\\\");\\nif (sink == NULL)\\ng_error (\\\"Could not create 'autovideosink' element\\\");\\n\\ngst_bin_add_many (GST_BIN (pipeline), src, csp, vs, sink, NULL);\\n</code></pre>\\n<h2>API</h2>\\n<p><code>gst_buffer_map</code> позволяет доставать <code>GstMapInfo</code> из <code>GstBuffer</code></p>\\n<p>У GstMapInfo есть поля:</p>\\n<pre><code class=\\\"language-cpp\\\">guint8 *data;\\ngsize size;\\n</code></pre>\\n<p>Pad probes are best suited for looking at data as it passes through the pipeline. If you need to modify data, you should rather write your own GStreamer element. Base classes like GstAudioFilter, GstVideoFilter or GstBaseTransform make this fairly easy.</p>\\n<p>If you just want to inspect buffers as they pass through the pipeline, you don't even need to set up pad probes. You could also just insert an identity element into the pipeline and connect to its \\\"handoff\\\" signal. The identity element also provides a few useful debugging tools like the dump and last-message properties; the latter is enabled by passing the '-v' switch to gst-launch and setting the silent property on the identity to FALSE.</p>\\n<h2>tcp</h2>\\n<h3>multifdsink</h3>\\n<p><a href=\\\"https://gstreamer.freedesktop.org/documentation/tcp/multifdsink.html?gi-language=c#multifdsink\\\">https://gstreamer.freedesktop.org/documentation/tcp/multifdsink.html?gi-language=c#multifdsink</a></p>\\n<p>Может писать поток в указанные файловые дескрипторы. Дескрипторы добавляются и удаляются через сигналы (<code>add</code>, <code>remove</code>)</p>\\n<h3>tcpclientsink/tcpserversrc</h3>\\n<p>Сами создают сокеты, достаточно передать лишь номер порта</p>\\n<pre><code class=\\\"language-shell\\\">gst-launch-1.0 tcpserversrc port=9999 ! decodebin ! alsasink\\ngst-launch-1.0 filesrc location=/home/yury-timofeev/samples/1.mp3 ! tcpclientsink port=9999\\n</code></pre>\\n<p>Можно и микшировать сразу:</p>\\n<pre><code class=\\\"language-cpp\\\">gst-launch-1.0 tcpserversrc port=9999 ! decodebin ! audiomixer name=mix ! alsasink tcpserversrc port=9998 ! decodebin ! mix.\\ngst-launch-1.0 filesrc location=/home/yury-timofeev/samples/1.mp3 ! tcpclientsink port=9999\\ngst-launch-1.0 filesrc location=/home/yury-timofeev/samples/2.mp3 ! tcpclientsink port=9998\\n</code></pre>\\n<p>При этом если мы хотим использовать <code>decodebin</code> на отправляющей стороне, то нужно поизвращаться:</p>\\n<pre><code class=\\\"language-cpp\\\">gst-launch-1.0 tcpserversrc port=9999 ! audio/x-raw,format=S8,channels=2,rate=48000 ! audioconvert ! alsasink\\n\\ngst-launch-1.0 filesrc location=/home/yury-timofeev/samples/1.mp3 ! decodebin ! audioconvert ! audioresample ! audio/x-raw,format=S8,channels=2,rate=48000 ! tcpclientsink port=9999\\n</code></pre>\\n<h2>Сигналы</h2>\\n<p>Используется концепция сигналов из GObjects (не имеют ничего общего с UNIX-сигналами): <a href=\\\"https://developer.gnome.org/gobject/stable/signal.html\\\">https://developer.gnome.org/gobject/stable/signal.html</a></p>\\n<p>Вот так мы посылаем сигнал в элемент:</p>\\n<pre><code class=\\\"language-cpp\\\">GstElement *sink = gst_bin_get_by_name(GST_BIN(pipeline), \\\"dest\\\");\\ng_signal_emit_by_name(sink, \\\"add\\\", \\\"192.168.1.25\\\", 5004, NULL);\\ng_object_unref(sink);\\n</code></pre>\\n<h2>decodebin, oggdemux</h2>\\n<p><a href=\\\"https://gstreamer.freedesktop.org/documentation/application-development/basics/pads.html#dynamic-or-sometimes-pads\\\">https://gstreamer.freedesktop.org/documentation/application-development/basics/pads.html#dynamic-or-sometimes-pads</a></p>\\n<p>Декодирующие элементы <code>decodebin</code> и <code>oggdemux</code> имеют особую природу. Так как <code>decodebin</code> может работать со многими форматами, а <code>oggdemux</code> может работать с аудио- и видео-потоком, то их синки становятся известны лишь во время выполнения. Поэтому они не могут быть связаны обычным образом и их нужно добавлять динамически. Делается это так:</p>\\n<pre><code class=\\\"language-cpp\\\">#include &#x3C;gobject/gsignal.h>\\n...\\nGstElement *pipeline = gst_pipeline_new(\\\"audio-sender\\\");\\nGstElement *source = gst_element_factory_make(\\\"filesrc\\\", \\\"file-source\\\");\\nGstElement *decodebin = gst_element_factory_make(\\\"decodebin\\\", \\\"decodebin\\\");\\nGstElement *alsasink = gst_element_factory_make(\\\"alsasink\\\", \\\"alsasink\\\");\\n\\nGstBus* bus = gst_pipeline_get_bus(GST_PIPELINE(pipeline));\\nguint bus_watch_id = gst_bus_add_watch(bus, bus_call, loop);\\ngst_object_unref(bus);\\n\\ngst_bin_add_many(GST_BIN(pipeline), source, decodebin, alsasink, nullptr); // в бин добавляем все 3 элемента\\ngst_element_link(source, decodebin);  // связываем только первые 2 элемента: filesrc ! decodebin\\n\\ng_signal_connect(decodebin, \\\"pad-added\\\", G_CALLBACK(on_pad_added), alsasink);   // на decodebin привязываемся к сигналу pad-added, который будет вызван, когда у decodebin появился pad, который sink (в начале работы такого пада у него нет)\\n</code></pre>\\n<p>Коллбэк выглядит так:</p>\\n<pre><code class=\\\"language-cpp\\\">static void on_pad_added (GstElement *element,\\n              GstPad     *pad,\\n              gpointer    data)\\n{\\n    GstPad *sinkpad;\\n    GstElement *alsasink = (GstElement *) data;\\n\\n    sinkpad = gst_element_get_static_pad (alsasink, \\\"sink\\\");    // берем пад, равный синку (то есть входной) у элемента alsasink\\n\\n    gst_pad_link (pad, sinkpad);    // связываем наш пад (т.е. decodebin) с синком алсасинка\\n\\n    gst_object_unref (sinkpad);\\n}\\n</code></pre>\\n<h2>capsfilter</h2>\\n<p>Когда вместо элемента в пайплайне начинает идти формат: </p>\\n<pre><code class=\\\"language-cpp\\\">gst-launch-1.0 tcpserversrc port=9999 ! audio/x-raw,format=S8,channels=2,rate=48000 ! audioconvert ! alsasink\\n</code></pre>\\n<p>то это алиас для:</p>\\n<pre><code class=\\\"language-cpp\\\">gst-launch-1.0 tcpserversrc port=9999 ! capsfilter caps=audio/x-raw,format=S8,channels=2,rate=48000 ! audioconvert ! alsasink\\n</code></pre>\\n<p>Я так до конца и не понял, что делает <code>capsfilter</code>, но вроде как он устанавливает ограничения для связи между двумя элементами. </p>\\n<h2>Итерирование по элементам бина</h2>\\n<pre><code class=\\\"language-cpp\\\">g_print(\\\"Pipeline contains the following elements:\\\\n\\\");\\nGstIterator *it;\\nGValue elem = G_VALUE_INIT;\\nit = gst_bin_iterate_elements(GST_BIN(pipeline));\\nwhile (gst_iterator_next(it, &#x26;elem) == GST_ITERATOR_OK)\\n{\\n    g_print(\\\"%s\\\\n\\\",\\n        gst_element_get_name(g_value_get_object(&#x26;elem)));\\n    g_value_reset(&#x26;elem);\\n}\\n\\ng_value_unset(&#x26;elem);\\ngst_iterator_free(it);\\n</code></pre>\\n<h2>queue2</h2>\\n<ul>\\n<li>\\n<p><code>buffering_level</code> - текущий уровень заполненности очереди. Нормализованный, принимает значения от 0 до 1.000.000</p>\\n</li>\\n<li>\\n<p><code>buffering_percent</code> - уровень заполненности промежутка между high и low вотермарками. 0% означает, что <code>buffering_level == low_watermark</code>, 100% означает, что <code>buffering_level == high_watermark</code>. Принимает значения от 0 до 100.</p>\\n</li>\\n<li>\\n<p><code>BUF_LEVEL_PERCENT_FACTOR</code> - чему в абсолютных значениях равен 1% buffering level, то есть <code>BUF_LEVEL_PERCENT_FACTOR ((MAX_BUFFERING_LEVEL) / 100) = 10.000</code></p>\\n</li>\\n</ul>\\n<p><code>gst_queue2_chain</code> - сюда поступают, здесь процессятся и отсюда выходят данные пайплайна. Это основная функция.</p>\\n<p>Она форвардит вызов к <code>gst_queue2_chain_buffer_or_buffer_list</code>. Там поступивший буфер кладется во внутреннюю очередь строчкой <code>gst_queue2_locked_enqueue</code></p>\\n<p>Следующие строки в методе <code>get_buffering_level</code>, кажется, наконец выставляют <code>buffering_level</code>:</p>\\n<pre><code class=\\\"language-cpp\\\">#define GET_BUFFER_LEVEL_FOR_QUANTITY(format,alt_max) \\\\\\n    normalize_to_buffering_level (queue->cur_level.format,queue->max_level.format,(alt_max))\\n\\n/* figure out the buffering level we are filled, we take the max of all formats. */\\nif (!QUEUE_IS_USING_RING_BUFFER (queue)) {\\n  buflevel = GET_BUFFER_LEVEL_FOR_QUANTITY (bytes, 0);\\n} else {\\n  guint64 rb_size = queue->ring_buffer_max_size;\\n  buflevel = GET_BUFFER_LEVEL_FOR_QUANTITY (bytes, rb_size);\\n}\\n\\nbuflevel2 = GET_BUFFER_LEVEL_FOR_QUANTITY (time, 0);\\nbuflevel = MAX (buflevel, buflevel2);\\n\\nbuflevel2 = GET_BUFFER_LEVEL_FOR_QUANTITY (buffers, 0);\\nbuflevel = MAX (buflevel, buflevel2);\\n\\n/* also apply the rate estimate when we need to */\\nif (queue->use_rate_estimate) {\\n  buflevel2 = GET_BUFFER_LEVEL_FOR_QUANTITY (rate_time, 0);\\n  buflevel = MAX (buflevel, buflevel2);\\n}\\n</code></pre>\\n<p>И она вычисляют уровень для байт, времени, буферов и rate_time, а потом берут из них максимальный.</p>\\n<h2>Написание плагина</h2>\\n<p>Лучшая статья по этой теме, что я видел: <a href=\\\"https://habr.com/ru/post/221483/\\\">https://habr.com/ru/post/221483/</a></p>\\n<h2>Preroll</h2>\\n<p>Когда из состояния READY выставляем состояние PAUSED, то данные уже начинают идти по пайплайну, но когда они доходят до последнего sink-элемента (напр. alsasink), то они блочатся у его входа и в результате не \\\"рендерятся\\\". В этом состоянии каждый из элементов держит один или несколько буферов, но когда все элементы заполнят свои внутренние очереди, проход данных по пайплайну остановится до перехода в состояние PLAYING. Этот процесс называется pre-roll и он нужен для того, чтобы когда мы переведем в состояние PLAYING, переход прошел максимально быстро.</p>\\n<p>Все изменения состояния, идущие \\\"наверх\\\" (то есть NULL-READY-PAUSED-PLAYING) - выполняются асинхронно. То есть мы шлем команду на изменение состояния, она возвращается сразу же и потом от шины приходит сообщение, что состояние изменено.</p>\\n<p>Изменения состояния, идущие \\\"вниз\\\" - наоборот, все синхронны.</p>\\n<p>Главная разница между сигналами и сообщениями от шины - сигналы синхронны и могут вызваться из любого потока в любое время (поэтому в них нужно заботиться о мультипоточности). Сообщения - асинхронны и выполняются в потоке приложения, поэтому могут быть выполнены тогда, когда приложению будет удобно.</p>\\n<p>Свойство <code>sync</code> у <code>sink</code>-элементов означает, будет ли поток из этих элементов синхронизирован с часами. Если стоит <code>false</code>, то поток будет выдан на рендер настолько быстро, насколько это возможно.</p>\\n<p><code>gst-inspect-1.0 --gst-debug -help</code> - выводит всю инфу о том, что может быть залогировано</p>\\n<p>В GST dev tools есть GST debug viewer, который облегчит чтение логов.</p>\\n<p>Пример использования сетевых часов для мульти-рума: <a href=\\\"https://github.com/thaytan/gst-tutorial-lca2018/tree/master/network-clocks\\\">https://github.com/thaytan/gst-tutorial-lca2018/tree/master/network-clocks</a></p>\\n<p>Working with dynamic pipelines: <a href=\\\"https://coaxion.net/blog/2014/01/gstreamer-dynamic-pipelines/\\\">https://coaxion.net/blog/2014/01/gstreamer-dynamic-pipelines/</a> код из тэой статьи здесь: <a href=\\\"https://github.com/sdroege/gst-snippets/blob/217ae015aaddfe3f7aa66ffc936ce93401fca04e/dynamic-tee-vsink.c\\\">https://github.com/sdroege/gst-snippets/blob/217ae015aaddfe3f7aa66ffc936ce93401fca04e/dynamic-tee-vsink.c</a></p>\\n<p>Когда регистрируем проб с типом <code>GST_PAD_PROBE_TYPE_IDLE</code>, то указанный коллбэк будет вызван как только этот пад начнет простаивать, то есть по нему перестанут идти данные.</p>\\n<h2>Удаление ветви пайплайна</h2>\\n<p>Например, у нас есть такой пайплайн:\\n\\nsrc -> bin -> conv -> tee -> queue -> fakesink\\t\\t\\t(1)\\n-> queue -> conv -> sink \\t\\t(2)</p>\\n<p>и мы хотим удалить ветвь (2)</p>\\n<p>Для этого мы берем наш src-pad элемента tee и ставим на него проб с типом <code>GST_PAD_PROBE_TYPE_IDLE</code>. В коллбэке проба делаем следующее (<a href=\\\"https://github.com/sdroege/gst-snippets/blob/217ae015aaddfe3f7aa66ffc936ce93401fca04e/dynamic-tee-vsink.c#L93\\\">https://github.com/sdroege/gst-snippets/blob/217ae015aaddfe3f7aa66ffc936ce93401fca04e/dynamic-tee-vsink.c#L93</a>):</p>\\n<pre><code class=\\\"language-c\\\">teepad = gst_element_get_static_pad(tee, \\\"src_&#x3C;номер>\\\");\\nsinkpad = gst_element_get_static_pad (queue, \\\"sink\\\");\\ngst_pad_unlink (teepad, sinkpad);\\ngst_object_unref (sinkpad);\\n\\ngst_element_set_state (sink, GST_STATE_NULL);\\ngst_element_set_state (conv, GST_STATE_NULL);\\ngst_element_set_state (queue, GST_STATE_NULL);\\n\\ngst_bin_remove (GST_BIN (pipeline), queue);\\ngst_bin_remove (GST_BIN (pipeline), conv);\\ngst_bin_remove (GST_BIN (pipeline), sink);\\n\\ngst_object_unref (sink);\\ngst_object_unref (conv);\\ngst_object_unref (queue);\\n\\ngst_element_release_request_pad (tee, teepad);\\ngst_object_unref (teepad);\\n\\nreturn GST_PAD_PROBE_REMOVE;\\n</code></pre>\\n<p>При окончании потока делаем gst<em>app</em>src<em>end</em>of_stream () чтобы послать EOS в пайплайн</p>\\n<p>В месте связи ветки ставим проб и ждем, пока придет EOS. только это надо сделать до того, как послали EOS.</p>\\n<p>Когда пришел EOS, запускаем наш unlink_cb</p>\\n<p>GST<em>PAD</em>PROBE<em>TYPE</em>EVENT_DOWNSTREAM чтобы ловить евенты через проб</p>\\n<p>нН чтобы были нотификации по ивентам, нужно сделать GST<em>PAD</em>PROBE<em>TYPE</em>EVENT_FLUSH</p>\\n<p>При получении EOS в пробе его можно дропнуть</p>\\n<h2>gst-shark</h2>\\n<p>Установка пути, куда сохраняются результаты:</p>\\n<p><code>export GST_SHARK_LOCATION=~/profile</code></p>\\n<p>Запуск с трейсером:</p>\\n<p><code>GST_TRACERS=\\\"tracer1;tracer2\\\" gst-launch-1.0 ...</code></p>\\n<p>Если нужно трейсерам указать параметры, то можно так:</p>\\n<p><code>GST_TRACERS=\\\"tracer1(parameter1=value1);tracer2(parameter2=value2)\\\" gst-launch-1.0 ...</code></p>\\n<p>Параметром <code>filter</code> можно устанавливать ограничение на профилируемый элемент. Значением фильтра пишем регэкспы по правилам Glib: <a href=\\\"https://developer.gnome.org/glib/stable/glib-regex-syntax.html\\\">https://developer.gnome.org/glib/stable/glib-regex-syntax.html</a></p>\\n<p>Пример:</p>\\n<p><code>gst-launch-1.0 videotestsrc ! identity name=i0 ! queue ! identity name=i1 ! x264enc ! identity name=i2 ! queue ! fakesink</code></p>\\n<p>Вывести фреймрейт в каждом из <code>identity</code>:</p>\\n<p><code>GST_TRACERS=\\\"framerate(filter=^i[0-9])\\\" GST_DEBUG=GST_TRACER:7</code></p>\\n<p>Вывести фреймрейт для всех <code>identity</code> кроме <code>i2</code></p>\\n<p><code>GST_TRACERS=\\\"framerate(filter=^i[^2])\\\" GST_DEBUG=GST_TRACER:7</code></p>\\n<p>Вывести <code>scheduletime</code> в <code>videotestsrc</code>:</p>\\n<p><code>GST_TRACERS=\\\"scheduletime(filter=videotestsrc0)\\\" GST_DEBUG=GST_TRACER:7</code></p>\\n<h2>Трейсеры</h2>\\n<ul>\\n<li><code>interlatency</code> - Замеряет время, требуемое буферу, чтобы пройти от одной точки до другой внутри пайплайна. Предоставляет замеры времени, за которое буфер прошел от src первого элемента до src каждого последующего. Точность - нс.</li>\\n<li><code>proctime</code> - замеры времени, за которое каждый из элементов обрабатывает очередной буфер</li>\\n<li><code>framerate</code> - каждую секунду для каждого элемента выводит количество кадров, которое через него прошло</li>\\n<li><code>scheduletime</code> - замеряет время, проходящее между появлениеями буферов на sink pad каждого элемента</li>\\n<li><code>cpuusage</code> - каждую секунду выводит загрузку ЦП. <strong>ВАЖНО</strong>: это относится к общей загрузке ЦП, а не только той, которая обеспечивается пайплайном</li>\\n<li><code>bitrate</code> - каждую секунду выводит битрейт</li>\\n<li><code>queuelevel</code> - выводит, сколько байт и сколько буферов лежит в каждой очереди, обновляется каждый раз, когда в очередь входит новый буфер. НЕ РАБОТАЕТ с queue2, только с queue.</li>\\n<li><code>buffer</code> - выводит инфу о каждом буфере, который выходит из первого (source) элемента. PTS = presentation time stamp (указывает, когда нужно отрендерить этот буфер), DTS = decoding time stamp (указывает, когда нужно декодировать этот кадр). Порядок рендера и декодирования может быть разный, потому что некоторые кадры может быть нужно декодировать раньше, чем они будут показаны.</li>\\n</ul>\",\"frontmatter\":{\"path\":\"/blog/gstreamer\",\"title\":\"Gstreamer\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---blog-gstreamer-5298189b6f670bfb7f51.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>Gstreamer</h1>\\n<p><a href=\\\"https://habr.com/ru/post/251427/\\\">https://habr.com/ru/post/251427/</a></p>\\n<pre><code class=\\\"language-cpp\\\">#include &#x3C;gst/gst.h>\\nint main (int argc, char * argv[]) {\\n\\n    if (argc != 3) {\\n        g_print (\\\"Syntax error\\\\n\\\");\\n        return -1;\\n    }\\n\\n    GstElement *pipeline, *src, *dst;\\n    /* Сюда будет читаться результат попытки запуска потока. */\\n    GstStateChangeReturn ret;\\n    /* bus - это шина конвейера. Через нее мы можем получать сообщения о событиях. */\\n    GstBus *bus;\\n    GstMessage *msg;\\n\\n    /* Инициализация GStreamer */\\n    gst_init (NULL, NULL);\\n\\n    /* Создаем элементы */\\n    pipeline = gst_element_factory_make (\\\"pipeline\\\", \\\"pipe\\\");\\n    src = gst_element_factory_make (\\\"filesrc\\\", \\\"src\\\");\\n    dst = gst_element_factory_make (\\\"filesink\\\", \\\"dst\\\");\\n    if ( !pipeline || !src || !dst ) {\\n        g_printerr (\\\"Unable to create some elements\\\\n\\\");\\n        return -1;\\n    }\\n\\n    /* Добавляем элементы в конвейер */\\n    gst_bin_add_many (GST_BIN(pipeline), src, dst, NULL);\\n\\n    /* И связываем их */\\n    if ( gst_element_link (src, dst) != TRUE )  {\\n        g_printerr (\\\"Elements can not be linked\\\\n\\\");\\n        gst_object_unref (pipeline);\\n        return -1;\\n    }\\n\\n    /* Задаем элементам свойства */\\n    g_object_set (src, \\\"location\\\", argv[1], NULL);\\n    g_object_set (dst, \\\"location\\\", argv[2], NULL);\\n\\n    /* Запускаем конвейер */\\n    ret = gst_element_set_state (pipeline, GST_STATE_PLAYING);\\n    if ( ret == GST_STATE_CHANGE_FAILURE ) {\\n        g_printerr (\\\"Unable to set pipeline to the playing state\\\\n\\\");\\n        gst_object_unref (pipeline);\\n        return -1;\\n    }\\n\\n    /* Мало просто установить режим PLAYING. Нужно ждать либо конца потока, либо \\n     * ошибок. Для начала подключаемся к шине конвейера (эти манипуляции будут \\n     * описаны в следующей статье) */\\n    bus = gst_element_get_bus (pipeline);\\n\\n    /* И ожидаем события на шине. Когда событие произойдет, функция вернет \\n     * сообщение, которое мы будем парсить. */\\n    msg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE, GST_MESSAGE_ERROR | GST_MESSAGE_EOS);\\n\\n    /* Парсим сообщение */\\n    if (msg != NULL)\\n    {\\n        GError *err;\\n        gchar *debug_info;\\n\\n        switch ( GST_MESSAGE_TYPE (msg) )\\n        {\\n            case GST_MESSAGE_ERROR:\\n                gst_message_parse_error (msg, &#x26;err, &#x26;debug_info);\\n                g_printerr (\\\"Error received from element %s: %s\\\\n\\\", GST_OBJECT_NAME (msg->src), err->message);\\n                g_printerr (\\\"Debugging information: %s\\\\n\\\", debug_info ? debug_info : \\\"none\\\");\\n                g_clear_error (&#x26;err);\\n                g_free (debug_info);\\n                break;\\n\\n            case GST_MESSAGE_EOS:\\n                g_print (\\\"We reach End-Of-Stream\\\\n\\\");\\n                break;\\n\\n            default:\\n                g_printerr (\\\"Unexpected message received\\\\n\\\");\\n                break;\\n        }\\n        gst_message_unref (msg);\\n    }\\n\\n    /* Освобождаем ресурсы */\\n    gst_object_unref (bus);\\n    gst_element_set_state (pipeline, GST_STATE_NULL);\\n    gst_object_unref (pipeline);\\n\\n    return 0;\\n}\\n</code></pre>\\n<h2>Типичное создание пайплайна</h2>\\n<pre><code class=\\\"language-cpp\\\">pipeline = gst_pipeline_new (\\\"my-pipeline\\\");\\n\\nbus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));\\ngst_bus_add_signal_watch (bus);\\ng_signal_connect (bus, \\\"message\\\", (GCallback) cb_message,\\n  pipeline);\\n\\nsrc = gst_element_factory_make (\\\"uridecodebin\\\", \\\"src\\\");\\nif (src == NULL)\\ng_error (\\\"Could not create 'uridecodebin' element\\\");\\n\\ng_object_set (src, \\\"uri\\\", argv[1], NULL);\\n\\ncsp = gst_element_factory_make (\\\"videoconvert\\\", \\\"csp\\\");\\nif (csp == NULL)\\ng_error (\\\"Could not create 'videoconvert' element\\\");\\n\\nvs = gst_element_factory_make (\\\"videoscale\\\", \\\"vs\\\");\\nif (csp == NULL)\\ng_error (\\\"Could not create 'videoscale' element\\\");\\n\\nsink = gst_element_factory_make (\\\"autovideosink\\\", \\\"sink\\\");\\nif (sink == NULL)\\ng_error (\\\"Could not create 'autovideosink' element\\\");\\n\\ngst_bin_add_many (GST_BIN (pipeline), src, csp, vs, sink, NULL);\\n</code></pre>\\n<h2>API</h2>\\n<p><code>gst_buffer_map</code> позволяет доставать <code>GstMapInfo</code> из <code>GstBuffer</code></p>\\n<p>У GstMapInfo есть поля:</p>\\n<pre><code class=\\\"language-cpp\\\">guint8 *data;\\ngsize size;\\n</code></pre>\\n<p>Pad probes are best suited for looking at data as it passes through the pipeline. If you need to modify data, you should rather write your own GStreamer element. Base classes like GstAudioFilter, GstVideoFilter or GstBaseTransform make this fairly easy.</p>\\n<p>If you just want to inspect buffers as they pass through the pipeline, you don't even need to set up pad probes. You could also just insert an identity element into the pipeline and connect to its \\\"handoff\\\" signal. The identity element also provides a few useful debugging tools like the dump and last-message properties; the latter is enabled by passing the '-v' switch to gst-launch and setting the silent property on the identity to FALSE.</p>\\n<h2>tcp</h2>\\n<h3>multifdsink</h3>\\n<p><a href=\\\"https://gstreamer.freedesktop.org/documentation/tcp/multifdsink.html?gi-language=c#multifdsink\\\">https://gstreamer.freedesktop.org/documentation/tcp/multifdsink.html?gi-language=c#multifdsink</a></p>\\n<p>Может писать поток в указанные файловые дескрипторы. Дескрипторы добавляются и удаляются через сигналы (<code>add</code>, <code>remove</code>)</p>\\n<h3>tcpclientsink/tcpserversrc</h3>\\n<p>Сами создают сокеты, достаточно передать лишь номер порта</p>\\n<pre><code class=\\\"language-shell\\\">gst-launch-1.0 tcpserversrc port=9999 ! decodebin ! alsasink\\ngst-launch-1.0 filesrc location=/home/yury-timofeev/samples/1.mp3 ! tcpclientsink port=9999\\n</code></pre>\\n<p>Можно и микшировать сразу:</p>\\n<pre><code class=\\\"language-cpp\\\">gst-launch-1.0 tcpserversrc port=9999 ! decodebin ! audiomixer name=mix ! alsasink tcpserversrc port=9998 ! decodebin ! mix.\\ngst-launch-1.0 filesrc location=/home/yury-timofeev/samples/1.mp3 ! tcpclientsink port=9999\\ngst-launch-1.0 filesrc location=/home/yury-timofeev/samples/2.mp3 ! tcpclientsink port=9998\\n</code></pre>\\n<p>При этом если мы хотим использовать <code>decodebin</code> на отправляющей стороне, то нужно поизвращаться:</p>\\n<pre><code class=\\\"language-cpp\\\">gst-launch-1.0 tcpserversrc port=9999 ! audio/x-raw,format=S8,channels=2,rate=48000 ! audioconvert ! alsasink\\n\\ngst-launch-1.0 filesrc location=/home/yury-timofeev/samples/1.mp3 ! decodebin ! audioconvert ! audioresample ! audio/x-raw,format=S8,channels=2,rate=48000 ! tcpclientsink port=9999\\n</code></pre>\\n<h2>Сигналы</h2>\\n<p>Используется концепция сигналов из GObjects (не имеют ничего общего с UNIX-сигналами): <a href=\\\"https://developer.gnome.org/gobject/stable/signal.html\\\">https://developer.gnome.org/gobject/stable/signal.html</a></p>\\n<p>Вот так мы посылаем сигнал в элемент:</p>\\n<pre><code class=\\\"language-cpp\\\">GstElement *sink = gst_bin_get_by_name(GST_BIN(pipeline), \\\"dest\\\");\\ng_signal_emit_by_name(sink, \\\"add\\\", \\\"192.168.1.25\\\", 5004, NULL);\\ng_object_unref(sink);\\n</code></pre>\\n<h2>decodebin, oggdemux</h2>\\n<p><a href=\\\"https://gstreamer.freedesktop.org/documentation/application-development/basics/pads.html#dynamic-or-sometimes-pads\\\">https://gstreamer.freedesktop.org/documentation/application-development/basics/pads.html#dynamic-or-sometimes-pads</a></p>\\n<p>Декодирующие элементы <code>decodebin</code> и <code>oggdemux</code> имеют особую природу. Так как <code>decodebin</code> может работать со многими форматами, а <code>oggdemux</code> может работать с аудио- и видео-потоком, то их синки становятся известны лишь во время выполнения. Поэтому они не могут быть связаны обычным образом и их нужно добавлять динамически. Делается это так:</p>\\n<pre><code class=\\\"language-cpp\\\">#include &#x3C;gobject/gsignal.h>\\n...\\nGstElement *pipeline = gst_pipeline_new(\\\"audio-sender\\\");\\nGstElement *source = gst_element_factory_make(\\\"filesrc\\\", \\\"file-source\\\");\\nGstElement *decodebin = gst_element_factory_make(\\\"decodebin\\\", \\\"decodebin\\\");\\nGstElement *alsasink = gst_element_factory_make(\\\"alsasink\\\", \\\"alsasink\\\");\\n\\nGstBus* bus = gst_pipeline_get_bus(GST_PIPELINE(pipeline));\\nguint bus_watch_id = gst_bus_add_watch(bus, bus_call, loop);\\ngst_object_unref(bus);\\n\\ngst_bin_add_many(GST_BIN(pipeline), source, decodebin, alsasink, nullptr); // в бин добавляем все 3 элемента\\ngst_element_link(source, decodebin);  // связываем только первые 2 элемента: filesrc ! decodebin\\n\\ng_signal_connect(decodebin, \\\"pad-added\\\", G_CALLBACK(on_pad_added), alsasink);   // на decodebin привязываемся к сигналу pad-added, который будет вызван, когда у decodebin появился pad, который sink (в начале работы такого пада у него нет)\\n</code></pre>\\n<p>Коллбэк выглядит так:</p>\\n<pre><code class=\\\"language-cpp\\\">static void on_pad_added (GstElement *element,\\n              GstPad     *pad,\\n              gpointer    data)\\n{\\n    GstPad *sinkpad;\\n    GstElement *alsasink = (GstElement *) data;\\n\\n    sinkpad = gst_element_get_static_pad (alsasink, \\\"sink\\\");    // берем пад, равный синку (то есть входной) у элемента alsasink\\n\\n    gst_pad_link (pad, sinkpad);    // связываем наш пад (т.е. decodebin) с синком алсасинка\\n\\n    gst_object_unref (sinkpad);\\n}\\n</code></pre>\\n<h2>capsfilter</h2>\\n<p>Когда вместо элемента в пайплайне начинает идти формат: </p>\\n<pre><code class=\\\"language-cpp\\\">gst-launch-1.0 tcpserversrc port=9999 ! audio/x-raw,format=S8,channels=2,rate=48000 ! audioconvert ! alsasink\\n</code></pre>\\n<p>то это алиас для:</p>\\n<pre><code class=\\\"language-cpp\\\">gst-launch-1.0 tcpserversrc port=9999 ! capsfilter caps=audio/x-raw,format=S8,channels=2,rate=48000 ! audioconvert ! alsasink\\n</code></pre>\\n<p>Я так до конца и не понял, что делает <code>capsfilter</code>, но вроде как он устанавливает ограничения для связи между двумя элементами. </p>\\n<h2>Итерирование по элементам бина</h2>\\n<pre><code class=\\\"language-cpp\\\">g_print(\\\"Pipeline contains the following elements:\\\\n\\\");\\nGstIterator *it;\\nGValue elem = G_VALUE_INIT;\\nit = gst_bin_iterate_elements(GST_BIN(pipeline));\\nwhile (gst_iterator_next(it, &#x26;elem) == GST_ITERATOR_OK)\\n{\\n    g_print(\\\"%s\\\\n\\\",\\n        gst_element_get_name(g_value_get_object(&#x26;elem)));\\n    g_value_reset(&#x26;elem);\\n}\\n\\ng_value_unset(&#x26;elem);\\ngst_iterator_free(it);\\n</code></pre>\\n<h2>queue2</h2>\\n<ul>\\n<li>\\n<p><code>buffering_level</code> - текущий уровень заполненности очереди. Нормализованный, принимает значения от 0 до 1.000.000</p>\\n</li>\\n<li>\\n<p><code>buffering_percent</code> - уровень заполненности промежутка между high и low вотермарками. 0% означает, что <code>buffering_level == low_watermark</code>, 100% означает, что <code>buffering_level == high_watermark</code>. Принимает значения от 0 до 100.</p>\\n</li>\\n<li>\\n<p><code>BUF_LEVEL_PERCENT_FACTOR</code> - чему в абсолютных значениях равен 1% buffering level, то есть <code>BUF_LEVEL_PERCENT_FACTOR ((MAX_BUFFERING_LEVEL) / 100) = 10.000</code></p>\\n</li>\\n</ul>\\n<p><code>gst_queue2_chain</code> - сюда поступают, здесь процессятся и отсюда выходят данные пайплайна. Это основная функция.</p>\\n<p>Она форвардит вызов к <code>gst_queue2_chain_buffer_or_buffer_list</code>. Там поступивший буфер кладется во внутреннюю очередь строчкой <code>gst_queue2_locked_enqueue</code></p>\\n<p>Следующие строки в методе <code>get_buffering_level</code>, кажется, наконец выставляют <code>buffering_level</code>:</p>\\n<pre><code class=\\\"language-cpp\\\">#define GET_BUFFER_LEVEL_FOR_QUANTITY(format,alt_max) \\\\\\n    normalize_to_buffering_level (queue->cur_level.format,queue->max_level.format,(alt_max))\\n\\n/* figure out the buffering level we are filled, we take the max of all formats. */\\nif (!QUEUE_IS_USING_RING_BUFFER (queue)) {\\n  buflevel = GET_BUFFER_LEVEL_FOR_QUANTITY (bytes, 0);\\n} else {\\n  guint64 rb_size = queue->ring_buffer_max_size;\\n  buflevel = GET_BUFFER_LEVEL_FOR_QUANTITY (bytes, rb_size);\\n}\\n\\nbuflevel2 = GET_BUFFER_LEVEL_FOR_QUANTITY (time, 0);\\nbuflevel = MAX (buflevel, buflevel2);\\n\\nbuflevel2 = GET_BUFFER_LEVEL_FOR_QUANTITY (buffers, 0);\\nbuflevel = MAX (buflevel, buflevel2);\\n\\n/* also apply the rate estimate when we need to */\\nif (queue->use_rate_estimate) {\\n  buflevel2 = GET_BUFFER_LEVEL_FOR_QUANTITY (rate_time, 0);\\n  buflevel = MAX (buflevel, buflevel2);\\n}\\n</code></pre>\\n<p>И она вычисляют уровень для байт, времени, буферов и rate_time, а потом берут из них максимальный.</p>\\n<h2>Написание плагина</h2>\\n<p>Лучшая статья по этой теме, что я видел: <a href=\\\"https://habr.com/ru/post/221483/\\\">https://habr.com/ru/post/221483/</a></p>\\n<h2>Preroll</h2>\\n<p>Когда из состояния READY выставляем состояние PAUSED, то данные уже начинают идти по пайплайну, но когда они доходят до последнего sink-элемента (напр. alsasink), то они блочатся у его входа и в результате не \\\"рендерятся\\\". В этом состоянии каждый из элементов держит один или несколько буферов, но когда все элементы заполнят свои внутренние очереди, проход данных по пайплайну остановится до перехода в состояние PLAYING. Этот процесс называется pre-roll и он нужен для того, чтобы когда мы переведем в состояние PLAYING, переход прошел максимально быстро.</p>\\n<p>Все изменения состояния, идущие \\\"наверх\\\" (то есть NULL-READY-PAUSED-PLAYING) - выполняются асинхронно. То есть мы шлем команду на изменение состояния, она возвращается сразу же и потом от шины приходит сообщение, что состояние изменено.</p>\\n<p>Изменения состояния, идущие \\\"вниз\\\" - наоборот, все синхронны.</p>\\n<p>Главная разница между сигналами и сообщениями от шины - сигналы синхронны и могут вызваться из любого потока в любое время (поэтому в них нужно заботиться о мультипоточности). Сообщения - асинхронны и выполняются в потоке приложения, поэтому могут быть выполнены тогда, когда приложению будет удобно.</p>\\n<p>Свойство <code>sync</code> у <code>sink</code>-элементов означает, будет ли поток из этих элементов синхронизирован с часами. Если стоит <code>false</code>, то поток будет выдан на рендер настолько быстро, насколько это возможно.</p>\\n<p><code>gst-inspect-1.0 --gst-debug -help</code> - выводит всю инфу о том, что может быть залогировано</p>\\n<p>В GST dev tools есть GST debug viewer, который облегчит чтение логов.</p>\\n<p>Пример использования сетевых часов для мульти-рума: <a href=\\\"https://github.com/thaytan/gst-tutorial-lca2018/tree/master/network-clocks\\\">https://github.com/thaytan/gst-tutorial-lca2018/tree/master/network-clocks</a></p>\\n<p>Working with dynamic pipelines: <a href=\\\"https://coaxion.net/blog/2014/01/gstreamer-dynamic-pipelines/\\\">https://coaxion.net/blog/2014/01/gstreamer-dynamic-pipelines/</a> код из тэой статьи здесь: <a href=\\\"https://github.com/sdroege/gst-snippets/blob/217ae015aaddfe3f7aa66ffc936ce93401fca04e/dynamic-tee-vsink.c\\\">https://github.com/sdroege/gst-snippets/blob/217ae015aaddfe3f7aa66ffc936ce93401fca04e/dynamic-tee-vsink.c</a></p>\\n<p>Когда регистрируем проб с типом <code>GST_PAD_PROBE_TYPE_IDLE</code>, то указанный коллбэк будет вызван как только этот пад начнет простаивать, то есть по нему перестанут идти данные.</p>\\n<h2>Удаление ветви пайплайна</h2>\\n<p>Например, у нас есть такой пайплайн:\\n\\nsrc -> bin -> conv -> tee -> queue -> fakesink\\t\\t\\t(1)\\n-> queue -> conv -> sink \\t\\t(2)</p>\\n<p>и мы хотим удалить ветвь (2)</p>\\n<p>Для этого мы берем наш src-pad элемента tee и ставим на него проб с типом <code>GST_PAD_PROBE_TYPE_IDLE</code>. В коллбэке проба делаем следующее (<a href=\\\"https://github.com/sdroege/gst-snippets/blob/217ae015aaddfe3f7aa66ffc936ce93401fca04e/dynamic-tee-vsink.c#L93\\\">https://github.com/sdroege/gst-snippets/blob/217ae015aaddfe3f7aa66ffc936ce93401fca04e/dynamic-tee-vsink.c#L93</a>):</p>\\n<pre><code class=\\\"language-c\\\">teepad = gst_element_get_static_pad(tee, \\\"src_&#x3C;номер>\\\");\\nsinkpad = gst_element_get_static_pad (queue, \\\"sink\\\");\\ngst_pad_unlink (teepad, sinkpad);\\ngst_object_unref (sinkpad);\\n\\ngst_element_set_state (sink, GST_STATE_NULL);\\ngst_element_set_state (conv, GST_STATE_NULL);\\ngst_element_set_state (queue, GST_STATE_NULL);\\n\\ngst_bin_remove (GST_BIN (pipeline), queue);\\ngst_bin_remove (GST_BIN (pipeline), conv);\\ngst_bin_remove (GST_BIN (pipeline), sink);\\n\\ngst_object_unref (sink);\\ngst_object_unref (conv);\\ngst_object_unref (queue);\\n\\ngst_element_release_request_pad (tee, teepad);\\ngst_object_unref (teepad);\\n\\nreturn GST_PAD_PROBE_REMOVE;\\n</code></pre>\\n<p>При окончании потока делаем gst<em>app</em>src<em>end</em>of_stream () чтобы послать EOS в пайплайн</p>\\n<p>В месте связи ветки ставим проб и ждем, пока придет EOS. только это надо сделать до того, как послали EOS.</p>\\n<p>Когда пришел EOS, запускаем наш unlink_cb</p>\\n<p>GST<em>PAD</em>PROBE<em>TYPE</em>EVENT_DOWNSTREAM чтобы ловить евенты через проб</p>\\n<p>нН чтобы были нотификации по ивентам, нужно сделать GST<em>PAD</em>PROBE<em>TYPE</em>EVENT_FLUSH</p>\\n<p>При получении EOS в пробе его можно дропнуть</p>\\n<h2>gst-shark</h2>\\n<p>Установка пути, куда сохраняются результаты:</p>\\n<p><code>export GST_SHARK_LOCATION=~/profile</code></p>\\n<p>Запуск с трейсером:</p>\\n<p><code>GST_TRACERS=\\\"tracer1;tracer2\\\" gst-launch-1.0 ...</code></p>\\n<p>Если нужно трейсерам указать параметры, то можно так:</p>\\n<p><code>GST_TRACERS=\\\"tracer1(parameter1=value1);tracer2(parameter2=value2)\\\" gst-launch-1.0 ...</code></p>\\n<p>Параметром <code>filter</code> можно устанавливать ограничение на профилируемый элемент. Значением фильтра пишем регэкспы по правилам Glib: <a href=\\\"https://developer.gnome.org/glib/stable/glib-regex-syntax.html\\\">https://developer.gnome.org/glib/stable/glib-regex-syntax.html</a></p>\\n<p>Пример:</p>\\n<p><code>gst-launch-1.0 videotestsrc ! identity name=i0 ! queue ! identity name=i1 ! x264enc ! identity name=i2 ! queue ! fakesink</code></p>\\n<p>Вывести фреймрейт в каждом из <code>identity</code>:</p>\\n<p><code>GST_TRACERS=\\\"framerate(filter=^i[0-9])\\\" GST_DEBUG=GST_TRACER:7</code></p>\\n<p>Вывести фреймрейт для всех <code>identity</code> кроме <code>i2</code></p>\\n<p><code>GST_TRACERS=\\\"framerate(filter=^i[^2])\\\" GST_DEBUG=GST_TRACER:7</code></p>\\n<p>Вывести <code>scheduletime</code> в <code>videotestsrc</code>:</p>\\n<p><code>GST_TRACERS=\\\"scheduletime(filter=videotestsrc0)\\\" GST_DEBUG=GST_TRACER:7</code></p>\\n<h2>Трейсеры</h2>\\n<ul>\\n<li><code>interlatency</code> - Замеряет время, требуемое буферу, чтобы пройти от одной точки до другой внутри пайплайна. Предоставляет замеры времени, за которое буфер прошел от src первого элемента до src каждого последующего. Точность - нс.</li>\\n<li><code>proctime</code> - замеры времени, за которое каждый из элементов обрабатывает очередной буфер</li>\\n<li><code>framerate</code> - каждую секунду для каждого элемента выводит количество кадров, которое через него прошло</li>\\n<li><code>scheduletime</code> - замеряет время, проходящее между появлениеями буферов на sink pad каждого элемента</li>\\n<li><code>cpuusage</code> - каждую секунду выводит загрузку ЦП. <strong>ВАЖНО</strong>: это относится к общей загрузке ЦП, а не только той, которая обеспечивается пайплайном</li>\\n<li><code>bitrate</code> - каждую секунду выводит битрейт</li>\\n<li><code>queuelevel</code> - выводит, сколько байт и сколько буферов лежит в каждой очереди, обновляется каждый раз, когда в очередь входит новый буфер. НЕ РАБОТАЕТ с queue2, только с queue.</li>\\n<li><code>buffer</code> - выводит инфу о каждом буфере, который выходит из первого (source) элемента. PTS = presentation time stamp (указывает, когда нужно отрендерить этот буфер), DTS = decoding time stamp (указывает, когда нужно декодировать этот кадр). Порядок рендера и декодирования может быть разный, потому что некоторые кадры может быть нужно декодировать раньше, чем они будут показаны.</li>\\n</ul>\",\"frontmatter\":{\"path\":\"/blog/gstreamer\",\"title\":\"Gstreamer\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/blog-gstreamer.json\n// module id = 440\n// module chunks = 76495366757855"],"sourceRoot":""}